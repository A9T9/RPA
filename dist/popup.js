/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 17304:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.types = exports.type3 = exports.make3 = undefined;

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generate three action types, used in actions that return promises
var make3 = exports.make3 = function make3(name) {
  return [name + '_REQUEST', name + '_SUCCESS', name + '_FAIL'];
};

var type3 = exports.type3 = function type3(name) {
  return make3(name).map(function (key) {
    return types[key];
  });
};

var promiseTypes = ['START_RECORDING', 'STOP_RECORDING', 'START_INSPECTING', 'STOP_INSPECTING'].reduce(function (prev, cur) {
  make3(cur).forEach(function (key) {
    prev[key] = key;
  });

  return prev;
}, {});

var simpleTypes = ['SET_ROUTE', 'SET_EDITOR_ACTIVE_TAB', 'DONE_INSPECTING', 'UPDATE_BASE_URL', 'APPEND_COMMAND', 'DUPLICATE_COMMAND', 'INSERT_COMMAND', 'UPDATE_COMMAND', 'REMOVE_COMMAND', 'SELECT_COMMAND', 'CUT_COMMAND', 'COPY_COMMAND', 'PASTE_COMMAND', 'NORMALIZE_COMMANDS', 'UPDATE_SELECTED_COMMAND', 'SAVE_EDITING_AS_EXISTED', 'SAVE_EDITING_AS_NEW', 'SET_TEST_CASES', 'SET_EDITING', 'EDIT_TEST_CASE', 'EDIT_NEW_TEST_CASE', 'ADD_TEST_CASES', 'RENAME_TEST_CASE', 'REMOVE_TEST_CASE', 'UPDATE_TEST_SUITE_STATUS', 'UPDATE_ONE_MACRO_EXTRA', 'SET_ONE_MACRO_EXTRA', 'SET_MACROS_EXTRA', 'SET_TEST_SUITES_EXTRA', 'SET_PLAYER_STATE', 'SET_PLAYER_MODE', 'SET_TEST_SUITES', 'UPDATE_TEST_SUITE', 'ADD_LOGS', 'CLEAR_LOGS', 'ADD_SCREENSHOT', 'CLEAR_SCREENSHOTS', 'ADD_VISION', 'CLEAR_VISIONS', 'START_PLAYING', 'STOP_PLAYING', 'SET_CSV_LIST', 'SET_SCREENSHOT_LIST', 'SET_VISION_LIST', 'SET_VARIABLE_LIST', 'SET_SOURCE_ERROR', 'SET_SOURCE_CURRENT', 'UPDATE_CONFIG', 'UPDATE_UI', 'UPDATE_PROXY'].reduce(function (prev, cur) {
  prev[cur] = cur;
  return prev;
}, {});

var types = exports.types = (0, _extends3.default)({}, simpleTypes, promiseTypes);

/***/ }),

/***/ 97876:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _stringify = __webpack_require__(63239);

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = __webpack_require__(88902);

var _keys2 = _interopRequireDefault(_keys);

var _slicedToArray2 = __webpack_require__(12424);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _toConsumableArray2 = __webpack_require__(85315);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

var _message2 = __webpack_require__(11187);

var _message3 = _interopRequireDefault(_message2);

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

exports.findSameNameMacro = findSameNameMacro;
exports.findSamePathMacro = findSamePathMacro;
exports.findMacrosInFolder = findMacrosInFolder;
exports.findSameNameTestSuite = findSameNameTestSuite;
exports.setRoute = setRoute;
exports.startRecording = startRecording;
exports.stopRecording = stopRecording;
exports.startInspecting = startInspecting;
exports.stopInspecting = stopInspecting;
exports.startPlaying = startPlaying;
exports.stopPlaying = stopPlaying;
exports.doneInspecting = doneInspecting;
exports.increaseRecordedCount = increaseRecordedCount;
exports.appendCommand = appendCommand;
exports.duplicateCommand = duplicateCommand;
exports.insertCommand = insertCommand;
exports.updateCommand = updateCommand;
exports.removeCommand = removeCommand;
exports.selectCommand = selectCommand;
exports.cutCommand = cutCommand;
exports.copyCommand = copyCommand;
exports.pasteCommand = pasteCommand;
exports.normalizeCommands = normalizeCommands;
exports.updateSelectedCommand = updateSelectedCommand;
exports.toggleComment = toggleComment;
exports.toggleCommentOnSelectedCommand = toggleCommentOnSelectedCommand;
exports.setSourceError = setSourceError;
exports.setSourceCurrent = setSourceCurrent;
exports.saveSourceCodeToEditing = saveSourceCodeToEditing;
exports.saveEditingAsExisted = saveEditingAsExisted;
exports.saveEditingAsNew = saveEditingAsNew;
exports.setTestCases = setTestCases;
exports.resetEditing = resetEditing;
exports.resetEditingIfNeeded = resetEditingIfNeeded;
exports.setEditing = setEditing;
exports.editTestCase = editTestCase;
exports.editNewTestCase = editNewTestCase;
exports.upsertTestCase = upsertTestCase;
exports.addTestCases = addTestCases;
exports.removeTestCase = removeTestCase;
exports.removeCurrentTestCase = removeCurrentTestCase;
exports.setPlayerState = setPlayerState;
exports.setTimeoutStatus = setTimeoutStatus;
exports.addPlayerWarningCommandIndex = addPlayerWarningCommandIndex;
exports.addPlayerErrorCommandIndex = addPlayerErrorCommandIndex;
exports.addLog = addLog;
exports.clearLogs = clearLogs;
exports.addScreenshot = addScreenshot;
exports.clearScreenshots = clearScreenshots;
exports.addVision = addVision;
exports.clearVisions = clearVisions;
exports.updateConfig = updateConfig;
exports.setMacrosExtra = setMacrosExtra;
exports.setTestSuitesExtra = setTestSuitesExtra;
exports.updateMacroExtra = updateMacroExtra;
exports.updateMacroPlayStatus = updateMacroPlayStatus;
exports.updateMacroBreakpoints = updateMacroBreakpoints;
exports.updateMacroDoneCommandsIndices = updateMacroDoneCommandsIndices;
exports.updateMacroErrorCommandsIndices = updateMacroErrorCommandsIndices;
exports.updateMacroWarningCommandsIndices = updateMacroWarningCommandsIndices;
exports.updateProxy = updateProxy;
exports.commonPlayerState = commonPlayerState;
exports.playerPlay = playerPlay;
exports.listCSV = listCSV;
exports.listScreenshots = listScreenshots;
exports.listVisions = listVisions;
exports.renameVisionImage = renameVisionImage;
exports.setTestSuites = setTestSuites;
exports.addTestSuite = addTestSuite;
exports.addTestSuites = addTestSuites;
exports.removeTestSuite = removeTestSuite;
exports.setPlayerMode = setPlayerMode;
exports.runBackup = runBackup;
exports.setVariables = setVariables;
exports.updateUI = updateUI;
exports.addBreakpoint = addBreakpoint;
exports.removeBreakpoint = removeBreakpoint;
exports.setEditorActiveTab = setEditorActiveTab;
exports.preinstall = preinstall;

var _antd = __webpack_require__(56318);

var _action_types = __webpack_require__(17304);

var _utils = __webpack_require__(63370);

var _ipc_cs = __webpack_require__(41471);

var _ipc_cs2 = _interopRequireDefault(_ipc_cs);

var _storage = __webpack_require__(67585);

var _storage2 = _interopRequireDefault(_storage);

var _storage3 = __webpack_require__(16058);

var _test_case_model = __webpack_require__(77278);

var _player = __webpack_require__(43625);

var _backup = __webpack_require__(26997);

var _log = __webpack_require__(77242);

var _log2 = _interopRequireDefault(_log);

var _convert_utils = __webpack_require__(61169);

var _convert_suite_utils = __webpack_require__(36832);

var _config = __webpack_require__(62275);

var _config2 = _interopRequireDefault(_config);

var _preinstall_macros = __webpack_require__(81930);

var _preinstall_macros2 = _interopRequireDefault(_preinstall_macros);

var _preinstall_suites = __webpack_require__(24776);

var _preinstall_suites2 = _interopRequireDefault(_preinstall_suites);

var _macro_extra_data = __webpack_require__(24577);

var _test_suite_extra_data = __webpack_require__(34945);

var _test_suite_model = __webpack_require__(64580);

var _recomputed = __webpack_require__(78328);

var _prompt = __webpack_require__(79197);

var _command = __webpack_require__(69396);

var _call_stack = __webpack_require__(61364);

var _macro = __webpack_require__(72767);

var _save_test_case = __webpack_require__(57879);

var _save_test_case2 = _interopRequireDefault(_save_test_case);

var _path = __webpack_require__(84037);

var _ts_utils = __webpack_require__(55452);

var _macro_log = __webpack_require__(41010);

var _log3 = __webpack_require__(30399);

var _misc_data = __webpack_require__(19878);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var recordedCount = 0; /* global PREINSTALL_CSV_LIST PREINSTALL_VISION_LIST */

var saveEditing = function saveEditing(_ref) {
  var dispatch = _ref.dispatch,
      getState = _ref.getState;

  var state = getState();
  var _state$editor = state.editor,
      editing = _state$editor.editing,
      isDraggingCommand = _state$editor.isDraggingCommand;


  if (isDraggingCommand) {
    return;
  }

  _storage2.default.set('editing', editing);
};

var saveMacroExtra = function saveMacroExtra(id) {
  return function (_ref2) {
    var dispatch = _ref2.dispatch,
        getState = _ref2.getState;

    var state = getState();

    if (state.editor.isDraggingCommand) {
      return;
    }

    var macroId = id || (0, _recomputed.getCurrentMacroId)(state);
    var updated = state.editor.macrosExtra[macroId] || {};

    return (0, _macro_extra_data.getMacroExtraKeyValueData)().update(macroId, function (data) {
      return (0, _extends3.default)({}, data, updated);
    });
  };
};

var saveWholeMacrosExtra = function saveWholeMacrosExtra(_ref3) {
  var dispatch = _ref3.dispatch,
      getState = _ref3.getState;

  var state = getState();
  var macrosExtra = (0, _recomputed.getMacrosExtra)(state);

  return (0, _macro_extra_data.getMacroExtraKeyValueData)().set('', macrosExtra);
};

var saveConfig = function () {
  var lastSize = {};

  return function (_ref4) {
    var dispatch = _ref4.dispatch,
        getState = _ref4.getState;

    var _getState = getState(),
        config = _getState.config;

    config = config || {};

    var savedSize = config.size ? config.size[config.showSidebar ? 'with_sidebar' : 'standard'] : null;
    var finalSize = savedSize || (config.showSidebar ? {
      width: 860,
      height: 775
    } : {
      width: 520,
      height: 775
    });

    if (finalSize.width !== lastSize.width || finalSize.height !== lastSize.height) {
      _storage2.default.get('config').then(function (oldConfig) {
        if ((oldConfig && oldConfig.showSidebar) === config.showSidebar) return;

        if (finalSize.width !== window.outerWidth || finalSize.height !== window.outerHeight) {
          _ipc_cs2.default.ask('PANEL_RESIZE_WINDOW', { size: finalSize });
        }
      });
    }

    _storage2.default.set('config', config);
    lastSize = finalSize;
  };
}();

var toLower = function toLower(str) {
  return (str || '').toLowerCase();
};

function findSameNameMacro(name, macros) {
  return macros.find(function (tc) {
    return toLower(tc.name) === toLower(name);
  });
}

function findSamePathMacro(path, macroNodes) {
  var converPath = function converPath(str) {
    return toLower(str).replace(/.json$/, '');
  };
  return macroNodes.find(function (node) {
    return converPath(node.relativePath) === converPath(path);
  });
}

function findMacrosInFolder(folderPath, macroNodes) {
  var lowerFolderPath = toLower(folderPath);

  return macroNodes.filter(function (macroNode) {
    var lowerMacroFullPath = toLower(macroNode.fullPath);

    if (lowerMacroFullPath.indexOf(lowerFolderPath) !== 0) {
      return false;
    }

    var parts = lowerMacroFullPath.substr(lowerFolderPath.length).split(/\/|\\/g);

    if (parts.length !== 2 || parts[0] !== '') {
      return false;
    }

    return true;
  });
}

function findSameNameTestSuite(name, testSuites) {
  return testSuites.find(function (ts) {
    return toLower(ts.name) === toLower(name);
  });
}

function setRoute(data) {
  return {
    type: _action_types.types.SET_ROUTE,
    data: data
  };
}

function startRecording() {
  recordedCount = 0;

  return {
    types: (0, _action_types.type3)('START_RECORDING'),
    promise: function promise() {
      return _ipc_cs2.default.ask('PANEL_START_RECORDING', {}).then(function () {
        return _ipc_cs2.default.ask('PANEL_TRY_TO_RECORD_OPEN_COMMAND');
      });
    }
  };
}

function stopRecording() {
  return {
    types: (0, _action_types.type3)('STOP_RECORDING'),
    promise: function promise() {
      return _ipc_cs2.default.ask('PANEL_STOP_RECORDING', {});
    }
  };
}

function startInspecting() {
  return {
    types: (0, _action_types.type3)('START_INSPECTING'),
    promise: function promise() {
      return _ipc_cs2.default.ask('PANEL_START_INSPECTING', {});
    }
  };
}

function stopInspecting() {
  return {
    types: (0, _action_types.type3)('STOP_INSPECTING'),
    promise: function promise() {
      return _ipc_cs2.default.ask('PANEL_STOP_INSPECTING', {});
    }
  };
}

function startPlaying() {
  return {
    type: _action_types.types.START_PLAYING,
    data: null
  };
}

function stopPlaying() {
  return {
    type: _action_types.types.STOP_PLAYING,
    data: null
  };
}

function doneInspecting() {
  return {
    type: _action_types.types.DONE_INSPECTING,
    data: {}
  };
}

function increaseRecordedCount() {
  recordedCount += 1;
  // Note: show in badge the recorded count
  _ipc_cs2.default.ask('PANEL_UPDATE_BADGE', {
    type: 'record',
    text: '' + recordedCount
  });
}

function appendCommand(cmdObj) {
  var fromRecord = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (fromRecord) {
    increaseRecordedCount();
  }

  return {
    type: _action_types.types.APPEND_COMMAND,
    data: { command: (0, _test_case_model.normalizeCommand)(cmdObj) },
    post: [saveEditing, saveMacroExtra()]
  };
}

function duplicateCommand(index) {
  return {
    type: _action_types.types.DUPLICATE_COMMAND,
    data: { index: index },
    post: [saveEditing, saveMacroExtra()]
  };
}

function insertCommand(cmdObj, index) {
  var fromRecord = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (fromRecord) {
    increaseRecordedCount();
  }

  return {
    type: _action_types.types.INSERT_COMMAND,
    data: {
      index: index,
      command: (0, _test_case_model.normalizeCommand)(cmdObj)
    },
    post: [saveEditing, saveMacroExtra()]
  };
}

function updateCommand(cmdObj, index) {
  return {
    type: _action_types.types.UPDATE_COMMAND,
    data: {
      command: (0, _test_case_model.normalizeCommand)(cmdObj),
      index: index
    },
    post: saveEditing
  };
}

function removeCommand(index) {
  return {
    type: _action_types.types.REMOVE_COMMAND,
    data: { index: index },
    post: [saveEditing, saveMacroExtra()]
  };
}

function selectCommand(index, forceClick) {
  return {
    type: _action_types.types.SELECT_COMMAND,
    data: { index: index, forceClick: forceClick },
    post: saveEditing
  };
}

function cutCommand(index) {
  return {
    type: _action_types.types.CUT_COMMAND,
    data: { indices: [index] },
    post: [saveEditing, saveMacroExtra()]
  };
}

function copyCommand(index) {
  return {
    type: _action_types.types.COPY_COMMAND,
    data: { indices: [index] }
  };
}

function pasteCommand(index) {
  return {
    type: _action_types.types.PASTE_COMMAND,
    data: { index: index },
    post: [saveEditing, saveMacroExtra()]
  };
}

function normalizeCommands() {
  return {
    type: _action_types.types.NORMALIZE_COMMANDS,
    data: {},
    post: saveEditing
  };
}

function updateSelectedCommand(obj) {
  return {
    type: _action_types.types.UPDATE_SELECTED_COMMAND,
    data: obj,
    post: saveEditing
  };
}

function toggleComment(commandIndex) {
  return function (dispatch, getState) {
    var state = getState();
    var commands = state.editor.editing.commands;
    var command = commands[commandIndex];

    if (!command || !command.cmd || !command.cmd.length) {
      return;
    }

    // Note: for commented out command, its data looks like:
    // {
    //   cmd:     'comment',
    //   target:  'originalCmd // originalTarget
    //   value:   not touched
    // }
    if (command.cmd === 'comment') {
      var separator = ' // ';
      var index = command.target.indexOf(separator);
      if (index === -1) return;

      var cmd = command.target.substr(0, index);
      if (!(0, _command.isValidCmd)(cmd)) return;

      var target = command.target.substr(index + separator.length);

      return dispatch(updateCommand((0, _extends3.default)({}, command, {
        cmd: cmd,
        target: target
      }), commandIndex));
    } else {
      return dispatch(updateCommand((0, _extends3.default)({}, command, {
        cmd: 'comment',
        target: command.cmd + ' // ' + (command.target || '')
      }), commandIndex));
    }
  };
}

function toggleCommentOnSelectedCommand() {
  return function (dispatch, getState) {
    var state = getState();
    var index = state.editor.editing.meta.selectedIndex;

    dispatch(toggleComment(index));
  };
}

function setSourceError(error) {
  return {
    type: _action_types.types.SET_SOURCE_ERROR,
    data: error
  };
}

function setSourceCurrent(str) {
  return {
    type: _action_types.types.SET_SOURCE_CURRENT,
    data: str
  };
}

function saveSourceCodeToEditing(str) {
  return function (dispatch, getState) {
    var _getState$editor = getState().editor,
        editing = _getState$editor.editing,
        editingSource = _getState$editor.editingSource;

    if (editingSource.pure === editing.current) return;

    (0, _log2.default)('ACTION, saveSourceCodeToEditing', str);

    try {
      var obj = (0, _convert_utils.fromJSONString)(str, 'untitled');

      dispatch(setEditing((0, _extends3.default)({}, obj.data, {
        meta: editing.meta
      })));

      dispatch(setSourceError(null));
    } catch (e) {
      _message3.default.error('There are errors in the source');
      dispatch(setSourceError(e.message));
    }
  };
}

// In the form of redux-thunnk, it saves current editing test case to local storage
function saveEditingAsExisted() {
  return function (dispatch, getState) {
    var state = getState();
    var src = state.editor.editing.meta.src;
    var macroId = src.id;
    var data = (0, _utils.pick)(['commands'], state.editor.editing);
    var macroStorage = (0, _storage3.getStorageManager)().getMacroStorage();

    if (!macroId) {
      throw new Error('Can\'t find macro with path \'' + macroId + '\'');
    }

    // Make sure, only 'cmd', 'value', 'target' are saved in storage
    data.commands = data.commands.map(_test_case_model.normalizeCommand);

    if ((0, _recomputed.hasUnsavedMacro)(state)) {
      // Reset test case status
      dispatch(updateMacroPlayStatus(macroId, null));
    }

    return macroStorage.read(macroId, 'Text').then(function (macro) {
      var updatedMacro = (0, _extends3.default)({}, macro, { data: data });

      dispatch({
        type: 'setCurrentMacro',
        data: updatedMacro
      });

      return macroStorage.write(macroId, updatedMacro);
    }).then(function () {
      dispatch({
        type: _action_types.types.SAVE_EDITING_AS_EXISTED,
        data: null,
        post: saveEditing
      });
    });
  };
}

// In the form of redux-thunnk, it saves the current editing test case as a new named test case
function saveEditingAsNew(name) {
  return function (dispatch, getState) {
    var state = getState();
    var data = (0, _utils.pick)(['commands'], state.editor.editing);
    var sameName = findSameNameMacro(name, state.editor.testCases);

    if (sameName) {
      return _promise2.default.reject(new Error('The macro name already exists!'));
    }

    var relativePath = '/' + name + '.json';
    var id = (0, _storage3.getStorageManager)().getMacroStorage().filePath(relativePath);
    var newMacro = { id: id, name: name, data: data };

    return (0, _storage3.getStorageManager)().getMacroStorage().write(relativePath, newMacro).then(function () {
      dispatch({
        type: 'setCurrentMacro',
        data: newMacro
      });

      return dispatch({
        type: _action_types.types.SAVE_EDITING_AS_NEW,
        data: {
          id: id,
          name: name
        },
        post: saveEditing
      });
    });
  };
}

function setTestCases(testCases) {
  var tcs = testCases.slice();

  tcs.sort(function (a, b) {
    var nameA = a.name.toLowerCase();
    var nameB = b.name.toLowerCase();

    if (nameA < nameB) return -1;
    if (nameA === nameB) return 0;
    return 1;
  });

  return {
    type: _action_types.types.SET_TEST_CASES,
    data: tcs,
    post: function post(_ref5) {
      var dispatch = _ref5.dispatch,
          getState = _ref5.getState;

      var state = getState();
      var macroNodes = (0, _recomputed.getMacroFileNodeList)(state);
      var shouldSelectDefault = macroNodes.length > 0 && !state.editor.editing.meta.src && state.editor.editing.commands.length === 0;

      if (shouldSelectDefault) {
        dispatch(editTestCase(macroNodes[0].fullPath));
      }
    }
  };
}

function resetEditing() {
  return function (dispatch, getState) {
    var state = getState();
    var editing = state.editor.editing;

    var macroNodes = (0, _recomputed.getMacroFileNodeList)(state);

    // Leave it if it's a new macro
    if (editing.meta && !editing.meta.src) return;
    if (macroNodes.length === 0) {
      dispatch(editNewTestCase());
    } else {
      dispatch(editTestCase(macroNodes[0].fullPath));
    }
  };
}

function resetEditingIfNeeded() {
  return function (dispatch, getState) {
    var state = getState();
    var editing = state.editor.editing;

    var lastTcId = editing.meta.src && editing.meta.src.id;

    if (!lastTcId) return resetEditing()(dispatch, getState);
    dispatch(editTestCase(lastTcId));
  };
}

function setEditing(editing) {
  return {
    type: _action_types.types.SET_EDITING,
    data: editing
  };
}

function editTestCase(id) {
  return function (dispatch, getState) {
    return (0, _storage3.getStorageManager)().getMacroStorage().read(id, 'Text').then(function (rawMacro) {
      var macro = (0, _test_case_model.normalizeTestCase)(rawMacro);

      dispatch({
        type: 'setCurrentMacro',
        data: macro
      });

      dispatch({
        type: _action_types.types.EDIT_TEST_CASE,
        data: {
          id: id,
          macro: macro
        },
        post: saveEditing
      });

      // Save last edited macro id for each mode,
      // so that we can recover to it after switching mode
      var mode = (0, _storage3.getStorageManager)().getCurrentStrategyType();
      var key = function () {
        switch (mode) {
          case _storage3.StorageStrategyType.Browser:
            return _misc_data.MiscKey.BrowserModeLastMacroId;

          case _storage3.StorageStrategyType.XFile:
            return _misc_data.MiscKey.XFileModeLastMacroId;

          default:
            throw new Error('Invalid mode: ' + mode);
        }
      }();

      (0, _misc_data.getMiscData)().set(key, id);

      return macro;
    });
  };
}

function editNewTestCase() {
  return {
    type: _action_types.types.EDIT_NEW_TEST_CASE,
    data: null,
    post: saveEditing
  };
}

function upsertTestCase(tc) {
  return function (dispatch, getState) {
    return (0, _storage3.getStorageManager)().getMacroStorage().write(tc.name, (0, _extends3.default)({
      id: (0, _utils.uid)()
    }, tc));
  };
}

function addTestCases(_ref6) {
  var macros = _ref6.macros,
      _ref6$folder = _ref6.folder,
      folder = _ref6$folder === undefined ? '/' : _ref6$folder,
      _ref6$overwrite = _ref6.overwrite,
      overwrite = _ref6$overwrite === undefined ? false : _ref6$overwrite,
      _ref6$storageStrategy = _ref6.storageStrategyType,
      storageStrategyType = _ref6$storageStrategy === undefined ? null : _ref6$storageStrategy;

  return function (dispatch, getState) {
    var storage = (0, _storage3.getStorageManager)().getStorageForTarget(_storage3.StorageTarget.Macro, storageStrategyType || (0, _storage3.getStorageManager)().getCurrentStrategyType());
    var state = getState();
    var dirToCompare = folder === '/' ? '' : storage.relativePath(folder, true);
    var allMacros = (0, _recomputed.getMacroFileNodeList)(state);
    var macroNodes = allMacros.filter(function (node) {
      var rawDir = storage.getPathLib().dirname(node.fullPath);
      var dir = storage.relativePath(rawDir, true);

      return dirToCompare === dir;
    });
    var failTcs = [];
    var validTcs = [];

    macros.forEach(function (macro) {
      var isValid = overwrite || !macroNodes.find(function (node) {
        return node.name === macro.name;
      });

      if (isValid) {
        validTcs.push(macro);
      } else {
        failTcs.push(macro);
      }
    });

    var passCount = validTcs.length;
    var failCount = macros.length - passCount;

    if (passCount === 0) {
      return _promise2.default.resolve({ passCount: passCount, failCount: failCount, failTcs: failTcs });
    }

    var macrosToWrite = validTcs.map(function (tc) {
      return {
        filePath: _path.posix.join(folder, tc.name + '.json'),
        content: (0, _extends3.default)({}, tc, {
          id: (0, _utils.uid)(),
          udpateTime: new Date() * 1
        })
      };
    });

    return storage.ensureDirectory(folder).then(function () {
      return storage.bulkWrite(macrosToWrite);
    }).then(function () {
      return { passCount: passCount, failCount: failCount, failTcs: failTcs };
    });
  };
}

function removeTestCase(macroId) {
  return function (dispatch, getState) {
    var state = getState();
    var curId = state.editor.editing.meta.src && state.editor.editing.meta.src.id;
    var tss = state.editor.testSuites.filter(function (ts) {
      return ts.cases.find(function (m) {
        return m.testCaseId === macroId;
      });
    });

    if (tss.length > 0) {
      return _promise2.default.reject(new Error('Can\'t delete this macro for now, it\'s currently used in following test suites: ' + tss.map(function (item) {
        return item.name;
      })));
    }

    // Reset test case status
    dispatch(updateMacroPlayStatus(macroId, null));

    return (0, _storage3.getStorageManager)().getMacroStorage().remove(macroId).then(function () {
      dispatch({
        type: _action_types.types.REMOVE_TEST_CASE,
        data: {
          isCurrent: curId === macroId
        },
        post: saveEditing
      });
    }).catch(function (e) {
      return _log2.default.error(e.stack);
    });
  };
}

function removeCurrentTestCase() {
  return function (dispatch, getState) {
    var state = getState();
    var id = state.editor.editing.meta.src.id;

    return removeTestCase(id)(dispatch, getState);
  };
}

function setPlayerState(obj) {
  return {
    type: _action_types.types.SET_PLAYER_STATE,
    data: obj
  };
}

function setTimeoutStatus(args) {
  return function (dispatch) {
    dispatch(setPlayerState({
      timeoutStatus: args
    }));

    // Note: show in badge the timeout left
    _ipc_cs2.default.ask('PANEL_UPDATE_BADGE', {
      type: 'play',
      text: (args.total - args.past) / 1000 + 's'
    });
  };
}

function addPlayerWarningCommandIndex(index) {
  return function (dispatch, getState) {
    var state = getState();
    var macroId = (0, _recomputed.getCurrentMacroId)(state);
    var indices = (0, _recomputed.getWarningCommandIndices)(state);
    var warningCommandIndices = indices.indexOf(index) === -1 ? [].concat((0, _toConsumableArray3.default)(indices), [index]) : indices;
    dispatch(updateMacroExtra(macroId, { warningCommandIndices: warningCommandIndices }));
  };
}

function addPlayerErrorCommandIndex(index) {
  return function (dispatch, getState) {
    var state = getState();
    var macroId = (0, _recomputed.getCurrentMacroId)(state);
    var indices = (0, _recomputed.getErrorCommandIndices)(state);
    var errorCommandIndices = indices.indexOf(index) === -1 ? [].concat((0, _toConsumableArray3.default)(indices), [index]) : indices;
    dispatch(updateMacroExtra(macroId, { errorCommandIndices: errorCommandIndices }));
  };
}

function addLog(type, text) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return function (dispatch, getState) {
    var state = getState();
    var callStack = options.noStack ? [] : (0, _call_stack.getMacroCallStack)().toArray();
    var logItem = {
      type: type,
      text: text,
      options: options,
      id: (0, _utils.uid)(),
      createTime: new Date(),
      stack: callStack.map(function (item, i) {
        return {
          macroId: item.resource.id,
          macroName: item.resource.name,
          commandIndex: i === callStack.length - 1 ? state.player.nextCommandIndex : item.runningStatus.nextIndex,
          isSubroutine: i !== 0
        };
      })
    };

    if (state.config.logFilter !== 'None') {
      // Also write file to hard drive when it's in xfile mode
      setTimeout(function () {
        _ipc_cs2.default.ask('PANEL_LOG', { log: (0, _macro_log.renderLog)(logItem, true) });
      }, 0);
    }

    return dispatch({
      type: _action_types.types.ADD_LOGS,
      data: [logItem]
    });
  };
}

function clearLogs() {
  return {
    type: _action_types.types.CLEAR_LOGS,
    data: null
  };
}

function addScreenshot(screenshot) {
  return {
    type: _action_types.types.ADD_SCREENSHOT,
    data: (0, _extends3.default)({}, screenshot, {
      createTime: new Date()
    })
  };
}

function clearScreenshots() {
  return {
    type: _action_types.types.CLEAR_SCREENSHOTS,
    data: null,
    post: function post() {
      return (0, _storage3.getStorageManager)().getScreenshotStorage().clear();
    }
  };
}

function addVision(vision) {
  return {
    type: _action_types.types.ADD_VISION,
    data: (0, _extends3.default)({}, vision, {
      createTime: new Date()
    })
  };
}

function clearVisions() {
  return {
    type: _action_types.types.CLEAR_VISIONS,
    data: null,
    post: function post() {
      return (0, _storage3.getStorageManager)().getVisionStorage().clear();
    }
  };
}

function updateConfig(data) {
  return {
    type: _action_types.types.UPDATE_CONFIG,
    data: data,
    post: saveConfig
  };
}

function setMacrosExtra(data) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var opts = (0, _extends3.default)({
    shouldPersist: false
  }, options);

  return {
    type: _action_types.types.SET_MACROS_EXTRA,
    data: data || {},
    post: opts.shouldPersist ? saveWholeMacrosExtra : function () {}
  };
}

function setTestSuitesExtra(data) {
  return {
    type: _action_types.types.SET_TEST_SUITES_EXTRA,
    data: data || {}
  };
}

function updateMacroExtra(id, extra) {
  // TODO: the key for extra info should be different,
  // something like storage mode + storage path + file name
  return {
    type: _action_types.types.UPDATE_ONE_MACRO_EXTRA,
    data: { id: id, extra: extra },
    post: saveMacroExtra(id)
  };
}

function updateMacroPlayStatus(id, status) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, { status: status }));
  };
}

function updateMacroBreakpoints(id, breakpointIndices) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, { breakpointIndices: breakpointIndices }));
  };
}

function updateMacroDoneCommandsIndices(id, doneCommandIndices) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, { doneCommandIndices: doneCommandIndices }));
  };
}

function updateMacroErrorCommandsIndices(id, errorCommandIndices) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, { errorCommandIndices: errorCommandIndices }));
  };
}

function updateMacroWarningCommandsIndices(id, warningCommandIndices) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, { warningCommandIndices: warningCommandIndices }));
  };
}

function updateProxy(proxy) {
  return {
    type: _action_types.types.UPDATE_PROXY,
    data: proxy
  };
}

function commonPlayerState(state, options, macroId, macroName) {
  var config = state.config;

  var cfg = (0, _utils.pick)(['playHighlightElements', 'playScrollElementsIntoView'], config);
  var finalMacroName = function () {
    if (macroName) {
      return macroName;
    }

    if (!macroId) {
      return state.editor.editing.meta.src ? state.editor.editing.meta.src.name : 'Untitled';
    }

    var macro = (0, _recomputed.getMacroFileNodeList)(state).find(function (node) {
      return node.fullPath === macroId;
    });

    if (!macro) {
      throw new Error('can\'t find macro with id \'' + macroId + '\'');
    }

    return macro.name;
  }();
  var scope = (0, _extends3.default)({
    '!MACRONAME': finalMacroName,
    '!TIMEOUT_PAGELOAD': parseFloat(config.timeoutPageLoad),
    '!TIMEOUT_WAIT': parseFloat(config.timeoutElement),
    '!TIMEOUT_MACRO': parseFloat(config.timeoutMacro),
    '!TIMEOUT_DOWNLOAD': parseFloat(config.timeoutDownload),
    '!OCRLANGUAGE': config.ocrLanguage,
    '!CVSCOPE': config.cvScope,
    '!REPLAYSPEED': {
      '0': 'FAST',
      '0.3': 'MEDIUM',
      '2': 'SLOW'
    }[options.postDelay / 1000] || 'MEDIUM'
  }, options.overrideScope || {});

  var breakpoints = macroId ? (0, _recomputed.getBreakpointsByMacroId)(state, macroId) : (0, _recomputed.getBreakpoints)(state);

  var opts = (0, _utils.compose)((0, _utils.on)('resources'), _utils.map, (0, _utils.on)('extra'))(function () {
    var extra = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return (0, _extends3.default)({}, extra, cfg, options.commandExtra || {});
  })(options);

  var playerState = (0, _extends3.default)({
    title: finalMacroName
  }, opts, {
    public: (0, _extends3.default)({}, opts.public || {}, {
      scope: scope
    }),
    breakpoints: [].concat((0, _toConsumableArray3.default)(breakpoints), (0, _toConsumableArray3.default)(options.breakpoints || []))
  });

  return playerState;
}

function playerPlay(options) {
  // Filter out empty commands
  var opts = (0, _extends3.default)({}, options, {
    resources: (options.resources || []).filter(function (res) {
      return res.cmd && res.cmd.length > 0;
    })
  });

  return function (dispatch, getState) {
    return (0, _save_test_case2.default)().saveOrNot({
      getContent: function getContent(data) {
        return 'You must save macro before replay';
      },
      okText: 'Save',
      cancelText: 'Cancel',
      autoSaveExisting: true
    }).then(function (saved) {
      if (!saved) return;

      var state = getState();
      var playerState = commonPlayerState(state, opts, opts.macroId, opts.title);

      (0, _call_stack.getMacroCallStack)().clear();

      return (0, _call_stack.getMacroCallStack)().call({
        id: opts.macroId,
        name: playerState.title,
        commands: opts.resources
      }, {
        playerState: playerState,
        status: _macro.MacroStatus.Running,
        nextIndex: opts.startIndex,
        commandResults: []
      });
    });
  };
}

function listCSV() {
  return function (dispatch, getState) {
    var csvStorage = (0, _storage3.getStorageManager)().getCSVStorage();

    csvStorage.list().then(function (list) {
      return _promise2.default.all(list.map(function (item) {
        return {
          name: item.name,
          size: item.size,
          fullPath: item.fullPath,
          createTime: new Date(item.lastModified)
        };
      }));
    }).then(function (list) {
      dispatch({
        type: _action_types.types.SET_CSV_LIST,
        data: list
      });
    }).catch(function (e) {
      _log2.default.error('listCSV error', e);
      return _promise2.default.reject(e);
    });
  };
}

function listScreenshots() {
  return function (dispatch, getState) {
    var man = (0, _storage3.getStorageManager)().getScreenshotStorage();

    return man.list().then(function (list) {
      (0, _log2.default)('listScreenshots', list);

      return list.map(function (item) {
        return {
          name: item.name,
          fullPath: item.fullPath,
          createTime: new Date(item.lastModified)
        };
      });
    }).then(function (list) {
      dispatch({
        type: _action_types.types.SET_SCREENSHOT_LIST,
        data: list
      });
    }).catch(function (e) {
      _log2.default.error('listScreenshots error', e);
      return _promise2.default.reject(e);
    });
  };
}

function listVisions() {
  return function (dispatch, getState) {
    var visionStorage = (0, _storage3.getStorageManager)().getVisionStorage();

    return visionStorage.list().then(function (list) {
      (0, _log2.default)('listVisions', list);

      return list.map(function (item) {
        return {
          name: item.name,
          fullPath: item.fullPath,
          createTime: new Date(item.lastModified)
        };
      });
    }).then(function (list) {
      dispatch({
        type: _action_types.types.SET_VISION_LIST,
        data: list
      });
    }).catch(function (e) {
      _log2.default.error('listVisions error', e);
      return _promise2.default.reject(e);
    });
  };
}

function renameVisionImage(fileName) {
  var shouldUpdateCommand = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  return function (dispatch, getState) {
    return (0, _utils.withFileExtension)(fileName, function (baseName, addExtName) {
      return (0, _prompt.prompt)({
        title: 'Image Name',
        message: 'Note: Please keep the \'_dpi_xx\' postfix',
        value: baseName,
        keepOpenOnError: true,
        selectionEnd: function () {
          var m = baseName.match(/_dpi_\d+/i);
          if (!m) return undefined;
          return m.index;
        }(),
        onOk: function onOk(finalBaseName) {
          // Note: a small timeout to prevent "select" button from accepting "enter" keypress
          var timeout = (0, _utils.delay)(function () {
            return true;
          }, 100);
          if (finalBaseName === baseName) return timeout;

          try {
            (0, _utils.validateStandardName)(finalBaseName, true);
          } catch (e) {
            _message3.default.error(e.message);
            throw e;
          }

          return (0, _storage3.getStorageManager)().getVisionStorage().exists(addExtName(finalBaseName)).then(function (result) {
            if (result) {
              var msg = '\'' + addExtName(finalBaseName) + '\' already exists';
              _message3.default.error(msg);
              throw new Error(msg);
            }

            return (0, _storage3.getStorageManager)().getVisionStorage().rename(fileName, addExtName(finalBaseName)).then(function () {
              return timeout;
            }).catch(function (e) {
              // Note: If there is error in renaming like duplicate names,
              // it should show error message and let users try again
              _message3.default.error(e.message);
              throw e;
            });
          });
        }
      }).then(function (finalFullName) {
        // If users click "Cancel" button, we should delete it #479
        // Have to give it private name, since withFileExtenion will try to add '.png'
        if (!finalFullName) {
          return (0, _storage3.getStorageManager)().getVisionStorage().remove(addExtName(baseName)).then(function () {
            return dispatch(listVisions());
          }).then(function () {
            return '__kantu_deleted__';
          });
        }

        return finalFullName;
      });
    }).then(function (finalFullName) {
      // It means it's deleted (user clicks "cancel")
      if (/__kantu_deleted__/.test(finalFullName)) return;

      if (shouldUpdateCommand) {
        dispatch(updateSelectedCommand({ target: finalFullName }));
      }
      dispatch(listVisions());
      _message3.default.success('Saved vision as ' + finalFullName);
      return finalFullName;
    });
  };
}

function setTestSuites(tss) {
  return {
    type: _action_types.types.SET_TEST_SUITES,
    data: tss
  };
}

function addTestSuite(ts) {
  return function (dispatch, getState) {
    var state = getState();
    var existingtestSuites = (0, _recomputed.getTestSuitesWithAllInfo)(state);
    var hasDuplicateName = !!existingtestSuites.find(function (item) {
      return ts.name === item.name;
    });

    if (hasDuplicateName) {
      return _promise2.default.reject(new Error('The test suite name \'' + ts.name + '\' already exists!'));
    }

    return (0, _storage3.getStorageManager)().getTestSuiteStorage().write(ts.name, (0, _extends3.default)({}, ts, {
      id: (0, _utils.uid)(),
      updateTime: new Date() * 1
    }));
  };
}

function addTestSuites(tss) {
  var storageStrategyType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  return function (dispatch, getState) {
    var state = getState();
    var existingtestSuites = (0, _recomputed.getTestSuitesWithAllInfo)(state);

    var validTss = tss.filter(function (ts) {
      return !existingtestSuites.find(function (item) {
        return item.name === ts.name;
      });
    });
    var passCount = validTss.length;
    var failCount = tss.length - passCount;

    if (passCount === 0) {
      return _promise2.default.resolve({ passCount: passCount, failCount: failCount, failTss: [] });
    }

    var storage = (0, _storage3.getStorageManager)().getStorageForTarget(_storage3.StorageTarget.TestSuite, storageStrategyType || (0, _storage3.getStorageManager)().getCurrentStrategyType());

    var testSuitesToWrite = validTss.map(function (ts) {
      return {
        filePath: ts.name,
        content: (0, _extends3.default)({}, ts, {
          id: (0, _utils.uid)(),
          updateTime: new Date() * 1
        })
      };
    });

    return storage.ensureDir().then(function () {
      return storage.bulkWrite(testSuitesToWrite);
    }).then(function () {
      return { passCount: passCount, failCount: failCount, failTss: [] };
    });
  };
}

function removeTestSuite(id) {
  return function (dispatch, getState) {
    var state = getState();
    var ts = state.editor.testSuites.find(function (ts) {
      return ts.id === id;
    });

    if (!ts) throw new Error('can\'t find test suite with id \'' + id + '\'');

    // Reset test suite status
    dispatch({
      type: _action_types.types.UPDATE_TEST_SUITE_STATUS,
      data: {
        id: id,
        extra: {
          fold: false,
          playStatus: {}
        }
      }
    });

    return (0, _storage3.getStorageManager)().getTestSuiteStorage().remove(ts.name);
  };
}

function setPlayerMode(mode) {
  return {
    type: _action_types.types.SET_PLAYER_STATE,
    data: { mode: mode }
  };
}

function runBackup() {
  return function (dispatch, getState) {
    var state = getState();
    var config = state.config,
        editor = state.editor;
    var autoBackupTestCases = config.autoBackupTestCases,
        autoBackupTestSuites = config.autoBackupTestSuites,
        autoBackupScreenshots = config.autoBackupScreenshots,
        autoBackupCSVFiles = config.autoBackupCSVFiles,
        autoBackupVisionImages = config.autoBackupVisionImages;


    var sm = (0, _storage3.getStorageManager)();

    return _promise2.default.all([sm.getCSVStorage().list(), sm.getScreenshotStorage().list(), sm.getVisionStorage().list()]).then(function (_ref7) {
      var _ref8 = (0, _slicedToArray3.default)(_ref7, 3),
          csvs = _ref8[0],
          screenshots = _ref8[1],
          visions = _ref8[2];

      return (0, _backup.backup)({
        csvs: csvs,
        screenshots: screenshots,
        visions: visions,
        macroNodes: (0, _recomputed.getMacroFileNodeList)(state),
        testSuites: editor.testSuites,
        backup: {
          testCase: autoBackupTestCases,
          testSuite: autoBackupTestSuites,
          screenshot: autoBackupScreenshots,
          csv: autoBackupCSVFiles,
          vision: autoBackupVisionImages
        }
      });
    }).catch(function (e) {
      _log2.default.error(e.stack);
    });
  };
}

function setVariables(variables) {
  variables.sort(function (a, b) {
    if (a.key < b.key) return -1;
    if (a.key > b.key) return 1;
    return 0;
  });

  return {
    type: _action_types.types.SET_VARIABLE_LIST,
    data: variables
  };
}

function updateUI(data) {
  return {
    type: _action_types.types.UPDATE_UI,
    data: data
  };
}

function addBreakpoint(macroId, commandIndex) {
  return function (dispatch, getState) {
    var state = getState();
    var extra = state.editor.macrosExtra[macroId] || {};
    var indices = extra.breakpointIndices || [];
    var newIndices = indices.indexOf(commandIndex) === -1 ? [].concat((0, _toConsumableArray3.default)(indices), [commandIndex]) : indices;

    dispatch(updateMacroBreakpoints(macroId, newIndices));
  };
}

function removeBreakpoint(macroId, commandIndex) {
  return function (dispatch, getState) {
    var state = getState();
    var extra = state.editor.macrosExtra[macroId] || {};
    var indices = extra.breakpointIndices || [];
    var newIndices = indices.filter(function (index) {
      return index !== commandIndex;
    });

    dispatch(updateMacroBreakpoints(macroId, newIndices));
  };
}

function setEditorActiveTab(tab) {
  return {
    type: _action_types.types.SET_EDITOR_ACTIVE_TAB,
    data: tab
  };
}

function preinstall() {
  var yesInstall = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

  return function (dispatch, getState) {
    var markThisVersion = function markThisVersion() {
      return _storage2.default.get('preinstall_info').then(function () {
        var info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var prevVersions = info.askedVersions || [];
        var thisVersion = _config2.default.preinstall.version;
        var hasThisOne = prevVersions.indexOf(thisVersion) !== -1;

        if (hasThisOne) return true;

        return _storage2.default.set('preinstall_info', (0, _extends3.default)({}, info, {
          askedVersions: [].concat((0, _toConsumableArray3.default)(prevVersions), [thisVersion])
        }));
      });
    };

    if (!yesInstall) return markThisVersion();

    (0, _log2.default)('PREINSTALL_CSV_LIST', ["preinstall/csv/readcsvtestdata.csv"]);
    (0, _log2.default)('PREINSTALL_VISION_LIST', ["preinstall/vision/canvas_3dots_verify_dpi_96.png","preinstall/vision/canvas_hydepark_dpi_96.png","preinstall/vision/canvas_hydepark_extract_dpi_96_relative.png","preinstall/vision/canvas_hydepark_verify_dpi_96.png","preinstall/vision/canvas_wyoming_dpi_96.png","preinstall/vision/canvas_wyoming_verify_dpi_96.png","preinstall/vision/democv_checkoverlay.png","preinstall/vision/democv_ocrdone.png","preinstall/vision/democv_share.png","preinstall/vision/democv_startocr.png","preinstall/vision/desktop_area_bottomright_dpi_96.png","preinstall/vision/desktop_area_topleft3_dpi_96.png","preinstall/vision/desktop_checktab_dpi_96.png","preinstall/vision/desktop_clearbutton_dpi_96.png","preinstall/vision/desktop_logstab_grey_dpi_96.png","preinstall/vision/desktop_logstab_white_dpi_96.png","preinstall/vision/desktop_scrtab_dpi_96.png","preinstall/vision/desktop_searcharea_dpi_96_relative.png","preinstall/vision/desktop_vartab_dpi_96.png","preinstall/vision/desktop_vitab_dpi_96.png","preinstall/vision/draw_canvas_dpi_96.png","preinstall/vision/draw_checkresult1_dpi_96.png","preinstall/vision/draw_pencil_dpi_96.png","preinstall/vision/draw_plus_dpi_96.png","preinstall/vision/draw_redbutton_dpi_96.png","preinstall/vision/draw_startingpoint_dpi_96.png","preinstall/vision/draw_text1_dpi_96.png","preinstall/vision/getquotenumber_dpi_96_relative.png","preinstall/vision/pdftest_salesquote.png","preinstall/vision/slider_handle_dpi_96.png","preinstall/vision/slider_red_dpi_96.png","preinstall/vision/uitest_download_dpi_96.png","preinstall/vision/uitest_hamburger_dpi_96.png","preinstall/vision/uitest_logo_mobile_dpi_96.png","preinstall/vision/uitest_logo_wide_dpi_96.png","preinstall/vision/uitest_share_dpi_96.png","preinstall/vision/youtube_play_button.png","preinstall/vision/youtube_video_content_verify.png"]);

    var installMacrosAndSuites = function installMacrosAndSuites() {
      if (!_preinstall_macros2.default || !(0, _keys2.default)(_preinstall_macros2.default).length) return _promise2.default.resolve();

      var installMacros = function installMacros() {
        var macroStorage = (0, _storage3.getStorageManager)().getMacroStorage();
        var path = macroStorage.getPathLib();
        var folders = (0, _keys2.default)(_preinstall_macros2.default).map(function (relativePath) {
          return path.join(_config2.default.preinstall.macroFolder, path.dirname(relativePath));
        });
        var uniqueFolders = _ts_utils.uniqueStrings.apply(undefined, (0, _toConsumableArray3.default)(folders));

        return _ts_utils.flow.apply(undefined, (0, _toConsumableArray3.default)(uniqueFolders.map(function (dirPath) {
          return function () {
            return macroStorage.ensureDirectory(dirPath);
          };
        }))).then(function () {
          return _promise2.default.all((0, _keys2.default)(_preinstall_macros2.default).map(function (relativePath) {
            var macroName = path.basename(relativePath);
            var filePath = macroStorage.filePath(path.join(_config2.default.preinstall.macroFolder, relativePath));
            var str = (0, _stringify2.default)(_preinstall_macros2.default[relativePath]);
            var macro = (0, _convert_utils.fromJSONString)(str, macroName);

            return macroStorage.write(filePath, macro);
          }));
        });
      };

      var installTestSuites = function installTestSuites() {
        var tss = _preinstall_suites2.default.map(function (ts) {
          return (0, _convert_suite_utils.parseTestSuite)((0, _stringify2.default)(ts));
        });
        dispatch(addTestSuites(tss, _storage3.StorageStrategyType.Browser));
      };

      return (0, _ts_utils.flow)(installMacros, installTestSuites);
    };

    // Preinstall csv
    var installCsvs = function installCsvs() {
      var list = ["preinstall/csv/readcsvtestdata.csv"];
      if (list.length === 0) return _promise2.default.resolve();

      // Note: preinstalled resources all go into browser mode
      var csvStorage = (0, _storage3.getStorageManager)().getStorageForTarget(_storage3.StorageTarget.CSV, _storage3.StorageStrategyType.Browser);

      return csvStorage.ensureDir().then(function () {
        var ps = list.map(function (url) {
          var parts = url.split('/');
          var fileName = parts[parts.length - 1];

          return (0, _utils.loadCsv)(url).then(function (text) {
            return csvStorage.write(fileName, new Blob([text]));
          });
        });

        return _promise2.default.resolve(ps)
        // Note: delay needed for Firefox and slow Chrome
        .then(function () {
          return (0, _utils.delay)(function () {}, 3000);
        }).then(function () {
          dispatch(listCSV());
        });
      });
    };

    // Preinstall vision images
    var installVisionImages = function installVisionImages() {
      var list = ["preinstall/vision/canvas_3dots_verify_dpi_96.png","preinstall/vision/canvas_hydepark_dpi_96.png","preinstall/vision/canvas_hydepark_extract_dpi_96_relative.png","preinstall/vision/canvas_hydepark_verify_dpi_96.png","preinstall/vision/canvas_wyoming_dpi_96.png","preinstall/vision/canvas_wyoming_verify_dpi_96.png","preinstall/vision/democv_checkoverlay.png","preinstall/vision/democv_ocrdone.png","preinstall/vision/democv_share.png","preinstall/vision/democv_startocr.png","preinstall/vision/desktop_area_bottomright_dpi_96.png","preinstall/vision/desktop_area_topleft3_dpi_96.png","preinstall/vision/desktop_checktab_dpi_96.png","preinstall/vision/desktop_clearbutton_dpi_96.png","preinstall/vision/desktop_logstab_grey_dpi_96.png","preinstall/vision/desktop_logstab_white_dpi_96.png","preinstall/vision/desktop_scrtab_dpi_96.png","preinstall/vision/desktop_searcharea_dpi_96_relative.png","preinstall/vision/desktop_vartab_dpi_96.png","preinstall/vision/desktop_vitab_dpi_96.png","preinstall/vision/draw_canvas_dpi_96.png","preinstall/vision/draw_checkresult1_dpi_96.png","preinstall/vision/draw_pencil_dpi_96.png","preinstall/vision/draw_plus_dpi_96.png","preinstall/vision/draw_redbutton_dpi_96.png","preinstall/vision/draw_startingpoint_dpi_96.png","preinstall/vision/draw_text1_dpi_96.png","preinstall/vision/getquotenumber_dpi_96_relative.png","preinstall/vision/pdftest_salesquote.png","preinstall/vision/slider_handle_dpi_96.png","preinstall/vision/slider_red_dpi_96.png","preinstall/vision/uitest_download_dpi_96.png","preinstall/vision/uitest_hamburger_dpi_96.png","preinstall/vision/uitest_logo_mobile_dpi_96.png","preinstall/vision/uitest_logo_wide_dpi_96.png","preinstall/vision/uitest_share_dpi_96.png","preinstall/vision/youtube_play_button.png","preinstall/vision/youtube_video_content_verify.png"];
      if (list.length === 0) return _promise2.default.resolve();

      // Note: preinstalled resources all go into browser mode
      var visionStorage = (0, _storage3.getStorageManager)().getStorageForTarget(_storage3.StorageTarget.Vision, _storage3.StorageStrategyType.Browser);

      return visionStorage.ensureDir().then(function () {
        var ps = list.map(function (url) {
          var parts = url.split('/');
          var fileName = parts[parts.length - 1];

          return (0, _utils.loadImage)(url).then(function (blob) {
            return visionStorage.write(fileName, blob);
          });
        });

        return _promise2.default.resolve(ps)
        // Note: delay needed for Firefox and slow Chrome
        .then(function () {
          return (0, _utils.delay)(function () {}, 3000);
        }).then(function () {
          dispatch(listVisions());
        });
      });
    };

    return _promise2.default.all([installMacrosAndSuites(), installCsvs(), installVisionImages()]).then(markThisVersion);
  };
}

/***/ }),

/***/ 29541:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _button = __webpack_require__(65400);

var _button2 = _interopRequireDefault(_button);

var _modal = __webpack_require__(56697);

var _modal2 = _interopRequireDefault(_modal);

var _message2 = __webpack_require__(11187);

var _message3 = _interopRequireDefault(_message2);

var _getPrototypeOf = __webpack_require__(85105);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(49135);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(93196);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(67294);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(33664);

var _redux = __webpack_require__(74127);

var _reactRouterDom = __webpack_require__(27597);

var _antd = __webpack_require__(56318);

var _actions = __webpack_require__(97876);

var actions = _interopRequireWildcard(_actions);

var _constant = __webpack_require__(43232);

var C = _interopRequireWildcard(_constant);

var _ipc_cs = __webpack_require__(41471);

var _ipc_cs2 = _interopRequireDefault(_ipc_cs);

var _header = __webpack_require__(74835);

var _header2 = _interopRequireDefault(_header);

var _sidebar = __webpack_require__(75256);

var _sidebar2 = _interopRequireDefault(_sidebar);

var _dashboard = __webpack_require__(35539);

var _dashboard2 = _interopRequireDefault(_dashboard);

__webpack_require__(11067);

__webpack_require__(25941);

var _state = __webpack_require__(16112);

var _recomputed = __webpack_require__(78328);

var _player = __webpack_require__(43625);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var App = function (_Component) {
  (0, _inherits3.default)(App, _Component);

  function App() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, App);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = App.__proto__ || (0, _getPrototypeOf2.default)(App)).call.apply(_ref, [this].concat(args))), _this), _this.hideBackupAlert = function () {
      _this.props.updateConfig({
        lastBackupActionTime: new Date() * 1
      });
      _this.$app.classList.remove('with-alert');
    }, _this.onClickBackup = function () {
      _this.props.runBackup();
      _this.hideBackupAlert();
    }, _this.onClickNoBackup = function () {
      _this.hideBackupAlert();
    }, _this.onClickMainArea = function () {
      _this.props.updateUI({ focusArea: _state.FocusArea.Unknown });
    }, _this.getPlayer = function (name) {
      if (name) return (0, _player.getPlayer)({ name: name });

      switch (_this.props.player.mode) {
        case C.PLAYER_MODE.TEST_CASE:
          return (0, _player.getPlayer)({ name: 'testCase' });

        case C.PLAYER_MODE.TEST_SUITE:
          return (0, _player.getPlayer)({ name: 'testSuite' });
      }
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  (0, _createClass3.default)(App, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var run = function run() {
        _ipc_cs2.default.ask('PANEL_TIME_FOR_BACKUP', {}).then(function (isTime) {
          if (!isTime) return;
          _this2.$app.classList.add('with-alert');
        });
      };

      // Note: check whether it's time for backup every 5 minutes
      this.timer = setInterval(run, 5 * 60000);
      run();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearInterval(this.timer);
    }
  }, {
    key: 'renderPreinstallModal',
    value: function renderPreinstallModal() {
      var _this3 = this;

      if (!this.props.ui.newPreinstallVersion) return null;

      return _react2.default.createElement(
        _modal2.default,
        {
          className: 'preinstall-modal',
          visible: true,
          title: 'New demo macros available',
          okText: 'Yes, overwrite',
          cancelText: 'Skip',
          onOk: function onOk() {
            _this3.props.updateUI({ newPreinstallVersion: false });

            return _this3.props.preinstall(true).then(function () {
              _message3.default.success('demo macros updated');
            }).catch(function (e) {
              _message3.default.error(e.message);
            });
          },
          onCancel: function onCancel() {
            _this3.props.updateUI({ newPreinstallVersion: false });
            _this3.props.preinstall(false);
          }
        },
        _react2.default.createElement(
          'p',
          { style: { fontSize: '14px' } },
          'Do you want to overwrite the demo macros with their latest versions?'
        )
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      if (this.props.noDisplay) {
        return _react2.default.createElement(
          'div',
          { className: 'app no-display' },
          _react2.default.createElement(
            'div',
            { className: 'content' },
            _react2.default.createElement(
              'div',
              { className: 'status' },
              'UI.Vision is in "No Display" mode now'
            ),
            _react2.default.createElement(
              _button2.default.Group,
              { className: 'simple-actions' },
              _react2.default.createElement(
                _button2.default,
                { size: 'large', onClick: function onClick() {
                    return _this4.getPlayer().stop();
                  } },
                _react2.default.createElement(
                  'span',
                  null,
                  'Stop'
                )
              ),
              _react2.default.createElement(
                _button2.default,
                { size: 'large', onClick: function onClick() {
                    return _this4.getPlayer('testCase').pause();
                  } },
                _react2.default.createElement(
                  'span',
                  null,
                  'Pause'
                )
              )
            )
          )
        );
      }

      return _react2.default.createElement(
        'div',
        { className: 'app with-sidebar', ref: function ref(el) {
            _this4.$app = el;
          } },
        _react2.default.createElement(
          'div',
          { className: 'backup-alert' },
          _react2.default.createElement(
            'span',
            null,
            'Do you want to run the automated backup?'
          ),
          _react2.default.createElement(
            'span',
            { className: 'backup-actions' },
            _react2.default.createElement(
              _button2.default,
              { type: 'primary', onClick: this.onClickBackup },
              'Yes'
            ),
            _react2.default.createElement(
              _button2.default,
              { onClick: this.onClickNoBackup },
              'No'
            )
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'app-inner' },
          _react2.default.createElement(_sidebar2.default, null),
          _react2.default.createElement(
            'section',
            {
              className: 'content',
              onClickCapture: this.onClickMainArea
            },
            _react2.default.createElement(_header2.default, null),
            _react2.default.createElement(_dashboard2.default, null)
          )
        ),
        this.renderPreinstallModal()
      );
    }
  }]);
  return App;
}(_react.Component);

exports["default"] = (0, _reactRedux.connect)(function (state) {
  return {
    ui: state.ui,
    player: state.player,
    noDisplay: (0, _recomputed.isNoDisplay)(state)
  };
}, function (dispatch) {
  return (0, _redux.bindActionCreators)((0, _extends3.default)({}, actions), dispatch);
})(App);

/***/ }),

/***/ 75303:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createBookmarkOnBar = undefined;

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _web_extension = __webpack_require__(61171);

var _web_extension2 = _interopRequireDefault(_web_extension);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Note: Get ids of bookmarks bar and other bookmarks
var pBookmarksBarId = function getIdsOfOtherBookmarksAndBookmarksBar() {
  var bookmarksBarIndex = _web_extension2.default.isFirefox() ? 1 : 0;

  return _web_extension2.default.bookmarks.getTree().then(function (nodes) {
    var bookmarksBar = nodes[0].children[bookmarksBarIndex];
    return bookmarksBar.id;
  });
}();

var createBookmarkOnBar = exports.createBookmarkOnBar = function createBookmarkOnBar(bookmark) {
  return pBookmarksBarId.then(function (barId) {
    return _web_extension2.default.bookmarks.create((0, _extends3.default)({}, bookmark, { parentId: barId }));
  });
};

/***/ }),

/***/ 80334:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

exports.parseFromCSV = parseFromCSV;
exports.stringifyToCSV = stringifyToCSV;
exports.toCsvDataURI = toCsvDataURI;

var _csv = __webpack_require__(61098);

var _csv2 = _interopRequireDefault(_csv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var csvDataURI = function csvDataURI(csvStr) {
  return 'data:text/csv;base64,' + window.btoa(unescape(encodeURIComponent(csvStr)));
};

function parseFromCSV(text) {
  return new _promise2.default(function (resolve, reject) {
    _csv2.default.parse(text, function (err, data) {
      if (err) return reject(err);
      return resolve(data);
    });
  });
}

function stringifyToCSV(list) {
  return new _promise2.default(function (resolve, reject) {
    _csv2.default.stringify(list, function (err, data) {
      if (err) return reject(err);
      return resolve(data);
    });
  });
}

function toCsvDataURI(list) {
  return stringifyToCSV(list).then(csvDataURI);
}

/***/ }),

/***/ 89412:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getDownloadMan = exports.DownloadMan = undefined;

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

var _slicedToArray2 = __webpack_require__(12424);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _web_extension = __webpack_require__(61171);

var _web_extension2 = _interopRequireDefault(_web_extension);

var _log = __webpack_require__(77242);

var _log2 = _interopRequireDefault(_log);

var _utils = __webpack_require__(63370);

var _ts_utils = __webpack_require__(55452);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DownloadMan = exports.DownloadMan = function () {
  function DownloadMan() {
    var _this = this;

    (0, _classCallCheck3.default)(this, DownloadMan);
    this.activeDownloads = [];
    this.eventsBound = false;

    this.filterActiveDownloads = function (predicate) {
      _this.activeDownloads = _this.activeDownloads.filter(predicate);

      if (_this.activeDownloads.length === 0) {
        _this.unbindEvents();
      }
    };

    this.createdListener = function (downloadItem) {
      if (!_this.isActive()) return;
      (0, _log2.default)('download on created', downloadItem);

      var item = _this.activeDownloads.find(function (item) {
        return !item.id;
      });
      if (!item) return;

      // Note: 3 things to do on download created
      // 1. record download id
      // 2. Start timer for timeout
      // 3. Start interval timer for count down message
      (0, _extends3.default)(item, (0, _extends3.default)({
        id: downloadItem.id
      }, !item.wait && item.timeout > 0 ? {} : {
        timeoutTimer: setTimeout(function () {
          item.reject(new Error('download timeout ' + item.timeout / 1000 + 's'));
          _this.filterActiveDownloads(function (d) {
            return item.uid !== d.uid;
          });
        }, item.timeout),

        countDownTimer: setInterval(function () {
          if (!_this.countDownHandler) return;

          var _item$past = item.past,
              past = _item$past === undefined ? 0 : _item$past;

          var newPast = past + 1000;

          _this.countDownHandler({
            total: item.timeout,
            past: newPast
          });
          (0, _extends3.default)(item, { past: newPast });
        }, 1000)
      }));
    };

    this.changedListener = function (downloadDelta) {
      if (!_this.isActive()) return;
      (0, _log2.default)('download on changed', downloadDelta);

      var item = _this.findById(downloadDelta.id);
      if (!item) return;

      if (downloadDelta.state) {
        var fn = function fn() {};
        var done = false;

        switch (downloadDelta.state.current) {
          case 'complete':
            fn = function fn() {
              return item.resolve(true);
            };
            done = true;

            if (_this.completeHandler) {
              _web_extension2.default.downloads.search({ id: item.id }).then(function (_ref) {
                var _ref2 = (0, _slicedToArray3.default)(_ref, 1),
                    downloadItem = _ref2[0];

                if (downloadItem) {
                  _this.completeHandler(downloadItem);
                }
              });
            }
            break;

          case 'interrupted':
            fn = function fn() {
              return item.reject(new Error('download interrupted'));
            };
            done = true;
            break;
        }

        // Remove this download item from our todo list if it's done
        if (done) {
          clearTimeout(item.timeoutTimer);
          clearInterval(item.countDownTimer);
          _this.filterActiveDownloads(function (item) {
            return item.id !== downloadDelta.id;
          });
        }

        // resolve or reject that promise object
        fn();
      }
    };

    this.determineFileNameListener = function (downloadItem, suggest) {
      if (!_this.isActive()) return;

      (0, _log2.default)('download on determine', downloadItem);

      var item = _this.findById(downloadItem.id);
      if (!item) return;

      var tmpName = item.fileName.trim();
      var fileName = tmpName === '' || tmpName === '*' ? null : tmpName;

      if (fileName) {
        return suggest({
          filename: fileName,
          conflictAction: 'uniquify'
        });
      }
    };
  }

  (0, _createClass3.default)(DownloadMan, [{
    key: 'isActive',


    /*
     * Private methods
     */

    value: function isActive() {
      return this.activeDownloads.length > 0;
    }
  }, {
    key: 'findById',
    value: function findById(id) {
      return this.activeDownloads.find(function (item) {
        return item.id === id;
      });
    }
  }, {
    key: 'bindEvents',
    value: function bindEvents() {
      if (this.eventsBound) return;

      _web_extension2.default.downloads.onCreated.addListener(this.createdListener);
      _web_extension2.default.downloads.onChanged.addListener(this.changedListener);

      // Note: only chrome supports api `chrome.downloads.onDeterminingFilename`
      if (_web_extension2.default.downloads.onDeterminingFilename) {
        _web_extension2.default.downloads.onDeterminingFilename.addListener(this.determineFileNameListener);
      }

      this.eventsBound = true;
    }
  }, {
    key: 'unbindEvents',
    value: function unbindEvents() {
      if (!this.eventsBound) return;

      if (_web_extension2.default.downloads.onCreated.removeListener) {
        _web_extension2.default.downloads.onCreated.removeListener(this.createdListener);
      }

      if (_web_extension2.default.downloads.onChanged.removeListener) {
        _web_extension2.default.downloads.onChanged.removeListener(this.changedListener);
      }

      if (_web_extension2.default.downloads.onDeterminingFilename && _web_extension2.default.downloads.onDeterminingFilename.removeListener) {
        _web_extension2.default.downloads.onDeterminingFilename.removeListener(this.determineFileNameListener);
      }

      this.eventsBound = false;
    }

    /*
     * Public methods
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.activeDownloads.forEach(function (item) {
        if (item.timeoutTimer) clearTimeout(item.timeoutTimer);
        if (item.countDownTimer) clearInterval(item.countDownTimer);
      });
      this.activeDownloads = [];
      this.unbindEvents();
    }
  }, {
    key: 'prepareDownload',
    value: function prepareDownload(fileName) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var downloadToCreate = this.activeDownloads.find(function (item) {
        return !item.id;
      });
      if (downloadToCreate) throw new Error('only one not-created download allowed at a time');

      this.bindEvents();

      var opts = (0, _extends3.default)({
        timeoutForStart: 10000,
        timeout: 60000,
        wait: false
      }, options);

      var promise = new _promise2.default(function (resolve, reject) {
        var uid = Math.floor(Math.random() * 1000) + new Date() * 1;

        // Note: we need to cache promise object, so have to wait for next tick
        setTimeout(function () {
          _this2.activeDownloads.push({
            uid: uid,
            resolve: resolve,
            reject: reject,
            fileName: fileName,
            promise: promise,
            timeoutForStart: opts.timeoutForStart,
            timeout: opts.timeout,
            wait: opts.wait
          });
        }, 0);
      });

      return promise;
    }
  }, {
    key: 'waitForDownloadIfAny',
    value: function waitForDownloadIfAny() {
      var _this3 = this;

      var downloadToCreate = this.activeDownloads.find(function (item) {
        return !item.id;
      });
      if (downloadToCreate) {
        return (0, _utils.until)('download start', function () {
          return {
            pass: !!downloadToCreate.id,
            result: true
          };
        }, 50, downloadToCreate.timeoutForStart).then(function () {
          return _this3.waitForDownloadIfAny();
        });
      }

      // Note: check if id exists, because it means this download item is created
      var downloadToComplete = this.activeDownloads.find(function (item) {
        return item.wait && item.id;
      });

      // A short delay after download is complete, so that background has time to send DOWNLOAD_COMPLETE event before it unblocks next command
      if (!downloadToComplete) return (0, _ts_utils.delay)(function () {
        return true;
      }, 500);
      return downloadToComplete.promise.then(function () {
        return _this3.waitForDownloadIfAny();
      });
    }
  }, {
    key: 'onCountDown',
    value: function onCountDown(fn) {
      this.countDownHandler = fn;
    }
  }, {
    key: 'onDownloadComplete',
    value: function onDownloadComplete(fn) {
      this.completeHandler = fn;
    }
  }, {
    key: 'hasPendingDownload',
    value: function hasPendingDownload() {
      var downloadToCreate = this.activeDownloads.find(function (item) {
        return !item.id;
      });
      return !!downloadToCreate;
    }
  }]);
  return DownloadMan;
}();

var getDownloadMan = exports.getDownloadMan = function () {
  var instance = void 0;

  return function () {
    if (!instance) {
      instance = new DownloadMan();
    }

    return instance;
  };
}();

/***/ }),

/***/ 77930:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decryptIfNeeded = exports.encryptIfNeeded = exports.decrypt = exports.encrypt = exports.aesDecrypt = exports.aesEncrypt = undefined;

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

var _pbkdf = __webpack_require__(25632);

var _pbkdf2 = _interopRequireDefault(_pbkdf);

var _aesJs = __webpack_require__(78826);

var _aesJs2 = _interopRequireDefault(_aesJs);

var _web_extension = __webpack_require__(61171);

var _web_extension2 = _interopRequireDefault(_web_extension);

var _storage = __webpack_require__(67585);

var _storage2 = _interopRequireDefault(_storage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RAW_PREFIX = '@_KANTU_@';
var DEPRECATED_CIPHER_PREFIX = '__KANTU_ENCRYPTED__';
var CIPHER_PREFIX = '__RPA_ENCRYPTED__';
var RAW_PREFIX_REG = new RegExp('^' + RAW_PREFIX);
var CIPHER_PREFIX_REG = new RegExp('^(' + CIPHER_PREFIX + '|' + DEPRECATED_CIPHER_PREFIX + ')');

var getEncryptConfig = function getEncryptConfig() {
  return _storage2.default.get('config').then(function (config) {
    return {
      shouldEncrypt: config.shouldEncryptPassword === 'master_password',
      masterPassword: config.masterPassword
    };
  });
};

var aesEncrypt = exports.aesEncrypt = function aesEncrypt(text, password) {
  var key = _pbkdf2.default.pbkdf2Sync(password, 'salt', 1, 256 / 8, 'sha512');
  var engine = new _aesJs2.default.ModeOfOperation.ctr(key);

  return _aesJs2.default.utils.hex.fromBytes(engine.encrypt(_aesJs2.default.utils.utf8.toBytes(text)));
};

var aesDecrypt = exports.aesDecrypt = function aesDecrypt(text, password) {
  var key = _pbkdf2.default.pbkdf2Sync(password, 'salt', 1, 256 / 8, 'sha512');
  var engine = new _aesJs2.default.ModeOfOperation.ctr(key);

  return _aesJs2.default.utils.utf8.fromBytes(engine.decrypt(_aesJs2.default.utils.hex.toBytes(text)));
};

var encrypt = exports.encrypt = function encrypt(text) {
  return getEncryptConfig().then(function (_ref) {
    var shouldEncrypt = _ref.shouldEncrypt,
        masterPassword = _ref.masterPassword;

    if (!shouldEncrypt) return text;
    return '' + CIPHER_PREFIX + aesEncrypt(RAW_PREFIX + text, masterPassword);
  });
};

var decrypt = exports.decrypt = function decrypt(text) {
  return getEncryptConfig().then(function (_ref2) {
    var shouldEncrypt = _ref2.shouldEncrypt,
        masterPassword = _ref2.masterPassword;

    if (!shouldEncrypt) return text;
    var raw = aesDecrypt(text.replace(CIPHER_PREFIX_REG, ''), masterPassword);
    if (raw.indexOf(RAW_PREFIX) !== 0) throw new Error('Wrong master password');
    return raw.replace(RAW_PREFIX_REG, '');
  }).catch(function (e) {
    throw new Error('password string invalid');
  });
};

var encryptIfNeeded = exports.encryptIfNeeded = function encryptIfNeeded(text, dom) {
  if (dom && dom.tagName.toUpperCase() === 'INPUT' && dom.type === 'password') {
    return encrypt(text);
  }

  return _promise2.default.resolve(text);
};

var decryptIfNeeded = exports.decryptIfNeeded = function decryptIfNeeded(text, dom) {
  if (!CIPHER_PREFIX_REG.test(text)) {
    return _promise2.default.resolve(text);
  }

  if (!dom || ['INPUT', 'TEXTAREA'].indexOf(dom.tagName.toUpperCase()) !== -1) {
    return decrypt(text);
  }

  return _promise2.default.resolve(text);
};

/***/ }),

/***/ 53867:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

exports.evaluateScript = evaluateScript;

var _kdJsInterpreter = __webpack_require__(20725);

var _kdJsInterpreter2 = _interopRequireDefault(_kdJsInterpreter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function evaluateScript(code) {
  var interpreter = new _kdJsInterpreter2.default(code);
  var run = function run() {
    var hasMore = interpreter.run();

    if (!hasMore) {
      return _promise2.default.resolve(interpreter.value);
    }

    return new _promise2.default(function (resolve) {
      setTimeout(function () {
        resolve(run());
      }, 100);
    });
  };

  return run();
}

/***/ }),

/***/ 14537:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _typeof2 = __webpack_require__(72444);

var _typeof3 = _interopRequireDefault(_typeof2);

var _keys = __webpack_require__(88902);

var _keys2 = _interopRequireDefault(_keys);

var _from = __webpack_require__(24043);

var _from2 = _interopRequireDefault(_from);

var _log = __webpack_require__(77242);

var _log2 = _interopRequireDefault(_log);

var _dom_utils = __webpack_require__(24874);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Basic tool function
 */

var extend = function extend() {
  var args = (0, _from2.default)(arguments);
  var len = args.length;

  if (len <= 0) return {};
  if (len === 1) return args[0];

  var head = args[0];
  var rest = args.slice(1);

  return rest.reduce(function (prev, cur) {
    for (var i = 0, keys = (0, _keys2.default)(cur), len = keys.length; i < len; i++) {
      prev[keys[i]] = cur[keys[i]];
    }

    return prev;
  }, head);
};

var isArray = Array.isArray;

var id = function id(x) {
  return x;
};

var trim = function trim(str) {
  return str.replace(/^\s*|\s*$/g, '');
};

var flatten = function flatten(list) {
  return [].concat.apply([], list);
};

var sum = function sum() {
  var list = (0, _from2.default)(arguments);
  return list.reduce(function (prev, cur) {
    return prev + cur;
  }, 0);
};

var last = function last(list) {
  return list[list.length - 1];
};

var or = function or(list) {
  return (list || []).reduce(function (prev, cur) {
    return prev || cur;
  }, false);
};

var and = function and(list) {
  return (list || []).reduce(function (prev, cur) {
    return prev && cur;
  }, true);
};

var zipWith = function zipWith(fn) {
  if (arguments.length < 3) return null;

  var list = (0, _from2.default)(arguments).slice(1);
  var len = list.reduce(function (min, cur) {
    return cur.length < min ? cur.length : min;
  }, Infinity);
  var ret = [];

  for (var i = 0; i < len; i++) {
    ret.push(fn.apply(null, list.map(function (item) {
      return item[i];
    })));
  }

  return ret;
};

var intersect = function intersect() {
  var list = (0, _from2.default)(arguments);
  var len = Math.max.apply(null, list.map(function (item) {
    return item.length;
  }));
  var result = [];

  for (var i = 0; i < len; i++) {
    var val = list[0][i];
    var no = list.filter(function (item) {
      return item[i] !== val;
    });

    if (no && no.length) break;

    result.push(val);
  }

  return result;
};

var deepEqual = function deepEqual(a, b) {
  if (isArray(a) && isArray(b)) {
    return a.length === b.length && and(zipWith(deepEqual, a, b));
  }

  if ((typeof a === 'undefined' ? 'undefined' : (0, _typeof3.default)(a)) === 'object' && (typeof b === 'undefined' ? 'undefined' : (0, _typeof3.default)(b)) === 'object') {
    // TODO
    return false;
  }

  return a === b;
};

/*
 * Dom helper function
 */

var pixel = function pixel(num) {
  if ((num + '').indexOf('px') !== -1) return num;
  return (num || 0) + 'px';
};

var getStyle = function getStyle(dom, styleName) {
  if (!dom) throw new Error('getStyle: dom does not exist');
  return getComputedStyle(dom)[styleName];
};

var setStyle = function setStyle(dom, style) {
  if (!dom) throw new Error('setStyle: dom does not exist');

  for (var i = 0, keys = (0, _keys2.default)(style), len = keys.length; i < len; i++) {
    dom.style[keys[i]] = style[keys[i]];
  }

  return dom;
};

var cssSum = function cssSum(dom, list) {
  var isInline = getStyle(dom, 'display') === 'inline';

  return list.reduce(function (prev, cur) {
    var val = isInline && ['width', 'height'].indexOf(cur) !== -1 ? dom.getClientRects()[0][cur] : getStyle(dom, cur);

    return prev + parseInt(val || '0', 10);
  }, 0);
};

var offset = function offset(dom, noPx) {
  if (!dom) return { left: 0, top: 0 };

  var rect = dom.getBoundingClientRect();
  var fn = noPx ? id : pixel;

  return {
    left: fn(rect.left + window.scrollX),
    top: fn(rect.top + window.scrollY)
  };
};

var rect = function rect(dom, noPx) {
  var pos = offset(dom, noPx);
  var isInline = getStyle(dom, 'display') === 'inline';
  var w = isInline ? dom.getClientRects()[0]['width'] : getStyle(dom, 'width');
  var h = isInline ? dom.getClientRects()[0]['height'] : getStyle(dom, 'height');
  var fn = noPx ? id : pixel;

  return extend({ width: fn(w), height: fn(h) }, pos);
};

// Reference: http://ryanve.com/lab/dimensions/
var clientWidth = function clientWidth(document) {
  return document.documentElement.clientWidth;
};

var clientHeight = function clientHeight(document) {
  return document.documentElement.clientHeight;
};

var removeChildren = function removeChildren(dom, predicate) {
  var pred = predicate || function () {
    return true;
  };
  var children = dom.childNodes;

  for (var i = children.length - 1; i >= 0; i--) {
    if (pred(children[i])) {
      dom.removeChild(children[i]);
    }
  }
};

var inDom = function inDom($outer, $el) {
  if (!$el) return false;
  if ($outer === $el) return true;
  return inDom($outer, $el.parentNode);
};

var inDomList = function inDomList(list, $el) {
  return or(list.map(function ($outer) {
    return inDom($outer, $el);
  }));
};

var parentWithTag = function parentWithTag(tag, $el) {
  var lowerTag = tag.toLowerCase();
  var $dom = $el;

  while ($dom) {
    if ($dom.tagName.toLowerCase() === lowerTag) {
      return $dom;
    }

    $dom = $dom.parentNode;
  }

  return null;
};

var parentWithClass = function parentWithClass(className, $el) {
  var $dom = $el;

  while ($dom) {
    // Note: In Firefox, HTML Document object doesn't have `classList` property
    if ($dom.classList !== undefined && $dom.classList.contains(className)) {
      return $dom;
    }

    $dom = $dom.parentNode;
  }

  return null;
};

var selector = function selector(dom) {
  if (dom.nodeType !== 1) return '';
  if (dom.tagName === 'BODY') return 'body';
  if (dom.id) return '#' + dom.id;

  var classes = (dom.getAttribute('class') || '').split(/\s+/g).filter(function (item) {
    return item && item.length;
  });

  var children = (0, _from2.default)(dom.parentNode.childNodes).filter(function ($el) {
    return $el.nodeType === 1;
  });

  var sameTag = children.filter(function ($el) {
    return $el.tagName === dom.tagName;
  });

  var sameClass = children.filter(function ($el) {
    var cs = ($el.getAttribute('class') || '').split(/\s+/g);

    return and(classes.map(function (c) {
      return cs.indexOf(c) !== -1;
    }));
  });

  var extra = '';

  if (sameTag.length === 1) {
    extra = '';
  } else if (classes.length && sameClass.length === 1) {
    extra = '.' + classes.join('.');
  } else {
    extra = ':nth-child(' + (1 + children.findIndex(function (item) {
      return item === dom;
    })) + ')';
  }

  var me = dom.tagName.toLowerCase() + extra;

  // Note: browser will add an extra 'tbody' when tr directly in table, which will cause an wrong selector,
  // so the hack is to remove all tbody here
  var ret = selector(dom.parentNode) + ' > ' + me;
  return ret;
  // return ret.replace(/\s*>\s*tbody\s*>?/g, ' ')
};

var getTagIndex = function getTagIndex(dom) {
  return (0, _from2.default)(dom.parentNode.childNodes).filter(function (item) {
    return item.nodeType === dom.nodeType && item.tagName === dom.tagName;
  }).reduce(function (prev, node, i) {
    if (prev !== null) return prev;
    return node === dom ? i + 1 : prev;
  }, null);
};

var relativeXPath = function relativeXPath(dom) {
  if (!dom) return null;
  if (dom.nodeType === 3) return '@text';

  var index = getTagIndex(dom);
  var count = (0, _from2.default)(dom.parentNode.childNodes).filter(function (item) {
    return item.nodeType === dom.nodeType && item.tagName === dom.tagName;
  }).length;
  var tag = dom.tagName.toLowerCase();

  return index > 1 ? tag + '[' + index + ']' : tag;
};

var xpath = function xpath(dom, cur, list) {
  var helper = function helper(dom, cur, list) {
    if (!dom) return null;

    if (!cur) {
      if (dom.nodeType === 3) {
        return helper(dom.parentNode);
      } else {
        return helper(dom, dom, []);
      }
    }

    if (!cur.parentNode) {
      return ['html'].concat(list);
    }

    if (cur.tagName === 'BODY') {
      return ['html', 'body'].concat(list);
    }

    if (cur.id) {
      return ['*[@id="' + cur.id + '"]'].concat(list);
    }

    return helper(dom, cur.parentNode, [relativeXPath(cur)].concat(list));
  };

  var parts = helper(dom, cur, list);
  var prefix = parts[0] === 'html' ? '/' : '//';
  var ret = prefix + parts.join('/');

  return ret;
};

var xpathPosition = function xpathPosition(dom) {
  var path = '';
  var current = dom;

  try {
    while (current !== null) {
      var currentPath = void 0;

      if (current.parentNode != null) {
        currentPath = '/' + relativeXPath(current);
      } else if (current.tagName === 'BODY') {
        currentPath = 'html/body';
      } else {
        currentPath = '/' + current.nodeName.toLowerCase();
      }

      path = currentPath + path;
      var locator = '/' + path;

      if (dom === (0, _dom_utils.getElementByXPath)(locator)) {
        return locator;
      }

      current = current.parentNode;
    }
  } catch (e) {}

  return null;
};

var attributeValue = function attributeValue(value) {
  if (value.indexOf("'") < 0) {
    return "'" + value + "'";
  } else if (value.indexOf('"') < 0) {
    return '"' + value + '"';
  } else {
    var result = 'concat(';
    var part = '';
    var didReachEndOfValue = false;
    while (!didReachEndOfValue) {
      var apos = value.indexOf("'");
      var quot = value.indexOf('"');
      if (apos < 0) {
        result += "'" + value + "'";
        didReachEndOfValue = true;
        break;
      } else if (quot < 0) {
        result += '"' + value + '"';
        didReachEndOfValue = true;
        break;
      } else if (quot < apos) {
        part = value.substring(0, apos);
        result += "'" + part + "'";
        value = value.substring(part.length);
      } else {
        part = value.substring(0, quot);
        result += '"' + part + '"';
        value = value.substring(part.length);
      }
      result += ',';
    }
    result += ')';
    return result;
  }
};

var xpathAttr = function xpathAttr(dom) {
  function attributesXPath(name, attNames, attributes) {
    var locator = '//' + name + '[';
    for (var i = 0; i < attNames.length; i++) {
      if (i > 0) {
        locator += ' and ';
      }
      var attName = attNames[i];
      locator += '@' + attName + '=' + attributeValue(attributes[attName]);
    }
    locator += ']';
    return locator;
  }

  try {
    var PREFERRED_ATTRIBUTES = ['id', 'name', 'value', 'type', 'action', 'onclick'];
    var i = 0;

    if (dom.attributes) {
      var atts = dom.attributes;
      var attsMap = {};
      for (i = 0; i < atts.length; i++) {
        var att = atts[i];
        attsMap[att.name] = att.value;
      }
      var names = [];
      // try preferred attributes
      for (i = 0; i < PREFERRED_ATTRIBUTES.length; i++) {
        var name = PREFERRED_ATTRIBUTES[i];

        if (attsMap[name] != null) {
          names.push(name);

          var locator = attributesXPath(dom.nodeName.toLowerCase(), names, attsMap);

          if (dom === (0, _dom_utils.getElementByXPath)(locator)) {
            return locator;
          }
        }
      }
    }
  } catch (e) {}

  return null;
};

var atXPath = function atXPath(xpath, document) {
  var lower = function lower(str) {
    return str && str.toLowerCase();
  };
  var reg = /^([a-zA-Z0-9]+)(\[(\d+)\])?$/;

  return xpath.reduce(function (prev, cur) {
    if (!prev) return prev;
    if (!prev.childNodes || !prev.childNodes.length) return null;

    var match = cur.match(reg);
    var tag = match[1];
    var index = match[3] ? parseInt(match[3], 10) : 1;
    var list = (0, _from2.default)(prev.childNodes).filter(function (item) {
      return item.nodeType === 1 && lower(item.tagName) === lower(tag);
    });

    return list[index - 1];
  }, document);
};

var domText = function domText($dom) {
  var it = $dom.innerText && $dom.innerText.trim();
  var tc = $dom.textContent;
  var pos = tc.toUpperCase().indexOf(it.toUpperCase());

  return tc.substr(pos, it.length);
};

var getFirstWorkingLocator = function getFirstWorkingLocator(locators, $el) {
  var _loop = function _loop(i, len) {
    var $match = function () {
      try {
        return (0, _dom_utils.getElementByLocator)(locators[i]);
      } catch (e) {
        return null;
      }
    }();

    if ($el === $match) {
      return {
        v: locators[i]
      };
    }
  };

  for (var i = 0, len = locators.length; i < len; i++) {
    var _ret = _loop(i, len);

    if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object") return _ret.v;
  }

  return null;
};

// Note: get the locator of a DOM
var getLocator = function getLocator($dom, withAllOptions) {
  var id = $dom.getAttribute('id');
  var name = $dom.getAttribute('name');
  var isLink = $dom.tagName.toLowerCase() === 'a';
  var text = function () {
    try {
      return domText($dom);
    } catch (e) {
      return null;
    }
  }();
  var classes = (0, _from2.default)($dom.classList);
  var candidates = [];

  // link
  if (isLink && text && text.length) {
    var links = [].slice.call(document.getElementsByTagName('a'));
    var matches = links.filter(function ($el) {
      return domText($el) === text;
    });
    var index = matches.findIndex(function ($el) {
      return $el === $dom;
    });

    if (index !== -1) {
      candidates.push(index === 0 ? 'linkText=' + text : 'linkText=' + text + '@POS=' + (index + 1));
    }
  }

  // id
  if (id && id.length) {
    candidates.push('id=' + id);
  }

  // name
  if (name && name.length) {
    candidates.push('name=' + name);
  }

  // xpath
  candidates.push('xpath=' + xpath($dom));

  var attrXPath = xpathAttr($dom);

  if (attrXPath) {
    candidates.push('xpath=' + attrXPath);
  }

  var positionXPath = xpathPosition($dom);

  if (positionXPath) {
    candidates.push('xpath=' + positionXPath);
  }

  // css
  // Try with simple css selector first. If not unqiue, use full css selector
  /**
   * Below is the old logic with a shorter css selector
   *
    let sel = null
    if (classes.length > 0) {
    sel = $dom.tagName.toLowerCase() + classes.map(c => '.' + c).join('')
      if ($dom !== document.querySelectorAll(sel)[0]) {
      sel = null
    }
  }
    if (!sel) {
    sel = selector($dom)
  }
  */
  candidates.push('css=' + selector($dom));

  // Get the first one working
  var chosen = getFirstWorkingLocator(candidates, $dom);

  if (withAllOptions) {
    return {
      target: chosen,
      targetOptions: candidates
    };
  }

  return chosen;
};

var checkIframe = function checkIframe(iframeWin) {
  var key = new Date() * 1 + '' + Math.random();

  try {
    iframeWin[key] = 'asd';
    return iframeWin[key] === 'asd';
  } catch (e) {
    return false;
  }
};

// Note: get the locator for frame
var getFrameLocator = function getFrameLocator(frameWin, win) {
  if (checkIframe(frameWin)) {
    var frameDom = frameWin.frameElement;
    var locator = getLocator(frameDom);

    if (/^id=/.test(locator) || /^name=/.test(locator)) {
      return locator;
    }
  }

  for (var i = 0, len = win.frames.length; i < len; i++) {
    if (win.frames[i] === frameWin) {
      return 'index=' + i;
    }
  }

  throw new Error('Frame locator not found');
};

/*
 * Mask related
 */

var maskFactory = function maskFactory() {
  var cache = [];
  var prefix = '__mask__' + new Date() * 1 + Math.round(Math.random() * 1000) + '__';
  var uid = 1;
  var defaultStyle = {
    position: 'absolute',
    zIndex: '999',
    display: 'none',
    boxSizing: 'border-box',
    backgroundColor: 'red',
    opacity: 0.5,
    pointerEvents: 'none'
  };

  var genMask = function genMask(style, dom) {
    var mask = document.createElement('div');

    if (dom) {
      style = extend({}, defaultStyle, style || {}, rect(dom));
    } else {
      style = extend({}, defaultStyle, style || {});
    }

    setStyle(mask, style);
    mask.id = prefix + uid++;
    cache.push(mask);

    return mask;
  };

  var clear = function clear() {
    for (var i = 0, len = cache.length; i < len; i++) {
      var mask = cache[i];

      if (mask && mask.parentNode) {
        mask.parentNode.removeChild(mask);
      }
    }
  };

  return {
    gen: genMask,
    clear: clear
  };
};

var showMaskOver = function showMaskOver(mask, el) {
  var pos = offset(el);
  var w = cssSum(el, ['width', 'paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth']);
  var h = cssSum(el, ['height', 'paddingTop', 'paddingBottom', 'borderTopWidth', ' borderBottomWidth']);

  setStyle(mask, extend(pos, {
    width: pixel(w),
    height: pixel(h),
    display: 'block'
  }));
};

var isVisible = function isVisible(el) {
  if (el === window.document) return true;
  if (!el) return true;

  var style = window.getComputedStyle(el);
  if (style.display === 'none' || style.opacity === '0' || style.visibility === 'hidden') return false;

  return isVisible(el.parentNode);
};

exports["default"] = {
  offset: offset,
  setStyle: setStyle,
  selector: selector,
  xpath: xpath,
  atXPath: atXPath,
  domText: domText,
  getLocator: getLocator,
  getFrameLocator: getFrameLocator,
  maskFactory: maskFactory,
  showMaskOver: showMaskOver,
  inDom: inDom,
  isVisible: isVisible,
  parentWithTag: parentWithTag,
  parentWithClass: parentWithClass
};

/***/ }),

/***/ 77669:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

var _defineProperty2 = __webpack_require__(88106);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = __webpack_require__(12424);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _extends3 = __webpack_require__(88239);

var _extends4 = _interopRequireDefault(_extends3);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _ts_utils = __webpack_require__(55452);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var normalizeLabelName = function normalizeLabelName(label) {
  return label.toUpperCase();
};

var Interpreter = function () {
  function Interpreter() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Interpreter);
    this.state = (0, _ts_utils.clone)(Interpreter.DefaultState);

    if (opts.pre) {
      this.__customPre = opts.pre;
    }

    if (opts.run) {
      this.__customRun = opts.run;
    }

    if (opts.post) {
      this.__customPost = opts.post;
    }
  }

  (0, _createClass3.default)(Interpreter, [{
    key: 'reset',
    value: function reset() {
      this.__setState({
        labels: {},
        tags: [],
        commands: []
      });
    }
  }, {
    key: 'preprocess',
    value: function preprocess(commands) {
      var _this = this;

      var nextState = { commands: commands, tags: [] };
      var halfTags = [];
      var errorAtIndex = function errorAtIndex(i, msg) {
        var e = new Error(msg);
        e.errorIndex = i;
        return e;
      };

      commands.forEach(function (c, i) {
        if (_this.__customPre && _this.__customPre(c, i)) return;

        var topHalfTag = halfTags[halfTags.length - 1];

        switch (c.cmd) {
          // Commands for if, while, do, times, forEach statements
          case 'if_v2':
          case 'if':
          case 'times':
          case 'forEach':
          case 'while_v2':
          case 'while':
          case 'do':
            {
              halfTags.push({
                type: c.cmd,
                start: { index: i, command: c }
              });

              break;
            }

          case 'repeatIf':
            {
              if (!topHalfTag || !/^do$/.test(topHalfTag.type)) {
                throw errorAtIndex(i, 'No matching do for this repeatIf (at command #' + (i + 1) + ')');
              }

              nextState.tags.push((0, _extends4.default)({}, topHalfTag, {
                end: { index: i, command: c }
              }));

              halfTags.pop();
              break;
            }

          case 'elseif':
          case 'else':
            {
              if (!topHalfTag || !/^if/.test(topHalfTag.type)) {
                throw errorAtIndex(i, 'No matching if for this ' + c.cmd + ' (at command #' + (i + 1) + ')');
              }

              topHalfTag.children = topHalfTag.children || [];

              var existingElseIndex = topHalfTag.children.findIndex(function (fork) {
                return fork.command && fork.command.cmd === 'else';
              });

              if (existingElseIndex !== -1) {
                var existingElse = topHalfTag.children[existingElseIndex];
                throw new Error('\'' + c.cmd + '\' (at command #' + (i + 1) + ') could not be used after \'' + existingElse.command.cmd + '\' (at command #' + (existingElse.index + 1) + ')');
              }

              topHalfTag.children.push({ index: i, command: c });

              break;
            }

          case 'break':
          case 'continue':
            {
              var targetHalfTag = halfTags.find(function (tag) {
                return (/^(do|while|forEach|times)/.test(tag.type)
                );
              });

              if (!targetHalfTag) {
                throw errorAtIndex(i, 'No matching loop command for this ' + c.cmd + ' (at command #' + (i + 1) + ')');
              }

              targetHalfTag.children = targetHalfTag.children || [];
              targetHalfTag.children.push({ index: i, command: c });

              break;
            }

          case 'end':
          case 'endWhile':
          case 'endif':
            {
              var _ref = function () {
                switch (c.cmd) {
                  case 'end':
                    return [/^(if|while|times|forEach)/, 'if/while/times/forEach'];

                  case 'endWhile':
                    return [/^while/, 'while'];

                  case 'endif':
                    return [/^if/, 'if'];
                }
              }(),
                  _ref2 = (0, _slicedToArray3.default)(_ref, 2),
                  reg = _ref2[0],
                  text = _ref2[1];

              if (!topHalfTag || !reg.test(topHalfTag.type)) {
                throw errorAtIndex(i, 'No matching ' + text + ' for this end (at command #' + (i + 1) + ')');
              }

              nextState.tags.push((0, _extends4.default)({}, topHalfTag, {
                end: { index: i, command: c }
              }));

              halfTags.pop();
              break;
            }

          case 'label':
            {
              if (!c.target || !c.target.length) {
                throw new Error('invalid target for label command');
              }

              _this.__setState({
                labels: (0, _extends4.default)({}, _this.state.labels, (0, _defineProperty3.default)({}, normalizeLabelName(c.target), { index: i }))
              });

              break;
            }
        }
      });

      if (halfTags.length > 0) {
        var topHalfTag = halfTags[halfTags.length - 1];
        throw errorAtIndex(topHalfTag.start.index, 'Unclosed \'' + topHalfTag.type + '\' (at command #' + (topHalfTag.start.index + 1) + ')');
      }

      this.__setState(nextState);
    }
  }, {
    key: 'run',
    value: function run(command, index) {
      var _this2 = this;

      var cmd = command.cmd,
          target = command.target,
          value = command.value;


      var p = function () {
        switch (cmd) {
          case 'onError':
            {
              var _value = command.value && command.value.trim();
              var _target = command.target && command.target.trim();
              var isValidTarget = _target && (/^#restart$/i.test(_target) || /^#goto$/i.test(_target));

              if (!isValidTarget) {
                throw new Error('invalid target for onError command');
              }

              if (/^#goto$/i.test(_target)) {
                var labelName = normalizeLabelName(_value);

                if (!_this2.state.labels[labelName]) {
                  throw new Error('label ' + _value + ' doesn\'t exist');
                }
              }

              return _promise2.default.resolve({ isFlowLogic: true });
            }

          case 'gotoLabel':
            {
              if (!target || !target.length) {
                throw new Error('invalid target for gotoLabel command');
              }

              var _labelName = normalizeLabelName(target);

              if (!_this2.state.labels[_labelName]) {
                throw new Error('label ' + target + ' doesn\'t exist');
              }

              return _promise2.default.resolve({
                isFlowLogic: true,
                nextIndex: _this2.state.labels[_labelName].index
              });
            }

          case 'elseif':
            {
              var tag = _this2.state.tags.find(function (tag) {
                return (/^if/.test(tag.type) && tag.children && tag.children.find(function (fork) {
                    return fork.index === index && fork.command.cmd === cmd;
                  })
                );
              });

              if (!tag) {
                throw new Error('tag not found for this else (at command #' + (index + 1) + ')');
              }

              // Note: if the `if` tag has already tried some branch, then this `elseif` should act like `else`
              // otherwise it acts like `if`
              if (tag.alreadyRun) {
                return _promise2.default.resolve({
                  isFlowLogic: true,
                  nextIndex: tag.end.index + 1
                });
              } else {
                return _promise2.default.resolve({ isFlowLogic: false });
              }
            }

          case 'else':
            {
              // Note: 'else' and 'elseif' command itself will be skipped if condition is false,
              // But it will be run as the ending command of 'if-else' when condition is true
              var _tag = _this2.state.tags.find(function (tag) {
                return (/^if/.test(tag.type) && tag.children && tag.children.find(function (fork) {
                    return fork.index === index && fork.command.cmd === cmd;
                  })
                );
              });

              if (!_tag) {
                throw new Error('tag not found for this else (at command #' + (index + 1) + ')');
              }

              return _promise2.default.resolve({
                isFlowLogic: true,
                nextIndex: _tag.end.index + 1
              });
            }

          case 'break':
            {
              var _tag2 = _this2.state.tags.find(function (tag) {
                return (/^(do|while|forEach|times)/.test(tag.type) && tag.children && tag.children.find(function (item) {
                    return item.index === index && item.command.cmd === cmd;
                  })
                );
              });

              if (!_tag2) {
                throw new Error('No loop found for this break (at command #' + (index + 1) + ')');
              }

              return _promise2.default.resolve({
                isFlowLogic: true,
                nextIndex: _tag2.end.index + 1
              });
            }

          case 'continue':
            {
              var _tag3 = _this2.state.tags.find(function (tag) {
                return (/^(do|while|forEach|times)/.test(tag.type) && tag.children && tag.children.find(function (item) {
                    return item.index === index && item.command.cmd === cmd;
                  })
                );
              });

              if (!_tag3) {
                throw new Error('No loop found for this break (at command #' + (index + 1) + ')');
              }

              return _promise2.default.resolve({
                isFlowLogic: true,
                nextIndex: _tag3.start.index
              });
            }

          case 'endif':
            {
              return _promise2.default.resolve({ isFlowLogic: true });
            }

          case 'endWhile':
            {
              var _tag4 = _this2.state.tags.find(function (tag) {
                return (/^while/.test(tag.type) && tag.end.index === index
                );
              });

              if (!_tag4) {
                throw new Error('tag not found for this endWhile (at command #' + (index + 1) + ')');
              }

              return _promise2.default.resolve({
                isFlowLogic: true,
                nextIndex: _tag4.start.index
              });
            }

          case 'end':
            {
              var _tag5 = _this2.state.tags.find(function (tag) {
                return (/^(if|while|times|forEach)/.test(tag.type) && tag.end.index === index
                );
              });

              if (!_tag5) {
                throw new Error('tag not found for this end (at command #' + (index + 1) + ')');
              }

              if (/^if/.test(_tag5.type)) {
                return _promise2.default.resolve({ isFlowLogic: true });
              }

              // Then it's a `while`, `forEach`, `times`
              return _promise2.default.resolve({
                isFlowLogic: true,
                nextIndex: _tag5.start.index
              });
            }

          case 'comment':
            return _promise2.default.resolve({ isFlowLogic: true });

          // As of 'label', it doesn't do anything, so we just kind of skip it
          case 'label':
            return _promise2.default.resolve({ isFlowLogic: true });

          case 'do':
            return _promise2.default.resolve({ isFlowLogic: true });

          // Note: gotoIf, if and while need to run eval, which is not allowed in extension scope,
          // so we have to run eval in content script
          //
          // gotoIf_v2/if_v2/while_v2 will be run in extension scope (we've added `unsafe-eval` in `content_security_policy)
          case 'gotoIf':
          case 'if':
          case 'while':
          case 'gotoIf_v2':
          case 'if_v2':
          case 'while_v2':
          case 'repeatIf':
          default:
            return _promise2.default.resolve({ isFlowLogic: false });
        }
      }();

      return p.then(function (result) {
        if (result.isFlowLogic) {
          return result;
        }

        if (_this2.__customRun) {
          var _p = _this2.__customRun(command, index);
          if (_p) return _promise2.default.resolve(_p);
        }

        return result;
      });
    }
  }, {
    key: 'postRun',
    value: function postRun(command, index, result) {
      var _this3 = this;

      var cmd = command.cmd,
          target = command.target,
          value = command.value;


      if (this.__customPost) {
        var p = this.__customPost(command, index, result);
        if (p) return _promise2.default.resolve(p);
      }

      switch (cmd) {
        case 'gotoIf_v2':
        case 'gotoIf':
          {
            // short-circuit the check on value
            if (!result.condition) return _promise2.default.resolve();

            if (!value || !value.length) {
              throw new Error('invalid value for value command');
            }

            var labelName = normalizeLabelName(value);

            if (!this.state.labels[labelName]) {
              throw new Error('label ' + value + ' doesn\'t exist');
            }

            return _promise2.default.resolve({
              nextIndex: this.state.labels[labelName].index
            });
          }

        case 'elseif':
        case 'if_v2':
        case 'if':
          {
            var cond = result.condition;
            var tag = function () {
              if (cmd === 'elseif') {
                return _this3.state.tags.find(function (tag) {
                  return (/^if/.test(tag.type) && tag.children && tag.children.find(function (fork) {
                      return fork.index === index && fork.command.cmd === 'elseif';
                    })
                  );
                });
              } else {
                return _this3.state.tags.find(function (tag) {
                  return (/^if/.test(tag.type) && tag.start.index === index
                  );
                });
              }
            }();

            if (!tag) {
              throw new Error('\'if\' tag not found for this ' + cmd + ' (at command #' + (index + 1) + ')');
            }

            // Mark this `if` tag as already run if condition fulfilled,
            // so that any coming `elseif` could know which role itself is
            tag.alreadyRun = !!cond;

            var forkIndex = function () {
              if (cmd !== 'elseif') {
                return 0;
              }

              var curIndex = (tag.children || []).findIndex(function (fork) {
                return fork.index === index && fork.command.cmd === 'elseif';
              });
              return curIndex === -1 ? -1 : curIndex + 1;
            }();

            if (forkIndex === -1) {
              throw new Error('Can\'t find fork for this elseif (at command #' + (index + 1) + ')');
            }

            var branchIndex = function () {
              var fork = tag.children && tag.children[forkIndex];

              if (!fork) {
                return null;
              }

              // Note: if next fork is elseif, it should execute that elseif
              // if next fork is else, it should go to the next line of that else
              var offset = fork && fork.command.cmd === 'else' ? 1 : 0;
              return fork.index + offset;
            }();
            var endIndex = tag.end && tag.end.index + 1;

            return _promise2.default.resolve({
              nextIndex: cond ? index + 1 : branchIndex || endIndex
            });
          }

        case 'times':
        case 'forEach':
        case 'while_v2':
        case 'while':
          {
            var _cond = result.condition;
            var _tag6 = this.state.tags.find(function (tag) {
              return (/^while|times|forEach/.test(tag.type) && tag.start.index === index
              );
            });

            if (!_tag6) {
              throw new Error('tag not found for this ' + cmd + ' (at command #' + (index + 1) + ')');
            }

            if (!_tag6.end || _tag6.end.index === undefined || _tag6.end.index === null) {
              throw new Error('tag doesn\'t have a valid end index');
            }

            return _promise2.default.resolve(_cond ? {} : { nextIndex: _tag6.end.index + 1 });
          }

        case 'repeatIf':
          {
            var _cond2 = result.condition;
            var _tag7 = this.state.tags.find(function (tag) {
              return (/^do$/.test(tag.type) && tag.end.index === index
              );
            });

            if (!_tag7) {
              throw new Error('tag not found for this repeatIf (at command #' + (index + 1) + ')');
            }

            if (!_tag7.end || _tag7.start.index === undefined || _tag7.start.index === null) {
              throw new Error('tag doesn\'t have a valid start index');
            }

            return _promise2.default.resolve(_cond2 ? { nextIndex: _tag7.start.index + 1 } : {});
          }

        default:
          return _promise2.default.resolve();
      }
    }
  }, {
    key: 'commandIndexByLabel',
    value: function commandIndexByLabel(labelName) {
      var label = this.state.labels[normalizeLabelName(labelName)];

      if (!label) {
        throw new Error('label \'' + labelName + '\' doesn\'t exist');
      }

      return label.index;
    }
  }, {
    key: 'backupState',
    value: function backupState() {
      return (0, _ts_utils.clone)(this.state);
    }
  }, {
    key: 'restoreState',
    value: function restoreState(state) {
      this.__setState(state);
    }
  }, {
    key: 'getKeyForTimes',
    value: function getKeyForTimes(commandIndex) {
      return 'times_' + commandIndex;
    }
  }, {
    key: 'getKeyForSurroundingTimes',
    value: function getKeyForSurroundingTimes(timesCommandIndex) {
      var _this4 = this;

      var tagIndex = this.state.tags.findIndex(function (tag) {
        return (/^(times)/.test(tag.type) && tag.start.index === timesCommandIndex
        );
      });

      if (tagIndex === -1) {
        return null;
      }

      var currentTimesTag = this.state.tags[tagIndex];
      var surroundingTimesTag = function () {
        for (var i = tagIndex; i < _this4.state.tags.length; i++) {
          var tag = _this4.state.tags[i];

          if (tag.type === 'times' && tag.start.index < currentTimesTag.start.index && tag.end.index > currentTimesTag.end.index) {
            return tag;
          }
        }

        return null;
      }();

      if (!surroundingTimesTag) {
        return null;
      }

      return this.getKeyForTimes(surroundingTimesTag.start.index);
    }
  }, {
    key: 'getExtraByKey',
    value: function getExtraByKey(key) {
      return this.state.extra[key];
    }
  }, {
    key: 'setExtraByKey',
    value: function setExtraByKey(key, value) {
      this.state.extra[key] = value;
    }
  }, {
    key: 'updateExtraByKey',
    value: function updateExtraByKey(key, updater) {
      this.setExtraByKey(key, updater(this.getExtraByKey[key]));
    }
  }, {
    key: 'removeExtraByKey',
    value: function removeExtraByKey(key) {
      delete this.state.extra[key];
    }
  }, {
    key: '__setState',
    value: function __setState(st) {
      this.state = (0, _extends4.default)({}, this.state, st);
    }
  }]);
  return Interpreter;
}();

Interpreter.DefaultState = {
  labels: {},
  tags: [],
  commands: [],
  // Any data specific to any command, for example, `times` and `forEach` uses it to store loop cursor
  extra: {}
};
exports["default"] = Interpreter;

/***/ }),

/***/ 5116:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.onMessage = exports.postMessage = undefined;

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TYPE = 'SELENIUM_IDE_CS_MSG';

var postMessage = exports.postMessage = function postMessage(targetWin, myWin, payload) {
  var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '*';
  var timeout = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 60000;

  return new _promise2.default(function (resolve, reject) {
    if (!targetWin || !targetWin.postMessage) {
      throw new Error('csPostMessage: targetWin is not a window');
    }

    if (!myWin || !myWin.addEventListener || !myWin.removeEventListener) {
      throw new Error('csPostMessage: myWin is not a window', myWin);
    }

    var secret = Math.random();
    var type = TYPE;

    // Note: create a listener with a corresponding secret every time
    var onMsg = function onMsg(e) {
      if (e.data && e.data.type === TYPE && !e.data.isRequest && e.data.secret === secret) {
        myWin.removeEventListener('message', onMsg);
        var _e$data = e.data,
            _payload = _e$data.payload,
            error = _e$data.error;


        if (error) return reject(new Error(error));
        if (_payload !== undefined) return resolve(_payload);

        reject(new Error('csPostMessage: No payload nor error found'));
      }
    };

    myWin.addEventListener('message', onMsg);

    // Note:
    // * `type` to make sure we check our own msg only
    // * `secret` is for 1 to 1 relationship between a msg and a listener
    // * `payload` is the real data you want to send
    // * `isRequest` is to mark that it's not an answer to some previous request

    targetWin.postMessage({
      type: type,
      secret: secret,
      payload: payload,
      isRequest: true
    }, target);

    setTimeout(function () {
      reject(new Error('csPostMessage: timeout ' + timeout + ' ms'));
    }, timeout);
  });
};

var onMessage = exports.onMessage = function onMessage(win, fn) {
  if (!win || !win.addEventListener || !win.removeEventListener) {
    throw new Error('csOnMessage: not a window', win);
  }

  var onMsg = function onMsg(e) {
    // Note: only respond to msg with `isRequest` as true
    if (e && e.data && e.data.type === TYPE && e.data.isRequest && e.data.secret) {
      var tpl = {
        type: TYPE,
        secret: e.data.secret

        // Note: wrapped with a new Promise to catch any exception during the execution of fn
      };new _promise2.default(function (resolve, reject) {
        var ret = void 0;

        try {
          ret = fn(e.data.payload, {
            source: e.source
          });
        } catch (err) {
          reject(err);
        }

        // Note: only resolve if returned value is not undefined. With this, we can have multiple
        // listeners added to onMessage, and each one takes care of what it really cares
        if (ret !== undefined) {
          resolve(ret);
        }
      }).then(function (res) {
        e.source.postMessage((0, _extends3.default)({}, tpl, {
          payload: res
        }), '*');
      }, function (err) {
        e.source.postMessage((0, _extends3.default)({}, tpl, {
          error: err.message
        }), '*');
      });
    }
  };

  win.addEventListener('message', onMsg);
  return function () {
    return win.removeEventListener('message', onMsg);
  };
};

/***/ }),

/***/ 41471:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _ipc_bg_cs = __webpack_require__(31745);

var throwNotTop = function throwNotTop() {
  throw new Error('You are not a top window, not allowed to initialize/use csIpc');
};

// Note: csIpc is only available to top window
var ipc = typeof window !== 'undefined' && window.top === window ? (0, _ipc_bg_cs.csInit)() : {
  ask: throwNotTop,
  send: throwNotTop,
  onAsk: throwNotTop,
  destroy: throwNotTop

  // Note: one ipc singleton per content script
};exports["default"] = ipc;

/***/ }),

/***/ 18187:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.2
 * 2016-06-16 18:25:19
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || function (view) {
	"use strict";
	// IE <10 is explicitly unsupported

	if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var doc = view.document
	// only get URL when necessary in case Blob.js hasn't overridden it yet
	,
	    get_URL = function get_URL() {
		return view.URL || view.webkitURL || view;
	},
	    is_firefox_extension = window.location.protocol === 'moz-extension:',
	    create_link_for_ff_ext = function create_link_for_ff_ext() {
		// Temporary fix for firefox extension on Mac / Linux
		// reference: https://bugzilla.mozilla.org/show_bug.cgi?format=default&id=1420419
		var iframeId = 'downloadFrame';
		var $iframe = doc.createElementNS("http://www.w3.org/1999/xhtml", "iframe");

		$iframe.id = iframeId;
		$iframe.style.visibility = 'hidden';
		$iframe.style.position = 'absolute';
		$iframe.style.left = '-999px';
		doc.body.appendChild($iframe);

		var link = $iframe.contentDocument.createElement('a');

		// wait for next tick when iframe is already in document,
		// otherwise link won't be add to body of iframe
		setTimeout(function () {
			$iframe.contentDocument.body.appendChild(link);
		});

		return link;
	},
	    save_link = is_firefox_extension ? create_link_for_ff_ext() : doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
	    can_use_save_link = "download" in save_link,
	    click = function click(node) {
		var event = new MouseEvent("click");
		node.dispatchEvent(event);
	},
	    is_safari = /constructor/i.test(view.HTMLElement) || view.safari,
	    is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent),
	    throw_outside = function throw_outside(ex) {
		(view.setImmediate || view.setTimeout)(function () {
			throw ex;
		}, 0);
	},
	    force_saveable_type = "application/octet-stream"
	// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
	,
	    arbitrary_revoke_timeout = 1000 * 40 // in ms
	,
	    revoke = function revoke(file) {
		var revoker = function revoker() {
			if (typeof file === "string") {
				// file is an object URL
				get_URL().revokeObjectURL(file);
			} else {
				// file is a File
				file.remove();
			}
		};
		setTimeout(revoker, arbitrary_revoke_timeout);
	},
	    dispatch = function dispatch(filesaver, event_types, event) {
		event_types = [].concat(event_types);
		var i = event_types.length;
		while (i--) {
			var listener = filesaver["on" + event_types[i]];
			if (typeof listener === "function") {
				try {
					listener.call(filesaver, event || filesaver);
				} catch (ex) {
					throw_outside(ex);
				}
			}
		}
	},
	    auto_bom = function auto_bom(blob) {
		// prepend BOM for UTF-8 XML and text/* types (including HTML)
		// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
		if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
			return new Blob([String.fromCharCode(0xFEFF), blob], { type: blob.type });
		}
		return blob;
	},
	    FileSaver = function FileSaver(blob, name, no_auto_bom) {
		if (!no_auto_bom) {
			blob = auto_bom(blob);
		}
		// First try a.download, then web filesystem, then object URLs
		var filesaver = this,
		    type = blob.type,
		    force = type === force_saveable_type,
		    object_url,
		    dispatch_all = function dispatch_all() {
			dispatch(filesaver, "writestart progress write writeend".split(" "));
		}
		// on any filesys errors revert to saving with object URLs
		,
		    fs_error = function fs_error() {
			if ((is_chrome_ios || force && is_safari) && view.FileReader) {
				// Safari doesn't allow downloading of blob urls
				var reader = new FileReader();
				reader.onloadend = function () {
					var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
					var popup = view.open(url, '_blank');
					if (!popup) view.location.href = url;
					url = undefined; // release reference before dispatching
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
				};
				reader.readAsDataURL(blob);
				filesaver.readyState = filesaver.INIT;
				return;
			}
			// don't create more object URLs than needed
			if (!object_url) {
				object_url = get_URL().createObjectURL(blob);
			}
			if (force) {
				view.location.href = object_url;
			} else {
				var opened = view.open(object_url, "_blank");
				if (!opened) {
					// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
					view.location.href = object_url;
				}
			}
			filesaver.readyState = filesaver.DONE;
			dispatch_all();
			revoke(object_url);
		};
		filesaver.readyState = filesaver.INIT;

		if (can_use_save_link) {
			object_url = get_URL().createObjectURL(blob);
			setTimeout(function () {
				save_link.href = object_url;
				save_link.download = name;
				click(save_link);
				dispatch_all();
				revoke(object_url);
				filesaver.readyState = filesaver.DONE;
			});
			return;
		}

		fs_error();
	},
	    FS_proto = FileSaver.prototype,
	    saveAs = function saveAs(blob, name, no_auto_bom) {
		return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
	};
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function (blob, name, no_auto_bom) {
			name = name || blob.name || "download";

			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}

	FS_proto.abort = function () {};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;

	return saveAs;
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || undefined.content);
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if ( true && module.exports) {
	module.exports.saveAs = saveAs;
} else if ( true && __webpack_require__.amdD !== null && __webpack_require__.amdO !== null) {
	!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
		return saveAs;
	}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}

/***/ }),

/***/ 43625:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getPlayer = exports.Player = undefined;

var _toConsumableArray2 = __webpack_require__(85315);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

var _keys = __webpack_require__(88902);

var _keys2 = _interopRequireDefault(_keys);

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _eventEmitter = __webpack_require__(76576);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _utils = __webpack_require__(63370);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MODE = {
  STRAIGHT: 'STRAIGHT',
  SINGLE: 'SINGLE',
  LOOP: 'LOOP'
};

var STATUS = {
  PLAYING: 'PLAYING',
  PAUSED: 'PAUSED',
  STOPPED: 'STOPPED',
  ERROR: 'ERROR'
};

var END_REASON = {
  COMPLETE: 'COMPLETE',
  ERROR: 'ERROR',
  MANUAL: 'MANUAL'
};

var NEXT_INDEX_INITIATOR = {
  INIT: 'INIT',
  NORMAL: 'NORMAL',
  LOOP: 'LOOP'
};

var isEmpty = function isEmpty(x) {
  return x === undefined || x === null;
};

var initialState = {
  startUrl: null,

  startIndex: null,
  endIndex: null,
  nextIndex: null,
  nextIndexInitiator: NEXT_INDEX_INITIATOR.INIT,

  errorIndex: null,
  doneIndices: [],

  mode: MODE.STRAIGHT,
  resources: [],

  // preDelay: 0,
  // postDelay: 0,

  status: STATUS.STOPPED

  // Note: A generic player for consuming some kind of resources
  // It supports 3 modes: single, straight, loop.
  // Also for straight and loop, it can start or end at any valid index you want
  //
  // The main API of a player is
  // 1. constructor({ run: Function,  prepare: Function })
  // 2. play(config)
  // 3. pause()
  // 4. resume()
  // 5. stop()
  //
  // Events it emits
  // 1. START
  // 2. PREPARED
  // 3. TO_PLAY
  // 4. PLAYED_LIST
  // 5. PAUSED
  // 6. RESUMED
  // 7. END
  // 8. ERROR

};
var Player = exports.Player = function () {
  function Player(opts, state) {
    (0, _classCallCheck3.default)(this, Player);
    this.state = (0, _extends3.default)({}, initialState);
    this.toResumePromises = {};

    if (!opts) {
      throw new Error('Player - constructor: must provide opts as 1st argument');
    }

    if (typeof opts.run !== 'function') {
      throw new Error('Player - constructor: must provide a run function');
    }

    if (typeof opts.prepare !== 'function') {
      throw new Error('Player - constructor: must provide a prepare function');
    }

    if (typeof opts.handleResult !== 'function') {
      throw new Error('Player - constructor: must provide a handleResult function');
    }

    this.__run = opts.run;
    this.__prepare = opts.prepare;
    this.__handle = opts.handleResult;

    this.__setState(state || {});
  }

  (0, _createClass3.default)(Player, [{
    key: 'play',
    value: function play(config) {
      var _this = this;

      if (!config) {
        throw new Error('Player - play: config should not be empty');
      }

      if (!config.mode || (0, _keys2.default)(MODE).indexOf(config.mode) === -1) {
        throw new Error('Player - play: must provide a valid mode, now it is ' + config.mode);
      }

      if (config.mode === MODE.LOOP && (!config.loopsStart || config.loopsStart < 0 || Math.floor(config.loopsStart) !== config.loopsStart || !config.loopsEnd || config.loopsEnd < config.loopsStart || Math.floor(config.loopsEnd) !== config.loopsEnd)) {
        throw new Error('Player - play: must provide a valid tuple of "loopsStart" and "loopsEnd" in loop mode, now it is ' + config.loopsStart + ', ' + config.loopsEnd);
      }

      if (config.resources.length !== 0) {
        if (isEmpty(config.startIndex) || config.startIndex < 0 || config.startIndex >= config.resources.length) {
          throw new Error('Player - play: startIndex out of range, now it is ' + config.startIndex + ', len: ' + config.resources.length);
        }
      }

      // Note: endIndex could be omitted
      if (!isEmpty(config.endIndex) && (config.endIndex < 0 || config.endIndex >= config.resources.length)) {
        throw new Error('Player - play: endIndex out of range, now it is ' + config.endIndex + ', len: ' + config.resources.length);
      }

      var nextIndex = config.nextIndex,
          startIndex = config.startIndex,
          startUrl = config.startUrl,
          resources = config.resources,
          title = config.title,
          extra = config.extra,
          doneIndices = config.doneIndices,
          noEndEvent = config.noEndEvent,
          token = config.token,
          isStep = config.isStep,
          loopsCursor = config.loopsCursor,
          loopsStart = config.loopsStart,
          loopsEnd = config.loopsEnd,
          isBackFromCalling = config.isBackFromCalling,
          needDelayAfterLoop = config.needDelayAfterLoop;

      var endIndex = config.endIndex || resources.length - 1;
      var basicState = {
        token: token,
        title: title,
        extra: extra,
        needDelayAfterLoop: needDelayAfterLoop,
        isBackFromCalling: isBackFromCalling,
        startUrl: startUrl,
        startIndex: startIndex,
        endIndex: endIndex,
        nextIndex: nextIndex !== undefined ? nextIndex : startIndex,
        errorIndex: null,
        doneIndices: doneIndices || [],
        mode: config.mode,
        loopsCursor: 1,
        loopsStart: 1,
        loopsEnd: 1,
        isStep: isStep || false,
        noEndEvent: noEndEvent || false,
        resources: config.resources,
        breakpoints: config.breakpoints || [],
        status: STATUS.PLAYING,
        public: config.public || {},
        callback: config.callback || function () {},
        lastPlayConfig: config,
        playUID: Math.random()
      };['preDelay', 'postDelay'].forEach(function (key) {
        if (isEmpty(config[key])) return;
        basicState[key] = config[key];
      });

      switch (config.mode) {
        case MODE.STRAIGHT:
          this.__setState((0, _extends3.default)({}, basicState));
          break;

        case MODE.SINGLE:
          this.__setState((0, _extends3.default)({}, basicState, {
            endIndex: startIndex
          }));
          break;

        case MODE.LOOP:
          this.__setState((0, _extends3.default)({}, basicState, {
            loopsStart: loopsStart,
            loopsEnd: loopsEnd,
            loopsCursor: loopsCursor !== undefined ? loopsCursor : loopsStart
          }));
          break;

        default:
          break;
      }

      this.emit('START', {
        title: title,
        loopsCursor: this.state.loopsCursor,
        doneIndices: this.state.doneIndices,
        extra: this.state.extra,
        isBackFromCalling: this.state.isBackFromCalling
      });

      return _promise2.default.resolve().then(function () {
        return _this.__prepare(_this.state);
      }).then(function () {
        _this.emit('PREPARED', {
          title: title,
          loopsCursor: _this.state.loopsCursor,
          doneIndices: _this.state.doneIndices,
          extra: _this.state.extra,
          isBackFromCalling: _this.state.isBackFromCalling
        });
      }).then(function () {
        return _this.__go(_this.state.token || null);
      }, function (e) {
        return _this.__errLog(e, e.errorIndex);
      });
    }
  }, {
    key: 'pause',
    value: function pause() {
      var _this2 = this;

      this.__setState({
        status: STATUS.PAUSED
      });

      setTimeout(function () {
        _this2.emit('PAUSED', { extra: _this2.state.extra });
      }, 0);

      return this.__createPromiseWaitForResume(this.state.token);
    }
  }, {
    key: 'resume',
    value: function resume(isStep) {
      this.__setState({
        status: STATUS.PLAYING,
        isStep: !!isStep
      });

      this.emit('RESUMED', { extra: this.state.extra });
      // this.__go(null)

      var item = this.toResumePromises[this.state.token];

      if (item && item.resolve) {
        item.resolve();
      }
    }
  }, {
    key: 'stop',
    value: function stop(opts) {
      this.__end(END_REASON.MANUAL, opts);
    }
  }, {
    key: 'stopWithError',
    value: function stopWithError(error) {
      this.__errLog(error);
    }
  }, {
    key: 'jumpTo',
    value: function jumpTo(nextIndex) {
      var resources = this.state.resources;

      // Note: validate nextIndex by resources.length instead of startIndex and endIndex,
      // to make it possible for 'run from here' to jump to commands ahead of the start point

      if (nextIndex < 0 || nextIndex >= resources.length) {
        throw new Error('jumpTo: nextIndex out of range');
      }

      this.__setState({
        nextIndex: nextIndex
      });
    }
  }, {
    key: 'setPostDelay',
    value: function setPostDelay(n) {
      this.__setState({
        postDelay: n
      });
    }
  }, {
    key: 'getStatus',
    value: function getStatus() {
      return this.state.status;
    }
  }, {
    key: 'getState',
    value: function getState() {
      return (0, _extends3.default)({}, this.state);
    }
  }, {
    key: 'setState',
    value: function setState(state) {
      return this.__setState(state);
    }
  }, {
    key: 'replayLastConfig',
    value: function replayLastConfig() {
      var config = this.state.lastPlayConfig;
      if (!config) throw new Error('No last play config available');

      return this.play((0, _extends3.default)({}, config, {
        nextIndex: config.startIndex
      }));
    }

    // Note: playUID changes on every `play` call
    // it's useful for features with timer to tell if it should continue to run

  }, {
    key: 'getPlayUID',
    value: function getPlayUID() {
      return this.state.playUID;
    }
  }, {
    key: 'checkPlayUID',
    value: function checkPlayUID(uid) {
      return this.state.playUID === uid;
    }
  }, {
    key: '__go',
    value: function __go(token) {
      var _this3 = this;

      // Note: in case it is returned from previous call

      if (token === undefined || token === null) {
        this.state.token = token = Math.random();
      } else if (token !== this.state.token) {
        return;
      }

      var guardToken = function guardToken(fn) {
        return function () {
          if (token !== _this3.state.token) {
            throw new Error('token expired');
          }
          return fn.apply(undefined, arguments);
        };
      };

      var _state = this.state,
          resources = _state.resources,
          nextIndex = _state.nextIndex,
          preDelay = _state.preDelay;

      var pre = preDelay > 0 ? this.__delay(function () {
        return undefined;
      }, preDelay) : _promise2.default.resolve();

      // Note: the flow of this process:
      // 1. delay if `preDelay` set
      // 2. check `__shouldContinue`
      // 3. stop if the player is stopped or paused
      // 4. otherwise call `__run` to actually consume the current resource
      // 5. set the state to next by calling `__setNext`
      // 6. delay if `postDelay` set
      return pre.then(function () {
        return _this3.__shouldContinue();
      }).then(function (_ref) {
        var paused = _ref.paused,
            complete = _ref.complete;

        if (paused) {
          throw new Error('player: paused or stopped');
        }

        if (complete) {
          return;
        }

        var _state2 = _this3.state,
            resources = _state2.resources,
            nextIndex = _state2.nextIndex,
            startIndex = _state2.startIndex,
            loopsCursor = _state2.loopsCursor,
            loopsStart = _state2.loopsStart,
            loopsEnd = _state2.loopsEnd,
            nextIndexInitiator = _state2.nextIndexInitiator;


        var obj = {
          loopsCursor: loopsCursor,
          index: nextIndex,
          currentLoop: loopsCursor - loopsStart + 1,
          loops: loopsEnd - loopsStart + 1,
          resource: resources[nextIndex],
          extra: _this3.state.extra

          // Note: when we're running loops
        };var isBottomFrame = !_this3.state.extra || _this3.state.extra.isBottomFrame;

        if (isBottomFrame && nextIndex === startIndex) {
          if (nextIndexInitiator === NEXT_INDEX_INITIATOR.LOOP || nextIndexInitiator === NEXT_INDEX_INITIATOR.INIT) {
            _this3.emit('LOOP_START', obj);
          }

          if (nextIndexInitiator === NEXT_INDEX_INITIATOR.LOOP && loopsCursor !== loopsStart) {
            _this3.emit('LOOP_RESTART', obj);
          }
        }

        _this3.emit('TO_PLAY', {
          index: nextIndex,
          currentLoop: loopsCursor - loopsStart + 1,
          loops: loopsEnd - loopsStart + 1,
          resource: resources[nextIndex],
          extra: _this3.state.extra
        });

        var possibleBreakpointPromise = function () {
          // Note: there will never be two breakpoints in straight. Use `lastBreakpoint` to tell whether we just hit a breakpoint
          // Also note that, 'TO_PLAY' events need to be fired before we pause.
          if (_this3.state.lastBreakpoint === undefined && _this3.state.breakpoints.indexOf(nextIndex) !== -1) {
            _this3.__setState({ lastBreakpoint: nextIndex });
            _this3.emit('BREAKPOINT', {
              index: nextIndex,
              currentLoop: loopsCursor - loopsStart + 1,
              loops: loopsEnd - loopsStart + 1,
              resource: resources[nextIndex],
              extra: _this3.state.extra
            });
            return _this3.pause();
          } else {
            _this3.__setState({ lastBreakpoint: undefined });
            return _promise2.default.resolve();
          }
        }();

        // Note: Check whether token expired or not after each async operations
        // Also also in the final catch to prevent unnecessary invoke of __errLog
        return possibleBreakpointPromise.then(function () {
          return _this3.__run(resources[nextIndex], _this3.state);
        }).then(guardToken(function (res) {
          // Note: allow users to handle the result
          return _this3.__handle(res, resources[nextIndex], _this3.state).then(guardToken(function (nextIndex) {
            // Note: __handle has the chance to return a `nextIndex`, mostly when it's
            // from a flow logic. But still, it could be undefined for normal commands
            var oldLoopsCursor = _this3.state.loopsCursor;

            _this3.__setNext(nextIndex);
            _this3.emit('PLAYED_LIST', {
              indices: _this3.state.doneIndices,
              extra: _this3.state.extra
            });

            return oldLoopsCursor !== _this3.state.loopsCursor;
          })).then(function (isLoopsCursorChanged) {
            // __handle may change postDelay
            var _state3 = _this3.state,
                postDelay = _state3.postDelay,
                needDelayAfterLoop = _state3.needDelayAfterLoop;

            var delay = Math.max(postDelay, isLoopsCursorChanged && needDelayAfterLoop ? 10 : 0);
            return delay > 0 ? _this3.__delay(function () {
              return undefined;
            }, delay) : _promise2.default.resolve();
          }).then(function () {
            if (_this3.state.isStep) return _this3.pause().then(function () {
              return _this3.__go(token);
            });
            return _this3.__go(token);
          });
        })).catch(guardToken(function (err) {
          return _this3.__errLog(err);
        }));
      });
    }
  }, {
    key: '__shouldContinue',
    value: function __shouldContinue() {
      var _state4 = this.state,
          status = _state4.status,
          mode = _state4.mode,
          nextIndex = _state4.nextIndex,
          startIndex = _state4.startIndex,
          endIndex = _state4.endIndex,
          token = _state4.token;

      var ret = void 0;

      if (status === STATUS.PAUSED || status === STATUS.STOPPED) {
        // Note: when it's paused, use a pending promise to holde the execution
        // so we can continue running after resume and resolve the promise
        var promiseItem = this.toResumePromises[this.state.token];
        return promiseItem ? promiseItem.promise.then(function () {
          return {};
        }) : { paused: true };
      }

      if (status === STATUS.PLAYING && nextIndex >= startIndex && nextIndex <= endIndex) {
        return _promise2.default.resolve({ paused: false, complete: false });
      }

      // Note: make this function return promise, just in case
      // an async check is needed in future

      this.__end(END_REASON.COMPLETE);
      return _promise2.default.resolve({ complete: true });
    }
  }, {
    key: '__createPromiseWaitForResume',
    value: function __createPromiseWaitForResume(token) {
      var _this4 = this;

      var p = new _promise2.default(function (resolve, reject) {
        setTimeout(function () {
          _this4.toResumePromises[token] = {
            resolve: resolve,
            reject: reject,
            promise: p
          };
        }, 10);
      });

      return p;
    }
  }, {
    key: '__createPromiseForStop',
    value: function __createPromiseForStop(token, stopReason) {
      var _this5 = this;

      var p = new _promise2.default(function (resolve, reject) {
        setTimeout(function () {
          _this5.toResumePromises[token] = {
            resolve: resolve,
            reject: reject,
            promise: p
          };

          reject(new Error('Stop reason: ' + stopReason));
        }, 10);
      });

      return p;
    }
  }, {
    key: '__end',
    value: function __end(reason, opts) {
      // Note: CANNOT end the player twice
      if (this.state.status === STATUS.STOPPED) return;

      if ((0, _keys2.default)(END_REASON).indexOf(reason) === -1) {
        throw new Error('Player - __end: invalid reason, ' + reason);
      }

      var silent = opts && opts.silent;
      var noEndEvent = this.state.noEndEvent && reason === END_REASON.COMPLETE;

      if (!noEndEvent && !silent) {
        this.emit('END', { opts: opts, reason: reason, extra: this.state.extra });

        if (reason !== END_REASON.ERROR) {
          this.state.callback(null, reason);
        }
      }

      if (reason !== END_REASON.COMPLETE) {
        this.__createPromiseForStop(this.state.token, reason);
      }

      this.__setState({
        status: STATUS.STOPPED
      });

      if (this.state.extra && this.state.extra.isBottomFrame) {
        this.__setState({
          nextIndexInitiator: NEXT_INDEX_INITIATOR.INIT
        });
      }
    }
  }, {
    key: '__errLog',
    value: function __errLog(err, errorIndex) {
      // Note: CANNOT log error if player is already stopped
      if (this.state.status === STATUS.STOPPED) {
        throw new Error(err);
      }

      this.emit('ERROR', {
        errorIndex: errorIndex !== undefined ? errorIndex : this.state.nextIndex,
        msg: err && err.message,
        stack: err && err.stack,
        extra: this.state.extra,
        restart: !!err.restart
      });
      this.state.callback(err, null);
      this.__end(END_REASON.ERROR);

      throw new Error(err);
    }
  }, {
    key: '__setNext',
    value: function __setNext(nextIndexPassed) {
      if (nextIndexPassed !== undefined && (nextIndexPassed < 0 || nextIndexPassed > this.state.resources.length)) {
        // Note: nextIndexPassed is allowed to be equal to resources.length
        // That means we run out of commands
        throw new Error('invalid nextIndexPassed ' + nextIndexPassed);
      }

      var _state5 = this.state,
          mode = _state5.mode,
          doneIndices = _state5.doneIndices,
          nextIndex = _state5.nextIndex,
          endIndex = _state5.endIndex,
          startIndex = _state5.startIndex,
          loopsCursor = _state5.loopsCursor,
          loopsEnd = _state5.loopsEnd;


      var nextIndexToSet = nextIndexPassed !== undefined ? nextIndexPassed : nextIndex + 1;

      var done = doneIndices.indexOf(nextIndex) === -1 ? [].concat((0, _toConsumableArray3.default)(doneIndices), [nextIndex]) : doneIndices;
      var lcur = loopsCursor;
      var next = null;
      var initiator = NEXT_INDEX_INITIATOR.NORMAL;

      if (mode === MODE.LOOP) {
        if (nextIndexToSet <= endIndex) {
          next = nextIndexToSet;
        } else if (loopsCursor >= loopsEnd) {
          next = nextIndexToSet;
        } else {
          lcur += 1;
          next = startIndex;
          done = [];
          initiator = NEXT_INDEX_INITIATOR.LOOP;
        }
      } else {
        next = nextIndexToSet;
      }

      // __setNext is still called after __end
      // so to protect the INIT value, check whether
      // it's already stopped
      if (this.state.status === STATUS.STOPPED && this.state.nextIndexInitiator === NEXT_INDEX_INITIATOR.INIT) {
        initiator = NEXT_INDEX_INITIATOR.INIT;
      }

      this.__setState({
        loopsCursor: lcur,
        nextIndex: next,
        nextIndexInitiator: initiator,
        doneIndices: done
      });
    }
  }, {
    key: '__setState',
    value: function __setState(obj) {
      this.state = (0, _extends3.default)({}, this.state, obj);
    }
  }, {
    key: '__delay',
    value: function __delay(fn, timeout) {
      var _this6 = this;

      var past = 0;
      var timer = setInterval(function () {
        past += 1000;
        _this6.emit('DELAY', {
          extra: _this6.state.extra,
          total: timeout,
          past: past
        });
      }, 1000);

      return (0, _utils.delay)(fn, timeout).then(function (res) {
        if (timer) clearInterval(timer);
        return res;
      });
    }
  }]);
  return Player;
}();

(0, _eventEmitter2.default)(Player.prototype);

Player.C = Player.prototype.C = {
  MODE: MODE,
  STATUS: STATUS,
  END_REASON: END_REASON
};

var playerPool = {};

// factory function to return a player singleton
var getPlayer = exports.getPlayer = function getPlayer() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var state = arguments[1];

  var name = opts.name || 'testCase';
  delete opts.name;

  if ((0, _keys2.default)(opts).length > 0) {
    playerPool[name] = new Player(opts, state);
  }

  if (!playerPool[name]) {
    throw new Error('player not initialized');
  }

  return playerPool[name];
};

/***/ }),

/***/ 79210:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.resizeWindow = resizeWindow;
exports.resizeViewport = resizeViewport;
exports.resizeViewportOfTab = resizeViewportOfTab;
exports.getWindowSize = getWindowSize;
exports.getFocusedWindowSize = getFocusedWindowSize;

var _web_extension = __webpack_require__(61171);

var _web_extension2 = _interopRequireDefault(_web_extension);

var _utils = __webpack_require__(63370);

var _log = __webpack_require__(77242);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var calcOffset = function calcOffset(screenTotal, screenOffset, oldOffset, oldSize, newSize) {
  var preferStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  var isCloserToStart = preferStart || oldOffset < screenTotal - oldOffset - oldSize;

  (0, _log2.default)('calcOffset', screenTotal, oldOffset, oldSize, newSize, preferStart);

  if (isCloserToStart) {
    return oldOffset;

    // Note: comment out a smarter position for now
    // if (newSize < oldSize) {
    //   return oldOffset
    // }

    // if (newSize < oldSize + oldOffset - screenOffset) {
    //   return oldSize + oldOffset - newSize
    // }

    // return screenOffset
  }

  if (!isCloserToStart) {
    var oldEndOffset = screenOffset + screenTotal - oldOffset - oldSize;

    return oldSize + oldOffset - newSize;

    // Note: comment out a smarter position for now
    // if (newSize < oldSize) {
    //   return oldSize + oldOffset - newSize
    // }

    // if (newSize < oldSize + oldEndOffset) {
    //   return oldOffset
    // }

    // return screenOffset + screenTotal - newSize
  }
};

// winSize.width
// winSize.height
function resizeWindow(winId, winSize, screenAvailableRect) {
  var sw = screenAvailableRect.width;
  var sh = screenAvailableRect.height;
  var sx = screenAvailableRect.x;
  var sy = screenAvailableRect.y;

  return _web_extension2.default.windows.get(winId).then(function (win) {
    var lastLeft = win.left;
    var lastTop = win.top;
    var lastWidth = win.width;
    var lastHeight = win.height;

    return _web_extension2.default.windows.update(winId, winSize).then(function (win) {
      var left = calcOffset(sw, sx, lastLeft, lastWidth, win.width);
      var top = calcOffset(sh, sy, lastTop, lastHeight, win.height, true);

      _web_extension2.default.windows.update(winId, { left: left, top: top });

      var actual = {
        width: win.width,
        height: win.height
      };

      return {
        actual: actual,
        desired: winSize,
        diff: ['width', 'height'].filter(function (key) {
          return actual[key] !== winSize[key];
        })
      };
    });
  });
}

// pureViewportSize.width
// pureViewportSize.height
// referenceViewportWindowSize.window.width
// referenceViewportWindowSize.window.height
// referenceViewportWindowSize.viewport.width
// referenceViewportWindowSize.viewport.height
function resizeViewport(winId, pureViewportSize, screenAvailableRect) {
  var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

  var maxRetry = 2;
  (0, _log2.default)('resizeViewport, ROUND', count);

  return getWindowSize(winId).then(function (currentSize) {
    logWindowSize(currentSize);

    var dx = currentSize.window.width - currentSize.viewport.width;
    var dy = currentSize.window.height - currentSize.viewport.height;

    var newWinSize = {
      width: dx + pureViewportSize.width,
      height: dy + pureViewportSize.height
    };

    (0, _log2.default)('size set to', newWinSize);
    return resizeWindow(winId, newWinSize, screenAvailableRect).then(function () {
      return getWindowSize(winId);
    }).then(function (newSize) {
      logWindowSize(newSize);

      var data = {
        actual: newSize.viewport,
        desired: pureViewportSize,
        diff: ['width', 'height'].filter(function (key) {
          return newSize.viewport[key] !== pureViewportSize[key];
        })
      };

      if (data.diff.length === 0 || count >= maxRetry) {
        return data;
      }

      return (0, _utils.delay)(function () {}, 0).then(function () {
        return resizeViewport(winId, pureViewportSize, screenAvailableRect, count + 1);
      });
    });
  });
}

function resizeViewportOfTab(tabId, pureViewportSize, screenAvailableRect) {
  return _web_extension2.default.tabs.get(tabId).then(function (tab) {
    return resizeViewport(tab.windowId, pureViewportSize, screenAvailableRect);
  });
}

// size.window.width
// size.window.height
// size.window.left
// size.window.top
// size.viewport.wdith
// size.viewport.height
function getWindowSize(winId) {
  return _web_extension2.default.windows.get(winId, { populate: true }).then(function (win) {
    var tab = win.tabs.find(function (tab) {
      return tab.active;
    });

    return {
      window: {
        width: win.width,
        height: win.height,
        left: win.left,
        top: win.top
      },
      viewport: {
        width: tab.width,
        height: tab.height
      }
    };
  });
}

function getFocusedWindowSize() {
  return _web_extension2.default.windows.getLastFocused().then(function (win) {
    return getWindowSize(win.id);
  });
}

function logWindowSize(winSize) {
  (0, _log2.default)(winSize.window, winSize.viewport);
  (0, _log2.default)('dx = ', winSize.window.width - winSize.viewport.width);
  (0, _log2.default)('dy = ', winSize.window.height - winSize.viewport.height);
}

/***/ }),

/***/ 52476:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createVarsFilter = exports.getVarsInstance = undefined;

var _stringify = __webpack_require__(63239);

var _stringify2 = _interopRequireDefault(_stringify);

var _slicedToArray2 = __webpack_require__(12424);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _keys = __webpack_require__(88902);

var _keys2 = _interopRequireDefault(_keys);

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _toConsumableArray2 = __webpack_require__(85315);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports["default"] = varsFactory;

var _registry = __webpack_require__(55290);

var _utils = __webpack_require__(63370);

var _languages = __webpack_require__(99489);

var _ts_utils = __webpack_require__(55452);

var _cv_utils = __webpack_require__(21063);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var standardKeyConstants = ['KEY_LEFT', 'KEY_UP', 'KEY_RIGHT', 'KEY_DOWN', 'KEY_PGUP', 'KEY_PAGE_UP', 'KEY_PGDN', 'KEY_PAGE_DOWN', 'KEY_BKSP', 'KEY_BACKSPACE', 'KEY_DEL', 'KEY_DELETE', 'KEY_ENTER', 'KEY_TAB', 'KEY_ESC', 'KEY_SPACE', 'KEY_HOME', 'KEY_END'];

var metaKeyConstants = ['KEY_CTRL', 'KEY_ALT', 'KEY_SHIFT', 'KEY_WIN', 'KEY_CMD', 'KEY_META'];

var fnKeyConstants = ['KEY_F1', 'KEY_F2', 'KEY_F3', 'KEY_F4', 'KEY_F5', 'KEY_F6', 'KEY_F7', 'KEY_F8', 'KEY_F9', 'KEY_F10', 'KEY_F11', 'KEY_F12', 'KEY_F13', 'KEY_F14', 'KEY_F15'];

var numericKeyConstants = ['KEY_Num0', 'KEY_Num1', 'KEY_Num2', 'KEY_Num3', 'KEY_Num4', 'KEY_Num5', 'KEY_Num6', 'KEY_Num7', 'KEY_Num8', 'KEY_Num9'];

var numberKeyConstants = ['KEY_0', 'KEY_1', 'KEY_2', 'KEY_3', 'KEY_4', 'KEY_5', 'KEY_6', 'KEY_7', 'KEY_8', 'KEY_9'];

var letterKeyConstants = ['KEY_A', 'KEY_B', 'KEY_C', 'KEY_D', 'KEY_E', 'KEY_F', 'KEY_G', 'KEY_H', 'KEY_I', 'KEY_J', 'KEY_K', 'KEY_L', 'KEY_M', 'KEY_N', 'KEY_O', 'KEY_P', 'KEY_Q', 'KEY_R', 'KEY_S', 'KEY_T', 'KEY_U', 'KEY_V', 'KEY_W', 'KEY_X', 'KEY_Y', 'KEY_Z'];

var keyConstants = [].concat(standardKeyConstants, metaKeyConstants, fnKeyConstants, numberKeyConstants, numericKeyConstants, letterKeyConstants).map(function (key) {
  return key.toUpperCase();
});

var isValidKeyConstant = function isValidKeyConstant(pattern) {
  var str = pattern && pattern.toUpperCase();

  if (keyConstants.indexOf(str) !== -1) return true;
  if (/^KEY_\w+(\+KEY_\w+)*$/.test(str)) {
    var keys = str.split('+');
    return _utils.and.apply(undefined, (0, _toConsumableArray3.default)(keys.map(function (s) {
      return keyConstants.indexOf(s) !== -1;
    })));
  }
  return false;
};

var DEFAULT_KEY = 'main';
var cache = {};

var validateVariableName = function validateVariableName(name) {
  if (name.charAt(0) === '!') {
    name = name.substr(1);
  }

  try {
    (0, _utils.validateStandardName)(name);
  } catch (e) {
    throw new Error('Invalid variable name \'' + name + '\'. A variable name ' + e.message);
  }

  return true;
};

var regDollarV2 = /\$\{((!?\w+)((\.\w+|\[(\d+|\$\{!?\w+\})\])*))\}/gi;
var regStoredVars = /storedVars\[('|")((!?\w+)((\.\w+|\[(\d+|\$\{!?\w+\})\])*))\1\]/gi;

function substrToList(substr) {
  var regSubstr = /\.(\w+)|\[(\d+|\$\{!?\w+\})\]/gi;
  var normalizedStr = substr && substr.trim();

  if (!normalizedStr || normalizedStr.length === 0) {
    return [];
  }

  var result = [];
  var lastEndIndex = -1;
  var m = void 0;

  // eslint-disable-next-line no-cond-assign
  while (m = regSubstr.exec(substr)) {
    if (!m || m.index !== lastEndIndex + 1) {
      throw new Error('Invalid variable expression');
    }

    result.push(m[1] || m[2]);
    lastEndIndex = lastEndIndex + m[0].length;
  }

  if (lastEndIndex !== normalizedStr.length - 1) {
    throw new Error('Invalid variable expression ending');
  }

  return result;
}

function listToSubstr(list) {
  return list.map(function (str) {
    return (/^\d+$/.test(str) ? '[' + str + ']' : '.' + str
    );
  }).join('');
}

function varsFactory() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_KEY;
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var isBoolean = function isBoolean(val) {
    return ['TRUE', 'FALSE'].indexOf((val + '').toUpperCase()) !== -1;
  };
  var opts = (0, _extends3.default)({
    isInvalidInternalVar: function isInvalidInternalVar(key) {
      return key.indexOf('!') === 0 && key !== '!TIMEOUT_PAGELOAD' && key !== '!TIMEOUT_WAIT' && key !== '!TIMEOUT_MACRO' && key !== '!TIMEOUT_DOWNLOAD' && key !== '!TIMEOUT_DOWNLOAD_START' && key !== '!REPLAYSPEED' && key !== '!LOOP' && key !== '!TESTSUITE_LOOP' && key !== '!URL' && key !== '!MACRONAME' && key !== '!RUNTIME' && key !== '!CSVLINE' && key !== '!CSVLINE' && key !== '!LASTCOMMANDOK' && key !== '!ERRORIGNORE' && key !== '!CSVREADLINENUMBER' && key !== '!CSVREADSTATUS' && key !== '!CSVREADMAXROW' && key !== '!CLIPBOARD' && key !== '!STATUSOK' && key !== '!WAITFORVISIBLE' && key !== '!IMAGEX' && key !== '!IMAGEY' && key !== '!IMAGEWIDTH' && key !== '!IMAGEHEIGHT' && key !== '!VISUALSEARCHAREA' && key !== '!STOREDIMAGERECT' && key !== '!STRINGESCAPE' && key !== '!CMD_VAR1' && key !== '!CMD_VAR2' && key !== '!CMD_VAR3' && key !== '!OCRLANGUAGE' && key !== '!OCRENGINE' && key !== '!OCRSCALE' && key !== '!OCRTABLEEXTRACTION' && key !== '!OCRX' && key !== '!OCRY' && key !== '!BROWSER' && key !== '!OS' && key !== '!TIMES' && key !== '!FOREACH' && key !== '!CVSCOPE' && key !== '!XRUN_EXITCODE' && key !== '!PROXY_EXEC_COUNT' && key !== '!GLOBAL_TESTSUITE_STOP_ON_ERROR' && key !== '!LAST_DOWNLOADED_FILE_NAME' && !/^!COL\d+$/i.test(key);
    },
    readonly: ['!LOOP', 'TESTSUITE_LOOP', '!URL', '!MACRONAME', '!RUNTIME', '!LASTCOMMANDOK', '!CSVREADSTATUS', '!CSVREADMAXROW', '!VISUALSEARCHAREA', '!BROWSER', '!OS', '!CVSCOPE', '!XRUN_EXITCODE', '!PROXY_EXEC_COUNT', '!TIMES', '!FOREACH', '!LAST_DOWNLOADED_FILE_NAME'].concat((0, _toConsumableArray3.default)(keyConstants)),
    typeCheck: {
      '!REPLAYSPEED': function REPLAYSPEED(val) {
        return ['SLOW', 'MEDIUM', 'FAST', 'NODISPLAY'].indexOf((val || '').toUpperCase()) !== -1;
      },
      '!TIMEOUT_PAGELOAD': function TIMEOUT_PAGELOAD(val) {
        return parseInt(val, 10) >= 0;
      },
      '!TIMEOUT_WAIT': function TIMEOUT_WAIT(val) {
        return parseInt(val, 10) >= 0;
      },
      '!TIMEOUT_MACRO': function TIMEOUT_MACRO(val) {
        return parseInt(val, 10) >= 0;
      },
      '!TIMEOUT_DOWNLOAD': function TIMEOUT_DOWNLOAD(val) {
        return parseInt(val, 10) >= 0;
      },
      '!TIMEOUT_DOWNLOAD_START': function TIMEOUT_DOWNLOAD_START(val) {
        return parseInt(val, 10) >= 0;
      },
      '!CSVREADLINENUMBER': function CSVREADLINENUMBER(val) {
        return parseInt(val, 10) >= 0;
      },
      '!OCRLANGUAGE': function OCRLANGUAGE(val) {
        return (0, _languages.isValidOCRLanguage)(val);
      },
      '!OCRENGINE': function OCRENGINE(val) {
        return [1, 2].indexOf(parseInt(val, 10)) !== -1;
      },
      '!OCRSCALE': isBoolean,
      '!OCRX': function OCRX(val) {
        return parseInt(val, 10) >= 0;
      },
      '!OCRY': function OCRY(val) {
        return parseInt(val, 10) >= 0;
      },
      '!ERRORIGNORE': isBoolean,
      '!STATUSOK': isBoolean,
      '!WAITFORVISIBLE': isBoolean,
      '!STRINGESCAPE': isBoolean,
      '!GLOBAL_TESTSUITE_STOP_ON_ERROR': isBoolean,
      '!CVSCOPE': function CVSCOPE(val) {
        return [_cv_utils.ComputerVisionType.Browser, _cv_utils.ComputerVisionType.Desktop, _cv_utils.ComputerVisionType.DesktopScreenCapture].indexOf(val) !== -1;
      }
    },
    normalize: function normalize(key, val) {
      var upperKey = key.toUpperCase();
      var acceptStringTrueFalse = function acceptStringTrueFalse(val) {
        if (val === 'true') return true;
        if (val === 'false') return false;
        return val;
      };
      var num = function num(s) {
        return parseFloat(s);
      };

      switch (upperKey) {
        case '!ERRORIGNORE':
        case '!STATUSOK':
        case '!WAITFORVISIBLE':
        case '!STRINGESCAPE':
        case '!GLOBAL_TESTSUITE_STOP_ON_ERROR':
        case '!OCRSCALE':
        case '!OCRTABLEEXTRACTION':
          return acceptStringTrueFalse(val);

        case '!TIMEOUT_PAGELOAD':
        case '!TIMEOUT_WAIT':
        case '!TIMEOUT_MACRO':
        case '!TIMEOUT_DOWNLOAD':
        case '!TIMEOUT_DOWNLOAD_START':
        case '!OCRENGINE':
          return num(val);

        default:
          return val;
      }
    }
  }, options);
  var vars = initial;

  var listeners = new _registry.Registry({ process: function process(fn, data, eventName) {
      return fn(data);
    } });
  var fireOnChange = function fireOnChange() {
    return listeners.fire('change', { vars: (0, _extends3.default)({}, vars) });
  };
  var self = {
    reset: function reset() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.keepGlobal) {
        var globals = (0, _keys2.default)(vars).reduce(function (prev, key) {
          if (/^!?global/i.test(key) || /^!TESTSUITE_LOOP$/i.test(key)) {
            prev[key] = vars[key];
          }
          return prev;
        }, {});

        vars = globals;
      } else {
        vars = {};
      }

      fireOnChange();
    },
    render: function render(str, options) {
      var _ref = options && options.withHashNotation ? [regStoredVars, 3, 4] : [regDollarV2, 2, 3],
          _ref2 = (0, _slicedToArray3.default)(_ref, 3),
          reg = _ref2[0],
          mainIndex = _ref2[1],
          subIndex = _ref2[2];

      var decorate = options && options.shouldStringify ? function (x) {
        return (0, _stringify2.default)(x);
      } : _ts_utils.id;

      return self.replaceAllVars({
        str: str,
        reg: reg,
        decorate: decorate,
        getVarName: function getVarName(args) {
          return args[mainIndex];
        },
        getSubstring: function getSubstring(args) {
          return args[subIndex];
        }
      });
    },
    replaceAllVars: function replaceAllVars(params) {
      var str = params.str,
          reg = params.reg,
          _params$getVarName = params.getVarName,
          getVarName = _params$getVarName === undefined ? function (args) {
        return args[1];
      } : _params$getVarName,
          _params$getSubstring = params.getSubstring,
          getSubstring = _params$getSubstring === undefined ? function (args) {
        return args[2];
      } : _params$getSubstring,
          _params$decorate = params.decorate,
          decorate = _params$decorate === undefined ? function (val) {
        return val;
      } : _params$decorate;


      return str.replace(reg, function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var variable = (getVarName(args) || '').toUpperCase();
        var subs = substrToList(getSubstring(args)).map(function (key) {
          return self.render(key);
        });

        // Note: keep as it is if it's a KEY_XXX variable, which should be handled by command runner
        if (isValidKeyConstant(variable)) {
          return args[0];
        }

        var root = self.getVarForRender(variable);
        var rawValue = subs.reduce(function (prev, key, i) {
          if (prev === null || prev === undefined) {
            throw new Error('' + variable + listToSubstr(subs.slice(0, i)) + ' is ' + prev);
          }
          return prev[key];
        }, root);

        return decorate(rawValue, args);
      });
    },
    getVarForRender: function getVarForRender(key) {
      var upperKey = (key || '').toUpperCase();

      if (upperKey in vars) {
        return vars[upperKey];
      } else {
        if (/^!cmd_var(1|2|3)$/i.test(upperKey)) return 'NOT_SET';

        if (/^!/.test(upperKey)) {
          throw new Error('Internal variable "' + upperKey + '" not supported');
        } else {
          throw new Error('variable "' + upperKey + '" is not defined');
        }
      }
    },
    get: function get(field) {
      return vars[field.toUpperCase()];
    },
    set: function set(obj, isAdmin) {
      (0, _keys2.default)(obj).forEach(function (key) {
        var trimmedKey = key.trim();
        if (trimmedKey.length === 0) return;

        validateVariableName(trimmedKey);

        var targetKey = trimmedKey.toUpperCase();

        // Note: prevent variable with empty name
        if (targetKey.length === 0) return;

        // Note: special treatment for !CSVLINE
        if (/^!CSVLINE$/i.test(targetKey)) {
          var csvLine = self.get('!CSVLINE');

          if (csvLine === undefined) {
            csvLine = [];
          } else if (!Array.isArray(csvLine)) {
            csvLine = [csvLine];
          }

          csvLine.push(obj[key]);
          vars['!CSVLINE'] = csvLine;

          return;
        }

        if (!isAdmin && opts.readonly.indexOf(targetKey) !== -1) {
          throw new Error('Cannot write to readonly variable \'' + key + '\'');
        }

        if (opts.isInvalidInternalVar(targetKey)) {
          throw new Error('Not allowed to write to \'' + key + '\'');
        }

        if (opts.typeCheck[targetKey] && !opts.typeCheck[targetKey](obj[key])) {
          throw new Error('Value \'' + obj[key] + '\' is not supported for variable "' + targetKey + '"');
        }

        vars[targetKey] = opts.normalize(key, obj[key]);
      });

      fireOnChange();
    },
    clear: function clear(reg) {
      (0, _keys2.default)(vars).forEach(function (key) {
        if (reg.test(key)) {
          delete vars[key];
        }
      });

      fireOnChange();
    },
    isReadOnly: function isReadOnly(variable) {
      var str = variable && variable.toUpperCase ? variable.toUpperCase() : '';
      return opts.readonly.indexOf(str) !== -1;
    },
    dump: function dump() {
      return (0, _extends3.default)({}, vars);
    },
    onChange: function onChange(fn) {
      listeners.add('change', fn);
      return function () {
        return listeners.remove('change', fn);
      };
    }
  };

  cache[name] = self;
  return self;
}

var getVarsInstance = exports.getVarsInstance = function getVarsInstance() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_KEY;

  return cache[name];
};

var createVarsFilter = exports.createVarsFilter = function createVarsFilter(_ref3) {
  var _ref3$withUserDefined = _ref3.withUserDefined,
      withUserDefined = _ref3$withUserDefined === undefined ? true : _ref3$withUserDefined,
      withCommonInternal = _ref3.withCommonInternal,
      withAdvancedInternal = _ref3.withAdvancedInternal;

  var checkUserDefined = function checkUserDefined(name) {
    return !/^!/.test(name);
  };
  var checkCommonInternal = function checkCommonInternal(name) {
    var list = ['!url', '!clipboard', '!runtime', '!statusok', '!errorignore'].map(function (x) {
      return x.toUpperCase();
    });
    return list.indexOf(name.toUpperCase()) !== -1;
  };
  var checkAdvancedInternal = function checkAdvancedInternal(name) {
    return (/^!/.test(name) && !checkCommonInternal(name)
    );
  };
  var orCheck = function orCheck(fns) {
    return function () {
      for (var i = 0, len = fns.length; i < len; i++) {
        if (fns[i].apply(fns, arguments)) return true;
      }
      return false;
    };
  };
  var list = [withUserDefined ? checkUserDefined : null, withCommonInternal ? checkCommonInternal : null, withAdvancedInternal ? checkAdvancedInternal : null].filter(function (x) {
    return !!x;
  });

  return orCheck(list);
};

/***/ }),

/***/ 92801:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _modal = __webpack_require__(56697);

var _modal2 = _interopRequireDefault(_modal);

var _getPrototypeOf = __webpack_require__(85105);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(49135);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(93196);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(67294);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(45697);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _antd = __webpack_require__(56318);

var _reactCodemirror = __webpack_require__(29656);

__webpack_require__(4631);

__webpack_require__(96876);

__webpack_require__(4328);

__webpack_require__(82801);

__webpack_require__(47462);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EditTestSuite = function (_React$Component) {
  (0, _inherits3.default)(EditTestSuite, _React$Component);

  function EditTestSuite() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, EditTestSuite);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = EditTestSuite.__proto__ || (0, _getPrototypeOf2.default)(EditTestSuite)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      value: '',
      valueModified: null,
      errMsg: null
    }, _this.onSave = function () {
      var errMsg = null;

      try {
        _this.props.validate(_this.state.valueModified);
        _this.props.onChange(_this.state.valueModified);
      } catch (e) {
        errMsg = e.message;
      } finally {
        _this.setState({ errMsg: errMsg });
      }
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  (0, _createClass3.default)(EditTestSuite, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState({
        value: this.props.value,
        valueModified: this.props.value
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.value !== this.props.value) {
        this.setState({
          value: nextProps.value,
          valueModified: nextProps.value
        });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      return _react2.default.createElement(
        _modal2.default,
        {
          visible: this.props.visible,
          okText: 'Save',
          onOk: this.onSave,
          onCancel: this.props.onClose,
          width: '80%'
        },
        _react2.default.createElement(
          'pre',
          { style: { color: 'red', lineHeight: '18px', marginBottom: '10px' } },
          this.state.errMsg
        ),
        _react2.default.createElement(_reactCodemirror.UnControlled, {
          className: this.state.sourceErrMsg ? 'has-error' : 'no-error',
          value: this.state.value,
          onChange: function onChange(editor, data, text) {
            return _this2.setState({ valueModified: text });
          },
          options: {
            mode: { name: 'javascript', json: true },
            lineNumbers: true,
            matchBrackets: true,
            autoCloseBrackets: true
          }
        })
      );
    }
  }]);
  return EditTestSuite;
}(_react2.default.Component);

EditTestSuite.propTypes = {
  value: _propTypes2.default.string.isRequired,
  onClose: _propTypes2.default.func.isRequired,
  visible: _propTypes2.default.bool,
  validate: _propTypes2.default.func,
  onChange: _propTypes2.default.func
};
EditTestSuite.defaultProps = {
  visible: false,
  validate: function validate() {
    return true;
  },
  onChange: function onChange() {}
};
exports["default"] = EditTestSuite;

/***/ }),

/***/ 33890:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _icon = __webpack_require__(86245);

var _icon2 = _interopRequireDefault(_icon);

var _input = __webpack_require__(51024);

var _input2 = _interopRequireDefault(_input);

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = __webpack_require__(85105);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(49135);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(93196);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(67294);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(45697);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _antd = __webpack_require__(56318);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EditableText = function (_React$Component) {
  (0, _inherits3.default)(EditableText, _React$Component);

  function EditableText() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, EditableText);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = EditableText.__proto__ || (0, _getPrototypeOf2.default)(EditableText)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      isEditing: false
    }, _this.onChange = function (e) {
      _this.setState({
        value: e.target.value
      });
    }, _this.onKeyDown = function (e) {
      if (e.keyCode === 13) {
        _this.submit();
      } else if (e.keyCode === 27) {
        _this.setState({
          value: _this.props.value
        }, _this.submit);
      }
    }, _this.onBlur = function (e) {
      _this.submit();
    }, _this.onClickText = function () {
      if (_this.props.clickToEdit) {
        _this.setState({ isEditing: true });
      }
    }, _this.submit = function () {
      _this.setState({
        isEditing: false
      });

      if (_this.props.onChange) {
        _this.props.onChange(_this.state.value).catch(function () {
          return false;
        }).then(function (success) {
          if (!success) {
            _this.setState({
              value: _this.props.value
            });
          }
        });
      }
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  (0, _createClass3.default)(EditableText, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState({
        isEditing: this.props.isEditing,
        value: this.props.value
      });

      if (this.props.isEditing) {
        this.focusOnInput();
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var nextState = {};

      if (this.props.isEditing !== nextProps.isEditing) {
        nextState.isEditing = nextProps.isEditing;

        if (nextState.isEditing) {
          this.focusOnInput();
        }
      }

      if (this.props.value !== nextProps.value) {
        nextState.value = nextProps.value;
      }

      this.setState(nextState);
    }
  }, {
    key: 'focusOnInput',
    value: function focusOnInput() {
      var _this2 = this;

      setTimeout(function () {
        var $input = _this2.input.refs.input;

        if ($input) {
          $input.focus();
          $input.selectionStart = 0;
          $input.selectionEnd = $input.value.length;
        }
      }, 200);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _state = this.state,
          isEditing = _state.isEditing,
          value = _state.value;


      return _react2.default.createElement(
        'div',
        { className: this.props.className },
        isEditing ? _react2.default.createElement(_input2.default, (0, _extends3.default)({
          value: value,
          onChange: this.onChange,
          onBlur: this.onBlur,
          onKeyDown: this.onKeyDown,
          ref: function ref(_ref2) {
            _this3.input = _ref2;
          }
        }, this.props.inputProps || {})) : _react2.default.createElement(
          'span',
          { onClick: this.onClickText },
          _react2.default.createElement(
            'span',
            null,
            value
          ),
          this.props.clickToEdit ? _react2.default.createElement(_icon2.default, { type: 'edit', style: { marginLeft: '10px' } }) : null
        )
      );
    }
  }]);
  return EditableText;
}(_react2.default.Component);

EditableText.propTypes = {
  value: _propTypes2.default.string,
  isEditing: _propTypes2.default.bool,
  onChange: _propTypes2.default.func,
  inputProps: _propTypes2.default.object,
  textProps: _propTypes2.default.object,
  className: _propTypes2.default.any,
  clickToEdit: _propTypes2.default.bool
};
exports["default"] = EditableText;

/***/ }),

/***/ 74835:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _icon = __webpack_require__(86245);

var _icon2 = _interopRequireDefault(_icon);

var _dropdown = __webpack_require__(82891);

var _dropdown2 = _interopRequireDefault(_dropdown);

var _menu = __webpack_require__(12386);

var _menu2 = _interopRequireDefault(_menu);

var _button = __webpack_require__(65400);

var _button2 = _interopRequireDefault(_button);

var _tabs = __webpack_require__(1350);

var _tabs2 = _interopRequireDefault(_tabs);

var _radio = __webpack_require__(64713);

var _radio2 = _interopRequireDefault(_radio);

var _select = __webpack_require__(64749);

var _select2 = _interopRequireDefault(_select);

var _checkbox = __webpack_require__(31059);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _row = __webpack_require__(55673);

var _row2 = _interopRequireDefault(_row);

var _col = __webpack_require__(5789);

var _col2 = _interopRequireDefault(_col);

var _form = __webpack_require__(97538);

var _form2 = _interopRequireDefault(_form);

var _modal = __webpack_require__(56697);

var _modal2 = _interopRequireDefault(_modal);

var _input = __webpack_require__(51024);

var _input2 = _interopRequireDefault(_input);

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

var _defineProperty2 = __webpack_require__(88106);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _message2 = __webpack_require__(11187);

var _message3 = _interopRequireDefault(_message2);

var _getPrototypeOf = __webpack_require__(85105);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(49135);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(93196);

var _inherits3 = _interopRequireDefault(_inherits2);

var _keys = __webpack_require__(88902);

var _keys2 = _interopRequireDefault(_keys);

var _react = __webpack_require__(67294);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(33664);

var _redux = __webpack_require__(74127);

var _reactRouterDom = __webpack_require__(27597);

var _antd = __webpack_require__(56318);

var _copyToClipboard = __webpack_require__(20640);

var _copyToClipboard2 = _interopRequireDefault(_copyToClipboard);

__webpack_require__(33607);

var _player = __webpack_require__(43625);

var _recomputed = __webpack_require__(78328);

var _save_test_case = __webpack_require__(57879);

var _save_test_case2 = _interopRequireDefault(_save_test_case);

var _simple_actions = __webpack_require__(46469);

var _actions = __webpack_require__(97876);

var actions = _interopRequireWildcard(_actions);

var _constant = __webpack_require__(43232);

var C = _interopRequireWildcard(_constant);

var _utils = __webpack_require__(63370);

var _xfile = __webpack_require__(1577);

var _x_user_io = __webpack_require__(35073);

var _xdesktop = __webpack_require__(91255);

var _x_screen_capture = __webpack_require__(74359);

var _common = __webpack_require__(75346);

var _storage = __webpack_require__(16058);

var _web_extension = __webpack_require__(61171);

var _web_extension2 = _interopRequireDefault(_web_extension);

var _languages = __webpack_require__(99489);

var _init_player = __webpack_require__(42322);

var _command_counter = __webpack_require__(29159);

var _convert_utils = __webpack_require__(61169);

var _ts_utils = __webpack_require__(55452);

var _convert = __webpack_require__(27734);

var _restore = __webpack_require__(58238);

var _proxy = __webpack_require__(51829);

var _ipc_cs = __webpack_require__(41471);

var _ipc_cs2 = _interopRequireDefault(_ipc_cs);

var _file_saver = __webpack_require__(18187);

var _file_saver2 = _interopRequireDefault(_file_saver);

var _encrypt = __webpack_require__(77930);

var _license = __webpack_require__(53678);

var _http_api = __webpack_require__(97551);

var _types = __webpack_require__(10714);

var _cv_utils = __webpack_require__(21063);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ocrLanguageOptions = function () {
  var list = (0, _keys2.default)(_languages.languages).map(function (key) {
    return {
      text: _languages.languages[key].name,
      value: _languages.languages[key].lang
    };
  });

  list.sort(function (a, b) {
    if (a.text < b.text) return -1;
    if (a.text > b.text) return 1;
    return 0;
  });

  return list;
}();

var Header = function (_React$Component) {
  (0, _inherits3.default)(Header, _React$Component);

  function Header() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, Header);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Header.__proto__ || (0, _getPrototypeOf2.default)(Header)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      showPlayLoops: false,
      loopsStart: 1,
      loopsEnd: 3,
      xModules: [(0, _xfile.getXFile)(), (0, _x_user_io.getXUserIO)(), (0, _xdesktop.getXDesktop)(), (0, _x_screen_capture.getXScreenCapture)()],
      xModuleData: {},
      xFileRootDirChanged: false,
      registerKey: '',
      websiteWhiteListText: '',

      // Security Tab - Encrypt Text
      textToEncrypt: '',
      encryptedText: '',
      showText: false,

      isCheckingLicense: false
    }, _this.getPlayer = function (name) {
      if (name) return (0, _player.getPlayer)({ name: name });

      switch (_this.props.player.mode) {
        case C.PLAYER_MODE.TEST_CASE:
          return (0, _player.getPlayer)({ name: 'testCase' });

        case C.PLAYER_MODE.TEST_SUITE:
          return (0, _player.getPlayer)({ name: 'testSuite' });
      }
    }, _this.getTestCaseName = function () {
      var src = _this.props.editing.meta.src;

      return src && src.name && src.name.length ? src.name : 'Untitled';
    }, _this.togglePlayLoopsModal = function (toShow) {
      _this.setState({
        showPlayLoops: toShow
      });
    }, _this.onToggleRecord = function () {
      if ((0, _cv_utils.isCVTypeForDesktop)(_this.props.config.cvScope)) {
        var msg = 'Recording is only available for browser automation. Desktop automation macros are created by adding XClick and other visual commands step by step.';

        _this.props.addLog('warning', msg);
        return _message3.default.warn(msg, 2.5);
      }

      if (_this.props.status === C.APP_STATUS.RECORDER) {
        _this.props.stopRecording();
        // Note: remove targetOptions from all commands
        _this.props.normalizeCommands();
      } else {
        _this.props.startRecording();
      }

      _this.setState({ lastOperation: 'record' });
    }, _this.onClickPlayLoops = function () {
      var _this$state = _this.state,
          loopsStart = _this$state.loopsStart,
          loopsEnd = _this$state.loopsEnd;


      if (loopsStart < 0) {
        return _message3.default.error('Start value must be no less than zero', 1.5);
      }

      if (loopsEnd < loopsStart) {
        return _message3.default.error('Max value must be greater than start value', 1.5);
      }

      var player = _this.getPlayer();
      var commands = _this.props.editing.commands;
      var src = _this.props.editing.meta.src;

      var openTc = commands.find(function (tc) {
        return tc.cmd.toLowerCase() === 'open';
      });

      _this.props.playerPlay({
        macroId: src && src.id,
        loopsEnd: loopsEnd,
        loopsStart: loopsStart,
        title: _this.getTestCaseName(),
        extra: {
          id: src && src.id
        },
        mode: player.C.MODE.LOOP,
        startIndex: 0,
        startUrl: openTc ? openTc.target : null,
        resources: _this.props.editing.commands,
        postDelay: _this.props.config.playCommandInterval * 1000
      });

      _this.setState({ lastOperation: 'play' });
      _this.togglePlayLoopsModal(false);
    }, _this.onCancelPlayLoops = function () {
      _this.togglePlayLoopsModal(false);
      _this.setState({
        loopsToPlay: 2
      });
    }, _this.onChangePlayLoops = function (field, value) {
      _this.setState((0, _defineProperty3.default)({}, field, parseInt(value, 10)));
    }, _this.onClickSave = function () {
      return (0, _save_test_case2.default)().save();
    }, _this.playCurrentMacro = function (isStep) {
      var commands = _this.props.editing.commands;
      var src = _this.props.editing.meta.src;

      var openTc = commands.find(function (tc) {
        return tc.cmd.toLowerCase() === 'open';
      });

      _this.setState({ lastOperation: 'play' });

      _this.props.playerPlay({
        macroId: src && src.id,
        title: _this.getTestCaseName(),
        extra: {
          id: src && src.id
        },
        mode: (0, _player.getPlayer)().C.MODE.STRAIGHT,
        startIndex: 0,
        startUrl: openTc ? openTc.target : null,
        resources: commands,
        postDelay: _this.props.config.playCommandInterval * 1000,
        isStep: isStep
      });
    }, _this.playCurrentLine = function () {
      var commands = _this.props.editing.commands;
      var _this$props$editing$m = _this.props.editing.meta,
          src = _this$props$editing$m.src,
          selectedIndex = _this$props$editing$m.selectedIndex;

      var commandIndex = selectedIndex === -1 ? 0 : selectedIndex || 0;

      return _this.props.playerPlay({
        macroId: src && src.id,
        title: _this.getTestCaseName(),
        extra: {
          id: src && src.id
        },
        mode: _player.Player.C.MODE.SINGLE,
        startIndex: commandIndex,
        startUrl: null,
        resources: commands,
        postDelay: _this.props.config.playCommandInterval * 1000,
        callback: function callback(err, res) {
          if (err) return;

          // Note: auto select next command
          if (commandIndex + 1 < commands.length) {
            _this.props.selectCommand(commandIndex + 1, true);
          }
        }
      });
    }, _this.checkRegisterKey = function () {
      var registerKey = _this.state.registerKey;

      var checkBasicPattern = function checkBasicPattern(str) {
        return str.length === 15 && str.charAt(0) === 'K';
      };
      var checkUnregistered = function checkUnregistered(str) {
        return str === 'freeman';
      };

      if (checkUnregistered(registerKey)) {
        _this.props.updateConfig({ xmodulesStatus: 'unregistered' });
        _message3.default.success('Unregistered');
        (0, _storage.getStorageManager)().emit(_storage.StorageManagerEvent.RootDirChanged);
        _this.resetRegisterKey();
        _this.forceUpdate();
        return;
      }

      var notifyLicenseError = function notifyLicenseError() {
        return _message3.default.error('Invalid license key');
      };

      if (!checkBasicPattern(registerKey)) {
        return notifyLicenseError();
      }

      _this.setState({ isCheckingLicense: true });

      return (0, _license.getLicenseService)().checkLicense(registerKey).then(function (license) {
        if (license.status === 'key_not_found') {
          return notifyLicenseError();
        }

        _this.resetRegisterKey();
        _this.forceUpdate();
        (0, _storage.getStorageManager)().emit(_storage.StorageManagerEvent.RootDirChanged);
        _message3.default.success('License key verified');
      }).catch(function (e) {
        var text = (0, _http_api.isNetworkError)(e) ? 'Internet connection required for activation. If you want use the software on a machine without Internet connection, please contact tech support' : e.message;

        _message3.default.error(text, 4);
      }).finally(function () {
        _this.setState({ isCheckingLicense: false });
      });
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  // Play loops relative


  (0, _createClass3.default)(Header, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var history = this.props.history;


      this.props.setRoute(history.location.pathname);
      this.props.history.listen(function (location, action) {
        _this2.props.setRoute(history.location.pathname);
      });

      (0, _license.getLicenseService)().getLatestInfo(function (info) {
        _this2.setState({
          licenseInfo: info
        });
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.ui.showSettings && !this.props.ui.showSettings) {
        this.onShowSettings();
      }

      if (nextProps.ui.showWebsiteWhiteList && !this.props.ui.showWebsiteWhiteList) {
        this.setState({
          websiteWhiteListText: (this.props.config.websiteWhiteList || []).join('\n')
        });
      }
    }
  }, {
    key: 'initXModules',
    value: function initXModules() {
      var _this3 = this;

      var xModules = this.state.xModules;

      // versionInfo: {
      //  installed: boolean
      //  version: string
      // },
      // checkResult: {
      //  error: string | null
      // }
      _promise2.default.all(xModules.map(function (mod) {
        // Note: call init config for each xmodule and discard any error
        return mod.initConfig().catch(function (e) {}).then(function () {
          return mod.getVersion();
        }).then(function (versionInfo) {
          if (versionInfo.installed) {
            return mod.sanityCheck().then(function () {
              return { error: null };
            }, function (e) {
              return { error: e.message };
            }).then(function (checkResult) {
              return {
                versionInfo: versionInfo,
                checkResult: checkResult
              };
            });
          } else {
            return {
              versionInfo: versionInfo,
              checkResult: null
            };
          }
        });
      })).then(function (results) {
        var xModuleData = results.reduce(function (prev, r, i) {
          prev[xModules[i].getName()] = (0, _extends3.default)({}, r.versionInfo, {
            checkResult: r.checkResult,
            config: xModules[i].getCachedConfig()
          });
          return prev;
        }, {});

        _this3.setState({
          xModuleData: xModuleData,
          xFileRootDirChanged: false
        });
      });
    }
  }, {
    key: 'isEitherXModuleInstalled',
    value: function isEitherXModuleInstalled() {
      var xFileData = this.state.xModuleData[(0, _xfile.getXFile)().getName()];
      var xUserIOData = this.state.xModuleData[(0, _x_user_io.getXUserIO)().getName()];

      return xFileData && xFileData.installed || xUserIOData && xUserIOData.installed;
    }
  }, {
    key: 'resetRegisterKey',
    value: function resetRegisterKey() {
      this.setState({
        registerKey: ''
      });
    }
  }, {
    key: 'onShowSettings',
    value: function onShowSettings() {
      this.initXModules();
      this.resetRegisterKey();
    }
  }, {
    key: 'showSettingsModal',
    value: function showSettingsModal() {
      this.props.updateUI({ showSettings: true });
    }
  }, {
    key: 'renderPublicWebsiteWhiteList',
    value: function renderPublicWebsiteWhiteList() {
      var _this4 = this;

      return _react2.default.createElement(
        _modal2.default,
        {
          title: 'Embedded Macros Website Whitelist',
          className: 'whitelist-modal',
          width: 450,
          okText: 'Save',
          visible: this.props.ui.showWebsiteWhiteList,
          onCancel: function onCancel() {
            return _this4.props.updateUI({ showWebsiteWhiteList: false });
          },
          onOk: function onOk(close) {
            var text = _this4.state.websiteWhiteListText;
            var lines = text.split(/\n/g).map(function (str) {
              return str.trim();
            }).filter(function (str) {
              return str.length > 0;
            });

            _this4.props.updateConfig({ websiteWhiteList: lines });
            _this4.props.updateUI({ showWebsiteWhiteList: false });
            _message3.default.success('Saved');

            return _promise2.default.resolve(true);
          }
        },
        _react2.default.createElement(
          'p',
          {
            style: { marginBottom: '10px' }
          },
          'Allow embedded macros to run ',
          _react2.default.createElement(
            'em',
            null,
            'without warning dialog'
          ),
          ', if started from the following sites:'
        ),
        _react2.default.createElement(_input2.default.TextArea, {
          placeholder: 'One url per line, e. g. https://ui.vision/rpa',
          autosize: { minRows: 6, maxRows: 12 },
          value: this.state.websiteWhiteListText,
          style: { resize: 'vertical' },
          onChange: function onChange(e) {
            return _this4.setState({ websiteWhiteListText: e.target.value });
          }
        }),
        _react2.default.createElement(
          'p',
          {
            style: { color: 'green', marginTop: '20px' }
          },
          _react2.default.createElement(
            'a',
            {
              style: { float: 'right', marginLeft: '20px' },
              href: 'https://ui.vision/x/idehelp?help=website_whitelist',
              target: '_blank'
            },
            'More info'
          ),
          'Only run embedded macros from websites you trust'
        )
      );
    }
  }, {
    key: 'renderPlayLoopModal',
    value: function renderPlayLoopModal() {
      var _this5 = this;

      return _react2.default.createElement(
        _modal2.default,
        {
          title: 'How many loops to play?',
          okText: 'Play',
          cancelText: 'Cancel',
          className: 'play-loop-modal',
          visible: this.state.showPlayLoops,
          onOk: this.onClickPlayLoops,
          onCancel: this.onCancelPlayLoops
        },
        _react2.default.createElement(
          _row2.default,
          null,
          _react2.default.createElement(
            _col2.default,
            { span: 10 },
            _react2.default.createElement(
              _form2.default.Item,
              { label: 'Start value' },
              _react2.default.createElement(_input2.default, {
                type: 'number',
                min: '0',
                value: this.state.loopsStart,
                onKeyDown: function onKeyDown(e) {
                  if (e.keyCode === 13) _this5.onClickPlayLoops();
                },
                onChange: function onChange(e) {
                  return _this5.onChangePlayLoops('loopsStart', e.target.value);
                }
              })
            )
          ),
          _react2.default.createElement(
            _col2.default,
            { span: 10, offset: 2 },
            _react2.default.createElement(
              _form2.default.Item,
              { label: 'Max' },
              _react2.default.createElement(_input2.default, {
                type: 'number',
                min: '0',
                value: this.state.loopsEnd,
                onKeyDown: function onKeyDown(e) {
                  if (e.keyCode === 13) _this5.onClickPlayLoops();
                },
                onChange: function onChange(e) {
                  return _this5.onChangePlayLoops('loopsEnd', e.target.value);
                }
              })
            )
          )
        ),
        _react2.default.createElement(
          'p',
          null,
          'The value of the loop counter is available in $',
          '{',
          '!LOOP',
          '}',
          ' variable'
        )
      );
    }
  }, {
    key: 'renderSettingModal',
    value: function renderSettingModal() {
      var _this6 = this;

      var onConfigChange = function onConfigChange(key, val) {
        _this6.props.updateConfig((0, _defineProperty3.default)({}, key, val));
      };

      var displayConfig = {
        labelCol: { span: 8 },
        wrapperCol: { span: 16 }
      };

      return _react2.default.createElement(
        _modal2.default,
        {
          title: 'Settings',
          className: 'settings-modal',
          width: 650,
          footer: null,
          visible: this.props.ui.showSettings,
          onCancel: function onCancel() {
            _this6.props.updateUI({ showSettings: false });
            _this6.setState({ textToEncrypt: '', encryptedText: '' });
          }
        },
        _react2.default.createElement(
          _tabs2.default,
          {
            activeKey: this.props.ui.settingsTab || 'replay',
            onChange: function onChange(activeKey) {
              return _this6.props.updateUI({ settingsTab: activeKey });
            }
          },
          _react2.default.createElement(
            _tabs2.default.TabPane,
            { tab: 'Replay', key: 'replay' },
            _react2.default.createElement(
              _form2.default,
              null,
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({ label: 'Replay Helper' }, displayConfig),
                _react2.default.createElement(
                  _checkbox2.default,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('playScrollElementsIntoView', e.target.checked);
                    },
                    checked: this.props.config.playScrollElementsIntoView
                  },
                  'Scroll elements into view during replay'
                ),
                _react2.default.createElement(
                  _checkbox2.default,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('playHighlightElements', e.target.checked);
                    },
                    checked: this.props.config.playHighlightElements
                  },
                  'Highlight elements during replay'
                )
              ),
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({
                  label: _react2.default.createElement(
                    'a',
                    { target: '_blank', href: 'https://ui.vision/x/idehelp?help=command_interval' },
                    'Command Interval'
                  )
                }, displayConfig),
                _react2.default.createElement(
                  _select2.default,
                  {
                    style: { width: '200px' },
                    placeholder: 'interval',
                    value: '' + this.props.config.playCommandInterval,
                    onChange: function onChange(val) {
                      return onConfigChange('playCommandInterval', val);
                    }
                  },
                  _react2.default.createElement(
                    _select2.default.Option,
                    { value: '0' },
                    'Fast (no delay)'
                  ),
                  _react2.default.createElement(
                    _select2.default.Option,
                    { value: '0.3' },
                    'Medium (0.3s delay)'
                  ),
                  _react2.default.createElement(
                    _select2.default.Option,
                    { value: '2' },
                    'Slow (2s delay)'
                  )
                )
              ),
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({
                  label: _react2.default.createElement(
                    'a',
                    { target: '_blank', href: 'https://ui.vision/x/idehelp?help=timeout_pageload' },
                    '!TIMEOUT_PAGELOAD'
                  )
                }, displayConfig),
                _react2.default.createElement(_input2.default, {
                  type: 'number',
                  min: '0',
                  style: { width: '70px' },
                  value: this.props.config.timeoutPageLoad,
                  onChange: function onChange(e) {
                    return onConfigChange('timeoutPageLoad', e.target.value);
                  },
                  placeholder: 'in seconds'
                }),
                _react2.default.createElement(
                  'span',
                  { className: 'tip' },
                  'Max. time for new page load'
                )
              ),
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({
                  label: _react2.default.createElement(
                    'a',
                    { target: '_blank', href: 'https://ui.vision/x/idehelp?help=timeout_wait' },
                    '!TIMEOUT_WAIT'
                  )
                }, displayConfig),
                _react2.default.createElement(_input2.default, {
                  type: 'number',
                  min: '0',
                  style: { width: '70px' },
                  value: this.props.config.timeoutElement,
                  onChange: function onChange(e) {
                    return onConfigChange('timeoutElement', e.target.value);
                  },
                  placeholder: 'in seconds'
                }),
                _react2.default.createElement(
                  'span',
                  { className: 'tip' },
                  'Max. time per step'
                )
              ),
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({
                  label: _react2.default.createElement(
                    'a',
                    { target: '_blank', href: 'https://ui.vision/x/idehelp?help=timeout_macro' },
                    '!TIMEOUT_MACRO'
                  )
                }, displayConfig),
                _react2.default.createElement(_input2.default, {
                  type: 'number',
                  min: '0',
                  style: { width: '70px' },
                  value: this.props.config.timeoutMacro,
                  onChange: function onChange(e) {
                    return onConfigChange('timeoutMacro', e.target.value);
                  },
                  placeholder: 'in seconds'
                }),
                _react2.default.createElement(
                  'span',
                  { className: 'tip' },
                  'Max. overall macro runtime'
                )
              ),
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({
                  label: _react2.default.createElement(
                    'a',
                    { target: '_blank', href: 'https://ui.vision/x/idehelp?help=timeout_download' },
                    '!TIMEOUT_DOWNLOAD'
                  )
                }, displayConfig),
                _react2.default.createElement(_input2.default, {
                  type: 'number',
                  min: '0',
                  style: { width: '70px' },
                  value: this.props.config.timeoutDownload,
                  onChange: function onChange(e) {
                    return onConfigChange('timeoutDownload', e.target.value);
                  },
                  placeholder: 'in seconds'
                }),
                _react2.default.createElement(
                  'span',
                  { className: 'tip' },
                  'Max. allowed time for file'
                )
              ),
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({ label: 'If error happens in loop' }, displayConfig),
                _react2.default.createElement(
                  _radio2.default.Group,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('onErrorInLoop', e.target.value);
                    },
                    value: this.props.config.onErrorInLoop
                  },
                  _react2.default.createElement(
                    _radio2.default,
                    { value: 'continue_next_loop' },
                    'Continue next loop'
                  ),
                  _react2.default.createElement(
                    _radio2.default,
                    { value: 'stop' },
                    'Stop'
                  )
                )
              )
            )
          ),
          _react2.default.createElement(
            _tabs2.default.TabPane,
            { tab: 'API', key: 'api', className: 'api-pane' },
            _react2.default.createElement(
              'p',
              null,
              'The RPA command line API allows you to run macros and test suites from the command line and to control UI.Vision RPA from any scripting or programming language (',
              _react2.default.createElement(
                'a',
                { href: 'https://ui.vision/x/idehelp?help=cmdline', target: '_blank' },
                'more info'
              ),
              ').'
            ),
            _react2.default.createElement(
              'p',
              null,
              _react2.default.createElement(
                _button2.default,
                {
                  type: 'primary',
                  onClick: function onClick() {
                    var str = (0, _convert_utils.generateEmptyHtml)();
                    var blob = new Blob([str], { type: 'text/plain;charset=utf-8' });

                    _file_saver2.default.saveAs(blob, 'ui.vision.html', true);
                  }
                },
                'Generate Autostart HTML Page'
              )
            ),
            _react2.default.createElement(
              _form2.default,
              null,
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({
                  label: _react2.default.createElement(
                    'a',
                    { target: '_blank', href: 'https://ui.vision/x/idehelp?help=cmdline' },
                    'Allow Command Line'
                  )
                }, displayConfig, {
                  labelCol: { span: 6 }
                }),
                _react2.default.createElement(
                  _checkbox2.default,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('allowRunFromBookmark', e.target.checked);
                    },
                    checked: this.props.config.allowRunFromBookmark
                  },
                  'Run macro and test suite shortcuts from Javascript Bookmarklets'
                ),
                _react2.default.createElement(
                  _checkbox2.default,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('allowRunFromFileSchema', e.target.checked);
                    },
                    checked: this.props.config.allowRunFromFileSchema
                  },
                  'Run embedded macros from local files'
                ),
                _react2.default.createElement(
                  _checkbox2.default,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('allowRunFromHttpSchema', e.target.checked);
                    },
                    checked: this.props.config.allowRunFromHttpSchema
                  },
                  'Run embedded macros from public websites',
                  _react2.default.createElement(
                    'a',
                    {
                      href: '#',
                      style: {
                        position: 'relative',
                        marginLeft: '10px',
                        padding: '15px 0'
                      },
                      onClick: function onClick(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        _this6.props.updateUI({ showWebsiteWhiteList: true });
                      }
                    },
                    'Edit Whitelist'
                  )
                )
              )
            )
          ),
          _react2.default.createElement(
            _tabs2.default.TabPane,
            { tab: 'Selenium', key: 'selenium', className: 'selenium-pane' },
            _react2.default.createElement(
              'h4',
              null,
              'Import Selenium IDE Projects'
            ),
            _react2.default.createElement(
              'p',
              null,
              'Import web tests created in the classic Selenium IDE. Unknown commands (if any) are imported as comments. If you want us to add a certain not yet supported command, or find any other import issues, please let us know in the ',
              _react2.default.createElement(
                'a',
                { href: 'https://ui.vision/x/idehelp?help=forum', target: '_blank' },
                'user forum'
              ),
              '.'
            ),
            _react2.default.createElement(
              'div',
              { className: 'import-row' },
              _react2.default.createElement('input', {
                type: 'file',
                accept: '.side',
                id: 'select_side_file',
                ref: function ref(_ref2) {
                  _this6.sideFileInput = _ref2;
                },
                style: { display: 'none' },
                onChange: function onChange(e) {
                  setTimeout(function () {
                    _this6.sideFileInput.value = null;
                  }, 500);

                  var file = e.target.files[0];

                  (0, _ts_utils.readFileAsText)(file).then(function (sideText) {
                    var sideProject = JSON.parse(sideText);

                    (0, _convert.importSideProject)(sideProject).then(function (result) {
                      var lines = ['Project "' + result.projectName + '" import into folder: "' + result.folderName + '"', '- ' + result.macros.successCount + ' ' + (result.macros.successCount === 1 ? 'macro' : 'macros') + ' (imported)', '- ' + result.suites.ignoreCount + ' ' + (result.suites.ignoreCount === 1 ? 'test suite' : 'test suites') + ' (test suites are not imported yet)'];

                      _this6.props.addLog('info', lines.join('\n'));
                      _message3.default.success('Project "' + result.projectName + '" import into folder: "' + result.folderName + '"');
                    }).catch(function (e) {
                      _message3.default.error(e.message);
                    });
                  });
                }
              }),
              _react2.default.createElement(
                _button2.default,
                {
                  type: 'primary',
                  onClick: function onClick() {
                    var $el = document.querySelector('#select_side_file');

                    if ($el) {
                      $el.click();
                    }
                  }
                },
                'Import .SIDE projects'
              ),
              _react2.default.createElement(
                'span',
                null,
                'Imports projects from Selenium IDE V3.x (',
                _react2.default.createElement(
                  'a',
                  { href: 'https://ui.vision/x/idehelp?help=import_side', target: '_blank' },
                  'more info'
                ),
                ')'
              )
            ),
            _react2.default.createElement(
              'div',
              { className: 'import-row' },
              _react2.default.createElement('input', {
                multiple: true,
                type: 'file',
                accept: '.html',
                id: 'select_html_files_for_macros',
                ref: function ref(_ref3) {
                  _this6.jsonFileInput = _ref3;
                },
                style: { display: 'none' },
                onChange: function onChange(e) {
                  setTimeout(function () {
                    _this6.jsonFileInput.value = null;
                  }, 500);

                  return _this6.props.readFilesAndImportTestCases({
                    files: e.target.files,
                    type: 'text',
                    process: function process(content, fileName) {
                      return {
                        macros: [(0, _convert_utils.fromHtml)(content, fileName)],
                        csvs: [],
                        images: []
                      };
                    }
                  });
                }
              }),
              _react2.default.createElement(
                _button2.default,
                {
                  type: 'primary',
                  onClick: function onClick() {
                    var $el = document.querySelector('#select_html_files_for_macros');

                    if ($el) {
                      $el.click();
                    }
                  }
                },
                'Import .HTML projects'
              ),
              _react2.default.createElement(
                'span',
                null,
                'Import projects from Selenium IDE V2.x (',
                _react2.default.createElement(
                  'a',
                  { href: 'https://ui.vision/x/idehelp?help=import_html', target: '_blank' },
                  'more info'
                ),
                ')'
              )
            ),
            _react2.default.createElement(
              'h4',
              null,
              'Web Recording Options'
            ),
            _react2.default.createElement(
              _form2.default,
              null,
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({ label: 'Notification' }, displayConfig),
                _react2.default.createElement(
                  _checkbox2.default,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('recordNotification', e.target.checked);
                    },
                    checked: this.props.config.recordNotification
                  },
                  'Show notifications when recording'
                )
              ),
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({ label: 'Locators' }, displayConfig),
                _react2.default.createElement(
                  _checkbox2.default,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('saveAlternativeLocators', e.target.checked);
                    },
                    checked: this.props.config.saveAlternativeLocators
                  },
                  'Store alternative locators in macro (',
                  _react2.default.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?help=alternative_locators', target: '_blank' },
                    'more info'
                  ),
                  ')'
                )
              ),
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({ label: 'click / clickAt' }, displayConfig),
                _react2.default.createElement(
                  _radio2.default.Group,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('recordClickType', e.target.value);
                    },
                    value: this.props.config.recordClickType
                  },
                  _react2.default.createElement(
                    _radio2.default,
                    { value: 'click' },
                    'Record click'
                  ),
                  _react2.default.createElement(
                    _radio2.default,
                    { value: 'clickAt' },
                    'Record clickAt'
                  )
                )
              )
            ),
            _react2.default.createElement(
              'h4',
              null,
              'Proxy Options'
            ),
            _react2.default.createElement(
              _form2.default,
              null,
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({ label: 'Default Proxy (IP:Port)' }, displayConfig),
                _react2.default.createElement(_input2.default, {
                  type: 'text',
                  style: { width: '300px' },
                  value: this.props.config.defaultProxy,
                  onChange: function onChange(e) {
                    return onConfigChange('defaultProxy', e.target.value);
                  },
                  placeholder: 'eg. http://0.0.0.0:1234'
                })
              ),
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({ label: 'User name, Password' }, displayConfig),
                _react2.default.createElement(_input2.default, {
                  type: 'text',
                  style: { width: '300px' },
                  value: this.props.config.defaultProxyAuth,
                  onChange: function onChange(e) {
                    return onConfigChange('defaultProxyAuth', e.target.value);
                  },
                  placeholder: 'eg. admin, mypassword'
                })
              ),
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({ label: 'Status' }, displayConfig),
                _react2.default.createElement(
                  _radio2.default.Group,
                  {
                    value: this.props.proxy ? 'on' : 'off',
                    onChange: function onChange(e) {
                      switch (e.target.value) {
                        case 'off':
                          return _ipc_cs2.default.ask('PANEL_SET_PROXY', { proxy: null });

                        case 'on':
                          {
                            var proxy = void 0;

                            try {
                              proxy = (0, _proxy.parseProxyUrl)(_this6.props.config.defaultProxy, _this6.props.config.defaultProxyAuth);
                            } catch (e) {
                              return _message3.default.error(e.message);
                            }

                            return _ipc_cs2.default.ask('PANEL_SET_PROXY', { proxy: proxy });
                          }
                      }
                    }
                  },
                  _react2.default.createElement(
                    _radio2.default,
                    { value: 'on' },
                    'Proxy ON'
                  ),
                  _react2.default.createElement(
                    _radio2.default,
                    { value: 'off' },
                    'Proxy OFF'
                  )
                ),
                _react2.default.createElement(
                  _checkbox2.default,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('turnOffProxyAfterReplay', e.target.checked);
                    },
                    checked: this.props.config.turnOffProxyAfterReplay
                  },
                  'Turn off at end of replay (Proxy controlled by ',
                  _react2.default.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?cmd=setproxy', target: '_blank' },
                    'setProxy command'
                  ),
                  ')'
                )
              )
            ),
            _react2.default.createElement(
              'h4',
              null,
              'Old-Style Test Cases'
            ),
            _react2.default.createElement(
              _form2.default,
              null,
              _react2.default.createElement(
                _form2.default.Item,
                (0, _extends3.default)({ label: 'Sidebar' }, displayConfig),
                _react2.default.createElement(
                  _checkbox2.default,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('showTestCaseTab', e.target.checked);
                    },
                    checked: this.props.config.showTestCaseTab
                  },
                  'Show test case tab (',
                  _react2.default.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?help=old_style_test_cases', target: '_blank' },
                    'more info'
                  ),
                  ')'
                )
              )
            )
          ),
          _react2.default.createElement(
            _tabs2.default.TabPane,
            { tab: 'Backup', key: 'backup', className: 'backup-pane' },
            _react2.default.createElement(
              'h4',
              null,
              'Automatic Backup'
            ),
            _react2.default.createElement(
              'p',
              null,
              'The automatic backup reminder helps to you to regularly export macros and other data as ZIP archive. As browser extension UI.Vision RPA must store its data ',
              _react2.default.createElement(
                'em',
                null,
                'inside the browser extension'
              ),
              '. This means that when you uninstall the extension, the data is removed, too. Therefore it is good to have backups! Note that if the hard drive storage mode of the File Access XModule is active, then the backup archive contains these files.'
            ),
            _react2.default.createElement(
              'div',
              { className: 'row' },
              _react2.default.createElement(_checkbox2.default, {
                onChange: function onChange(e) {
                  return onConfigChange('enableAutoBackup', e.target.checked);
                },
                checked: this.props.config.enableAutoBackup
              }),
              _react2.default.createElement(
                'span',
                null,
                'Show backup reminder every'
              ),
              _react2.default.createElement(_input2.default, {
                type: 'number',
                min: 1,
                disabled: !this.props.config.enableAutoBackup,
                value: this.props.config.autoBackupInterval,
                onChange: function onChange(e) {
                  return onConfigChange('autoBackupInterval', e.target.value);
                },
                style: { width: '40px' }
              }),
              _react2.default.createElement(
                'span',
                null,
                ' days'
              )
            ),
            _react2.default.createElement(
              'div',
              { className: 'row' },
              _react2.default.createElement(
                'p',
                null,
                'Backup includes'
              ),
              _react2.default.createElement(
                'ul',
                null,
                _react2.default.createElement(
                  'li',
                  null,
                  _react2.default.createElement(_checkbox2.default, {
                    onChange: function onChange(e) {
                      return onConfigChange('autoBackupTestCases', e.target.checked);
                    },
                    checked: this.props.config.autoBackupTestCases
                  }),
                  _react2.default.createElement(
                    'span',
                    null,
                    'Macros and Folders (includes Folders as Test Suites)'
                  )
                ),
                _react2.default.createElement(
                  'li',
                  null,
                  _react2.default.createElement(_checkbox2.default, {
                    onChange: function onChange(e) {
                      return onConfigChange('autoBackupTestSuites', e.target.checked);
                    },
                    checked: this.props.config.autoBackupTestSuites
                  }),
                  _react2.default.createElement(
                    'span',
                    null,
                    'Old-style Test Suites'
                  )
                ),
                _react2.default.createElement(
                  'li',
                  null,
                  _react2.default.createElement(_checkbox2.default, {
                    onChange: function onChange(e) {
                      return onConfigChange('autoBackupScreenshots', e.target.checked);
                    },
                    checked: this.props.config.autoBackupScreenshots
                  }),
                  _react2.default.createElement(
                    'span',
                    null,
                    'Screenshots'
                  )
                ),
                _react2.default.createElement(
                  'li',
                  null,
                  _react2.default.createElement(_checkbox2.default, {
                    onChange: function onChange(e) {
                      return onConfigChange('autoBackupCSVFiles', e.target.checked);
                    },
                    checked: this.props.config.autoBackupCSVFiles
                  }),
                  _react2.default.createElement(
                    'span',
                    null,
                    'CSV Files'
                  )
                ),
                _react2.default.createElement(
                  'li',
                  null,
                  _react2.default.createElement(_checkbox2.default, {
                    onChange: function onChange(e) {
                      return onConfigChange('autoBackupVisionImages', e.target.checked);
                    },
                    checked: this.props.config.autoBackupVisionImages
                  }),
                  _react2.default.createElement(
                    'span',
                    null,
                    'Visual UI Test images'
                  )
                )
              )
            ),
            _react2.default.createElement(
              'div',
              { className: 'row' },
              _react2.default.createElement(
                _button2.default,
                {
                  type: 'primary',
                  onClick: function onClick() {
                    return _this6.props.runBackup();
                  }
                },
                'Run Backup Now'
              ),
              _react2.default.createElement(
                'span',
                null,
                ' Create a backup ZIP file now.'
              )
            ),
            _react2.default.createElement(
              'div',
              {
                style: { paddingTop: '30px' },
                className: 'row'
              },
              _react2.default.createElement(
                _button2.default,
                {
                  type: 'primary',
                  onClick: function onClick() {
                    var $input = document.getElementById('select_zip_file');

                    if ($input) {
                      $input.click();
                    }
                  }
                },
                'Restore Data from Backup'
              ),
              _react2.default.createElement(
                'span',
                null,
                ' Select a backup ZIP file to import it (',
                _react2.default.createElement(
                  'a',
                  { href: 'https://ui.vision/x/idehelp?help=bkup_import', target: '_blank' },
                  'more info'
                ),
                '). '
              ),
              _react2.default.createElement('input', {
                type: 'file',
                accept: '.zip',
                id: 'select_zip_file',
                ref: function ref(_ref4) {
                  _this6.zipFileInput = _ref4;
                },
                style: { display: 'none' },
                onChange: function onChange(e) {
                  setTimeout(function () {
                    _this6.zipFileInput.value = null;
                  }, 500);

                  var file = e.target.files[0];

                  (0, _restore.restoreBackup)({
                    file: file,
                    storage: (0, _storage.getStorageManager)().getCurrentStrategyType()
                  }).then(function (result) {
                    (0, _storage.getStorageManager)().emit(_storage.StorageManagerEvent.ForceReload);
                    _message3.default.success('Backup restored');

                    _this6.props.addLog('info', ['Backup restored:', result.count.macro + ' macros', result.count.testSuite + ' test suites', result.count.csv + ' csvs', result.count.screenshot + ' screenshots', result.count.vision + ' vision images'].join('\n'));
                  }, function (e) {
                    _message3.default.error('Failed to restore: ' + e.message);
                    console.error(e);
                  });
                }
              })
            )
          ),
          _react2.default.createElement(
            _tabs2.default.TabPane,
            { tab: 'Security', key: 'security', className: 'security-pane' },
            _react2.default.createElement(
              'h4',
              null,
              'Master password for Password Encryption'
            ),
            _react2.default.createElement(
              'p',
              null,
              'A master password is used to encrypt and decrypt all stored website passwords. The websites passwords are encrypted using strong encryption.\xA0\xA0',
              _react2.default.createElement(
                'a',
                { target: '_blank', href: 'https://ui.vision/x/idehelp?help=encryption' },
                'More info >>'
              )
            ),
            _react2.default.createElement(
              'div',
              null,
              _react2.default.createElement(
                _radio2.default.Group,
                {
                  onChange: function onChange(e) {
                    return onConfigChange('shouldEncryptPassword', e.target.value);
                  },
                  value: this.props.config.shouldEncryptPassword
                },
                _react2.default.createElement(
                  _radio2.default,
                  { value: 'no' },
                  'Do not encrypt passwords'
                ),
                _react2.default.createElement(
                  _radio2.default,
                  { value: 'master_password' },
                  'Enter master password here to store it'
                )
              ),
              this.props.config.shouldEncryptPassword === 'master_password' ? _react2.default.createElement(
                'div',
                null,
                _react2.default.createElement(
                  'div',
                  null,
                  _react2.default.createElement(
                    'label',
                    null,
                    'Master password:'
                  ),
                  _react2.default.createElement(_input2.default, {
                    type: 'password',
                    style: { width: '200px' },
                    value: this.props.config.masterPassword,
                    onChange: function onChange(e) {
                      return onConfigChange('masterPassword', e.target.value);
                    }
                  })
                ),
                _react2.default.createElement(
                  'div',
                  null,
                  _react2.default.createElement('hr', { style: { margin: '20px 0' } }),
                  _react2.default.createElement(
                    'h4',
                    null,
                    'Create encrypted text string'
                  ),
                  _react2.default.createElement(
                    'p',
                    null,
                    'The feature uses the master password to encrypt text. The encrypted string can be used with TYPE, SENDKEY and XTYPE.'
                  ),
                  _react2.default.createElement(
                    'div',
                    { className: 'input-line' },
                    _react2.default.createElement(
                      'span',
                      { className: 'input-label' },
                      'Text to encrypt:'
                    ),
                    _react2.default.createElement(_input2.default, {
                      type: this.state.showText ? 'text' : 'password',
                      style: { width: '200px' },
                      value: this.state.textToEncrypt,
                      onChange: function onChange(e) {
                        _this6.setState({
                          textToEncrypt: e.target.value,
                          encryptedText: ''
                        });
                      }
                    }),
                    _react2.default.createElement(
                      _checkbox2.default,
                      {
                        onChange: function onChange(e) {
                          _this6.setState({ showText: e.target.checked });
                        },
                        checked: this.state.showText
                      },
                      'Show text'
                    )
                  ),
                  _react2.default.createElement(
                    'div',
                    { className: 'input-line' },
                    _react2.default.createElement(
                      'span',
                      { className: 'input-label' },
                      'Encrypted string:'
                    ),
                    _react2.default.createElement(_input2.default, {
                      readOnly: true,
                      type: 'text',
                      style: { width: '200px' },
                      value: this.state.encryptedText
                    })
                  ),
                  _react2.default.createElement(
                    'div',
                    { className: 'input-line' },
                    _react2.default.createElement('span', { className: 'input-label' }),
                    _react2.default.createElement(
                      _button2.default,
                      {
                        type: 'primary',
                        onClick: function onClick() {
                          (0, _encrypt.encrypt)(_this6.state.textToEncrypt).then(function (text) {
                            _this6.setState({ encryptedText: text });

                            (0, _copyToClipboard2.default)(text, {
                              format: 'text/plain'
                            });

                            _message3.default.success('Copied to clipboard');
                          });
                        }
                      },
                      'Encrypt & Copy'
                    ),
                    _react2.default.createElement(
                      'a',
                      { href: 'https://ui.vision/x/idehelp?help=encrypt', target: '_blank' },
                      '(More info)'
                    )
                  )
                )
              ) : null
            )
          ),
          _react2.default.createElement(
            _tabs2.default.TabPane,
            {
              tab: 'OCR',
              key: 'ocr',
              className: (0, _utils.cn)('ocr-pane', {
                'ocr-disabled': this.props.config.ocrMode === 'disabled',
                'ocr-enabled': this.props.config.ocrMode === 'enabled',
                'ocr-offline': this.props.config.ocrMode === 'offline_enabled'
              })
            },
            _react2.default.createElement(
              'p',
              null,
              'This tab manages the ',
              _react2.default.createElement(
                'a',
                { href: 'https://ui.vision/x/idehelp?help=ocr', target: '_blank' },
                'OCR commands'
              ),
              '. Please note that the Online OCR option sends screenshots to our Cloud OCR API. All screenshots are deleted after processing. But since this means that data leaves your machine, you must explicitly allow it. By default (after installation) Online OCR is disabled.'
            ),
            _react2.default.createElement(
              'div',
              { className: 'row' },
              _react2.default.createElement(
                _radio2.default.Group,
                {
                  className: 'radio-block',
                  onChange: function onChange(e) {
                    return onConfigChange('ocrMode', e.target.value);
                  },
                  value: this.props.config.ocrMode
                },
                _react2.default.createElement(
                  _radio2.default,
                  { value: 'disabled' },
                  'OCR feature disabled'
                ),
                _react2.default.createElement(
                  _radio2.default,
                  { value: 'enabled' },
                  'Online OCR enabled (',
                  _react2.default.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?help=ocronline', target: '_blank' },
                    'more info'
                  ),
                  ')',
                  _react2.default.createElement('br', null),
                  'Conversion counter: You used ',
                  (0, _command_counter.getOcrCommandCounter)().get(),
                  ' from ',
                  (0, _command_counter.getOcrCommandCounter)().getMaximum(),
                  ' conversions/day (',
                  _react2.default.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?help=ocradd', target: '_blank' },
                    'add more'
                  ),
                  ')'
                ),
                _react2.default.createElement(
                  _radio2.default,
                  {
                    value: 'offline_enabled',
                    disabled: !(0, _license.getLicenseService)().isProLicense(),
                    'class': (0, _utils.cn)({ 'need-pro': !(0, _license.getLicenseService)().isProLicense() })
                  },
                  'Offline OCR - use ',
                  _react2.default.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?help=ocroffline', target: '_blank' },
                    'local OCR engine'
                  ),
                  ' (Requires XModules Enterprise Edition)',
                  _react2.default.createElement('br', null),
                  _react2.default.createElement(
                    'span',
                    { className: 'offline-label' },
                    'Local OCR'
                  ),
                  _react2.default.createElement(_input2.default, {
                    type: 'text',
                    style: { width: '200px' },
                    disabled: this.props.config.ocrMode !== 'offline_enabled',
                    value: this.props.config.ocrOfflineURL,
                    onChange: function onChange(e) {
                      return onConfigChange('ocrOfflineURL', e.target.value);
                    }
                  }),
                  _react2.default.createElement('br', null),
                  _react2.default.createElement(
                    'span',
                    { className: 'offline-label' },
                    'Local API key'
                  ),
                  _react2.default.createElement(_input2.default, {
                    type: 'password',
                    style: { width: '200px' },
                    disabled: this.props.config.ocrMode !== 'offline_enabled',
                    value: this.props.config.ocrOfflineAPIKey,
                    onChange: function onChange(e) {
                      return onConfigChange('ocrOfflineAPIKey', e.target.value);
                    }
                  })
                )
              )
            ),
            _react2.default.createElement(
              'div',
              { className: 'row' },
              _react2.default.createElement(
                'p',
                null,
                _react2.default.createElement(
                  'span',
                  { className: 'label-text' },
                  'Default OCR Engine'
                ),
                _react2.default.createElement(
                  _radio2.default.Group,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('ocrEngine', parseInt(e.target.value, 10));
                    },
                    value: '' + this.props.config.ocrEngine
                  },
                  _react2.default.createElement(
                    _radio2.default,
                    { value: '1' },
                    'Engine 1'
                  ),
                  _react2.default.createElement(
                    _radio2.default,
                    { value: '2' },
                    'Engine 2'
                  )
                )
              )
            ),
            _react2.default.createElement(
              'div',
              { className: 'row' },
              _react2.default.createElement(
                'p',
                null,
                _react2.default.createElement(
                  'span',
                  { className: 'label-text' },
                  'Default OCR language'
                ),
                _react2.default.createElement(
                  _select2.default,
                  {
                    style: { width: '150px' },
                    placeholder: 'OCR Language',
                    value: this.props.config.ocrLanguage,
                    disabled: this.props.config.ocrMode === 'disabled' || this.props.config.ocrEngine === 2,
                    onChange: function onChange(val) {
                      return onConfigChange('ocrLanguage', val);
                    }
                  },
                  ocrLanguageOptions.map(function (item) {
                    return _react2.default.createElement(
                      _select2.default.Option,
                      { value: item.value, key: item.value },
                      item.text
                    );
                  })
                )
              ),
              _react2.default.createElement(
                'div',
                null,
                'You can overwrite the default OCR settings in the macro with ',
                _react2.default.createElement(
                  'a',
                  { href: 'https://ui.vision/x/idehelp?help=ocrlanguage', target: '_blank' },
                  '!OCRLanguage'
                ),
                ' and ',
                _react2.default.createElement(
                  'a',
                  { href: 'https://ui.vision/x/idehelp?help=ocrengine', target: '_blank' },
                  '!OCREngine'
                ),
                '.'
              )
            ),
            _react2.default.createElement(
              'div',
              { className: 'row' },
              _react2.default.createElement(
                'p',
                null,
                _react2.default.createElement(
                  _button2.default,
                  {
                    type: 'primary',
                    loading: this.state.testingOcrAPI,
                    disabled: this.props.config.ocrMode === 'disabled',
                    onClick: function onClick() {
                      _this6.setState({
                        testingOcrAPI: true
                      });

                      (0, _init_player.ocrViewport)({
                        store: window['store'],
                        isDesktop: (0, _cv_utils.isCVTypeForDesktop)(_this6.props.config.cvScope)
                      }).catch(function (e) {
                        _message3.default.error(e.message);
                      }).then(function () {
                        _this6.setState({
                          testingOcrAPI: false
                        });
                      });
                    }
                  },
                  'Show OCR Overlay'
                )
              ),
              _react2.default.createElement(
                'p',
                null,
                'The test runs OCR on the currently active browser tab and displays the result as overlay.'
              )
            )
          ),
          _react2.default.createElement(
            _tabs2.default.TabPane,
            { tab: 'Vision', key: 'vision', className: 'vision-pane' },
            _react2.default.createElement(
              'p',
              null,
              'UI.Vision RPA\'s eyes can look inside the web browser or search the complete desktop.'
            ),
            _react2.default.createElement(
              'div',
              { className: 'row' },
              _react2.default.createElement(
                _radio2.default.Group,
                {
                  onChange: function onChange(e) {
                    return onConfigChange('cvScope', e.target.value);
                  },
                  value: this.props.config.cvScope
                },
                _react2.default.createElement(
                  _radio2.default,
                  { value: 'browser' },
                  'Browser Automation (Look inside browser)'
                ),
                _react2.default.createElement(
                  _radio2.default,
                  {
                    value: 'desktop',
                    disabled: !(this.state.xModuleData[(0, _xdesktop.getXDesktop)().getName()] && this.state.xModuleData[(0, _xdesktop.getXDesktop)().getName()].installed)
                  },
                  _react2.default.createElement(
                    'span',
                    null,
                    'Desktop Automation (Search complete desktop)'
                  ),
                  this.state.xModuleData[(0, _xdesktop.getXDesktop)().getName()] && this.state.xModuleData[(0, _xdesktop.getXDesktop)().getName()].installed ? null : _react2.default.createElement(
                    'a',
                    {
                      target: '_blank',
                      href: (0, _xdesktop.getXDesktop)().downloadLink(),
                      style: {
                        marginLeft: '15px'
                      }
                    },
                    'Install the DesktopAutomation XModule first.'
                  ),
                  _react2.default.createElement(
                    'div',
                    null,
                    _react2.default.createElement(
                      _checkbox2.default,
                      {
                        onChange: function onChange(e) {
                          return onConfigChange('useDesktopScreenCapture', e.target.checked);
                        },
                        checked: this.props.config.useDesktopScreenCapture,
                        disabled: this.props.config.cvScope !== 'desktop' || !(this.state.xModuleData[(0, _x_screen_capture.getXScreenCapture)().getName()] && this.state.xModuleData[(0, _x_screen_capture.getXScreenCapture)().getName()].installed)
                      },
                      _react2.default.createElement(
                        'span',
                        null,
                        'Use native ',
                        _react2.default.createElement(
                          'a',
                          { href: (0, _x_screen_capture.getXScreenCapture)().infoLink(), target: '_blank' },
                          'desktop screen capture (BETA)'
                        ),
                        ' if installed (see XModule below)'
                      ),
                      this.state.xModuleData[(0, _x_screen_capture.getXScreenCapture)().getName()] && this.state.xModuleData[(0, _x_screen_capture.getXScreenCapture)().getName()].installed ? null : _react2.default.createElement(
                        'a',
                        {
                          target: '_blank',
                          href: (0, _x_screen_capture.getXScreenCapture)().downloadLink(),
                          style: {
                            marginLeft: '15px'
                          }
                        },
                        'Install the ScreenCapture XModule first.'
                      )
                    )
                  )
                )
              )
            ),
            _react2.default.createElement(
              'p',
              null,
              'Inside a macro the computer vision scope can be changed with the ',
              _react2.default.createElement(
                'a',
                { href: (0, _xdesktop.getXDesktop)().infoLink(), target: '_blank' },
                'XDesktopAutomation'
              ),
              ' command. In addition, you can restrict the image search  area with the ',
              _react2.default.createElement(
                'a',
                { href: 'https://ui.vision/x/idehelp?help=limitsearcharea', target: '_blank' },
                'visionLimitSearchArea'
              ),
              ' command.'
            ),
            _react2.default.createElement(
              'div',
              { className: 'row', style: { marginTop: '30px' } },
              _react2.default.createElement(
                'p',
                null,
                'Default Vision Search Confidence'
              ),
              _react2.default.createElement(
                _select2.default,
                {
                  style: { width: '200px' },
                  placeholder: 'interval',
                  value: '' + this.props.config.defaultVisionSearchConfidence,
                  onChange: function onChange(val) {
                    return onConfigChange('defaultVisionSearchConfidence', parseFloat(val));
                  }
                },
                (0, _utils.range)(1, 11, 1).map(function (n) {
                  return _react2.default.createElement(
                    _select2.default.Option,
                    { key: n, value: '' + (0.1 * n).toFixed(1) },
                    (0.1 * n).toFixed(1)
                  );
                })
              )
            ),
            _react2.default.createElement(
              'div',
              { className: 'row', style: { marginTop: '30px' } },
              _react2.default.createElement(
                _checkbox2.default,
                {
                  onChange: function onChange(e) {
                    return onConfigChange('waitBeforeDesktopScreenCapture', e.target.checked);
                  },
                  checked: this.props.config.waitBeforeDesktopScreenCapture
                },
                _react2.default.createElement(
                  'span',
                  null,
                  'Wait'
                ),
                _react2.default.createElement(_input2.default, {
                  type: 'number',
                  min: '0',
                  max: '60',
                  value: this.props.config.secondsBeforeDesktopScreenCapture,
                  style: { width: '60px', margin: '0 10px' },
                  onChange: function onChange(e) {
                    return onConfigChange('secondsBeforeDesktopScreenCapture', Math.min(60, Number(e.target.value)));
                  }
                }),
                _react2.default.createElement(
                  'span',
                  null,
                  'seconds before taking screenshots. This allows you to switch windows'
                )
              )
            ),
            _react2.default.createElement(
              'div',
              {
                style: { margin: '30px 0 0' },
                className: 'xmodule-item'
              },
              _react2.default.createElement(
                'div',
                { className: 'xmodule-title' },
                _react2.default.createElement(
                  'span',
                  null,
                  _react2.default.createElement(
                    'b',
                    null,
                    'Screen Capture XModule'
                  ),
                  ' - Select images more quickly'
                ),
                _react2.default.createElement(
                  'a',
                  { href: (0, _x_screen_capture.getXScreenCapture)().infoLink(), target: '_blank' },
                  'More Info'
                ),
                _react2.default.createElement(
                  _button2.default,
                  {
                    type: 'primary',
                    onClick: function onClick() {
                      (0, _x_screen_capture.getXScreenCapture)().getVersion().then(function (data) {
                        var installed = data.installed,
                            version = data.version;

                        var msg = installed ? 'Installed (v' + version + ')' : 'Not Installed';
                        _message3.default.info('status updated: ' + msg);

                        _this6.setState((0, _utils.updateIn)(['xModuleData', (0, _x_screen_capture.getXScreenCapture)().getName()], function (orig) {
                          return (0, _extends3.default)({}, orig, data, { config: (0, _x_screen_capture.getXScreenCapture)().getCachedConfig() });
                        }, _this6.state));
                      });
                    }
                  },
                  'Test it'
                )
              ),
              _react2.default.createElement(
                'div',
                { className: 'xmodule-status' },
                _react2.default.createElement(
                  'label',
                  null,
                  'Status:'
                ),
                this.state.xModuleData[(0, _x_screen_capture.getXScreenCapture)().getName()] && this.state.xModuleData[(0, _x_screen_capture.getXScreenCapture)().getName()].installed ? _react2.default.createElement(
                  'div',
                  { className: 'status-box' },
                  _react2.default.createElement(
                    'span',
                    null,
                    'Installed (v',
                    this.state.xModuleData[(0, _x_screen_capture.getXScreenCapture)().getName()].version,
                    ')'
                  ),
                  _react2.default.createElement(
                    'a',
                    {
                      target: '_blank',
                      href: (0, _x_screen_capture.getXScreenCapture)().checkUpdateLink(this.state.xModuleData[(0, _x_screen_capture.getXScreenCapture)().getName()] && this.state.xModuleData[(0, _x_screen_capture.getXScreenCapture)().getName()].version, _web_extension2.default.runtime.getManifest().version)
                    },
                    'Check for update'
                  )
                ) : _react2.default.createElement(
                  'div',
                  { className: 'status-box' },
                  _react2.default.createElement(
                    'span',
                    null,
                    'Not Installed'
                  ),
                  _react2.default.createElement(
                    'a',
                    { href: (0, _x_screen_capture.getXScreenCapture)().downloadLink(), target: '_blank' },
                    'Download it'
                  )
                )
              )
            )
          ),
          _react2.default.createElement(
            _tabs2.default.TabPane,
            { tab: 'XModules', key: 'xmodules', className: 'xmodules-pane' },
            _react2.default.createElement(
              'div',
              { className: 'xmodule-item' },
              _react2.default.createElement(
                'div',
                { className: 'xmodule-title' },
                _react2.default.createElement(
                  'span',
                  null,
                  _react2.default.createElement(
                    'b',
                    null,
                    'FileAccess XModule'
                  ),
                  ' - Read and write to your hard drive'
                ),
                _react2.default.createElement(
                  'a',
                  { href: (0, _xfile.getXFile)().infoLink(), target: '_blank' },
                  'More Info'
                ),
                _react2.default.createElement(
                  _button2.default,
                  {
                    type: 'primary',
                    onClick: function onClick() {
                      (0, _xfile.getXFile)().getVersion().then(function (data) {
                        var installed = data.installed,
                            version = data.version;

                        var msg = installed ? 'Installed (v' + version + ')' : 'Not Installed';
                        _message3.default.info('status updated: ' + msg);

                        var p = !installed ? _promise2.default.resolve() : (0, _xfile.getXFile)().initConfig();

                        p.catch(function (e) {}).then(function () {
                          _this6.setState((0, _utils.updateIn)(['xModuleData', (0, _xfile.getXFile)().getName()], function (orig) {
                            return (0, _extends3.default)({}, orig, data, { config: (0, _xfile.getXFile)().getCachedConfig() });
                          }, _this6.state));
                        });
                      });
                    }
                  },
                  'Test it'
                )
              ),
              _react2.default.createElement(
                'div',
                { className: 'xmodule-status' },
                _react2.default.createElement(
                  'label',
                  null,
                  'Status:'
                ),
                this.state.xModuleData[(0, _xfile.getXFile)().getName()] && this.state.xModuleData[(0, _xfile.getXFile)().getName()].installed ? _react2.default.createElement(
                  'div',
                  { className: 'status-box' },
                  _react2.default.createElement(
                    'span',
                    null,
                    'Installed (v',
                    this.state.xModuleData[(0, _xfile.getXFile)().getName()].version,
                    ')'
                  ),
                  _react2.default.createElement(
                    'a',
                    {
                      target: '_blank',
                      href: (0, _xfile.getXFile)().checkUpdateLink(this.state.xModuleData[(0, _xfile.getXFile)().getName()] && this.state.xModuleData[(0, _xfile.getXFile)().getName()].version, _web_extension2.default.runtime.getManifest().version)
                    },
                    'Check for update'
                  )
                ) : _react2.default.createElement(
                  'div',
                  { className: 'status-box' },
                  _react2.default.createElement(
                    'span',
                    null,
                    'Not Installed'
                  ),
                  _react2.default.createElement(
                    'a',
                    { href: (0, _xfile.getXFile)().downloadLink(), target: '_blank' },
                    'Download it'
                  )
                )
              ),
              _react2.default.createElement(
                'div',
                { className: 'xmodule-settings' },
                _react2.default.createElement(
                  'h3',
                  null,
                  'Settings'
                ),
                _react2.default.createElement(
                  'div',
                  { className: 'xmodule-settings-item' },
                  _react2.default.createElement(
                    'div',
                    { className: 'settings-detail' },
                    _react2.default.createElement(
                      'label',
                      null,
                      'Home Folder'
                    ),
                    _react2.default.createElement(
                      'div',
                      { className: 'settings-detail-content' },
                      _react2.default.createElement(_input2.default, {
                        type: 'text',
                        value: (0, _xfile.getXFile)().getCachedConfig().rootDir,
                        disabled: !(this.state.xModuleData[(0, _xfile.getXFile)().getName()] && this.state.xModuleData[(0, _xfile.getXFile)().getName()].installed),
                        onChange: function onChange(e) {
                          var rootDir = e.target.value;

                          _this6.setState((0, _utils.compose)((0, _utils.setIn)(['xModuleData', (0, _xfile.getXFile)().getName(), 'config', 'rootDir'], rootDir), (0, _utils.setIn)(['xFileRootDirChanged'], true))(_this6.state));

                          (0, _xfile.getXFile)().setConfig({ rootDir: rootDir });
                        },
                        onBlur: function onBlur() {
                          if (_this6.state.xFileRootDirChanged) {
                            _this6.setState({ xFileRootDirChanged: false });

                            (0, _xfile.getXFile)().sanityCheck().then(function () {
                              _this6.setState((0, _utils.setIn)(['xModuleData', (0, _xfile.getXFile)().getName(), 'checkResult'], { error: null }, _this6.state));

                              (0, _storage.getStorageManager)().emit(_storage.StorageManagerEvent.RootDirChanged);
                            }, function (e) {
                              _this6.setState((0, _utils.setIn)(['xModuleData', (0, _xfile.getXFile)().getName(), 'checkResult'], { error: e.message }, _this6.state));

                              _this6.props.updateUI({ showSettings: true, settingsTab: 'xmodules' });
                            });
                          }
                        }
                      }),
                      this.state.xModuleData[(0, _xfile.getXFile)().getName()] && this.state.xModuleData[(0, _xfile.getXFile)().getName()].checkResult && this.state.xModuleData[(0, _xfile.getXFile)().getName()].checkResult.error ? _react2.default.createElement(
                        'div',
                        { className: 'check-result' },
                        this.state.xModuleData[(0, _xfile.getXFile)().getName()].checkResult.error
                      ) : null
                    )
                  ),
                  _react2.default.createElement(
                    'div',
                    { className: 'settings-desc' },
                    'In this folder, UI.Vision RPA creates /macros, /images, /testsuites, /datasources'
                  )
                )
              )
            ),
            _react2.default.createElement(
              'div',
              { className: 'xmodule-item' },
              _react2.default.createElement(
                'div',
                { className: 'xmodule-title' },
                _react2.default.createElement(
                  'span',
                  null,
                  _react2.default.createElement(
                    'b',
                    null,
                    'RealUser XModule'
                  ),
                  ' - Click / Type / Drag with OS native events'
                ),
                _react2.default.createElement(
                  'a',
                  { href: (0, _x_user_io.getXUserIO)().infoLink(), target: '_blank' },
                  'More Info'
                ),
                _react2.default.createElement(
                  _button2.default,
                  {
                    type: 'primary',
                    onClick: function onClick() {
                      (0, _x_user_io.getXUserIO)().getVersion().then(function (data) {
                        var installed = data.installed,
                            version = data.version;

                        var msg = installed ? 'Installed (v' + version + ')' : 'Not Installed';
                        _message3.default.info('status updated: ' + msg);

                        _this6.setState((0, _utils.updateIn)(['xModuleData', (0, _x_user_io.getXUserIO)().getName()], function (orig) {
                          return (0, _extends3.default)({}, orig, data, { config: (0, _x_user_io.getXUserIO)().getCachedConfig() });
                        }, _this6.state));
                      });
                    }
                  },
                  'Test it'
                )
              ),
              _react2.default.createElement(
                'div',
                { className: 'xmodule-status' },
                _react2.default.createElement(
                  'label',
                  null,
                  'Status:'
                ),
                this.state.xModuleData[(0, _x_user_io.getXUserIO)().getName()] && this.state.xModuleData[(0, _x_user_io.getXUserIO)().getName()].installed ? _react2.default.createElement(
                  'div',
                  { className: 'status-box' },
                  _react2.default.createElement(
                    'span',
                    null,
                    'Installed (v',
                    this.state.xModuleData[(0, _x_user_io.getXUserIO)().getName()].version,
                    ')'
                  ),
                  _react2.default.createElement(
                    'a',
                    {
                      target: '_blank',
                      href: (0, _x_user_io.getXUserIO)().checkUpdateLink(this.state.xModuleData[(0, _x_user_io.getXUserIO)().getName()] && this.state.xModuleData[(0, _x_user_io.getXUserIO)().getName()].version, _web_extension2.default.runtime.getManifest().version)
                    },
                    'Check for update'
                  )
                ) : _react2.default.createElement(
                  'div',
                  { className: 'status-box' },
                  _react2.default.createElement(
                    'span',
                    null,
                    'Not Installed'
                  ),
                  _react2.default.createElement(
                    'a',
                    { href: (0, _x_user_io.getXUserIO)().downloadLink(), target: '_blank' },
                    'Download it'
                  )
                )
              )
            ),
            _react2.default.createElement(
              'div',
              { className: 'xmodule-item' },
              _react2.default.createElement(
                'div',
                { className: 'xmodule-title' },
                _react2.default.createElement(
                  'span',
                  null,
                  _react2.default.createElement(
                    'b',
                    null,
                    'DesktopAutomation XModule'
                  ),
                  ' - Visual Desktop Automation'
                ),
                _react2.default.createElement(
                  'a',
                  { href: (0, _xdesktop.getXDesktop)().infoLink(), target: '_blank' },
                  'More Info'
                ),
                _react2.default.createElement(
                  _button2.default,
                  {
                    type: 'primary',
                    onClick: function onClick() {
                      (0, _xdesktop.getXDesktop)().getVersion().then(function (data) {
                        var installed = data.installed,
                            version = data.version;

                        var msg = installed ? 'Installed (v' + version + ')' : 'Not Installed';
                        _message3.default.info('status updated: ' + msg);

                        _this6.setState((0, _utils.updateIn)(['xModuleData', (0, _xdesktop.getXDesktop)().getName()], function (orig) {
                          return (0, _extends3.default)({}, orig, data, { config: (0, _xdesktop.getXDesktop)().getCachedConfig() });
                        }, _this6.state));
                      });
                    }
                  },
                  'Test it'
                )
              ),
              _react2.default.createElement(
                'div',
                { className: 'xmodule-status' },
                _react2.default.createElement(
                  'label',
                  null,
                  'Status:'
                ),
                this.state.xModuleData[(0, _xdesktop.getXDesktop)().getName()] && this.state.xModuleData[(0, _xdesktop.getXDesktop)().getName()].installed ? _react2.default.createElement(
                  'div',
                  { className: 'status-box' },
                  _react2.default.createElement(
                    'span',
                    null,
                    'Installed (v',
                    this.state.xModuleData[(0, _xdesktop.getXDesktop)().getName()].version,
                    ')'
                  ),
                  _react2.default.createElement(
                    'a',
                    {
                      target: '_blank',
                      href: (0, _xdesktop.getXDesktop)().checkUpdateLink(this.state.xModuleData[(0, _xdesktop.getXDesktop)().getName()] && this.state.xModuleData[(0, _xdesktop.getXDesktop)().getName()].version, _web_extension2.default.runtime.getManifest().version)
                    },
                    'Check for update'
                  )
                ) : _react2.default.createElement(
                  'div',
                  { className: 'status-box' },
                  _react2.default.createElement(
                    'span',
                    null,
                    'Not Installed'
                  ),
                  _react2.default.createElement(
                    'a',
                    { href: (0, _xdesktop.getXDesktop)().downloadLink(), target: '_blank' },
                    'Download it'
                  )
                )
              )
            )
          ),
          _react2.default.createElement(
            _tabs2.default.TabPane,
            { tab: 'XModules PRO', key: 'register', className: 'register-pane' },
            _react2.default.createElement(
              'div',
              {
                className: (0, _utils.cn)('register-note', {
                  inactive: !(0, _license.getLicenseService)().hasNoLicense()
                })
              },
              _react2.default.createElement(
                'p',
                null,
                'Thank you for using the UI.Vision RPA Community Edition. For unlimited real user commands (XClick, XMove and XType), unlimited direct file access and priority support, please upgrade to our PRO and Enterprise Editions. If you have already purchased a license key, you can enter it here:'
              ),
              _react2.default.createElement(
                'div',
                { className: 'actions' },
                _react2.default.createElement(
                  'a',
                  {
                    href: (0, _license.getLicenseService)().getUpgradeUrl(),
                    target: '_blank'
                  },
                  'Click here to upgrade.'
                )
              )
            ),
            _react2.default.createElement(
              'div',
              { className: 'register-form' },
              _react2.default.createElement(
                'label',
                null,
                'Enter license key:'
              ),
              _react2.default.createElement(
                'div',
                { className: 'register-row' },
                _react2.default.createElement(_input2.default, {
                  value: this.state.registerKey,
                  type: 'text',
                  onChange: function onChange(e) {
                    _this6.setState({
                      registerKey: e.target.value
                    });
                  }
                }),
                _react2.default.createElement(
                  _button2.default,
                  {
                    type: 'primary',
                    loading: this.state.isCheckingLicense,
                    onClick: this.checkRegisterKey
                  },
                  'Check Key'
                )
              )
            ),
            _react2.default.createElement(
              'div',
              { className: 'register-status' },
              (0, _license.getLicenseService)().hasNoLicense() ? _react2.default.createElement(
                'div',
                null,
                _react2.default.createElement(
                  'span',
                  null,
                  'XModules status: '
                ),
                _react2.default.createElement(
                  'b',
                  null,
                  this.isEitherXModuleInstalled() ? (0, _license.getLicenseService)().getEditionName() + ' active' : 'Not installed'
                ),
                '.',
                _react2.default.createElement(
                  'a',
                  {
                    href: (0, _license.getLicenseService)().getUpgradeUrl(),
                    target: '_blank'
                  },
                  'Upgrade to XModules Personal, PRO or Enterprise'
                )
              ) : null,
              (0, _license.getLicenseService)().isPersonalLicense() ? _react2.default.createElement(
                'div',
                null,
                'XModules status: ',
                _react2.default.createElement(
                  'b',
                  null,
                  (0, _license.getLicenseService)().getEditionName(),
                  ' active'
                ),
                '.',
                _react2.default.createElement(
                  'a',
                  {
                    href: (0, _license.getLicenseService)().getUpgradeUrl(),
                    target: '_blank'
                  },
                  'Upgrade to PRO or Enterprise'
                )
              ) : null,
              (0, _license.getLicenseService)().isProLicense() ? _react2.default.createElement(
                'div',
                null,
                'XModules status: ',
                _react2.default.createElement(
                  'b',
                  null,
                  (0, _license.getLicenseService)().getEditionName(),
                  ' active'
                ),
                '.',
                _react2.default.createElement(
                  'a',
                  {
                    href: (0, _license.getLicenseService)().getUpgradeUrl(),
                    target: '_blank'
                  },
                  'Contact Support'
                )
              ) : null,
              (0, _license.getLicenseService)().isPlayerLicense() ? _react2.default.createElement(
                'div',
                null,
                'XModules status: ',
                _react2.default.createElement(
                  'b',
                  null,
                  (0, _license.getLicenseService)().getEditionName(),
                  ' active'
                ),
                '.',
                _react2.default.createElement(
                  'a',
                  {
                    href: (0, _license.getLicenseService)().getUpgradeUrl(),
                    target: '_blank'
                  },
                  'Contact Support'
                )
              ) : null
            )
          )
        )
      );
    }
  }, {
    key: 'renderMainMenu',
    value: function renderMainMenu() {
      var _this7 = this;

      var _state = this.state,
          htmlUri = _state.htmlUri,
          jsonUri = _state.jsonUri;
      var _props = this.props,
          status = _props.status,
          editing = _props.editing;
      var commands = editing.commands,
          meta = editing.meta;
      var src = meta.src;

      var canPlay = this.props.player.status === C.PLAYER_STATUS.STOPPED;
      var downloadNamePrefix = src ? src.name : 'Untitled';

      var onClickMenuItem = function onClickMenuItem(_ref5) {
        var key = _ref5.key;

        switch (key) {
          case 'play_settings':
            {
              _this7.showSettingsModal();
              break;
            }
        }
      };

      return _react2.default.createElement(
        _menu2.default,
        { onClick: onClickMenuItem, selectable: false },
        _react2.default.createElement(
          _menu2.default.Item,
          { key: 'play_settings', disabled: !canPlay },
          'Replay settings..'
        )
      );
    }
  }, {
    key: 'renderStatus',
    value: function renderStatus() {
      var _props2 = this.props,
          status = _props2.status,
          player = _props2.player;

      var renderInner = function renderInner() {
        switch (status) {
          case C.APP_STATUS.RECORDER:
            return 'Recording';

          case C.APP_STATUS.PLAYER:
            {
              switch (player.status) {
                case C.PLAYER_STATUS.PLAYING:
                  {
                    var nextCommandIndex = player.nextCommandIndex,
                        loops = player.loops,
                        currentLoop = player.currentLoop,
                        timeoutStatus = player.timeoutStatus;


                    if (nextCommandIndex === null || loops === null || currentLoop === 0) {
                      return '';
                    }

                    var parts = ['Line ' + (nextCommandIndex + 1), 'Round ' + currentLoop + '/' + loops];

                    if (timeoutStatus && timeoutStatus.type && timeoutStatus.total) {
                      var type = timeoutStatus.type,
                          total = timeoutStatus.total,
                          past = timeoutStatus.past;

                      parts.unshift(type + ' ' + past / 1000 + 's (' + total / 1000 + ')');
                    }

                    return parts.join(' | ');
                  }

                case C.PLAYER_STATUS.PAUSED:
                  return 'Player paused';

                default:
                  return '';
              }
            }

          default:
            return '';
        }
      };

      return _react2.default.createElement(
        'div',
        { className: 'status' },
        renderInner()
      );
    }
  }, {
    key: 'renderActions',
    value: function renderActions() {
      var _this8 = this;

      var _props3 = this.props,
          player = _props3.player,
          status = _props3.status;


      var onClickMenuItem = function onClickMenuItem(_ref6) {
        var key = _ref6.key;

        switch (key) {
          case 'play_loop':
            {
              _this8.togglePlayLoopsModal(true);
              break;
            }
        }
      };

      var playMenu = _react2.default.createElement(
        _menu2.default,
        { onClick: onClickMenuItem, selectable: false },
        _react2.default.createElement(
          _menu2.default.Item,
          { key: 'play_loop', disabled: false },
          'Play loop..'
        )
      );

      if (status === C.APP_STATUS.RECORDER) {
        return _react2.default.createElement(
          'div',
          { className: 'actions' },
          _react2.default.createElement(
            _button2.default,
            {
              onClick: this.onToggleRecord,
              style: { color: '#ff0000' }
            },
            _react2.default.createElement(
              'span',
              null,
              'Stop Record'
            )
          )
        );
      }

      switch (player.status) {
        case C.PLAYER_STATUS.PLAYING:
          {
            return _react2.default.createElement(
              'div',
              { className: 'actions' },
              _react2.default.createElement(
                _button2.default.Group,
                null,
                _react2.default.createElement(
                  _button2.default,
                  { onClick: function onClick() {
                      return _this8.getPlayer().stop();
                    } },
                  _react2.default.createElement(
                    'span',
                    null,
                    'Stop'
                  )
                ),
                _react2.default.createElement(
                  _button2.default,
                  { onClick: function onClick() {
                      return _this8.getPlayer('testCase').pause();
                    } },
                  _react2.default.createElement(
                    'span',
                    null,
                    'Pause'
                  )
                )
              )
            );
          }

        case C.PLAYER_STATUS.PAUSED:
          {
            return _react2.default.createElement(
              'div',
              { className: 'actions' },
              _react2.default.createElement(
                _button2.default.Group,
                null,
                this.props.player.mode === C.PLAYER_MODE.TEST_CASE ? _react2.default.createElement(
                  _button2.default,
                  { onClick: function onClick() {
                      return _this8.getPlayer('testCase').resume(true);
                    } },
                  'Step'
                ) : null,
                _react2.default.createElement(
                  _button2.default,
                  { onClick: function onClick() {
                      return _this8.getPlayer().stop();
                    } },
                  'Stop'
                ),
                _react2.default.createElement(
                  _button2.default,
                  { onClick: function onClick() {
                      return _this8.getPlayer('testCase').resume();
                    } },
                  'Resume'
                )
              )
            );
          }

        case C.PLAYER_STATUS.STOPPED:
          {
            return _react2.default.createElement(
              'div',
              { className: 'actions' },
              _react2.default.createElement(
                _button2.default,
                {
                  disabled: !(0, _license.getLicenseService)().canPerform(_types.Feature.Record),
                  onClick: this.onToggleRecord
                },
                _react2.default.createElement(
                  'span',
                  null,
                  'Record'
                )
              ),
              _react2.default.createElement(
                _button2.default.Group,
                { className: 'play-actions' },
                _react2.default.createElement(
                  _button2.default,
                  { onClick: function onClick() {
                      return _this8.playCurrentMacro(true);
                    } },
                  'Step'
                ),
                _react2.default.createElement(
                  _dropdown2.default.Button,
                  { onClick: function onClick() {
                      return _this8.playCurrentMacro(false);
                    }, overlay: playMenu },
                  _react2.default.createElement(
                    'span',
                    null,
                    'Play Macro'
                  )
                )
              ),
              _react2.default.createElement(
                _button2.default,
                { shape: 'circle', onClick: function onClick() {
                    return _this8.showSettingsModal();
                  } },
                _react2.default.createElement(_icon2.default, { type: 'setting' })
              )
            );
          }
      }
    }
  }, {
    key: 'renderMacro',
    value: function renderMacro() {
      var _props4 = this.props,
          editing = _props4.editing,
          player = _props4.player,
          hasUnsaved = _props4.hasUnsaved;
      var src = editing.meta.src;

      var isPlayerStopped = player.status === C.PLAYER_STATUS.STOPPED;
      var klass = hasUnsaved ? 'unsaved' : '';

      var saveBtnState = {
        text: src ? 'Save' : 'Save..',
        disabled: !hasUnsaved
      };

      return _react2.default.createElement(
        'div',
        { className: 'select-case' },
        _react2.default.createElement(
          'span',
          { className: 'test-case-name ' + klass },
          src ? src.name : 'Untitled'
        ),
        !isPlayerStopped ? null : _react2.default.createElement(
          _button2.default,
          { disabled: saveBtnState.disabled, onClick: this.onClickSave },
          _react2.default.createElement(
            'span',
            null,
            saveBtnState.text
          )
        )
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var player = this.props.player;

      var isPlayerStopped = player.status === C.PLAYER_STATUS.STOPPED;

      return _react2.default.createElement(
        'div',
        { className: 'header ' + this.props.status.toLowerCase() },
        this.renderMacro(),
        this.renderStatus(),
        this.renderActions(),
        this.renderPlayLoopModal(),
        this.renderSettingModal(),
        this.renderPublicWebsiteWhiteList()
      );
    }
  }]);
  return Header;
}(_react2.default.Component);

exports["default"] = (0, _reactRedux.connect)(function (state) {
  return {
    hasUnsaved: (0, _recomputed.hasUnsavedMacro)(state),
    route: state.route,
    editing: state.editor.editing,
    player: state.player,
    status: state.status,
    config: state.config,
    ui: state.ui,
    proxy: state.proxy
  };
}, function (dispatch) {
  return (0, _redux.bindActionCreators)((0, _extends3.default)({}, actions, _simple_actions.Actions), dispatch);
})((0, _reactRouterDom.withRouter)(Header));

/***/ }),

/***/ 57879:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _message2 = __webpack_require__(11187);

var _message3 = _interopRequireDefault(_message2);

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

var _modal = __webpack_require__(56697);

var _modal2 = _interopRequireDefault(_modal);

var _input = __webpack_require__(51024);

var _input2 = _interopRequireDefault(_input);

var _getPrototypeOf = __webpack_require__(85105);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(49135);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(93196);

var _inherits3 = _interopRequireDefault(_inherits2);

exports["default"] = getSaveTestCase;

var _react = __webpack_require__(67294);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(73935);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _antd = __webpack_require__(56318);

var _index = __webpack_require__(97876);

var _recomputed = __webpack_require__(78328);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SaveAsModal = function (_React$Component) {
  (0, _inherits3.default)(SaveAsModal, _React$Component);

  function SaveAsModal() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, SaveAsModal);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = SaveAsModal.__proto__ || (0, _getPrototypeOf2.default)(SaveAsModal)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      name: null
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  (0, _createClass3.default)(SaveAsModal, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      if (this.props.name) {
        this.setState({ name: this.props.name });
      }

      setTimeout(function () {
        var input = _this2.inputSaveTestCase.refs.input;
        input.focus();
        input.selectionStart = input.selectionEnd = input.value.length;
      }, 100);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      return _react2.default.createElement(
        _modal2.default,
        {
          title: 'Save macro as..',
          okText: 'Save',
          cancelText: 'Cancel',
          visible: true,
          onOk: function onOk() {
            return _this3.props.onOk(_this3.state.name);
          },
          onCancel: this.props.onCancel,
          className: 'save-modal'
        },
        _react2.default.createElement(_input2.default, {
          style: { width: '100%' },
          onKeyDown: function onKeyDown(e) {
            e.keyCode === 13 && _this3.props.onOk(_this3.state.name);
          },
          onChange: function onChange(e) {
            return _this3.setState({ name: e.target.value });
          },
          value: this.state.name || '',
          placeholder: 'macro name',
          ref: function ref(el) {
            _this3.inputSaveTestCase = el;
          }
        })
      );
    }
  }]);
  return SaveAsModal;
}(_react2.default.Component);

var getContainer = function getContainer() {
  var id = 'save_test_case_container';
  var $el = document.getElementById(id);

  if ($el) return $el;

  var $new = document.createElement('div');
  $new.id = id;
  document.body.appendChild($new);
  return $new;
};

var getTestCaseName = function getTestCaseName(state) {
  var src = state.editor.editing.meta.src;

  return src && src.name && src.name.length ? src.name : 'Untitled';
};

var tryToSave = function tryToSave(store, testCaseName) {
  var $container = getContainer();
  var state = store.getState();
  var existed = !!state.editor.editing.meta.src;

  if (existed) {
    return store.dispatch((0, _index.saveEditingAsExisted)()).then(function () {
      return true;
    });
  }

  return new _promise2.default(function (resolve, reject) {
    var onSave = function onSave(name) {
      return store.dispatch((0, _index.saveEditingAsNew)(name)).then(function () {
        _message3.default.success('successfully saved!', 1.5);
        resolve(true);
      }, function (e) {
        _message3.default.error(e.message, 1.5);
        reject(e);
      });
    };

    _reactDom2.default.render(_react2.default.createElement(SaveAsModal, {
      name: testCaseName,
      onOk: onSave,
      onCancel: function onCancel() {
        return resolve(false);
      }
    }), $container);
    // TODO
  }).then(function (saved) {
    _reactDom2.default.unmountComponentAtNode($container);
    return saved;
  }).catch(function (e) {
    console.error(e.message);
    throw e;
  });
};

var factory = function factory(store) {
  var withIsSaving = function withIsSaving(fn) {
    store.dispatch((0, _index.updateUI)({ isSaving: true }));

    return new _promise2.default(function (resolve) {
      resolve(fn());
    }).finally(function () {
      store.dispatch((0, _index.updateUI)({ isSaving: false }));
    });
  };

  return {
    saveOrNot: function saveOrNot() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var state = store.getState();
      var hasUnsaved = (0, _recomputed.hasUnsavedMacro)(state);
      var isExisting = !!state.editor.editing.meta.src;
      var opts = (0, _extends3.default)({
        getTitle: function getTitle(data) {
          return 'Unsaved changes in macro "' + data.macroName + '"';
        },
        getContent: function getContent(data) {
          return 'Do you want to discard or save these changes?';
        },
        okText: 'Save',
        cancelText: 'Discard'
      }, options || {});

      return withIsSaving(function () {
        if (!hasUnsaved) return _promise2.default.resolve(true);

        if (isExisting && options.autoSaveExisting) {
          return tryToSave(store);
        }

        return new _promise2.default(function (resolve, reject) {
          var macroName = getTestCaseName(state);

          _modal2.default.confirm({
            title: opts.getTitle({ macroName: macroName }),
            content: opts.getContent({ macroName: macroName }),
            okText: opts.okText,
            cancelText: opts.cancelText,
            onOk: function onOk() {
              tryToSave(store).then(resolve, reject);
              return _promise2.default.resolve(true);
            },
            onCancel: function onCancel() {
              resolve(false);
              return _promise2.default.resolve(true);
            }
          });
        });
      });
    },
    save: function save(defaultName) {
      var state = store.getState();
      var hasUnsaved = (0, _recomputed.hasUnsavedMacro)(state);

      return withIsSaving(function () {
        if (!hasUnsaved) return _promise2.default.resolve(true);
        return tryToSave(store, defaultName);
      });
    }
  };
};

var api = void 0;

function getSaveTestCase(store) {
  if (api) return api;
  if (!store) throw new Error('must provide store');

  api = factory(store);
  return api;
}

/***/ }),

/***/ 70462:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _icon = __webpack_require__(86245);

var _icon2 = _interopRequireDefault(_icon);

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = __webpack_require__(85105);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(49135);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(93196);

var _inherits3 = _interopRequireDefault(_inherits2);

var _input = __webpack_require__(51024);

var _input2 = _interopRequireDefault(_input);

var _react = __webpack_require__(67294);

var _react2 = _interopRequireDefault(_react);

var _antd = __webpack_require__(56318);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SearchBox = function (_Input2) {
  (0, _inherits3.default)(SearchBox, _Input2);

  function SearchBox() {
    (0, _classCallCheck3.default)(this, SearchBox);
    return (0, _possibleConstructorReturn3.default)(this, (SearchBox.__proto__ || (0, _getPrototypeOf2.default)(SearchBox)).apply(this, arguments));
  }

  (0, _createClass3.default)(SearchBox, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _ref = this.props.inputProps || {},
          value = _ref.value;

      var canClear = value !== undefined && value.length > 0;

      return _react2.default.createElement(
        'span',
        {
          className: this.props.className,
          style: (0, _extends3.default)({}, this.props.style || {}, {
            position: 'relative'
          })
        },
        _react2.default.createElement(_input2.default, this.props.inputProps || {}),
        _react2.default.createElement(_icon2.default, {
          type: canClear ? 'close' : 'search',
          onClick: function onClick(e) {
            if (!canClear) return;
            if (!_this2.props.inputProps || !_this2.props.inputProps.onChange) return;
            _this2.props.inputProps.onChange({ target: { value: '' } });
          },
          style: {
            position: 'absolute',
            right: '10px',
            top: '50%',
            transform: 'translateY(-50%)',
            cursor: canClear ? 'pointer' : 'auto'
          }
        })
      );
    }
  }]);
  return SearchBox;
}(_input2.default);

exports["default"] = SearchBox;

/***/ }),

/***/ 81930:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = {
  "Core/DemoAutofill": {
    "CreationDate": "2020-05-28",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "store",
      "Target": "15",
      "Value": "!TIMEOUT_WAIT"
    }, {
      "Command": "store",
      "Target": "60",
      "Value": "!TIMEOUT_PAGELOAD"
    }, {
      "Command": "open",
      "Target": "https://docs.google.com/forms/d/1cbI5dMRs0-t_IwNzPm6T3lAG_nPgsnJZEA-FEYVARxg/",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"UI.Vision IDE\")]",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//*[text()[contains(.,'Web Testing')]]",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"Form Autofilling\")]",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//*[text()[contains(.,\"General Web Automation\")]]",
      "Value": ""
    }, {
      "Command": "pause",
      "Target": "500",
      "Value": ""
    }, {
      "Command": "captureScreenshot",
      "Target": "AutoFill1stPage${!LOOP}",
      "Value": ""
    }, {
      "Command": "clickAndWait",
      "Target": "xpath=//*[@id=\"mG61Hd\"]/div/div/div[3]/div/div/div/span/span",
      "Value": "",
      "Targets": ["xpath=//*[@id=\"mG61Hd\"]/div/div/div[3]/div/div/div/span/span", "xpath=//*[@id=\"mG61Hd\"]/div[2]/div/div[3]/div/div/div/span/span"]
    }, {
      "Command": "type",
      "Target": "xpath=//input[@type='text']",
      "Value": "This is a single line test..."
    }, {
      "Command": "type",
      "Target": "xpath=//textarea",
      "Value": "...and this a multiline test:\nLine2\nLine3"
    }, {
      "Command": "captureScreenshot",
      "Target": "AutoFill2ndPage${!LOOP}",
      "Value": ""
    }, {
      "Command": "pause",
      "Target": "1000",
      "Value": ""
    }, {
      "Command": "clickAndWait",
      "Target": "xpath=//*[@id=\"mG61Hd\"]/div/div/div[3]/div[1]/div[1]/div[2]/span/span",
      "Value": ""
    }, {
      "Command": "captureScreenshot",
      "Target": "AutoFill3rdPage${!LOOP}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "DemoAutofill macro completed (shown as notification because of #shownotification in the 3rd column)",
      "Value": "#shownotification"
    }, {
      "Command": "comment",
      "Target": "Open form filling tutorial page",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/rpa/docs/selenium-ide/form-filling",
      "Value": ""
    }, {
      "Command": "assertTitle",
      "Target": "*Form Filling*",
      "Value": ""
    }]
  },
  "Core/DemoDragDrop": {
    "CreationDate": "2017-10-18",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/demo/webtest/dragdrop/",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Reduce replay speed so we can better see what is going on...",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "medium",
      "Value": "!replayspeed"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=one",
      "Value": "id=bin"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=two",
      "Value": "id=bin"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=three",
      "Value": "id=bin"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=four",
      "Value": "id=bin"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=five",
      "Value": "id=bin"
    }]
  },
  "Core/DemoDownload": {
    "CreationDate": "2018-11-23",
    "Commands": [{
      "Command": "store",
      "Target": "60",
      "Value": "!timeout_download"
    }, {
      "Command": "store",
      "Target": "10",
      "Value": "!timeout_wait"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var d=new Date(); return d.getFullYear() + '-' +((d.getMonth()+1))+'-' +d.getDate();",
      "Value": "todaydate"
    }, {
      "Command": "echo",
      "Target": "Today is ${todaydate}",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/filedownload",
      "Value": ""
    }, {
      "Command": "onDownload",
      "Target": "DownloadTest1_${todaydate}.exe",
      "Value": "true"
    }, {
      "Command": "store",
      "Target": "${!runtime}",
      "Value": "starttime"
    }, {
      "Command": "click",
      "Target": "linkText=XModules for Windows",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "File name on disk is ${!LAST_DOWNLOADED_FILE_NAME}",
      "Value": "blue"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return parseFloat(${!runtime})-parseFloat(${starttime})",
      "Value": "downloadtime"
    }, {
      "Command": "echo",
      "Target": "Download1 (Windows version) took ${downloadtime} seconds",
      "Value": "blue"
    }, {
      "Command": "onDownload",
      "Target": "DownloadTest2_${todaydate}.exe",
      "Value": "true"
    }, {
      "Command": "store",
      "Target": "${!runtime}",
      "Value": "starttime"
    }, {
      "Command": "click",
      "Target": "partialLinkText=for macOS",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "File name on disk is ${!LAST_DOWNLOADED_FILE_NAME}",
      "Value": "green"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return parseFloat(${!runtime})-parseFloat(${starttime})",
      "Value": "downloadtime"
    }, {
      "Command": "echo",
      "Target": "Download2 (Mac) took ${downloadtime} seconds",
      "Value": "green"
    }, {
      "Command": "echo",
      "Target": "All done...",
      "Value": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=OnDownload command",
      "Value": ""
    }]
  },
  "Core/DemoExtract": {
    "CreationDate": "2018-05-28",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/executescript",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Current page URL = ${!URL}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Current loop value = ${!LOOP}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "This macro shows various methods to extract and save data from a website",
      "Value": ""
    }, {
      "Command": "storeAttribute",
      "Target": "css=img.responsive-img@src",
      "Value": "mylink"
    }, {
      "Command": "echo",
      "Target": "href=${mylink}",
      "Value": ""
    }, {
      "Command": "storeAttribute",
      "Target": "css=img.responsive-img@alt",
      "Value": "myalttext"
    }, {
      "Command": "echo",
      "Target": "alt text = ${myalttext}",
      "Value": ""
    }, {
      "Command": "storeAttribute",
      "Target": "//input[@id='sometext']@size",
      "Value": "boxsize"
    }, {
      "Command": "echo",
      "Target": "input box size =${boxsize}",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "This box is ${boxsize} chars wide"
    }, {
      "Command": "executeScript",
      "Target": "document.title = ${boxsize};",
      "Value": ""
    }, {
      "Command": "assertTitle",
      "Target": "70",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[3]",
      "Value": ""
    }, {
      "Command": "storeText",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[3]",
      "Value": "myheader"
    }, {
      "Command": "echo",
      "Target": "header = ${myheader}",
      "Value": ""
    }, {
      "Command": "storeTitle",
      "Target": "",
      "Value": "mytitle"
    }, {
      "Command": "echo",
      "Target": "page title = ${mytitle}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "page title = ${mytitle}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "page title = ${mytitle}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "page title = ${mytitle}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Now test some extraction with storeValue",
      "Value": ""
    }, {
      "Command": "storeValue",
      "Target": "id=sometext",
      "Value": "mytext"
    }, {
      "Command": "select",
      "Target": "id=tesla",
      "Value": "label=Model Y"
    }, {
      "Command": "storeValue",
      "Target": "id=tesla",
      "Value": "mytesla"
    }, {
      "Command": "echo",
      "Target": "The text box contains [${mytext}] and the select box has the value [${mytesla}] selected",
      "Value": ""
    }, {
      "Command": "verifyValue",
      "Target": "id=tesla",
      "Value": "y"
    }, {
      "Command": "storeChecked",
      "Target": "name=vehicle",
      "Value": "hasbike"
    }, {
      "Command": "storeChecked",
      "Target": "xpath=(//input[@name='vehicle'])[2]",
      "Value": "hascar"
    }, {
      "Command": "storeChecked",
      "Target": "xpath=(//input[@name='vehicle'])[3]",
      "Value": "hasboat"
    }, {
      "Command": "echo",
      "Target": "User has bike:${hasbike}, car:${hascar}, boat:${hasboat}",
      "Value": "green"
    }, {
      "Command": "comment",
      "Target": "Search and extract directly from the page SOURCE",
      "Value": "y"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=[\\$\\£\\€](\\d+(?:\\.\\d{1,2})?)",
      "Value": "match1"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=[\\$\\£\\€](\\d+(?:\\.\\d{1,2})?)@2",
      "Value": "match2"
    }, {
      "Command": "comment",
      "Target": "You can also extract without regex with the * symbol",
      "Value": "match2b"
    }, {
      "Command": "sourceExtract",
      "Target": "$*<",
      "Value": "match2b"
    }, {
      "Command": "echo",
      "Target": "Coffee costs ${match1} and tea ${match2}",
      "Value": "blue"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=_width: (\\d+)",
      "Value": "match1"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=_width: (\\d+)@1,1",
      "Value": "match1group1"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=_width: (\\d+)@2",
      "Value": "match2"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=_width: (\\d+)@2,1",
      "Value": "match2group1"
    }, {
      "Command": "echo",
      "Target": "match1 = [${MATCH1}] (group1 = [${match1group1}]) match2 =  [${MATCH2}]  (group1 = [${MATCH2GROUP1}])",
      "Value": "blue"
    }, {
      "Command": "comment",
      "Target": "Extract Google Analytics ID",
      "Value": ""
    }, {
      "Command": "sourceExtract",
      "Target": "UA-*,",
      "Value": "ga_option1"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=UA-[0-9]+-[0-9]+",
      "Value": "ga_option2"
    }, {
      "Command": "echo",
      "Target": "Google Analytics ID = ${ga_option2}",
      "Value": "pink"
    }, {
      "Command": "comment",
      "Target": "Some assertion test for QA",
      "Value": ""
    }, {
      "Command": "if_v2",
      "Target": "${match2group1} != 22",
      "Value": ""
    }, {
      "Command": "throwError",
      "Target": "Regex Extraction failed for Match2(1):  ${match2group1}",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Last but not least, taking a screenshot is another way to extract data",
      "Value": ""
    }, {
      "Command": "captureScreenshot",
      "Target": "myscreenshot_${mytitle}",
      "Value": ""
    }, {
      "Command": "storeImage",
      "Target": "//*[@id=\"page-header\"]/div/div/h1",
      "Value": "pagetitle.png"
    }, {
      "Command": "comment",
      "Target": "Export images to download folder",
      "Value": ""
    }, {
      "Command": "localStorageExport",
      "Target": "myscreenshot_${mytitle}.png",
      "Value": ""
    }, {
      "Command": "localStorageExport",
      "Target": "pagetitle.png",
      "Value": ""
    }]
  },
  "Core/DemoFrames": {
    "CreationDate": "2022-02-27",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/demo/webtest/frames/",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Reduce replay speed so we can better see what is going on...",
      "Value": "",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "medium",
      "Value": "!replayspeed",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=0",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "name=mytext1",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=mytext1",
      "Value": "Frame1 (index=0)",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=1",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "name=mytext2",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=mytext2",
      "Value": "Frame2 (index=1)",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=2",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "name=mytext3",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=mytext3",
      "Value": "Frame3 (index=2)",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=3",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "name=mytext4",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=mytext4",
      "Value": "Frame4 (index=3)",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=4",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "name=mytext5",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=mytext5",
      "Value": "Frame5 (index=4)",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=2",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=mytext3",
      "Value": "now testing iframe inside this frame",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=0",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"UI.Vision IDE\")]",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "xpath=//input[@type='text']",
      "Value": "iframe in frame: works!",
      "Description": ""
    }, {
      "Command": "clickAndWait",
      "Target": "xpath=//div[3]/div/div/div/span",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=entry.1572386418",
      "Value": "Form Filling Test Done!",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "xpath=//*[@id=\"mG61Hd\"]/div/div/div[3]/div[1]/div[1]/div[2]/span/span",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=2",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=mytext3",
      "Value": "Test completed!",
      "Description": ""
    }]
  },

  "Core/DemoTakeScreenshots": {
    "CreationDate": "2018-1-25",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/blog/",
      "Value": ""
    }, {
      "Command": "captureEntirePageScreenshot",
      "Target": "rpablog",
      "Value": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=read more@POS=1",
      "Value": ""
    }, {
      "Command": "captureEntirePageScreenshot",
      "Target": "article1",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/blog/",
      "Value": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=read more@POS=2",
      "Value": ""
    }, {
      "Command": "captureEntirePageScreenshot",
      "Target": "article2",
      "Value": ""
    }, {
      "Command": "captureScreenshot",
      "Target": "article2_just_viewport",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "take screenshot of an _element_ with storeImage",
      "Value": ""
    }, {
      "Command": "storeImage",
      "Target": "partialLinkText=Blog",
      "Value": "blogtitle"
    }]
  },
  "Core/DemoIfElse": {
    "CreationDate": "2018-4-28",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/executeScript",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "How to use gotoIf and label(s) for flow control. For a while/endWhile demo, see the DemoSaveCSV macro.",
      "Value": ""
    }, {
      "Command": "executeScript",
      "Target": "return (new Date().getHours())",
      "Value": "mytime"
    }, {
      "Command": "echo",
      "Target": "mytime = ${mytime}",
      "Value": ""
    }, {
      "Command": "if_v2",
      "Target": "${mytime}  > 16",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Good afternoon!",
      "Value": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Good morning!",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "storeAttribute",
      "Target": "//input[@id='sometext-WRONG-ID-TEST']@size",
      "Value": "boxsize"
    }, {
      "Command": "if_v2",
      "Target": "${boxsize} == \"#LNF\"",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "The xpath was not found. In this case the variable gets filled with #LNF (Locator Not Found).",
      "Value": "blue"
    }, {
      "Command": "storeAttribute",
      "Target": "//input[@id='sometext']@size",
      "Value": "boxsize"
    }, {
      "Command": "echo",
      "Target": "With correct Xpath ID we get: Boxsize = ${boxsize}",
      "Value": "green"
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "gotoIf_v2",
      "Target": "${boxsize} > 70",
      "Value": "BOX-TOO-BIG"
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "This box is ${boxsize} chars wide"
    }, {
      "Command": "executeScript",
      "Target": "document.title = ${boxsize};",
      "Value": ""
    }, {
      "Command": "gotoLabel",
      "Target": "END",
      "Value": ""
    }, {
      "Command": "label",
      "Target": "BOX-TOO-BIG",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Input box too big. This is just a test of gotoIf",
      "Value": ""
    }, {
      "Command": "executeScript",
      "Target": "document.title = \"Just a gotoIf test. This line should not be reached unless you edit the macro\"",
      "Value": ""
    }, {
      "Command": "label",
      "Target": "END",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "test case completed",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "",
      "Value": ""
    }, {
      "Command": "onError",
      "Target": "#goto",
      "Value": "fixerror"
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "this line works"
    }, {
      "Command": "type",
      "Target": "id=sometextXXXXX",
      "Value": "this line has the wrong ID..."
    }, {
      "Command": "echo",
      "Target": "this line is never reached, because of the error above",
      "Value": "blue"
    }, {
      "Command": "gotoLabel",
      "Target": "end-part2",
      "Value": ""
    }, {
      "Command": "label",
      "Target": "fixerror",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "here we can have code that handles the error..",
      "Value": "green"
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "Fix Error Section: This command works."
    }, {
      "Command": "label",
      "Target": "end-part2",
      "Value": ""
    }]
  },
  "Core/DemoIframe": {
    "CreationDate": "2022-05-18",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/demo/iframes",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "//*[@id=\"content\"]/div[2]/div/p[1]",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[1]",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "First iframe: Embedded Google Doc",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=0",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"UI.Vision IDE\")]",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "xpath=//input[@type='text']",
      "Value": "Automating a website inside an embedded iframe",
      "Description": ""
    }, {
      "Command": "clickAndWait",
      "Target": "xpath=//div[3]/div/div/div/span",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=entry.1572386418",
      "Value": "Form Filling Test Done!",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "xpath=//*[@id=\"mG61Hd\"]/div/div/div[3]/div[1]/div[1]/div[2]/span/span",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": "",
      "Description": "Back to main page (top frame)"
    }]
  },
  "Core/DemoImplicitWaiting": {
    "CreationDate": "2019-8-5",
    "Commands": [{
      "Command": "comment",
      "Target": "waitForElementVisible is not part of implicit waiting",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/waitforelementvisible",
      "Value": ""
    }, {
      "Command": "waitForElementVisible",
      "Target": "css=#div1 > h1",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "css=#div1 > h1",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "20",
      "Value": "!timeout_wait"
    }, {
      "Command": "waitForElementVisible",
      "Target": "css=#div2 > h1",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "css=#div2 > h1",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Implicit waiting: Wait for elements to be loaded  or <timeout_wait> is reached",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/webtest/implicitwaiting/",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "15",
      "Value": "!TIMEOUT_WAIT"
    }, {
      "Command": "assertText",
      "Target": "/html/body/header/center/p[2]",
      "Value": "Use the select box to start the timer..."
    }, {
      "Command": "select",
      "Target": "id=minutesSelect",
      "Value": "label=5 Seconds"
    }, {
      "Command": "echo",
      "Target": "The next element (target) is not available yet... UI.Vision RPA waits for it up to ${!TIMEOUT_WAIT} seconds to appear.",
      "Value": "blue"
    }, {
      "Command": "click",
      "Target": "/html/body/header/center/img",
      "Value": ""
    }]
  },
  "Core/DemoCsvReadWithLoop": {
    "CreationDate": "2019-03-23",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "comment",
      "Target": "The file ReadCSVTestData.csv is pre-installed with UI.Vision RPA.",
      "Value": ""
    }, {
      "Command": "csvRead",
      "Target": "ReadCSVTestData.csv",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Call subroutine for the actual form filling",
      "Value": ""
    }, {
      "Command": "run",
      "Target": "Sub/Sub_DemoCsvRead_FillForm",
      "Value": ""
    }]
  },
  "Core/DemoCsvReadWithWhile": {
    "CreationDate": "2018-1-25",
    "Commands": [{
      "Command": "store",
      "Target": "180",
      "Value": "!timeout_macro"
    }, {
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "comment",
      "Target": "The file ReadCSVTestData.csv is pre-installed with UI.Vision RPA.",
      "Value": ""
    }, {
      "Command": "csvRead",
      "Target": "ReadCSVTestData.csv",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Status = ${!csvReadStatus}, line = ${!csvReadLineNumber}",
      "Value": ""
    }, {
      "Command": "while_v2",
      "Target": "${!csvReadStatus} == \"OK\"",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "status = ${!csvReadStatus}, line = ${!csvReadLineNumber}",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Call subroutine for the actual form filling",
      "Value": ""
    }, {
      "Command": "run",
      "Target": "Sub/Sub_DemoCsvRead_FillForm",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number(${!csvReadLineNumber})+1",
      "Value": "!csvReadLineNumber"
    }, {
      "Command": "store",
      "Target": "true",
      "Value": "!errorIgnore"
    }, {
      "Command": "echo",
      "Target": "Reading CSV line No.  ${!csvReadLineNumber} ",
      "Value": "!errorIgnore"
    }, {
      "Command": "csvRead",
      "Target": "ReadCSVTestData.csv",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "false",
      "Value": "!errorIgnore"
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }]
  },
  "Core/DemoCsvReadArray": {
    "CreationDate": "2022-03-23",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed",
      "Description": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/rpa/docs/selenium-ide/executescript",
      "Value": "We open a website (any website will do) because executeScript runs inside the webpage. ",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Create an array and save the content to a CSV file",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript",
      "Target": "var arr = []; for(var x = 0; x < 5; x++){arr[x] = []; for(var y = 0; y < 3; y++){arr[x][y] = (x+1)*(y+1);}}; return arr",
      "Value": "array1",
      "Description": "Note that (non-sandbox) executeScript command runs inside the webpage, so a website must be open in the browser."
    }, {
      "Command": "comment",
      "Target": "Manually set two array values ",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript",
      "Target": "var newArr = ${array1}; newArr[0][2] = 'Hello World'; return newArr",
      "Value": "array1",
      "Description": "We must use executeScript here since the \"_Sandbox\" version can not return arrays. "
    }, {
      "Command": "executeScript",
      "Target": "var newArr = ${array1}; newArr[2][1] = 'This is how you set an array value'; return newArr",
      "Value": "array1",
      "Description": "We must use executeScript here since the \"_Sandbox\" version can not return arrays. "
    }, {
      "Command": "csvSaveArray",
      "Target": "array1",
      "Value": "data_from_array.csv",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Read the array again from csv file",
      "Value": "",
      "Description": ""
    }, {
      "Command": "csvReadArray",
      "Target": "data_from_array.csv",
      "Value": "myCSV",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Number of rows = ${!CsvReadMaxRow}",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${mycsv[0]}.length;",
      "Value": "col",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Number of columns = ${col}",
      "Value": "pink",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "loop over all CSV values",
      "Value": "",
      "Description": ""
    }, {
      "Command": "forEach",
      "Target": "myCSV",
      "Value": "row",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "col1=${row[0]}, col2=${row[1]}, col3=${row[2]}",
      "Value": "brown",
      "Description": ""
    }, {
      "Command": "forEach",
      "Target": "row",
      "Value": "elem",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Element=${elem}",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "row",
      "Value": "elem",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Another way to loop over the array content",
      "Value": "",
      "Description": ""
    }, {
      "Command": "times",
      "Target": "${!CsvReadMaxRow}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Substract 1 from !times, as the array index starts with 0",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!times} - 1;",
      "Value": "i",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Row ${i}, 3rd Element => ${myCSV[${i}][2]}",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }]
  },

  "Core/DemoCsvSave": {
    "CreationDate": "2018-06-01",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/csvsave",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var d = new Date(); m = d.getFullYear()+\"-\"+(d.getMonth()+1)+\"-\"+ d.getDate()+\" \"+ d.getHours()+\":\" + d.getMinutes() + \":\" + d.getSeconds(); return m",
      "Value": "timestamp"
    }, {
      "Command": "store",
      "Target": "${timestamp}",
      "Value": "!csvLine"
    }, {
      "Command": "echo",
      "Target": "First column in the CSV is time (${timestamp})",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Set i = 1 as we start the extraction with the 2nd table cell.",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "1",
      "Value": "i"
    }, {
      "Command": "while_v2",
      "Target": "(${i} < 8)",
      "Value": ""
    }, {
      "Command": "executeScript",
      "Target": "return Number (${i}) + 1",
      "Value": "i"
    }, {
      "Command": "echo",
      "Target": "Current value of i = ${i}",
      "Value": "i"
    }, {
      "Command": "storeText",
      "Target": "//*[@id=\"gcw_mainFNGP5XSu6\"]/div[2]/table/tbody/tr[2]/td[${i}]/a",
      "Value": "c2"
    }, {
      "Command": "store",
      "Target": "${c2}",
      "Value": "!csvLine"
    }, {
      "Command": "echo",
      "Target": "Extracted Value for i=${i} is exchange rate = ${c2}",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "${!csvLine}",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Append content of !csvLine to CSV file (or create file if none exists)",
      "Value": ""
    }, {
      "Command": "csvSave",
      "Target": "CurrencyConverterData",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "If needed, you can download (save) the CSV data from the CSV tab to the the download folder",
      "Value": ""
    }, {
      "Command": "localStorageExport",
      "Target": "currencyconverterdata.csv",
      "Value": ""
    }]
  },
  "XModules/DemoPDFTest_with_OCR": {
    "CreationDate": "2022-05-18",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed",
      "Description": ""
    }, {
      "Command": "if_v2",
      "Target": "${!browser} ==\"firefox\"",
      "Value": "",
      "Description": ""
    }, {
      "Command": "throwError",
      "Target": "This macro works only in Chrome and Edge - Firefox does not support automating PDF documents yet.",
      "Value": "",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "open",
      "Target": "http://download.ui.vision/demo/pdf-test.pdf",
      "Value": "",
      "Description": ""
    }, {
      "Command": "setWindowSize",
      "Target": "800x700",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Check that PDF is loaded OK",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Option 1: Check with image search",
      "Value": "",
      "Description": ""
    }, {
      "Command": "visualAssert",
      "Target": "pdftest_salesquote.png@0.35",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Option 2: Check with text search  search",
      "Value": "",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "ENG",
      "Value": "!ocrlanguage",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "1",
      "Value": "!ocrengine",
      "Description": "Online OCR uses the OCR API at https://ocr.space - on this website you can test the different OCR engines directly and use the one that works best."
    }, {
      "Command": "store",
      "Target": "true",
      "Value": "!ocrscale",
      "Description": "Upscaling can help with smaller fonts"
    }, {
      "Command": "OCRSearch",
      "Target": "sales quote",
      "Value": "matches",
      "Description": "Search the (visible part of the ) PDF for the word \"sales quote\""
    }, {
      "Command": "echo",
      "Target": "Number of matches: ${matches}",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "if_v2",
      "Target": "${matches} == \"0\"",
      "Value": "",
      "Description": ""
    }, {
      "Command": "throwError",
      "Target": "Something wrong, I can not find the text <sales quote>",
      "Value": "",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Now extract the quote number and check that it is the correct one",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClickRelative",
      "Target": "getquotenumber_dpi_96_relative.png@0.30",
      "Value": "",
      "Description": "Takes a screenshof the area inside the pink box and OCR its. The extracted area can be checked by looking at the \"__lastscreenshot.png\" image in the Screenshots tab"
    }, {
      "Command": "OCRExtractRelative",
      "Target": "getquotenumber_dpi_96_relative.png@0.30",
      "Value": "q",
      "Description": "Takes a screenshof the area inside the pink box and OCR its. The extracted area can be checked by looking at the \"__lastscreenshot.png\" image in the Screenshots tab"
    }, {
      "Command": "echo",
      "Target": "Extracted text in pink area: >${q}<",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "executeScript",
      "Target": "return ${q}.replace(/( |\\n|\\r)/gm, \"\")",
      "Value": "q",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Remove space(s) and line break(s): Quote Number: >${q}<",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var string = ${q}, substring = \"135\";  b= string.lastIndexOf(substring)>=0; return b;",
      "Value": "textfound",
      "Description": "lastIndexOf>=0 is true if the substring is found inside the q variable, see https://forum.ui.vision/t/string-search-startswith-and-includes/10081/3"
    }, {
      "Command": "if_v2",
      "Target": "${textfound} == true",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Quote number OK",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "throwError",
      "Target": "Wrong quote number. Extracted text was >${q}<",
      "Value": "",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "The X... commands require the RealUser XModule to be installed",
      "Value": "",
      "Description": ""
    }, {
      "Command": "pause",
      "Target": "500",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Click on the document to give it the focus. For this, we click on the word \"SALES QUOTE\".",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClick",
      "Target": "ocr=sales quote",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Scroll down to next page",
      "Value": "",
      "Description": ""
    }, {
      "Command": "if_v2",
      "Target": "${!os}==\"mac\"",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Page scroll in macOS is CMD key + Down",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_CMD+KEY_DOWN}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Page scroll in Windows and Linux is PAGE DOWN key",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_PAGE_DOWN}${KEY_PAGE_DOWN}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Find link image and click it",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Wait 0.5 seconds for the PDF to complete scrolling. Otherwise if the Xclick image is found while the PDF still scrolls, the click goes to the wrong location.",
      "Value": "",
      "Description": ""
    }, {
      "Command": "pause",
      "Target": "500",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClick",
      "Target": "ocr=website",
      "Value": "",
      "Description": "For XClick to work correctly make sure the browser zoom is at 100%. Otherwise the calculated x/y are wrong."
    }, {
      "Command": "comment",
      "Target": "Check the right page is loaded (here: check logo is there)",
      "Value": "",
      "Description": ""
    }, {
      "Command": "assertElementPresent",
      "Target": "//*[@id=\"logo\"]/img",
      "Value": "",
      "Description": "Make sure the previous XClick was successful "
    }]
  },
  "Core/DemoExecuteScript": {
    "CreationDate": "2022-2-1",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed",
      "Description": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/executescript",
      "Value": "",
      "Description": ""
    }, {
      "Command": "assertText",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[1]",
      "Value": "Input box to display some results",
      "Description": ""
    }, {
      "Command": "verifyText",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[1]",
      "Value": "Input box to display some results",
      "Description": ""
    }, {
      "Command": "verifyTitle",
      "Target": "Selenium IDE executeScript Demo Page",
      "Value": "",
      "Description": ""
    }, {
      "Command": "assertTitle",
      "Target": "Selenium IDE executeScript Demo Page",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript",
      "Target": "function randomString(length, chars) {\n    var result = '';\n    for (var i = length; i > 0; --i) result += chars[Math.round(Math.random() * (chars.length - 1))];\n    return result;\n}\n\n//The executeScript script(s) can have multiple lines!\n\n//Demo: Here we generate a random key \nvar s = randomString(8, '0123456789ABCDE') + \"<= Random String\";\n\n//Set the page title to the random key \ndocument.title = s;\n\nreturn s;\n",
      "Value": "s",
      "Description": "executeScript can run Javascript... and store the result in a variable (optional)"
    }, {
      "Command": "assertTitle",
      "Target": "${s}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Use sourceSearch to assert we have the right Google Analytics Code",
      "Value": "",
      "Description": ""
    }, {
      "Command": "sourceSearch",
      "Target": "UA-86195842-1",
      "Value": "matches",
      "Description": ""
    }, {
      "Command": "if_v2",
      "Target": "${matches} == 0",
      "Value": "",
      "Description": ""
    }, {
      "Command": "throwError",
      "Target": "Google Analytics ID is wrong!",
      "Value": "",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "First some basic calculations with STORE",
      "Value": "",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "15",
      "Value": "AAA",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "10",
      "Value": "BBB",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return (Number (${AAA}) - Number (${BBB}) )",
      "Value": "CCC",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "${CCC}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript",
      "Target": "document.title = ${CCC};",
      "Value": "",
      "Description": ""
    }, {
      "Command": "assertTitle",
      "Target": "5",
      "Value": "",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "SELenium IDe",
      "Value": "AAA",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${AAA}.toUpperCase()",
      "Value": "CCC",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "${CCC}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "${CCC}",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Generate TODAYs date in in YYYY-MM-DD format ",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Create today's date in the YYYY-MM-DD format",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var d = new Date(); \nvar m = ((d.getMonth()+1)<10)?'0'+(d.getMonth()+1):(d.getMonth()+1);\nvar d2 = (d.getDate() <10)?'0'+d.getDate():d.getDate(); \nvar date_today = d.getFullYear()+\"-\"+m+\"-\"+d2; \nreturn date_today",
      "Value": "mydate",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Today is ${mydate}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Pick a random item from a list, useful for data-driven testing",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return new Array ('cat','dog','fish','dog','deer','frog','whale','dog','seal','horse','elephant')",
      "Value": "names",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${names}.length",
      "Value": "len",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "array length = ${len}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Math.floor(Math.random()*${len})",
      "Value": "num",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "num=${num}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "The next command picks the random item",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${names}[${num}]",
      "Value": "myrandomname",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "Today is ${mydate}, and we draw a ${myrandomname}",
      "Value": "output",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "To is ${mydate}, and we draw a ${myrandomname}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "${output}",
      "Description": ""
    }, {
      "Command": "if_v2",
      "Target": "parseFloat(${!runtime}) > 20",
      "Value": "",
      "Description": ""
    }, {
      "Command": "throwError",
      "Target": "Runtime too slow (${!runtime} seconds), test failed",
      "Value": "",
      "Description": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Runtime Ok, test passed!",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "With @POS you click on the (in this case) 3rd link with the same name. Great for looping over a list of links with the same name.",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=This link@POS=3",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Demo: Create array and then loop over it with forEach",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript",
      "Target": "var arr = [\"Hello\",\"World\", \"2020\"]; \nreturn arr;",
      "Value": "myarray",
      "Description": "We must use executeScript here, since executeScript _Sandbox does not support returning arrays."
    }, {
      "Command": "forEach",
      "Target": "myarray",
      "Value": "elem",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "${elem}",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }]
  },
  "Core/DemoTabs": {
    "CreationDate": "2017-10-15",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/demo/tabs",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "linkText=Open new web page in new browser tab",
      "Value": ""
    }, {
      "Command": "selectWindow",
      "Target": "tab=1",
      "Value": ""
    }, {
      "Command": "assertTitle",
      "Target": "*1* TAB1",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "id=sometext1",
      "Value": "this is tab 1"
    }, {
      "Command": "click",
      "Target": "linkText=Open yet another web page in a new browser tab",
      "Value": ""
    }, {
      "Command": "selectWindow",
      "Target": "tab=2",
      "Value": ""
    }, {
      "Command": "assertTitle",
      "Target": "*2* TAB2",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "id=sometext2",
      "Value": "And this is tab 2!"
    }, {
      "Command": "selectWindow",
      "Target": "tab=1",
      "Value": ""
    }, {
      "Command": "assertTitle",
      "Target": "*1* TAB1",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "id=sometext1",
      "Value": "Now back in tab 1 - test done!"
    }, {
      "Command": "comment",
      "Target": "We can also open new tabs",
      "Value": ""
    }, {
      "Command": "selectWindow",
      "Target": "tab=open",
      "Value": "https://ui.vision"
    }, {
      "Command": "selectWindow",
      "Target": "tab=open",
      "Value": "https://ocr.space"
    }, {
      "Command": "type",
      "Target": "id=imageUrl",
      "Value": "UI.Vision RPA Tab Test done"
    }]
  },
  "XModules/DemoVisualUITest": {
    "CreationDate": "2022-2-21",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/",
      "Value": ""
    }, {
      "Command": "setWindowSize",
      "Target": "1024x768",
      "Value": ""
    }, {
      "Command": "visualVerify",
      "Target": "uitest_logo_wide_dpi_96.png@0.70",
      "Value": ""
    }, {
      "Command": "visualVerify",
      "Target": "uitest_share_dpi_96.png@0.70",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Resize to iPhone6 screen size",
      "Value": ""
    }, {
      "Command": "setWindowSize",
      "Target": "375x768",
      "Value": ""
    }, {
      "Command": "visualVerify",
      "Target": "uitest_logo_mobile_dpi_96.png",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Missing menu is critical, so we use ASSERT (instead of just VERIFY)",
      "Value": ""
    }, {
      "Command": "visualAssert",
      "Target": "uitest_hamburger_dpi_96.png",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Check that Share buttons do not show",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "At this point, page is surely loaded => reduce wait for (normally missing) image",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "2",
      "Value": "!timeout_wait"
    }, {
      "Command": "visualSearch",
      "Target": "uitest_share_dpi_96.png@0.70",
      "Value": "count"
    }, {
      "Command": "if_v2",
      "Target": "${count} > 0",
      "Value": ""
    }, {
      "Command": "throwError",
      "Target": "Share buttons should NOT show on mobile phones",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Restore default wait (not really needed here, since macro stops now anyway)",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "10",
      "Value": "!timeout_wait"
    }, {
      "Command": "comment",
      "Target": "Done, enlarge browser again",
      "Value": ""
    }, {
      "Command": "setWindowSize",
      "Target": "1024x768",
      "Value": ""
    }]
  },
  "XModules/DemoXType": {
    "CreationDate": "2019-01-28",
    "Commands": [{
      "Command": "store",
      "Target": "medium",
      "Value": "!replayspeed"
    }, {
      "Command": "comment",
      "Target": "Make sure the browser is in the foreground, so it receives the XTYPE keystrokes",
      "Value": ""
    }, {
      "Command": "bringBrowserToForeground",
      "Target": "",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/xtype",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "To save the page, open the browser save dialog with a shortcut",
      "Value": ""
    }, {
      "Command": "if_v2",
      "Target": "${!os}==\"mac\"",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Save web page in macOS is CMD+S",
      "Value": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_CMD+KEY_S}",
      "Value": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Save web page in Windows and Linux is CTRL+S",
      "Value": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_CTRL+KEY_S}",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Generate today's date and time ",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var d= new Date(); var m=((d.getMonth()+1)<10)?'0'+(d.getMonth()+1):(d.getMonth()+1); m = d.getFullYear()+\"-\"+m+\"-\"+d.getDate(); return m",
      "Value": "mydate"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return new Date().getHours()+\"-\" + new Date().getMinutes() + \"-\" + new Date().getSeconds()",
      "Value": "mytime"
    }, {
      "Command": "echo",
      "Target": "Today is ${mydate}, and the time is ${mytime}",
      "Value": "blue"
    }, {
      "Command": "comment",
      "Target": "Wait for the dialog to appear before sending the next keystrokes",
      "Value": ""
    }, {
      "Command": "pause",
      "Target": "2000",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Send the new file name to the dialog and press ENTER",
      "Value": "blue"
    }, {
      "Command": "XType",
      "Target": "Page_saved_by_UiVision_${mydate}_${mytime}",
      "Value": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_ENTER}",
      "Value": ""
    }]
  },

  "XModules/DemoXRun": {
    "CreationDate": "2019-09-16",
    "Commands": [{
      "Command": "echo",
      "Target": "This demo macro uses hard-coded paths for the default calculator app. But the correct path depends on your operating system version and language. So the default path in this macro might be wrong and needs to be adjusted.",
      "Value": "blue"
    }, {
      "Command": "if_v2",
      "Target": "${!os}==\"mac\"",
      "Value": ""
    }, {
      "Command": "XRun",
      "Target": "/Applications/Calculator.app/Contents/MacOS/Calculator",
      "Value": ""
    }, {
      "Command": "elseif",
      "Target": "${!os}==\"linux\"",
      "Value": ""
    }, {
      "Command": "XRun",
      "Target": "/snap/bin/gnome-calculator",
      "Value": ""
    }, {
      "Command": "elseif",
      "Target": "${!os}==\"windows\"",
      "Value": ""
    }, {
      "Command": "XRun",
      "Target": "C:\\Windows\\System32\\calc.exe",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "You find the example PowerShell script for this demo in the UI.Vision docs for \"XRunAndWait\"",
      "Value": "-executionpolicy bypass -File  c:\\test\\test1.ps1  c:\\test\\test.txt Hello"
    }, {
      "Command": "comment",
      "Target": "XRunAndWait // Powershell.exe ",
      "Value": "-executionpolicy bypass -File  c:\\test\\test1.ps1  c:\\test\\test.txt Hello"
    }, {
      "Command": "comment",
      "Target": "echo // Exitcode = ${!xrun_exitcode}  (Note: The exit code is only captured if you use XRunAndWait)",
      "Value": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "This should never happen",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Calculator app launched ",
      "Value": ""
    }]
  },

  "XModules/DemoXClick": {
    "CreationDate": "2022-05-19",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed",
      "Description": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/draw",
      "Value": "",
      "Description": ""
    }, {
      "Command": "bringBrowserToForeground",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "linkText=this link",
      "Value": "",
      "Description": ""
    }, {
      "Command": "pause",
      "Target": "1000",
      "Value": "",
      "Description": ""
    }, {
      "Command": "visualAssert",
      "Target": "draw_canvas_dpi_96.png",
      "Value": "",
      "Description": "Check we are on the right page"
    }, {
      "Command": "XClick",
      "Target": "draw_plus_dpi_96.png",
      "Value": "",
      "Description": "Click the plus icon to start a new drawing"
    }, {
      "Command": "XClick",
      "Target": "draw_redbutton_dpi_96.png",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "We use a relative click, since the pencil icon can change shape",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClickRelative",
      "Target": "draw_pencil_dpi_96.png",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_ESC}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClickRelative",
      "Target": "draw_startingpoint_dpi_96.png",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Starting point: x=${!imagex} y=${!imagey}",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "${!imagex}",
      "Value": "x",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "${!imagey}",
      "Value": "y",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Draw top line --->",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#down",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${x}) +100",
      "Value": "x",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#move",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#up",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Draw right line down",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#down",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${y}) +100",
      "Value": "y",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#move",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#up",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Draw bottom line <---",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#down",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${x}) - 100",
      "Value": "x",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#move",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#up",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Draw left line up",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#down",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${y}) - 100",
      "Value": "y",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#move",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#up",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "visualVerify // draw_compare_dpi_96.png",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Add some text...",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClick",
      "Target": "draw_text1_dpi_96.png",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_ESC}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Now click on the canvas. This is the place where the text starts.",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${y}) +180",
      "Value": "y",
      "Description": ""
    }, {
      "Command": "XClick",
      "Target": "${x},${y}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Send keystrokes",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XType",
      "Target": "Demo completed.",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Click once more on the canvas to close text menu",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${y}) - 150",
      "Value": "y",
      "Description": ""
    }, {
      "Command": "XClick",
      "Target": "${x},${y}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Confirm that the text is shown. @0.5 overwrites the global confidence level.",
      "Value": "",
      "Description": ""
    }, {
      "Command": "visualAssert",
      "Target": "draw_checkresult1_dpi_96.png@0.4",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "DemoXClick completed",
      "Value": "#shownotification",
      "Description": ""
    }]
  },

  "XModules/DemoXMove": {
    "CreationDate": "2021-05-17",
    "Commands": [{
      "Command": "comment",
      "Target": "This demo shows *two* methods to select an image from a list of matches",
      "Value": "",
      "Description": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/draw",
      "Value": "",
      "Description": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=this external website",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Move 2nd range slider using #POS method",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "slider_handle_dpi_96.png@0.75#2",
      "Value": "#down",
      "Description": "Press slider handle down"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var x = ${!imagex}; return x+200",
      "Value": "xnew",
      "Description": "Calcuate new X position. "
    }, {
      "Command": "XMove",
      "Target": "${xnew}, ${!imagey}",
      "Value": "#up",
      "Description": "Move slider handle and release left mouse button"
    }, {
      "Command": "comment",
      "Target": "Move 3rd slider with AREALIMIT method",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "xpath=//ion-list[3]/ion-item/div/div/ion-range",
      "Value": "#down",
      "Description": "CLICK is not needed. We used it just to find the XPath for use with visionLimitSearchArea below."
    }, {
      "Command": "pause",
      "Target": "2000",
      "Value": "",
      "Description": ""
    }, {
      "Command": "visionLimitSearchArea",
      "Target": "element: xpath=//ion-list[3]/ion-item/div/div/ion-range",
      "Value": "",
      "Description": "Restrict computer vision image search to the HTML tag area"
    }, {
      "Command": "XMove",
      "Target": "slider_handle_dpi_96.png@0.6",
      "Value": "#down",
      "Description": "We do not need to add \"#1\" because in the new (limited) area there is only one slider handle, so the BEST MATCH option (=without #) is most reliable"
    }, {
      "Command": "XMoveRelative",
      "Target": "slider_red_dpi_96.png@0.6",
      "Value": "#up",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Confirm slider is in the right position.",
      "Value": "",
      "Description": ""
    }, {
      "Command": "storeText",
      "Target": "xpath=//ion-list[3]/ion-list-header/div/ion-badge",
      "Value": "warmth",
      "Description": "Extract slider position"
    }, {
      "Command": "echo",
      "Target": "Slider WARMTH value is: ${warmth}",
      "Value": "red",
      "Description": ""
    }, {
      "Command": "assert",
      "Target": "warmth",
      "Value": "2000",
      "Description": "Show error if slider has not the expected value"
    }]
  },

  "XModules_Desktop/DemoXDesktopAutomation": {
    "CreationDate": "2020-02-13",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "echo",
      "Target": "Running DESKTOP image search now",
      "Value": "#shownotification"
    }, {
      "Command": "XDesktopAutomation",
      "Target": "true",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Limit the search area for better performance",
      "Value": ""
    }, {
      "Command": "run",
      "Target": "Sub/Sub_XDesktopAutomation_Area",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Log button can be greyed out - try both options",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "true",
      "Value": "!errorignore"
    }, {
      "Command": "comment",
      "Target": "Log button can have white or grey background",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_logstab_white_dpi_96.png@0.5",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "false",
      "Value": "!errorignore"
    }, {
      "Command": "if_v2",
      "Target": "${!statusOK} == false",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_logstab_grey_dpi_96.png@0.5",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "true",
      "Value": "!statusOK"
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Press Clear button",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_clearbutton_dpi_96.png@0.5",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Log cleared by macro (clear button pressed)",
      "Value": "blue"
    }, {
      "Command": "comment",
      "Target": "Now search and open other tabs",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_vartab_dpi_96.png@0.5",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_scrtab_dpi_96.png@0.4",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_vitab_dpi_96.png@0.4",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Check that the correct tab is selected",
      "Value": ""
    }, {
      "Command": "visualAssert",
      "Target": "desktop_checktab_dpi_96.png@0.55",
      "Value": ""
    }]
  },
  "XModules_Desktop/DemoXDesktopAutomation_OCR": {
    "CreationDate": "2020-05-15",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "comment",
      "Target": "For more information please see https://ui.vision/x/desktop-automation#ocr",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Running DESKTOP image search now",
      "Value": "#shownotification"
    }, {
      "Command": "XDesktopAutomation",
      "Target": "true",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Limit the search area for better performance",
      "Value": ""
    }, {
      "Command": "run",
      "Target": "Sub/Sub_XDesktopAutomation_Area",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "eng",
      "Value": "!OCRlanguage"
    }, {
      "Command": "store",
      "Target": "1",
      "Value": "!OCRengine"
    }, {
      "Command": "comment",
      "Target": "Instead of the word \"Logs\" we look only for (L)\"ogs\". There is no need for this. It is done to demo and test the substring search.",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "ocr=ogs@pos=1",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "ocr=Clear@pos=1",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "\"Clear\" button pressed by macro. The button was found at ${!OCRX}, ${!OCRY})",
      "Value": "blue"
    }, {
      "Command": "XClick",
      "Target": "ocr=Screenshots@pos=1",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Now we use the second OCR Engine. Both work fine here. So this switch is just for test and demo purposes.",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "2",
      "Value": "!OCREngine"
    }, {
      "Command": "XClick",
      "Target": "ocr=Visual@pos=1",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Check the right tab is selected",
      "Value": ""
    }, {
      "Command": "visualAssert",
      "Target": "desktop_checktab_dpi_96.png@0.55",
      "Value": ""
    }]
  },
  "XModules_Desktop/Sub/Sub_XDesktopAutomation_Area": {
    "CreationDate": "2021-04-29",
    "Commands": [{
      "Command": "comment",
      "Target": "SUBROUTINE used by DemoXDesktopAutomation and DemoXDesktopAutomation_OCR",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "It uses two anchor images to define the new search area",
      "Value": "",
      "Description": ""
    }, {
      "Command": "visualAssert",
      "Target": "desktop_area_topleft3_dpi_96.png@0.4",
      "Value": "",
      "Description": "Find image to calculate the top left x/y for visionLimitSearchArea "
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!imagex}-${!imagewidth}/1.5",
      "Value": "x1",
      "Description": "New limited area top left corner = bottom left corner of the anchor image. We use image x/y and image width/height to calculate this value. For X we use /1.5 instead of /2 in the formular below to make the area a bit wider."
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!imagey}+${!imageheight}/2",
      "Value": "y1",
      "Description": ""
    }, {
      "Command": "visualAssert",
      "Target": "desktop_area_bottomright_dpi_96.png@0.4",
      "Value": "",
      "Description": "Find image to calculate the bottom right x/y for visionLimitSearchArea."
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!imagex}+${!imagewidth}/2",
      "Value": "x2",
      "Description": "New Search Area bottom right corner = top right corner of the anchor image."
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!imagey}-${!imageheight}/2",
      "Value": "y2",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "x1=${x1}, y1=${y1}, x2=${x2}, y2=${y2}",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "visionLimitSearchArea",
      "Target": "area=${x1},${y1},${x2},${y2}",
      "Value": "",
      "Description": ""
    }]
  },
  "Core/Sub/Sub_DemoCsvRead_FillForm": {
    "CreationDate": "2020-08-08",
    "Commands": [{
      "Command": "comment",
      "Target": "Subroutine used by DemoCsvReadWithLoop and DemoCsvReadWithWhile",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Inside subroutine: Status = ${!csvReadStatus}, Line = ${!csvReadLineNumber}",
      "Value": "green"
    }, {
      "Command": "open",
      "Target": "https://docs.google.com/forms/d/e/1FAIpQLScGWVjexH2FNzJqPACzuzBLlTWMJHgLUHjxehtU-2cJxtu6VQ/viewform",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "xpath=//input[@type='text']",
      "Value": "${!COL1}_${!csvReadLineNumber}"
    }, {
      "Command": "type",
      "Target": "xpath=//div[3]/div/div/div[2]/div/div/div/div/input",
      "Value": "${!COL2}"
    }, {
      "Command": "type",
      "Target": "xpath=//div[4]/div/div/div[2]/div/div/div/div/input",
      "Value": "${!COL3}"
    }, {
      "Command": "clickAndWait",
      "Target": "xpath=//span/span",
      "Value": ""
    }]
  }
};

/***/ }),

/***/ 24776:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = [{
  "creationDate": "2019-05-21",
  "name": "Old_Style_Testsuites_(Deprecated)",
  "fold": true,
  "macros": [{
    "macro": "Demo/Core/DemoAutofill.json",
    "loops": 1
  }, {
    "macro": "Demo/Core/DemoFrames.json",
    "loops": 1
  }]
}];

/***/ }),

/***/ 70924:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _icon = __webpack_require__(86245);

var _icon2 = _interopRequireDefault(_icon);

var _select = __webpack_require__(64749);

var _select2 = _interopRequireDefault(_select);

var _checkbox = __webpack_require__(31059);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _tabs = __webpack_require__(1350);

var _tabs2 = _interopRequireDefault(_tabs);

var _slicedToArray2 = __webpack_require__(12424);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _table = __webpack_require__(2307);

var _table2 = _interopRequireDefault(_table);

var _stringify = __webpack_require__(63239);

var _stringify2 = _interopRequireDefault(_stringify);

var _button = __webpack_require__(65400);

var _button2 = _interopRequireDefault(_button);

var _input = __webpack_require__(51024);

var _input2 = _interopRequireDefault(_input);

var _modal = __webpack_require__(56697);

var _modal2 = _interopRequireDefault(_modal);

var _message2 = __webpack_require__(11187);

var _message3 = _interopRequireDefault(_message2);

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = __webpack_require__(85105);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(49135);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(93196);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(67294);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(33664);

var _redux = __webpack_require__(74127);

var _antd = __webpack_require__(56318);

var _jszip = __webpack_require__(55733);

var _jszip2 = _interopRequireDefault(_jszip);

var _web_extension = __webpack_require__(61171);

var _web_extension2 = _interopRequireDefault(_web_extension);

var _log = __webpack_require__(77242);

var _log2 = _interopRequireDefault(_log);

var _file_saver = __webpack_require__(18187);

var _file_saver2 = _interopRequireDefault(_file_saver);

var _variables = __webpack_require__(52476);

var _utils = __webpack_require__(63370);

var _storage = __webpack_require__(16058);

var _macro_log = __webpack_require__(41010);

var _actions = __webpack_require__(97876);

var actions = _interopRequireWildcard(_actions);

var _edit_in_place = __webpack_require__(37744);

var _edit_in_place2 = _interopRequireDefault(_edit_in_place);

var _search_box = __webpack_require__(70462);

var _search_box2 = _interopRequireDefault(_search_box);

var _recomputed = __webpack_require__(78328);

var _csv_list = __webpack_require__(96812);

var _vision_list = __webpack_require__(9543);

var _screenshot_list = __webpack_require__(77596);

var _recomputed2 = __webpack_require__(78328);

var _messages = __webpack_require__(29319);

var _messages2 = _interopRequireDefault(_messages);

var _config = __webpack_require__(62275);

var _config2 = _interopRequireDefault(_config);

var _resource_not_loaded = __webpack_require__(29102);

var _cv_utils = __webpack_require__(21063);

var _state = __webpack_require__(16112);

var _simple_actions = __webpack_require__(46469);

var _license = __webpack_require__(53678);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DashboardBottom = function (_React$Component) {
  (0, _inherits3.default)(DashboardBottom, _React$Component);

  function DashboardBottom() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, DashboardBottom);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = DashboardBottom.__proto__ || (0, _getPrototypeOf2.default)(DashboardBottom)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      activeTabForLogScreenshot: 'Logs',

      showCSVModal: false,
      csvText: '',
      csvFile: '',

      drag: {
        isDragging: false,
        // Check out the note on `screenX` in `onResizeDragEnd` event
        startY: 0,
        lastHeight: 220,
        currentMinHeight: 220
      },

      searchImageText: ''
    }, _this.getBottomMinHeight = function () {
      var _this$state$drag = _this.state.drag,
          isDragging = _this$state$drag.isDragging,
          lastHeight = _this$state$drag.lastHeight,
          currentMinHeight = _this$state$drag.currentMinHeight;

      return (isDragging ? currentMinHeight : lastHeight) + 'px';
    }, _this.onResizeDragStart = function (e) {
      // Note: Firefox requires us to set something to DataTransfer, otherwise drag and dragEnd won't be triggered
      // refer to https://stackoverflow.com/questions/33434275/firefox-on-drag-end-is-not-called-in-a-react-component
      e.dataTransfer.setData('text', '');

      var style = window.getComputedStyle(_this.$dom);
      var height = parseInt(style.height);

      _this.setState((0, _utils.setIn)(['drag'], {
        isDragging: true,
        startY: e.screenY,
        lastHeight: height,
        currentHeight: height
      }, _this.state));
    }, _this.onResizeDragEnd = function (e) {
      // Note: use `screenY` instead of `clientY`, because `clientY` of dragEnd events in Firefox
      // is always set to 0, while `screenY` is luckily still available. And since we only make use of
      // difference of X coordinate. `screenY` and `clientY` both work for us.
      //
      // reference:
      // https://bugzilla.mozilla.org/show_bug.cgi?id=505521
      // https://developer.mozilla.org/en-US/docs/Web/Events/dragend
      var diff = e.screenY - _this.state.drag.startY;
      var height = _this.state.drag.lastHeight - diff;

      _this.setState((0, _utils.setIn)(['drag'], {
        isDragging: false,
        startY: 0,
        lastHeight: height,
        currentMinHeight: height
      }));
    }, _this.onFileChange = function (e) {
      var csvStorage = (0, _storage.getStorageManager)().getCSVStorage();
      var files = [].slice.call(e.target.files);
      if (!files || !files.length) return;

      var read = function read(file) {
        return new _promise2.default(function (resolve, reject) {
          var reader = new FileReader();

          reader.onload = function (readerEvent) {
            var text = readerEvent.target.result;
            resolve({
              text: text,
              fileName: file.name
            });
          };

          reader.readAsText(file);
        });
      };

      _promise2.default.all(files.map(read)).then(function (list) {
        var names = list.map(function (item) {
          return item.fileName;
        });
        var ps = list.map(function (fileItem) {
          return csvStorage.write((0, _utils.sanitizeFileName)(fileItem.fileName), new Blob([fileItem.text]));
        });

        return _promise2.default.all(ps).then(function () {
          return _this.props.listCSV();
        }).then(function () {
          _message3.default.info(list.length + ' csv files imported');
          _this.props.addLog('info', list.length + ' csv files imported: ' + names.join(', '));
        });
      }).catch(function (e) {
        _this.props.addLog('error', e.message);
      });
    }, _this.removeCSV = function (csv) {
      var csvStorage = (0, _storage.getStorageManager)().getCSVStorage();

      csvStorage.remove(csv.name).then(function () {
        return _this.props.listCSV();
      }).then(function () {
        _message3.default.success('successfully deleted');
        _this.props.addLog('info', csv.name + ' deleted');
      });
    }, _this.viewCSV = function (csv) {
      window.open('./csv_editor.html?csv=' + csv.name, '', 'width=600,height=500,scrollbars=true');
    }, _this.downloadCSV = function (csv) {
      (0, _storage.getStorageManager)().getCSVStorage().read(csv.fullPath, 'Text').then(function (text) {
        var blob = new Blob([text]);
        _file_saver2.default.saveAs(blob, csv.name);
      });
    }, _this.onImageFileChange = function (e) {
      var files = [].slice.call(e.target.files);
      if (!files || !files.length) return;

      var read = function read(file) {
        return new _promise2.default(function (resolve, reject) {
          var reader = new FileReader();

          reader.onload = function (readerEvent) {
            try {
              var dataUrl = readerEvent.target.result;
              var obj = storeImage({ dataUrl: dataUrl, name: file.name });
              resolve(obj);
            } catch (e) {
              resolve({ err: e, fileName: file.name });
            }
          };

          reader.readAsDataURL(file);
        });
      };

      var storeImage = function storeImage(_ref2) {
        var dataUrl = _ref2.dataUrl,
            name = _ref2.name;

        return (0, _utils.uniqueName)(name, {
          check: function check(name) {
            return (0, _storage.getStorageManager)().getVisionStorage().exists(name).then(function (result) {
              return !result;
            });
          }
        }).then(function (fileName) {
          return (0, _storage.getStorageManager)().getVisionStorage().write((0, _utils.sanitizeFileName)(fileName), (0, _utils.dataURItoBlob)(dataUrl)).then(function () {
            return fileName;
          });
        }).catch(function (e) {
          _log2.default.error(e.stack);
        });
      };

      _promise2.default.all(files.map(read)).then(function (fileNames) {
        _message3.default.success(fileNames.length + ' image files imported into Vision tab');
        _this.props.addLog('info', fileNames.length + ' image files imported: ' + fileNames.join(', '));
        _this.props.listVisions();
      }).catch(function (e) {
        _log2.default.error(e.stack);
        _this.props.addLog('error', e.message);
      });
    }, _this.viewVision = function (filePath) {
      window.open('./vision_editor.html?vision=' + filePath, '', 'width=600,height=500,scrollbars=true');
    }, _this.renameVision = function (oldName, newName) {
      return (0, _storage.getStorageManager)().getVisionStorage().rename(oldName, (0, _utils.ensureExtName)('.png', newName)).then(function () {
        _message3.default.success('Successfully renamed');
        _this.props.listVisions();
      }).catch(function (e) {
        _message3.default.error(e.message);
        throw e;
      });
    }, _this.isVisionNameValid = function (name) {
      return _promise2.default.resolve((0, _utils.withFileExtension)(name, function (baseName) {
        try {
          (0, _utils.validateStandardName)(baseName, true);
        } catch (e) {
          _message3.default.error(e.message);
          throw e;
        }
        return baseName;
      })).then(function () {
        return (0, _storage.getStorageManager)().getVisionStorage().exists(name).then(function (result) {
          if (result) {
            _message3.default.error('\'' + name + '\' already exists');
          }
          return !result;
        });
      }, function () {
        return false;
      });
    }, _this.duplicateVision = function (name) {
      _this.props.duplicateVisionImage(name);
    }, _this.deleteVision = function (name) {
      return _modal2.default.confirm({
        title: 'Sure to delete?',
        okText: 'Delete',
        onOk: function onOk() {
          return (0, _storage.getStorageManager)().getVisionStorage().remove(name).then(function () {
            _message3.default.success('Successfully deleted');
            _this.props.listVisions();
          }).catch(function (e) {
            _log2.default.error(e);
          });
        },
        onCancel: function onCancel() {
          return _promise2.default.resolve(true);
        }
      });
    }, _this.addVisionNameToTargetBox = function (filePath) {
      var _this$props = _this.props,
          config = _this$props.config,
          selectedCmd = _this$props.selectedCommand;

      var selectedCmdIsVisualSearch = function () {
        if (!selectedCmd) return false;
        if ((0, _cv_utils.isCVTypeForDesktop)(config.cvScope) && selectedCmd.cmd === 'visionLimitSearchArea') return true;

        return ['visionFind', 'visualSearch', 'visualAssert', 'visualVerify', 'XClick', 'XMove', 'XClickRelative', 'XMoveRelative', 'OCRExtract', 'OCRExtractRelative', 'visionLimitSearchAreaRelative'].indexOf(selectedCmd.cmd) !== -1;
      }();

      if (!selectedCmdIsVisualSearch) {
        return _message3.default.error('Image names can only be added to the target box if a vision related command is selected');
      }

      _this.props.updateSelectedCommand({ target: filePath });
    }, _this.exportAllVisions = function () {
      var zip = new _jszip2.default();
      var visionStorage = (0, _storage.getStorageManager)().getVisionStorage();

      visionStorage.list().then(function (visions) {
        if (visions.length === 0) {
          return _message3.default.error('No vision to export');
        }

        var ps = visions.map(function (ss) {
          return visionStorage.read(ss.fullPath, 'ArrayBuffer').then(function (buffer) {
            zip.file(ss.name, buffer, { binary: true });
          });
        });

        return _promise2.default.all(ps).then(function () {
          zip.generateAsync({ type: 'blob' }).then(function (blob) {
            _file_saver2.default.saveAs(blob, 'vision-images-export.zip');
          });
        });
      });
    }, _this.downloadScreenshot = function (name, fullPath) {
      return (0, _storage.getStorageManager)().getScreenshotStorage().read(fullPath, 'ArrayBuffer').then(function (buffer) {
        _file_saver2.default.saveAs(new Blob([new Uint8Array(buffer)]), name);
      });
    }, _this.toggleBottom = function () {
      _this.props.updateConfig({
        showBottomArea: !_this.props.config.showBottomArea
      });
    }, _this.logLinkPatterns = [[/Error #101/i, 'https://ui.vision/x/idehelp?help=error101'], [/Error #120/i, 'https://ui.vision/x/idehelp?help=error120'], [/Error #121/i, 'https://ui.vision/x/idehelp?help=error121'], [/Error #170/i, 'https://ui.vision/x/idehelp?help=error179'], [/Error #220/i, 'https://ui.vision/x/idehelp?help=error220']], _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  (0, _createClass3.default)(DashboardBottom, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      (0, _storage.getStorageManager)().on(_storage.StorageManagerEvent.StrategyTypeChanged, function (type) {
        _this2.forceUpdate();
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _this3 = this;

      if (nextProps.logs.length !== this.props.logs.length) {
        var $logContent = document.querySelector('.log-content');

        if (!$logContent) {
          return;
        }

        // Note: set scroll top to a number large enough so that it will scroll to bottom
        // setTimeout 100ms to ensure content has been rendered before scroll
        setTimeout(function () {
          var $last = $logContent.children[$logContent.children.length - 1];

          if ($last) {
            $last.scrollIntoView();
          }
        }, 100);
      }

      if (nextProps.visions.length > this.props.visions.length) {
        var diff = nextProps.visions.filter(function (item) {
          return !_this3.props.visions.find(function (v) {
            return v.name === item.name;
          });
        });

        if (diff.length > 1) {
          diff.sort(function (a, b) {
            return a.createTime > b.createTime;
          });
        }

        var toFocus = diff[0];

        setTimeout(function () {
          var $dom = document.getElementById(toFocus.name);
          if (!$dom) return;
          $dom.scrollIntoView({ block: 'center', behavior: 'smooth' });
        }, 100);
      }
    }
  }, {
    key: 'logStyle',
    value: function logStyle(log) {
      if (log.options && log.options.color) {
        return { color: log.options.color };
      }

      if (log.options && log.options.ignored) {
        return { color: 'orange' };
      }
    }
  }, {
    key: 'prefixHardDisk',
    value: function prefixHardDisk(str) {
      var isXFileMode = (0, _storage.getStorageManager)().isXFileMode();
      if (!isXFileMode) return str;

      return _react2.default.createElement(
        'div',
        {
          style: {
            display: 'inline-block'
          }
        },
        _react2.default.createElement('img', {
          src: './img/hard-drive.svg',
          style: {
            position: 'relative',
            top: '3px',
            marginRight: '5px',
            height: '15px'
          }
        }),
        _react2.default.createElement(
          'span',
          null,
          str
        )
      );
    }
  }, {
    key: 'shouldUseFileSaverForDownloadingScreenshot',
    value: function shouldUseFileSaverForDownloadingScreenshot() {
      if (_web_extension2.default.isFirefox()) {
        return true;
      }

      return (0, _storage.getStorageManager)().isXFileMode();
    }
  }, {
    key: 'shouldRenderLogStack',
    value: function shouldRenderLogStack(log) {
      if (log.stack.length <= 1) {
        return false;
      }

      switch (log.type) {
        case 'error':
        case 'warning':
          return true;

        case 'status':
          return (/^Running/.test(log.text)
          );

        default:
          return false;
      }
    }
  }, {
    key: 'renderCSVModal',
    value: function renderCSVModal() {
      var _this4 = this;

      return _react2.default.createElement(
        _modal2.default,
        {
          title: 'Preview - ' + this.state.csvFile,
          visible: this.state.showCSVModal,
          onCancel: function onCancel() {
            return _this4.setState({ showCSVModal: false, csvText: '', csvFile: '' });
          },
          className: 'csv-preview-modal',
          footer: null
        },
        _react2.default.createElement(_input2.default.TextArea, {
          style: { width: '100%' },
          value: this.state.csvText,
          readOnly: true,
          rows: 10
        })
      );
    }
  }, {
    key: 'renderCSVTable',
    value: function renderCSVTable() {
      var _this5 = this;

      if (!this.props.shouldLoadResources) {
        return _react2.default.createElement(_resource_not_loaded.ResourceNotLoaded, {
          name: 'CSV list',
          from: this.props.from,
          showList: function showList() {
            _this5.props.setFrom(_state.RunBy.Manual);
          }
        });
      }

      if (this.state.activeTabForLogScreenshot !== 'CSV') {
        return null;
      }

      if (this.props.isPlaying && this.props.csvs.length > _config2.default.performanceLimit.fileCount) {
        return _react2.default.createElement(
          'div',
          { className: 'hidden-during-replay' },
          _messages2.default.contentHidden
        );
      }

      return _react2.default.createElement(_csv_list.CsvList, {
        list: this.props.csvs,
        viewCSV: this.viewCSV,
        removeCSV: this.removeCSV,
        downloadCSV: this.downloadCSV
      });
    }
  }, {
    key: 'renderVisionSection',
    value: function renderVisionSection() {
      var _this6 = this;

      if (!this.props.shouldLoadResources) {
        return _react2.default.createElement(
          'div',
          { className: 'vision-content' },
          _react2.default.createElement(_resource_not_loaded.ResourceNotLoaded, {
            name: 'Image list',
            from: this.props.from,
            showList: function showList() {
              _this6.props.setFrom(_state.RunBy.Manual);
            }
          })
        );
      }

      return _react2.default.createElement(
        'div',
        { className: 'vision-content' },
        _react2.default.createElement(
          'div',
          { className: 'vision-top-actions' },
          _react2.default.createElement(
            'div',
            { className: 'main-actions' },
            _react2.default.createElement(
              'div',
              { className: 'main-actions-left' },
              _react2.default.createElement(
                'span',
                {
                  className: 'load-image-button ant-btn ant-btn-primary'
                },
                _react2.default.createElement(
                  'label',
                  { htmlFor: 'select_image_files' },
                  'Load Image'
                ),
                _react2.default.createElement('input', {
                  multiple: true,
                  type: 'file',
                  accept: 'image/*',
                  id: 'select_image_files',
                  onChange: this.onImageFileChange,
                  ref: function ref(_ref3) {
                    _this6.imageFileInput = _ref3;
                  },
                  style: { display: 'none' }
                })
              ),
              _react2.default.createElement(
                _button2.default,
                {
                  onClick: this.exportAllVisions
                },
                'Export All'
              )
            ),
            _react2.default.createElement(_search_box2.default, {
              style: { flex: 0.8 },
              inputProps: {
                placeholder: 'search image',
                value: this.state.searchImageText,
                onChange: function onChange(e) {
                  return _this6.setState({ searchImageText: e.target.value });
                }
              }
            })
          ),
          _react2.default.createElement(
            'a',
            { className: 'more-info', target: '_blank', href: 'https://ui.vision/x/idehelp?help=visual' },
            'More Info'
          )
        ),
        this.renderVisionTable()
      );
    }
  }, {
    key: 'renderVisionTable',
    value: function renderVisionTable() {
      if (this.state.activeTabForLogScreenshot !== 'Vision') {
        return null;
      }

      if (this.props.isPlaying && this.props.visions.length > _config2.default.performanceLimit.fileCount) {
        return _react2.default.createElement(
          'div',
          { className: 'hidden-during-replay' },
          _messages2.default.contentHidden
        );
      }

      if (!this.$dom) {
        return null;
      }

      return _react2.default.createElement(_vision_list.VisionList, {
        visions: this.props.visions,
        intersectRoot: this.$dom,
        query: this.state.searchImageText,
        isNameValid: this.isVisionNameValid,
        renameVision: this.renameVision,
        viewVision: this.viewVision,
        duplicateVision: this.duplicateVision,
        deleteVision: this.deleteVision,
        copyNameToTarget: this.addVisionNameToTargetBox
      });
    }
  }, {
    key: 'renderScreenshots',
    value: function renderScreenshots() {
      if (this.state.activeTabForLogScreenshot !== 'Screenshots') {
        return null;
      }

      if (!this.$dom) {
        return null;
      }

      return _react2.default.createElement(_screenshot_list.ScreenshotList, {
        screenshots: this.props.screenshots,
        intersectRoot: this.$dom,
        downloadScreenshot: this.downloadScreenshot
      });
    }
  }, {
    key: 'renderVariableTable',
    value: function renderVariableTable() {
      if (this.state.activeTabForLogScreenshot !== 'Variables') {
        return null;
      }

      var columns = [{ title: 'Name', dataIndex: 'key', key: 'key', width: '40%' }, { title: 'Value', dataIndex: 'value', key: 'value', render: function render(val) {
          return (0, _stringify2.default)(val) || 'undefined';
        } }];
      var _props$config = this.props.config,
          showCommonInternalVariables = _props$config.showCommonInternalVariables,
          showAdvancedInternalVariables = _props$config.showAdvancedInternalVariables;

      var filter = (0, _variables.createVarsFilter)({
        withCommonInternal: showCommonInternalVariables,
        withAdvancedInternal: showAdvancedInternalVariables
      });
      var variables = this.props.variables.filter(function (variable) {
        return filter(variable.key);
      });

      var tableConfig = {
        columns: columns,
        dataSource: variables,
        pagination: false,
        bordered: true,
        size: 'middle',
        rowKey: 'key',
        onRowClick: function onRowClick(record, index, e) {
          // Do nothing
        },
        rowClassName: function rowClassName(record, index) {
          var vars = (0, _variables.getVarsInstance)();
          if (!vars) return '';
          return vars.isReadOnly(record.key) ? 'read-only' : '';
        }
      };

      return _react2.default.createElement(_table2.default, tableConfig);
    }
  }, {
    key: 'renderLogStack',
    value: function renderLogStack(log) {
      var _this7 = this;

      // Don't care about the top element in stack
      var stack = log.stack.slice(0, -1).reverse();

      if (stack.length === 0) {
        return null;
      }

      return _react2.default.createElement(
        'div',
        { style: { marginLeft: '80px' } },
        stack.map(function (item, i) {
          return _react2.default.createElement(
            'div',
            { key: i },
            'At ',
            _react2.default.createElement(
              'a',
              {
                href: '#',
                onClick: function onClick(e) {
                  e.preventDefault();

                  if (typeof item.commandIndex === 'number' && item.macroId) {
                    _this7.props.gotoLineInMacro(item.macroId, item.commandIndex);
                  }
                }
              },
              'Line ',
              item.commandIndex + 1,
              ' in ',
              item.macroName
            )
          );
        })
      );
    }
  }, {
    key: 'appendLinkIfPatternMatched',
    value: function appendLinkIfPatternMatched(text) {
      var linksToAdd = [];

      this.logLinkPatterns.forEach(function (item) {
        var _item = (0, _slicedToArray3.default)(item, 3),
            patternReg = _item[0],
            link = _item[1],
            _item$ = _item[2],
            anchorText = _item$ === undefined ? '(more info)' : _item$;

        if (patternReg.test(text)) {
          linksToAdd.push(_react2.default.createElement(
            'a',
            { href: link, 'class': 'info', target: '_blank', style: { marginLeft: '8px' } },
            anchorText
          ));
        }
      });

      if (linksToAdd.length === 0) {
        return text;
      }

      return _react2.default.createElement(
        'span',
        null,
        _react2.default.createElement(
          'span',
          null,
          text
        ),
        linksToAdd
      );
    }
  }, {
    key: 'renderLogText',
    value: function renderLogText(log) {
      var _this8 = this;

      if (typeof log.text === 'function') {
        return log.text({ renderText: this.renderLogText.bind(this) });
      }

      if (['error', 'warning'].indexOf(log.type) === -1) {
        return log.text;
      }

      var content = function () {
        if (/XClick\/XMove\/XType \d+ commands limit reached/.test(log.text) || /OCR conversion limit reached/.test(log.text) || /PROXY \d+ commands? limit reached/.test(log.text)) {
          var licenceType = function () {
            if ((0, _license.getLicenseService)().hasNoLicense()) {
              return 'PRO';
            }

            if ((0, _license.getLicenseService)().isPersonalLicense()) {
              return 'PRO2 or Enterprise';
            }

            return null;
          }();

          if (!licenceType) return log.text;

          return _react2.default.createElement(
            'span',
            null,
            _react2.default.createElement(
              'span',
              null,
              log.text
            ),
            _react2.default.createElement(
              'a',
              {
                href: '#',
                style: { marginLeft: '10px' },
                onClick: function onClick(e) {
                  e.preventDefault();
                  _this8.props.updateUI({ showSettings: true, settingsTab: 'register' });
                }
              },
              'Get a ',
              licenceType,
              ' license key to remove this limit'
            )
          );
        }

        if (/(XModule|xFile) is not installed yet/.test(log.text)) {
          return _react2.default.createElement(
            'span',
            null,
            _react2.default.createElement(
              'span',
              null,
              log.text
            ),
            _react2.default.createElement(
              'a',
              {
                href: '#',
                style: { marginLeft: '10px' },
                onClick: function onClick(e) {
                  e.preventDefault();
                  _this8.props.updateUI({ showSettings: true, settingsTab: 'xmodules' });
                }
              },
              'Install now'
            )
          );
        }

        if (/OCR feature disabled/.test(log.text)) {
          return _react2.default.createElement(
            'span',
            null,
            _react2.default.createElement(
              'span',
              null,
              'OCR feature disabled. Please enable it in the '
            ),
            _react2.default.createElement(
              'a',
              {
                href: '#',
                onClick: function onClick(e) {
                  e.preventDefault();
                  _this8.props.updateUI({ showSettings: true, settingsTab: 'ocr' });
                }
              },
              'OCR Settings'
            )
          );
        }

        return _this8.appendLinkIfPatternMatched(log.text);
      }();

      var stack = log.stack || [];
      var source = stack[stack.length - 1];

      if (!source) {
        return content;
      }

      return _react2.default.createElement(
        'span',
        null,
        _react2.default.createElement(
          'a',
          {
            href: '#',
            onClick: function onClick(e) {
              e.preventDefault();

              if (typeof source.commandIndex === 'number' && source.macroId) {
                _this8.props.gotoLineInMacro(source.macroId, source.commandIndex);
              }
            }
          },
          _react2.default.createElement(
            'span',
            null,
            'Line ',
            source.commandIndex + 1
          ),
          !source.isSubroutine ? null : _react2.default.createElement(
            'span',
            null,
            ' (Sub: ',
            source.macroName,
            ')'
          )
        ),
        _react2.default.createElement(
          'span',
          null,
          ': '
        ),
        content
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _this9 = this;

      var activeTabForLogScreenshot = this.state.activeTabForLogScreenshot;

      var filters = {
        'All': function All() {
          return true;
        },
        'Echo': function Echo(item) {
          return item.type === 'echo' || item.type === 'error' && (!item.options || !item.options.ignored);
        },
        'Echo_And_Status': function Echo_And_Status(item) {
          return item.type === 'echo' || item.type === 'error' && (!item.options || !item.options.ignored) || item.type === 'status';
        },
        // 'Info':   (item) => item.type === 'info' || item.type === 'echo' || item.type === 'reflect' || item.type === 'status',
        'Error': function Error(item) {
          return item.type === 'error' || item.type === 'report';
        },
        'None': function None() {
          return false;
        }
      };
      var logFilter = this.props.config.logFilter || 'All';
      var logs = this.props.logs.filter(filters[logFilter] || function () {
        return true;
      });

      return _react2.default.createElement(
        'div',
        {
          className: (0, _utils.cn)('logs-screenshots', { fold: !this.props.config.showBottomArea }),
          ref: function ref(el) {
            _this9.$dom = el;
          },
          style: { height: this.getBottomMinHeight() }
        },
        this.renderCSVModal(),
        _react2.default.createElement('div', {
          className: (0, _utils.cn)('resize-handler', { focused: this.state.drag.isDragging }),
          draggable: 'true',
          onDragStart: this.onResizeDragStart,
          onDragEnd: this.onResizeDragEnd,
          onMouseDown: function onMouseDown() {
            return _this9.setState((0, _utils.setIn)(['drag', 'isDragging'], true, _this9.state));
          }
        }),
        _react2.default.createElement(
          _tabs2.default,
          {
            type: 'card',
            onChange: function onChange(key) {
              _this9.setState({ activeTabForLogScreenshot: key });

              if (key === 'Screenshots') {
                _this9.props.listScreenshots();
              }
            }
          },
          _react2.default.createElement(
            _tabs2.default.TabPane,
            { tab: 'Logs', key: 'Logs' },
            _react2.default.createElement(
              'ul',
              { className: 'log-content' },
              logs.map(function (log, i) {
                return _react2.default.createElement(
                  'li',
                  { className: log.type, key: log.id, style: _this9.logStyle(log) },
                  _react2.default.createElement(
                    'span',
                    { className: 'log-type' },
                    (0, _macro_log.renderLogType)(log)
                  ),
                  _react2.default.createElement(
                    'pre',
                    { className: 'log-detail' },
                    _this9.renderLogText(log)
                  ),
                  _this9.shouldRenderLogStack(log) ? _this9.renderLogStack(log) : null
                );
              })
            )
          ),
          _react2.default.createElement(
            _tabs2.default.TabPane,
            { tab: 'Variables', key: 'Variables' },
            _react2.default.createElement(
              'div',
              { className: 'variable-content' },
              _react2.default.createElement(
                'div',
                { className: 'variable-options' },
                _react2.default.createElement(
                  _checkbox2.default,
                  {
                    onChange: function onChange(e) {
                      return _this9.props.updateConfig({ showCommonInternalVariables: e.target.checked });
                    },
                    checked: this.props.config.showCommonInternalVariables
                  },
                  'Show most common ',
                  _react2.default.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?help=internalvars', target: '_blank' },
                    'internal variables'
                  )
                ),
                _react2.default.createElement(
                  _checkbox2.default,
                  {
                    onChange: function onChange(e) {
                      return _this9.props.updateConfig({ showAdvancedInternalVariables: e.target.checked });
                    },
                    checked: this.props.config.showAdvancedInternalVariables
                  },
                  'Show advanced ',
                  _react2.default.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?help=internalvars', target: '_blank' },
                    'internal variables'
                  )
                )
              ),
              this.renderVariableTable()
            )
          ),
          _react2.default.createElement(
            _tabs2.default.TabPane,
            { tab: this.prefixHardDisk('Screenshots'), key: 'Screenshots' },
            this.renderScreenshots()
          ),
          _react2.default.createElement(
            _tabs2.default.TabPane,
            { tab: this.prefixHardDisk('CSV'), key: 'CSV' },
            _react2.default.createElement(
              'div',
              { className: 'csv-content' },
              this.renderCSVTable()
            )
          ),
          _react2.default.createElement(
            _tabs2.default.TabPane,
            { tab: this.prefixHardDisk('👁Visual'), key: 'Vision' },
            this.renderVisionSection()
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'ls-toolbox' },
          activeTabForLogScreenshot === 'Logs' ? [_react2.default.createElement(
            _select2.default,
            {
              value: this.props.config.logFilter,
              onChange: function onChange(value) {
                _this9.props.updateConfig({ logFilter: value });
              },
              style: { width: '60px' },
              dropdownMatchSelectWidth: false,
              size: 'small'
            },
            _react2.default.createElement(
              _select2.default.Option,
              { value: 'All' },
              'All'
            ),
            _react2.default.createElement(
              _select2.default.Option,
              { value: 'Echo' },
              'Echo'
            ),
            _react2.default.createElement(
              _select2.default.Option,
              { value: 'Echo_And_Status' },
              'Echo & Status'
            ),
            _react2.default.createElement(
              _select2.default.Option,
              { value: 'Error' },
              'Error & Reports'
            ),
            _react2.default.createElement(
              _select2.default.Option,
              { value: 'None' },
              'No log'
            )
          ), _react2.default.createElement(
            _button2.default,
            {
              size: 'small',
              onClick: this.props.clearLogs
            },
            'Clear'
          )] : null,
          activeTabForLogScreenshot === 'Screenshots' ? _react2.default.createElement(
            _button2.default,
            {
              size: 'small',
              onClick: this.props.clearScreenshots
            },
            'Clear'
          ) : null,
          activeTabForLogScreenshot === 'CSV' && this.props.shouldLoadResources ? _react2.default.createElement(
            _button2.default,
            {
              size: 'small',
              onClick: function onClick() {
                if ((0, _storage.getStorageManager)().isXFileMode()) {
                  _modal2.default.info({
                    title: 'In hard-drive mode, there is no need to import CSV files.',
                    content: 'To view the latest /datasource folder content, press the "Refresh" icon next to the word "Storage mode" on the left.'
                  });
                } else {
                  _this9.fileInput.click();
                }
              }
            },
            'Import CSV',
            _react2.default.createElement('input', {
              multiple: true,
              type: 'file',
              accept: '.csv',
              onChange: this.onFileChange,
              style: { display: 'none' },
              ref: function ref(_ref4) {
                _this9.fileInput = _ref4;
              }
            })
          ) : null,
          _react2.default.createElement(
            _button2.default,
            {
              size: 'small',
              onClick: this.toggleBottom
            },
            _react2.default.createElement(_icon2.default, { type: this.props.config.showBottomArea ? 'down' : 'up' })
          )
        )
      );
    }
  }]);
  return DashboardBottom;
}(_react2.default.Component);

exports["default"] = (0, _reactRedux.connect)(function (state) {
  return {
    hasSelectedCommand: state.editor.editing && state.editor.editing.meta && state.editor.editing.meta.selectedIndex !== -1,
    selectedCommand: (0, _recomputed.editorSelectedCommand)(state),
    shouldLoadResources: (0, _recomputed2.getShouldLoadResources)(state),
    isPlaying: (0, _recomputed2.isPlaying)(state),
    status: state.status,
    from: state.from,
    logs: state.logs,
    screenshots: state.screenshots,
    variables: state.variables,
    csvs: state.csvs,
    visions: state.visions,
    config: state.config
  };
}, function (dispatch) {
  return (0, _redux.bindActionCreators)((0, _extends3.default)({}, actions, _simple_actions.Actions), dispatch);
})(DashboardBottom);

/***/ }),

/***/ 28769:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _tabs = __webpack_require__(1350);

var _tabs2 = _interopRequireDefault(_tabs);

var _input = __webpack_require__(51024);

var _input2 = _interopRequireDefault(_input);

var _form = __webpack_require__(97538);

var _form2 = _interopRequireDefault(_form);

var _select = __webpack_require__(64749);

var _select2 = _interopRequireDefault(_select);

var _table = __webpack_require__(2307);

var _table2 = _interopRequireDefault(_table);

var _icon = __webpack_require__(86245);

var _icon2 = _interopRequireDefault(_icon);

var _toConsumableArray2 = __webpack_require__(85315);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _button = __webpack_require__(65400);

var _button2 = _interopRequireDefault(_button);

var _menu = __webpack_require__(12386);

var _menu2 = _interopRequireDefault(_menu);

var _message2 = __webpack_require__(11187);

var _message3 = _interopRequireDefault(_message2);

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

var _defineProperty2 = __webpack_require__(88106);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = __webpack_require__(85105);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(49135);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(93196);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(67294);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(33664);

var _redux = __webpack_require__(74127);

var _antd = __webpack_require__(56318);

var _kdReactVirtualList = __webpack_require__(22099);

var _kdReactVirtualList2 = _interopRequireDefault(_kdReactVirtualList);

var _reactCodemirror = __webpack_require__(29656);

var _keycode = __webpack_require__(27537);

var _keycode2 = _interopRequireDefault(_keycode);

__webpack_require__(4631);

__webpack_require__(96876);

__webpack_require__(4328);

__webpack_require__(82801);

__webpack_require__(47462);

var _select_input = __webpack_require__(67504);

var _command_item = __webpack_require__(29754);

var _storage = __webpack_require__(16058);

var _inspector = __webpack_require__(14537);

var _inspector2 = _interopRequireDefault(_inspector);

var _player = __webpack_require__(43625);

var _ipc_cs = __webpack_require__(41471);

var _ipc_cs2 = _interopRequireDefault(_ipc_cs);

var _actions = __webpack_require__(97876);

var actions = _interopRequireWildcard(_actions);

var _simple_actions = __webpack_require__(46469);

var _constant = __webpack_require__(43232);

var C = _interopRequireWildcard(_constant);

var _log = __webpack_require__(77242);

var _log2 = _interopRequireDefault(_log);

var _recomputed = __webpack_require__(78328);

var _ts_utils = __webpack_require__(55452);

var _command = __webpack_require__(69396);

var _state = __webpack_require__(16112);

var _config = __webpack_require__(62275);

var _config2 = _interopRequireDefault(_config);

var _utils = __webpack_require__(63370);

var _license = __webpack_require__(53678);

var _types = __webpack_require__(10714);

var _cv_utils = __webpack_require__(21063);

var _desktop_vision = __webpack_require__(623);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var newCommand = {
  cmd: '',
  target: '',
  value: ''
};

var defaultDataSource = [newCommand];

var ITEM_HEIGHT = _config2.default.ui.commandItemHeight;

var DashboardEditor = function (_React$Component) {
  (0, _inherits3.default)(DashboardEditor, _React$Component);

  function DashboardEditor() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, DashboardEditor);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = DashboardEditor.__proto__ || (0, _getPrototypeOf2.default)(DashboardEditor)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      cursor: null,

      contextMenu: {
        x: null,
        y: null,
        isShown: false
      },

      visionFindPreview: {
        visible: false,
        url: null,
        timer: null,
        left: -9999,
        top: -9999
      },

      targetEditor: {
        visible: false,
        text: ''
      }
    }, _this.resetSourceCodeCursor = function (resetCursor) {
      return (0, _extends3.default)({}, resetCursor ? { cursor: { line: 0, ch: 0 } } : {});
    }, _this.onDetailChange = function (key, value) {
      _this.props.updateSelectedCommand((0, _defineProperty3.default)({}, key, value));
    }, _this.onChangeCommandsView = function (type) {
      switch (type) {
        case 'table_view':
        case 'source_view':
          {
            var forceType = _this.props.sourceErrMsg ? 'source_view' : type;

            _this.props.setEditorActiveTab(forceType);

            if (type === 'source_view' && _this.codeMirror && _this.state.cursor) {
              // Note: must delay a while so that focus will take effect
              setTimeout(function () {
                _this.codeMirror.setCursor(_this.state.cursor, true, true);
              }, 200);
            }

            break;
          }
      }
    }, _this.onSourceBlur = function () {
      var _this$props = _this.props,
          sourceTextModified = _this$props.sourceTextModified,
          sourceText = _this$props.sourceText;

      _this.props.saveSourceCodeToEditing(sourceTextModified);
    }, _this.onChangeEditSource = function (editor, data, text) {
      _this.props.setSourceCurrent(text);
    }, _this.onClickFind = function () {
      var lastOperation = _this.state.lastOperation;
      var selectedCommand = _this.props.selectedCommand;


      var p = new _promise2.default(function (resolve, reject) {
        switch (selectedCommand.cmd) {
          case 'visualGetPixelColor':
          case 'visionFind':
          case 'visualSearch':
          case 'visualAssert':
          case 'visualVerify':
          case 'visionLimitSearchArea':
          case 'visionLimitSearchAreaRelative':
          case 'XClick':
          case 'XClickRelative':
          case 'XMove':
          case 'XMoveRelative':
          case 'OCRExtract':
          case 'OCRExtractRelative':
          case 'OCRSearch':
            {
              var selectedIndex = _this.props.editing.meta.selectedIndex;
              var run = function run() {
                // Note: run visionFind/visualSearch as single line command, but without timeout waiting
                _this.playLine(selectedIndex, {
                  overrideScope: { '!TIMEOUT_WAIT': 0 },
                  commandExtra: {
                    throwError: true,
                    // visualXXX uses this flag in desktop mode to open Desktop Screenshot Editor to preview result
                    debugVisual: true
                  }
                });
                return resolve(true);
              };

              return _this.waitBeforeScreenCapture().then(run);
            }

          default:
            {
              return _ipc_cs2.default.ask('PANEL_HIGHLIGHT_DOM', {
                lastOperation: lastOperation,
                locator: selectedCommand.target
              }).then(resolve, reject);
            }
        }
      });

      p.catch(function (e) {
        _message3.default.error(e.message, 1.5);
      });
    }, _this.onToggleSelect = function () {
      var _this$props2 = _this.props,
          selectedCommand = _this$props2.selectedCommand,
          config = _this$props2.config;

      var p = new _promise2.default(function (resolve, reject) {
        var defaultAction = function defaultAction() {
          if (_this.props.status === C.APP_STATUS.INSPECTOR) {
            _this.props.stopInspecting();
          } else {
            _this.props.startInspecting();
          }

          resolve(true);
        };
        var takeImage = function takeImage() {
          var isDesktop = (0, _cv_utils.isCVTypeForDesktop)(config.cvScope);

          return _this.waitBeforeScreenCapture().then(function () {
            if (isDesktop) {
              return (0, _desktop_vision.selectAreaOnDesktop)({
                width: screen.availWidth,
                height: screen.availHeight
              });
            } else {
              return _ipc_cs2.default.ask('PANEL_SELECT_AREA_ON_CURRENT_PAGE');
            }
          }).then(function (res) {
            return _this.props.renameVisionImage(res.fileName);
          }).then(resolve, reject);
        };

        switch (selectedCommand.cmd) {
          case 'visionFind':
          case 'visualSearch':
          case 'visualAssert':
          case 'visualVerify':
          case 'OCRExtract':
          case 'OCRExtractRelative':
          case 'visionLimitSearchAreaRelative':
          case 'XClickRelative':
          case 'XMoveRelative':
          case 'XMove':
            {
              return takeImage();
            }

          case 'OCRSearch':
            throw new Error('No select possible in OCR mode, just enter the text');

          case 'XClick':
            {
              if (/^ocr=/i.test(selectedCommand.target)) {
                throw new Error('No select possible in OCR mode, just enter the text');
              } else {
                return takeImage();
              }
            }

          case 'visionLimitSearchArea':
            {
              if ((0, _cv_utils.isCVTypeForDesktop)(config.cvScope)) {
                return takeImage();
              } else {
                return defaultAction();
              }
            }

          default:
            {
              return defaultAction();
            }
        }
      });

      p.catch(function (e) {
        console.error(e);
        _message3.default.error(e.message);
      });
    }, _this.onKeyDown = function (e) {
      if (!_this.props.canUseKeyboardShortcuts) {
        return;
      }

      if (['INPUT', 'TEXTAREA'].indexOf(e.target.tagName) !== -1) {
        return;
      }

      var code = (0, _keycode2.default)(e.keyCode);
      var isValidCtrlKeyPressed = (0, _ts_utils.isMac)() ? e.metaKey : e.ctrlKey;
      var noModifierKeyPressed = !e.metaKey && !e.ctrlKey && !e.shiftKey && !e.altKey;

      if (isValidCtrlKeyPressed) {
        switch (code) {
          case 'c':
            return _this.props.copyCurrentCommand();

          case 'x':
            return _this.props.cutCurrentCommand();

          case 'v':
            return _this.props.pasteAtCurrentCommand();
        }
      }

      if (noModifierKeyPressed) {
        switch (code) {
          case 'delete':
          case 'backspace':
            {
              var selectedIndex = _this.props.editing.meta.selectedIndex;


              if (selectedIndex === -1) {
                return;
              }

              return _this.props.removeCommand(selectedIndex);
            }

          case 'up':
            if (_this.props.selectedCommandIndex !== null) {
              var commandIndexToSelect = Math.max(0, _this.props.selectedCommandIndex - 1);
              _this.selectCommandAndScroll(commandIndexToSelect);
            }
            break;

          case 'down':
            {
              if (_this.props.selectedCommandIndex !== null) {
                var _commandIndexToSelect = Math.min(_this.props.commandCount - 1, _this.props.selectedCommandIndex + 1);
                _this.selectCommandAndScroll(_commandIndexToSelect);
              }
              break;
            }
        }
      }
    }, _this.onDoubleClick = function () {
      var lastScreenX = void 0;
      var lastScreenY = void 0;
      var lastTime = void 0;

      return function (e) {
        var go = function go() {
          var $row = _inspector2.default.parentWithClass('real-command', e.target);
          if (!$row) return;

          var index = parseInt($row.getAttribute('data-index'));
          if (isNaN(index)) return;

          _this.playLine(index);
        };

        var now = new Date() * 1;

        if (lastScreenX === e.screenX && lastScreenY === e.screenY && now - lastTime < 300) {
          if (e.target.tagName !== 'BUTTON') {
            go();
          }
        }

        lastScreenX = e.screenX;
        lastScreenY = e.screenY;
        lastTime = now;
      };
    }(), _this.onMoveCommand = function (startIndex, endIndex) {
      _this.props.moveCommands(startIndex, endIndex);
    }, _this.onStartDraggingCommand = function () {
      _this.props.setIsDraggingCommand(true);
    }, _this.onEndDraggingCommand = function () {
      _this.props.setIsDraggingCommand(false);
    }, _this.scheduleHideVisionFindPreview = function () {
      (0, _log2.default)('scheduleHideVisionFindPreview');
      var timer = _this.state.visionFindPreview.timer;


      clearTimeout(timer);

      return setTimeout(function () {
        var visible = _this.state.visionFindPreview.visible;


        if (visible) {
          (0, _log2.default)('to hide preview');

          _this.setState({
            visionFindPreview: {
              visible: false
            }
          });
        }
      }, 3000);
    }, _this.onMouseEnterTarget = function (e, command) {
      (0, _log2.default)('onMouseOverTarget');
      if (!_this.commandHasVisionImage(command)) return;
      if (_this.state.visionFindPreview.visible) return;

      clearTimeout(_this.state.visionFindPreview.timer);

      var visionStorage = (0, _storage.getStorageManager)().getVisionStorage();
      var rect = e.target.getBoundingClientRect();
      var file = command.target.trim().split('@')[0];
      var common = {
        visible: true,
        left: rect.left,
        top: rect.top + rect.height
      };

      visionStorage.exists(file).then(function (existed) {
        if (!existed) {
          return _this.setState({
            visionFindPreview: (0, _extends3.default)({}, common, {
              url: './img/not_found.png',
              timer: _this.scheduleHideVisionFindPreview()
            })
          });
        }

        return visionStorage.getLink(file).then(function (link) {
          return _this.setState({
            visionFindPreview: (0, _extends3.default)({}, common, {
              url: link,
              timer: _this.scheduleHideVisionFindPreview()
            })
          });
        });
      });
    }, _this.onMouseLeaveTarget = function (e, command) {
      (0, _log2.default)('onMouseOutTarget');
      if (!_this.commandHasVisionImage(command)) return;
      if (!_this.state.visionFindPreview.visible) return;

      clearTimeout(_this.state.visionFindPreview.timer);

      _this.setState({
        visionFindPreview: {
          visible: false
        }
      });
    }, _this.jumpToSourceCode = function (commandIndex) {
      _this.props.setEditorActiveTab('source_view');
      setTimeout(function () {
        var editing = _this.props.editing;
        var commands = editing.commands;

        var instance = _this.state.cmEdtiorInstance;
        var headingLineCount = 4;
        var ch = 0;

        var $tab = document.querySelector('.source-view');
        var tabHeight = parseInt(window.getComputedStyle($tab).height, 10);
        var margin = (tabHeight - 60) / 2;

        var lineCountForCommand = function lineCountForCommand(command) {
          return 6 + (command.targetOptions ? command.targetOptions.length + 2 : 0);
        };

        var startLine = headingLineCount;

        for (var i = 0; i < commandIndex; i++) {
          startLine += lineCountForCommand(commands[i]);
        }

        var endLine = startLine + lineCountForCommand(commands[commandIndex]);

        (0, _log2.default)('margin', margin, tabHeight);
        instance.scrollIntoView({ ch: ch, line: startLine }, margin);
        instance.setSelection({ ch: ch, line: startLine }, { ch: ch, line: endLine }, { scroll: false });
      }, 100);
    }, _this.commandClassName = function (record, index) {
      var _this$props3 = _this.props,
          editing = _this$props3.editing,
          player = _this$props3.player,
          breakpointIndices = _this$props3.breakpointIndices,
          doneCommandIndices = _this$props3.doneCommandIndices,
          errorCommandIndices = _this$props3.errorCommandIndices,
          warningCommandIndices = _this$props3.warningCommandIndices;
      var nextCommandIndex = player.nextCommandIndex;
      var commands = editing.commands;

      var classNames = [];

      if (breakpointIndices.indexOf(index) !== -1) {
        classNames.push('breakpoint-command');
      }

      if (record.cmd === 'comment' || record.cmd === '') {
        classNames.push('comment-command');
      }

      if (!_this.props.canUseKeyboardShortcuts) {
        classNames.push('blur');
      }

      if (index === nextCommandIndex) {
        classNames.push('running-command');
      } else if (warningCommandIndices.indexOf(index) !== -1) {
        classNames.push('warning-command');
      } else if (errorCommandIndices.indexOf(index) !== -1) {
        classNames.push('error-command');
      } else if (doneCommandIndices.indexOf(index) !== -1) {
        classNames.push('done-command');
      }

      if (index === editing.meta.selectedIndex) {
        classNames.push('selected-command');
      }

      return classNames.join(' ');
    }, _this.needVirtualList = function () {
      var _this$props$editing$c = _this.props.editing.commands,
          commands = _this$props$editing$c === undefined ? [] : _this$props$editing$c;

      var threshold = 0;

      return commands.length >= threshold;
    }, _this.virtualCommmandList = function (_ref2) {
      var virtual = _ref2.virtual,
          itemHeight = _ref2.itemHeight;
      var commands = _this.props.editing.commands;

      var editable = _this.isPlayerStopped() && (0, _license.getLicenseService)().canPerform(_types.Feature.Edit);
      var renderItem = function renderItem(item, i) {
        if (item.header) {
          return _react2.default.createElement(
            'div',
            { className: 'command-row header-row', key: 'header' },
            _react2.default.createElement('div', { className: 'row-col index-col' }),
            _react2.default.createElement(
              'div',
              { className: 'row-col command-col' },
              'Command'
            ),
            _react2.default.createElement(
              'div',
              { className: 'row-col target-col' },
              'Target'
            ),
            _react2.default.createElement(
              'div',
              { className: 'row-col value-col' },
              'Value'
            ),
            _react2.default.createElement(
              'div',
              { className: 'row-col op-col' },
              'Ops'
            )
          );
        }

        if (item.footer) {
          return _react2.default.createElement(
            'div',
            { className: 'command-row footer-row', key: 'footer', onClick: function onClick() {
                if (!(0, _license.getLicenseService)().canPerform(_types.Feature.Edit)) {
                  return;
                }

                _this.props.updateUI({ focusArea: _state.FocusArea.CommandTable });
                _this.props.insertCommand(newCommand, commands.length);
              } },
            'Add'
          );
        }

        return _react2.default.createElement(_command_item.CommandItem, {
          key: item.key,
          index: item.realIndex + 1,
          command: item,
          style: { height: itemHeight + 'px' },
          className: 'command-row real-command ' + _this.commandClassName(item, item.realIndex),
          attributes: { 'data-index': '' + item.realIndex },
          editable: editable,
          onClick: function onClick(e, command) {
            return _this.onClickCommand(e, command);
          },
          onContextMenu: function onContextMenu(e, command) {
            return _this.onContextMenu(e, command.realIndex);
          },
          onToggleComment: function onToggleComment(e, command) {
            _this.props.toggleComment(command.realIndex);e.stopPropagation();
          },
          onDuplicate: function onDuplicate(e, command) {
            _this.props.duplicateCommand(command.realIndex);e.stopPropagation();
          },
          onMouseEnterTarget: _this.onMouseEnterTarget,
          onMouseLeaveTarget: _this.onMouseLeaveTarget,
          onMoveCommand: _this.onMoveCommand,
          onDragStart: _this.onStartDraggingCommand,
          onDragEnd: _this.onEndDraggingCommand
        });
      };

      return _react2.default.createElement(
        'div',
        { style: virtual.style },
        virtual.items.map(renderItem)
      );
    }, _this.onContextMenu = function (e, index) {
      (0, _log2.default)('onContextMenu');

      _this.setState({
        contextMenu: {
          x: e.clientX,
          y: e.clientY,
          isShown: true,
          commandIndex: index
        }
      });

      _this.props.selectCommand(index, true);
      e.preventDefault();
      e.stopPropagation();
    }, _this.onHideMenu = function (e) {
      if (e.button !== 0) return;

      _this.setState({
        contextMenu: (0, _extends3.default)({}, _this.state.contextMenu, {
          isShown: false
        })
      });
    }, _this.onClickCommand = function (e, command) {
      _this.props.updateUI({ focusArea: _state.FocusArea.CommandTable });
      _this.props.selectCommand(command.realIndex, true);
    }, _this.getTestCaseName = function () {
      var src = _this.props.editing.meta.src;

      return src && src.name && src.name.length ? src.name : 'Untitled';
    }, _this.playLine = function (commandIndex) {
      var extraOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var commands = _this.props.editing.commands;
      var src = _this.props.editing.meta.src;


      _this.setState({ lastOperation: 'play' });

      return _this.props.playerPlay((0, _extends3.default)({
        macroId: src && src.id,
        title: _this.getTestCaseName(),
        extra: {
          id: src && src.id
        },
        mode: _player.Player.C.MODE.SINGLE,
        startIndex: commandIndex,
        startUrl: null,
        resources: commands,
        postDelay: _this.props.config.playCommandInterval * 1000
      }, extraOptions));
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  // Note: virtual-list eats up double click events. so have to manually track click event instead


  (0, _createClass3.default)(DashboardEditor, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      document.addEventListener('click', this.onHideMenu);
      document.addEventListener('click', this.onDoubleClick);
      document.addEventListener('keydown', this.onKeyDown);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      // Note: update sourceText whenever editing changed
      if (nextProps.editing.meta.src !== this.props.editing.meta.src || nextProps.editing.commands !== this.props.editing.commands) {
        var resetCursor = nextProps.editing.meta.src !== this.props.editing.meta.src;

        this.setState(this.resetSourceCodeCursor(resetCursor));
      }

      if (nextProps.status === C.APP_STATUS.PLAYER && nextProps.player.nextCommandIndex !== this.props.player.nextCommandIndex) {
        var $tableBody = document.querySelector('.table-wrapper');
        var itemHeight = ITEM_HEIGHT;

        if (!$tableBody) return;

        $tableBody.scrollTop = itemHeight * nextProps.player.nextCommandIndex;
      }

      if (nextProps.status === C.APP_STATUS.RECORDER && nextProps.editing.commands.length > this.props.editing.commands.length) {
        var _$tableBody = document.querySelector('.table-wrapper');
        var _itemHeight = ITEM_HEIGHT;

        if (!_$tableBody) return;

        setTimeout(function () {
          _$tableBody.scrollTop = _itemHeight * nextProps.editing.commands.length * 2;
        }, 100);
      }
    }
  }, {
    key: 'isPlayerStopped',
    value: function isPlayerStopped() {
      return this.props.player.status === C.PLAYER_STATUS.STOPPED;
    }
  }, {
    key: 'waitBeforeScreenCapture',
    value: function waitBeforeScreenCapture() {
      if (!(0, _cv_utils.isCVTypeForDesktop)(this.props.config.cvScope)) {
        return _promise2.default.resolve();
      }

      if (this.props.config.waitBeforeDesktopScreenCapture && this.props.config.secondsBeforeDesktopScreenCapture > 0) {
        _message3.default.info('About to take desktop screenshot in ' + this.props.config.secondsBeforeDesktopScreenCapture + ' seconds');
        return (0, _ts_utils.delay)(function () {}, this.props.config.secondsBeforeDesktopScreenCapture * 1000);
      }

      return _promise2.default.resolve();
    }
  }, {
    key: 'isSelectedCommandVisualSearch',
    value: function isSelectedCommandVisualSearch(command) {
      var _props = this.props,
          editing = _props.editing,
          config = _props.config;
      var commands = editing.commands,
          meta = editing.meta;
      var selectedIndex = meta.selectedIndex;


      var dataSource = commands && commands.length ? commands : defaultDataSource;
      var selectedCmd = command || dataSource[selectedIndex];

      var selectedCmdIsVisualSearch = function () {
        if (!selectedCmd) return false;
        if ((0, _cv_utils.isCVTypeForDesktop)(config.cvScope) && selectedCmd.cmd === 'visionLimitSearchArea') return true;

        return ['visionFind', 'visualSearch', 'visualAssert', 'visualVerify', 'XClick', 'XMove', 'XClickRelative', 'XMoveRelative', 'OCRExtract', 'OCRExtractRelative', 'visionLimitSearchAreaRelative'].indexOf(selectedCmd.cmd) !== -1;
      }();

      return selectedCmdIsVisualSearch;
    }
  }, {
    key: 'commandHasVisionImage',
    value: function commandHasVisionImage(command) {
      if (!this.isSelectedCommandVisualSearch(command)) return false;

      var commandsCouldHaveVisionImage = ['XClick', 'XClickRelative', 'XMove', 'XMoveRelative', 'OCRExtract', 'OCRExtractRelative', 'visionLimitSearchArea', 'visionLimitSearchAreaRelative'];

      if (commandsCouldHaveVisionImage.indexOf(command.cmd) !== -1 && !/\.png/i.test(command.target)) return false;
      return true;
    }
  }, {
    key: 'selectCommandAndScroll',
    value: function selectCommandAndScroll(commandIndex) {
      this.props.selectCommand(commandIndex, true);
      this.props.scrollToCommandAtIndex(commandIndex);
    }
  }, {
    key: 'renderVisionFindPreview',
    value: function renderVisionFindPreview() {
      var _state$visionFindPrev = this.state.visionFindPreview,
          visible = _state$visionFindPrev.visible,
          url = _state$visionFindPrev.url,
          left = _state$visionFindPrev.left,
          top = _state$visionFindPrev.top;

      if (!visible) return null;

      return _react2.default.createElement('div', { style: {
          position: 'absolute',
          width: '100px',
          height: '100px',
          border: '1px solid #ccc',
          left: left + 'px',
          top: top + 'px',
          backgroundColor: '#eee',
          backgroundImage: 'url(' + url + ')',
          backgroundSize: 'contain',
          backgroundRepeat: 'no-repeat',
          backgroundPosition: 'center'
        } });
    }
  }, {
    key: 'renderContextMenu',
    value: function renderContextMenu() {
      var _this2 = this;

      var _props2 = this.props,
          clipboard = _props2.clipboard,
          status = _props2.status;
      var contextMenu = this.state.contextMenu;

      var isNormal = status === C.APP_STATUS.NORMAL;
      var dw = document.documentElement.clientWidth;
      var dh = document.documentElement.clientHeight;
      var mw = 240;
      var x = contextMenu.x + window.scrollX;
      var y = contextMenu.y + window.scrollY;

      if (!isNormal) {
        return null;
      }

      if (x + mw > dw) x -= mw;

      var style = {
        position: 'absolute',
        top: y,
        left: x,
        display: contextMenu.isShown ? 'block' : 'none'
      };

      var menuStyle = {
        width: mw + 'px'
      };

      var commandIndex = contextMenu.commandIndex;

      var isBreakpoint = this.props.breakpointIndices.indexOf(commandIndex) !== -1;

      var handleClick = function handleClick(e) {
        switch (e.key) {
          case 'cut':
            return _this2.props.cutCommand(commandIndex);
          case 'copy':
            return _this2.props.copyCommand(commandIndex);
          case 'paste':
            return _this2.props.pasteCommand(commandIndex);
          case 'insert':
            return _this2.props.insertCommand(newCommand, commandIndex + 1);
          case 'delete':
            return _this2.props.removeCommand(commandIndex);
          case 'run_line':
            {
              return _this2.playLine(commandIndex);
            }
          case 'play_from_here':
            {
              var commands = _this2.props.editing.commands;


              _this2.setState({ lastOperation: 'play' });

              return _this2.props.playerPlay({
                macroId: _this2.props.macroId,
                title: _this2.getTestCaseName(),
                extra: { id: _this2.props.macroId },
                mode: _player.Player.C.MODE.STRAIGHT,
                startIndex: commandIndex,
                startUrl: null,
                resources: commands,
                postDelay: _this2.props.config.playCommandInterval * 1000
              });
            }
          case 'play_to_here':
            {
              var _commands = _this2.props.editing.commands;


              _this2.setState({ lastOperation: 'play' });

              return _this2.props.playerPlay({
                macroId: _this2.props.macroId,
                title: _this2.getTestCaseName(),
                extra: { id: _this2.props.macroId },
                mode: _player.Player.C.MODE.STRAIGHT,
                startIndex: 0,
                startUrl: null,
                resources: _commands,
                postDelay: _this2.props.config.playCommandInterval * 1000,
                breakpoints: [commandIndex]
              });
            }
          case 'add_breakpoint':
            {
              return _this2.props.addBreakpoint(_this2.props.macroId, commandIndex);
            }
          case 'remove_breakpoint':
            {
              return _this2.props.removeBreakpoint(_this2.props.macroId, commandIndex);
            }
          case 'jump_to_source_code':
            {
              return _this2.jumpToSourceCode(commandIndex);
            }
          case 'record_from_here':
            {
              _this2.props.setIndexToInsertRecorded(commandIndex + 1);
              _this2.props.toggleRecorderSkipOpen(true);
              return _this2.props.startRecording();
            }
        }
      };

      var ctrlKey = (0, _ts_utils.isMac)() ? '⌘' : 'CTRL-';

      return _react2.default.createElement(
        'div',
        { style: style, id: 'context_menu' },
        _react2.default.createElement(
          _menu2.default,
          { onClick: handleClick, style: menuStyle, mode: 'vertical', selectable: false },
          _react2.default.createElement(
            _menu2.default.Item,
            {
              key: 'cut',
              disabled: !(0, _license.getLicenseService)().canPerform(_types.Feature.Edit)
            },
            _react2.default.createElement(
              'span',
              null,
              'Cut'
            ),
            _react2.default.createElement(
              'span',
              { className: 'shortcut' },
              ctrlKey,
              'X'
            )
          ),
          _react2.default.createElement(
            _menu2.default.Item,
            {
              key: 'copy',
              disabled: !(0, _license.getLicenseService)().canPerform(_types.Feature.Edit)
            },
            _react2.default.createElement(
              'span',
              null,
              'Copy'
            ),
            _react2.default.createElement(
              'span',
              { className: 'shortcut' },
              ctrlKey,
              'C'
            )
          ),
          _react2.default.createElement(
            _menu2.default.Item,
            {
              key: 'paste',
              disabled: clipboard.commands.length === 0
            },
            _react2.default.createElement(
              'span',
              null,
              'Paste'
            ),
            _react2.default.createElement(
              'span',
              { className: 'shortcut' },
              ctrlKey,
              'P'
            )
          ),
          _react2.default.createElement(
            _menu2.default.Item,
            {
              key: 'delete',
              disabled: !(0, _license.getLicenseService)().canPerform(_types.Feature.Edit)
            },
            _react2.default.createElement(
              'span',
              null,
              'Delete'
            )
          ),
          _react2.default.createElement(_menu2.default.Divider, null),
          _react2.default.createElement(
            _menu2.default.Item,
            {
              key: 'insert',
              disabled: !(0, _license.getLicenseService)().canPerform(_types.Feature.Edit)
            },
            'Insert new line'
          ),
          _react2.default.createElement(_menu2.default.Divider, null),
          _react2.default.createElement(
            _menu2.default.Item,
            { key: 'jump_to_source_code' },
            'Jump to source code'
          ),
          _react2.default.createElement(
            _menu2.default.Item,
            { key: isBreakpoint ? 'remove_breakpoint' : 'add_breakpoint' },
            isBreakpoint ? 'Remove breakpoint' : 'Add breakpoint'
          ),
          _react2.default.createElement(_menu2.default.Divider, null),
          _react2.default.createElement(
            _menu2.default.Item,
            { key: 'run_line' },
            'Execute this command'
          ),
          _react2.default.createElement(
            _menu2.default.Item,
            { key: 'play_from_here' },
            'Play from here'
          ),
          _react2.default.createElement(
            _menu2.default.Item,
            { key: 'play_to_here' },
            'Play to this point'
          ),
          _react2.default.createElement(
            _menu2.default.Item,
            {
              key: 'record_from_here',
              disabled: !(0, _license.getLicenseService)().canPerform(_types.Feature.Record)
            },
            'Record from here'
          )
        )
      );
    }
  }, {
    key: 'renderTargetEditor',
    value: function renderTargetEditor() {
      var _this3 = this;

      var _props3 = this.props,
          status = _props3.status,
          editing = _props3.editing,
          config = _props3.config,
          ui = _props3.ui;
      var commands = editing.commands,
          meta = editing.meta;
      var selectedIndex = meta.selectedIndex;


      var isPlayerStopped = this.isPlayerStopped();
      var dataSource = commands && commands.length ? commands : defaultDataSource;
      var selectedCmd = dataSource[selectedIndex];
      var isCmdEditable = isPlayerStopped && !!selectedCmd;

      if (!isCmdEditable || !this.state.targetEditor.visible) {
        return null;
      }

      return _react2.default.createElement(
        'div',
        { className: 'target-full-editor' },
        _react2.default.createElement('div', { className: 'mask' }),
        _react2.default.createElement(_button2.default, {
          shape: 'circle',
          icon: 'close',
          className: 'close-button',
          onClick: function onClick() {
            _this3.setState({
              targetEditor: {
                visible: false,
                text: ''
              }
            });
          }
        }),
        _react2.default.createElement(_reactCodemirror.UnControlled, {
          value: this.state.targetEditor.text,
          onChange: function onChange(editor, _, text) {
            _this3.onDetailChange('target', text);
          },
          onCursor: function onCursor(editor, data) {
            // this.setState({ cmEdtiorInstance: editor })
            // // Note: when value updated, code mirror will automatically emit onCursor with cursor at bottom
            // // It can be tell with `sticky` as null
            // if (data.sticky) {
            //   this.setState({ cursor: { line: data.line, ch: data.ch } })
            // }
          },
          onFocus: function onFocus() {
            _this3.props.updateUI({ focusArea: _state.FocusArea.CodeSource });
          },
          options: {
            mode: { name: 'javascript', json: true },
            lineNumbers: true,
            matchBrackets: true,
            autoCloseBrackets: true
          }
        })
      );
    }
  }, {
    key: 'renderTable',
    value: function renderTable() {
      var _props4 = this.props,
          editing = _props4.editing,
          player = _props4.player;
      var commands = editing.commands;

      var _reduce = (commands && commands.length ? commands : defaultDataSource).reduce(function (_ref3, command, i) {
        var dataSource = _ref3.dataSource,
            indent = _ref3.indent;

        var _indentCreatedByComma = (0, _command.indentCreatedByCommand)(command.cmd),
            selfIndent = _indentCreatedByComma.selfIndent,
            nextIndent = _indentCreatedByComma.nextIndent;

        dataSource.push((0, _extends3.default)({}, command, {
          key: Math.random(),
          indent: indent + selfIndent,
          realIndex: i
        }));

        return {
          dataSource: dataSource,
          indent: Math.max(0, indent + selfIndent + nextIndent)
        };
      }, { dataSource: [], indent: 0 }),
          dataSource = _reduce.dataSource;

      return this.needVirtualList() ? this.renderVirtualTable(dataSource) : this.renderNormalTable(dataSource);
    }
  }, {
    key: 'renderVirtualTable',
    value: function renderVirtualTable(dataSource) {
      var CommandVirtualList = (0, _kdReactVirtualList2.default)({ container: this.listContainer })(this.virtualCommmandList);
      var paddedDataSource = [{ header: true }].concat((0, _toConsumableArray3.default)(dataSource), [{ footer: true }]);

      return _react2.default.createElement(
        'div',
        { className: 't-body' },
        !this.listContainer ? null : _react2.default.createElement(CommandVirtualList, { itemHeight: ITEM_HEIGHT, items: paddedDataSource })
      );
    }
  }, {
    key: 'renderNormalTable',
    value: function renderNormalTable(dataSource) {
      var _this4 = this;

      var _props5 = this.props,
          editing = _props5.editing,
          player = _props5.player,
          doneCommandIndices = _props5.doneCommandIndices,
          errorCommandIndices = _props5.errorCommandIndices;
      var nextCommandIndex = player.nextCommandIndex;
      var commands = editing.commands;

      var editable = this.isPlayerStopped();

      var columns = [{ title: 'Command', dataIndex: 'cmd', key: 'cmd', width: 130 }, { title: 'Target', dataIndex: 'target', key: 'target', width: 190 }, { title: 'Value', dataIndex: 'value', key: 'value' }, {
        title: 'Ops',
        key: 'ops',
        width: 80,
        render: function render(text, record, index) {
          return _react2.default.createElement(
            'div',
            null,
            _react2.default.createElement(
              _button2.default,
              {
                disabled: !editable,
                shape: 'circle',
                onClick: function onClick(e) {
                  _this4.props.removeCommand(index);e.stopPropagation();
                }
              },
              _react2.default.createElement(_icon2.default, { type: 'minus' })
            ),
            _react2.default.createElement(
              _button2.default,
              {
                disabled: !editable,
                shape: 'circle',
                onClick: function onClick(e) {
                  _this4.props.duplicateCommand(index);e.stopPropagation();
                }
              },
              _react2.default.createElement(_icon2.default, { type: 'plus' })
            )
          );
        }
      }];

      var tableConfig = {
        dataSource: dataSource,
        columns: columns,
        pagination: false,
        footer: function footer() {
          return _react2.default.createElement(
            'div',
            { className: 'table-footer', onClick: function onClick(e) {
                if (!(0, _license.getLicenseService)().canPerform(_types.Feature.Edit)) {
                  return;
                }

                _this4.props.insertCommand(newCommand, commands.length);
              } },
            'Add'
          );
        },
        onRowClick: function onRowClick(record, index, e) {
          _this4.props.selectCommand(index);
        },
        rowClassName: this.commandClassName
      };

      return _react2.default.createElement(_table2.default, tableConfig);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this5 = this;

      var _props6 = this.props,
          status = _props6.status,
          editing = _props6.editing,
          config = _props6.config,
          ui = _props6.ui;
      var commands = editing.commands,
          meta = editing.meta;
      var selectedIndex = meta.selectedIndex;


      var isPlayerStopped = this.isPlayerStopped();
      var dataSource = commands && commands.length ? commands : defaultDataSource;
      var selectedCmd = dataSource[selectedIndex];
      var editable = isPlayerStopped && !!selectedCmd;
      var isCmdEditable = editable && (0, _license.getLicenseService)().canPerform(_types.Feature.Edit);
      var isInspecting = status === C.APP_STATUS.INSPECTOR;

      var selectedCmdIsVisualSearch = this.isSelectedCommandVisualSearch();

      var isSelectEnabled = selectedCmd && selectedCmd.cmd && (0, _command.canCommandSelect)(selectedCmd.cmd);
      var isFindEnabled = selectedCmd && selectedCmd.cmd && (0, _command.canCommandFind)(selectedCmd.cmd);

      var shouldUseSelectInputForTarget = selectedCmd && selectedCmd.targetOptions && selectedCmd.targetOptions.length && (0, _command.doesCommandSupportTargetOptions)(selectedCmd.cmd);
      var shouldUseTextareaForTarget = selectedCmd && ['executeScript', 'executeScript_Sandbox'].indexOf(selectedCmd.cmd) !== -1;
      var shouldUseNormalInputForTarget = !shouldUseSelectInputForTarget && !shouldUseTextareaForTarget;

      return _react2.default.createElement(
        'div',
        { className: 'editor-wrapper' },
        _react2.default.createElement(
          'div',
          { className: 'tabs-wrapper' },
          _react2.default.createElement(
            _tabs2.default,
            {
              type: 'card',
              className: (0, _utils.cn)('commands-view', { 'target-as-textarea': shouldUseTextareaForTarget }),
              activeKey: this.props.editor.activeTab,
              onChange: this.onChangeCommandsView
            },
            _react2.default.createElement(
              _tabs2.default.TabPane,
              { tab: 'Table View', key: 'table_view' },
              _react2.default.createElement(
                'div',
                { className: 'form-group table-wrapper', style: { marginBottom: 0 }, ref: function ref(_ref4) {
                    _this5.listContainer = _ref4;
                  } },
                this.renderTable()
              ),
              _react2.default.createElement(
                'div',
                { className: 'form-group fields-wrapper', style: { marginBottom: 0 } },
                _react2.default.createElement(
                  _form2.default,
                  null,
                  _react2.default.createElement(
                    _form2.default.Item,
                    { label: 'Command', labelCol: { span: 4 }, wrapperCol: { span: 20 } },
                    _react2.default.createElement(
                      'div',
                      { className: 'flex-row' },
                      _react2.default.createElement(
                        _select2.default,
                        {
                          showSearch: true,
                          optionFilterProp: 'children',
                          placeholder: 'command',
                          disabled: !isCmdEditable,
                          value: selectedCmd && selectedCmd.cmd,
                          onChange: function onChange(value) {
                            return _this5.onDetailChange('cmd', value);
                          },
                          filterOption: function filterOption(input, _ref5) {
                            var key = _ref5.key;
                            return key.toLowerCase().indexOf(input.toLowerCase()) !== -1;
                          },
                          style: { flex: 1, maxWidth: '60%', marginRight: '10px' },
                          size: 'default'
                        },
                        ((0, _cv_utils.isCVTypeForDesktop)(config.cvScope) ? _command.availableCommandsForDesktop : _command.availableCommands).map(function (cmd) {
                          return _react2.default.createElement(
                            _select2.default.Option,
                            { value: cmd, key: cmd },
                            (0, _command.commandText)(cmd)
                          );
                        })
                      ),
                      _react2.default.createElement(
                        'div',
                        { style: {
                            flex: 0.6,
                            display: 'flex',
                            justifyContent: 'space-between'
                          } },
                        selectedCmd && selectedCmd.cmd ? _react2.default.createElement(
                          'a',
                          {
                            style: { marginRight: '10px', whiteSpace: 'nowrap' },
                            href: 'https://ui.vision/x/idehelp?cmd=' + selectedCmd.cmd.toLowerCase(),
                            target: '_blank'
                          },
                          'Info for this command'
                        ) : _react2.default.createElement('span', null),
                        _react2.default.createElement(
                          _button2.default,
                          {
                            style: { padding: '0 10px' },
                            title: 'Toggle comment',
                            disabled: !isCmdEditable,
                            onClick: function onClick() {
                              _this5.props.toggleCommentOnSelectedCommand();
                            }
                          },
                          '//'
                        )
                      )
                    )
                  ),
                  _react2.default.createElement(
                    _form2.default.Item,
                    { label: 'Target', className: 'target-row', labelCol: { span: 4 }, wrapperCol: { span: 20 } },
                    _react2.default.createElement(
                      'div',
                      { className: 'flex-row' },
                      shouldUseNormalInputForTarget ? _react2.default.createElement(_input2.default, {
                        style: { flex: 1, maxWidth: '60%', marginRight: '10px' },
                        placeholder: 'target',
                        disabled: !isCmdEditable,
                        value: selectedCmd && selectedCmd.target,
                        onChange: function onChange(e) {
                          return _this5.onDetailChange('target', e.target.value);
                        },
                        size: 'default'
                      }) : null,
                      shouldUseSelectInputForTarget ? _react2.default.createElement(_select_input.SelectInput, {
                        disabled: !isCmdEditable,
                        getId: function getId(str) {
                          return str;
                        },
                        stringifyOption: function stringifyOption(str) {
                          return str;
                        },
                        value: selectedCmd.target,
                        options: selectedCmd.targetOptions,
                        onChange: function onChange(val) {
                          return _this5.onDetailChange('target', val);
                        }
                      }) : null,
                      shouldUseTextareaForTarget ? _react2.default.createElement(
                        'div',
                        { className: 'textarea-wrapper' },
                        _react2.default.createElement(_input2.default.TextArea, {
                          rows: 2,
                          placeholder: 'target',
                          disabled: !isCmdEditable,
                          value: selectedCmd && selectedCmd.target,
                          onChange: function onChange(e) {
                            return _this5.onDetailChange('target', e.target.value);
                          },
                          size: 'default'
                        }),
                        _react2.default.createElement(_icon2.default, {
                          type: 'arrows-alt',
                          className: 'open-full-editor',
                          title: 'Open full editor',
                          onClick: function onClick() {
                            _this5.setState({
                              targetEditor: {
                                visible: true,
                                text: selectedCmd.target
                              }
                            });
                          }
                        })
                      ) : null,
                      _react2.default.createElement(
                        _button2.default,
                        {
                          disabled: !isCmdEditable || !isSelectEnabled,
                          onClick: this.onToggleSelect
                        },
                        isInspecting ? _react2.default.createElement(
                          'span',
                          null,
                          (selectedCmdIsVisualSearch ? '👁' : '') + 'Cancel'
                        ) : _react2.default.createElement(
                          'span',
                          null,
                          (selectedCmdIsVisualSearch ? '👁' : '') + 'Select'
                        )
                      ),
                      _react2.default.createElement(
                        _button2.default,
                        {
                          disabled: !editable || !isFindEnabled,
                          onClick: this.onClickFind
                        },
                        (selectedCmdIsVisualSearch ? '👁' : '') + 'Find'
                      )
                    )
                  ),
                  _react2.default.createElement(
                    _form2.default.Item,
                    { label: 'Value', labelCol: { span: 4 }, wrapperCol: { span: 20 } },
                    _react2.default.createElement(_input2.default, {
                      disabled: !isCmdEditable,
                      value: selectedCmd && selectedCmd.value,
                      onChange: function onChange(e) {
                        return _this5.onDetailChange('value', e.target.value);
                      },
                      style: { width: '100%' },
                      placeholder: 'value',
                      size: 'default'
                    })
                  ),
                  _react2.default.createElement(
                    _form2.default.Item,
                    { label: 'Description', labelCol: { span: 4 }, wrapperCol: { span: 20 }, style: { marginBottom: 0 } },
                    _react2.default.createElement(_input2.default, {
                      disabled: !isCmdEditable,
                      value: selectedCmd && selectedCmd.description,
                      onChange: function onChange(e) {
                        return _this5.onDetailChange('description', e.target.value);
                      },
                      style: { width: '100%' },
                      placeholder: 'description',
                      size: 'default'
                    })
                  )
                )
              )
            ),
            _react2.default.createElement(
              _tabs2.default.TabPane,
              { tab: 'Source View (JSON)', key: 'source_view', className: 'source-view' },
              _react2.default.createElement(
                'pre',
                { className: 'source-error' },
                this.props.sourceErrMsg
              ),
              _react2.default.createElement(_reactCodemirror.UnControlled, {
                ref: function ref(el) {
                  _this5.codeMirror = el;
                },
                className: this.props.sourceErrMsg ? 'has-error' : 'no-error',
                value: this.props.sourceText,
                onChange: this.onChangeEditSource,
                onBlur: this.onSourceBlur,
                onCursor: function onCursor(editor, data) {
                  _this5.setState({ cmEdtiorInstance: editor });
                  // Note: when value updated, code mirror will automatically emit onCursor with cursor at bottom
                  // It can be tell with `sticky` as null
                  if (data.sticky) {
                    _this5.setState({ cursor: { line: data.line, ch: data.ch } });
                  }
                },
                onFocus: function onFocus() {
                  _this5.props.updateUI({ focusArea: _state.FocusArea.CodeSource });
                },
                options: {
                  mode: { name: 'javascript', json: true },
                  lineNumbers: true,
                  matchBrackets: true,
                  autoCloseBrackets: true,
                  readOnly: !(0, _license.getLicenseService)().canPerform(_types.Feature.Edit)
                }
              })
            )
          ),
          (0, _cv_utils.isCVTypeForDesktop)(config.cvScope) && ui.shouldEnableDesktopAutomation !== false || ui.shouldEnableDesktopAutomation === true ? _react2.default.createElement(
            'div',
            {
              className: 'vision-type',
              onClick: function onClick() {
                _this5.props.updateUI({ showSettings: true, settingsTab: 'vision' });
              }
            },
            _react2.default.createElement('img', { src: './img/computer.svg' }),
            _react2.default.createElement(
              'span',
              null,
              'Desktop mode active'
            )
          ) : null
        ),
        this.renderContextMenu(),
        this.renderVisionFindPreview(),
        this.renderTargetEditor()
      );
    }
  }]);
  return DashboardEditor;
}(_react2.default.Component);

exports["default"] = (0, _reactRedux.connect)(function (state) {
  return {
    status: state.status,
    editor: state.editor,
    editing: state.editor.editing,
    clipboard: state.editor.clipboard,
    player: state.player,
    config: state.config,
    ui: state.ui,
    sourceErrMsg: state.editor.editingSource.error,
    sourceText: state.editor.editingSource.pure,
    sourceTextModified: state.editor.editingSource.current,
    selectedCommand: (0, _recomputed.editorSelectedCommand)(state),
    selectedCommandIndex: (0, _recomputed.editorSelectedCommandIndex)(state),
    commandCount: (0, _recomputed.editorCommandCount)(state),
    breakpointIndices: (0, _recomputed.getBreakpoints)(state),
    doneCommandIndices: (0, _recomputed.getDoneCommandIndices)(state),
    errorCommandIndices: (0, _recomputed.getErrorCommandIndices)(state),
    warningCommandIndices: (0, _recomputed.getWarningCommandIndices)(state),
    macroId: (0, _recomputed.getCurrentMacroId)(state),
    canUseKeyboardShortcuts: (0, _recomputed.isFocusOnCommandTable)(state)
  };
}, function (dispatch) {
  return (0, _redux.bindActionCreators)((0, _extends3.default)({}, actions, _simple_actions.Actions), dispatch);
})(DashboardEditor);

/***/ }),

/***/ 35539:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = __webpack_require__(85105);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(49135);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(93196);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(67294);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(33664);

var _redux = __webpack_require__(74127);

__webpack_require__(8776);

var _actions = __webpack_require__(97876);

var actions = _interopRequireWildcard(_actions);

var _editor = __webpack_require__(28769);

var _editor2 = _interopRequireDefault(_editor);

var _bottom = __webpack_require__(70924);

var _bottom2 = _interopRequireDefault(_bottom);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Dashboard = function (_React$Component) {
  (0, _inherits3.default)(Dashboard, _React$Component);

  function Dashboard() {
    (0, _classCallCheck3.default)(this, Dashboard);
    return (0, _possibleConstructorReturn3.default)(this, (Dashboard.__proto__ || (0, _getPrototypeOf2.default)(Dashboard)).apply(this, arguments));
  }

  (0, _createClass3.default)(Dashboard, [{
    key: 'render',
    value: function render() {
      var isWindows = /windows/i.test(window.navigator.userAgent);

      return _react2.default.createElement(
        'div',
        { className: 'dashboard' },
        _react2.default.createElement(_editor2.default, null),
        _react2.default.createElement(_bottom2.default, null),
        _react2.default.createElement(
          'div',
          { className: 'online-help' },
          _react2.default.createElement(
            'div',
            { style: { visibility: isWindows ? 'visible' : 'hidden' } },
            _react2.default.createElement('a', { href: 'https://ui.vision/x/idehelp?help=visual', target: '_blank' })
          ),
          _react2.default.createElement(
            'div',
            null,
            'UI.Vision RPA:',
            _react2.default.createElement(
              'a',
              { href: 'https://ui.vision/x/idehelp?help=forum', target: '_blank' },
              ' User Forum'
            ),
            ' -',
            _react2.default.createElement(
              'a',
              { href: 'https://ui.vision/x/idehelp?help=docs', target: '_blank' },
              ' Online Help'
            )
          )
        )
      );
    }
  }]);
  return Dashboard;
}(_react2.default.Component);

exports["default"] = (0, _reactRedux.connect)(function (state) {
  return {};
}, function (dispatch) {
  return (0, _redux.bindActionCreators)((0, _extends3.default)({}, actions), dispatch);
})(Dashboard);

/***/ }),

/***/ 75256:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _select = __webpack_require__(64749);

var _select2 = _interopRequireDefault(_select);

var _tabs = __webpack_require__(1350);

var _tabs2 = _interopRequireDefault(_tabs);

var _modal = __webpack_require__(56697);

var _modal2 = _interopRequireDefault(_modal);

var _button = __webpack_require__(65400);

var _button2 = _interopRequireDefault(_button);

var _message2 = __webpack_require__(11187);

var _message3 = _interopRequireDefault(_message2);

var _getPrototypeOf = __webpack_require__(85105);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(49135);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(93196);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(67294);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(33664);

var _redux = __webpack_require__(74127);

var _antd = __webpack_require__(56318);

__webpack_require__(2047);

var _actions = __webpack_require__(97876);

var actions = _interopRequireWildcard(_actions);

var _utils = __webpack_require__(63370);

var _test_suites = __webpack_require__(64248);

var _test_suites2 = _interopRequireDefault(_test_suites);

var _test_cases = __webpack_require__(8588);

var _test_cases2 = _interopRequireDefault(_test_cases);

var _storage = __webpack_require__(16058);

var _state = __webpack_require__(16112);

var _license = __webpack_require__(53678);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Sidebar = function (_React$Component) {
  (0, _inherits3.default)(Sidebar, _React$Component);

  function Sidebar() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, Sidebar);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Sidebar.__proto__ || (0, _getPrototypeOf2.default)(Sidebar)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      drag: {
        isDragging: false,
        startX: 0,
        movingX: 0,
        lastWidth: 260,
        currentMinWidth: 260
      }
    }, _this.getSideBarMinWidth = function () {
      var _this$state$drag = _this.state.drag,
          isDragging = _this$state$drag.isDragging,
          lastWidth = _this$state$drag.lastWidth,
          currentMinWidth = _this$state$drag.currentMinWidth;

      return (isDragging ? currentMinWidth : lastWidth) + 'px';
    }, _this.onResizeDragStart = function (e) {
      // Note: Firefox requires us to set something to DataTransfer, otherwise drag and dragEnd won't be triggered
      // refer to https://stackoverflow.com/questions/33434275/firefox-on-drag-end-is-not-called-in-a-react-component
      e.dataTransfer.setData('text', '');

      var style = window.getComputedStyle(_this.$dom);
      var width = parseInt(style.width);

      _this.setState((0, _utils.setIn)(['drag'], {
        isDragging: true,
        // Check out the note on `screenX` in `onResizeDragEnd` event
        startX: e.screenX,
        lastWidth: width,
        currentWidth: width
      }, _this.state));
    }, _this.onResizeDragEnd = function (e) {
      // Note: use `screenX` instead of `clientX`, because `clientX` of dragEnd events in Firefox
      // is always set to 0, while `screenX` is luckily still available. And since we only make use of
      // difference of X coordinate. `screenX` and `clientX` both work for us.
      //
      // reference:
      // https://bugzilla.mozilla.org/show_bug.cgi?id=505521
      // https://developer.mozilla.org/en-US/docs/Web/Events/dragend
      var diff = e.screenX - _this.state.drag.startX;
      var width = diff + _this.state.drag.lastWidth;

      _this.setState((0, _utils.setIn)(['drag'], {
        isDragging: false,
        startX: 0,
        lastWidth: width,
        currentMinWidth: width
      }));
    }, _this.onTryToChangeStorageMode = function (storageMode) {
      // Steps:
      // 1. [pseudo code] StorageManager.changeMode()
      // 2. Try to refresh / reload all resources (macros, test suites, csvs, vision images)
      // 3. Be aware of any pending changes in current storage
      //
      // There should be no exception when switching back to browser mode
      // But `[pseudo code] StorageManager.changeMode(xFileMode)` should throw error when xFile is not ready.
      //
      // Once catched that error, should do following:
      // 1. Reset mode back to browser mode
      // 2. Show info dialog to encourage users to download xFile host

      var man = (0, _storage.getStorageManager)();

      man.isStrategyTypeAvailable(storageMode).then(function (isOk) {
        if (isOk) {
          // Note: it will emit events, so that `index.js` could handle the rest (refresh / reload resources)
          _this.props.updateConfig({ storageMode: storageMode });
          return man.setCurrentStrategyType(storageMode);
        }

        throw new Error('It should be impossible to get isOk as false');
      }).catch(function (e) {
        _message3.default.warn(e.message);

        if (e.message && /xFile is not installed yet/.test(e.message)) {
          _this.props.updateUI({ showXFileNotInstalledDialog: true });
        } else {
          _this.props.updateUI({ showSettings: true, settingsTab: 'xmodules' });
        }
      });
    }, _this.openRegisterSettings = function (e) {
      if (e && e.preventDefault) e.preventDefault();
      _this.props.updateUI({ showSettings: true, settingsTab: 'register' });
    }, _this.onClickSidebar = function () {
      _this.props.updateUI({ focusArea: _state.FocusArea.Sidebar });
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  (0, _createClass3.default)(Sidebar, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var type = (0, _storage.getStorageManager)().getCurrentStrategyType();
      this.setState({ storageMode: type });
    }
  }, {
    key: 'prefixHardDisk',
    value: function prefixHardDisk(str) {
      var isXFileMode = (0, _storage.getStorageManager)().isXFileMode();
      if (!isXFileMode) return str;

      return _react2.default.createElement(
        'div',
        {
          style: {
            display: 'inline-block'
          }
        },
        _react2.default.createElement('img', {
          src: './img/hard-drive.svg',
          style: {
            position: 'relative',
            top: '3px',
            marginRight: '5px',
            height: '15px'
          }
        }),
        _react2.default.createElement(
          'span',
          null,
          str
        )
      );
    }
  }, {
    key: 'renderXFileNotInstalledModal',
    value: function renderXFileNotInstalledModal() {
      var _this2 = this;

      return _react2.default.createElement(
        _modal2.default,
        {
          title: '',
          className: (0, _utils.cn)('xfile-not-installed-modal', { 'left-bottom': this.props.ui.showXFileNotInstalledDialog === true }),
          width: 350,
          footer: null,
          visible: this.props.ui.showXFileNotInstalledDialog,
          onCancel: function onCancel() {
            _this2.props.updateUI({ showXFileNotInstalledDialog: false });
          }
        },
        _react2.default.createElement(
          'p',
          null,
          'XFileAccess Module not installed.'
        ),
        _react2.default.createElement(
          'div',
          null,
          _react2.default.createElement(
            _button2.default,
            {
              type: 'primary',
              onClick: function onClick() {
                _this2.props.updateUI({
                  showXFileNotInstalledDialog: false,
                  showSettings: true,
                  settingsTab: 'xmodules'
                });
              }
            },
            'Open Settings'
          )
        )
      );
    }
  }, {
    key: 'shouldRenderMacroNote',
    value: function shouldRenderMacroNote() {
      var _props$config = this.props.config,
          xmodulesStatus = _props$config.xmodulesStatus,
          storageMode = _props$config.storageMode;


      if (storageMode !== _storage.StorageStrategyType.XFile) return false;
      if (xmodulesStatus === 'pro') return false;

      var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
      return macroStorage.getDisplayCount() < macroStorage.getTotalCount();
    }
  }, {
    key: 'renderMacroNote',
    value: function renderMacroNote() {
      if (!this.shouldRenderMacroNote()) return null;

      var max = (0, _license.getLicenseService)().getMaxXFileMacros();
      var link = (0, _license.getLicenseService)().getUpgradeUrl();

      return _react2.default.createElement(
        'div',
        { className: 'note-for-macros' },
        (0, _license.getLicenseService)().hasNoLicense() ? _react2.default.createElement(
          'div',
          null,
          'XModules Free Edition:',
          _react2.default.createElement('br', null),
          'Only the first ',
          max,
          ' files/folders are displayed.',
          _react2.default.createElement('br', null),
          _react2.default.createElement(
            'a',
            { href: link, onClick: this.openRegisterSettings },
            'Upgrade to PRO'
          ),
          ' to add more.'
        ) : null,
        (0, _license.getLicenseService)().isPersonalLicense() ? _react2.default.createElement(
          'div',
          null,
          'XModules PRO1 Edition:',
          _react2.default.createElement('br', null),
          'Only the first ',
          max,
          ' files/folders displayed.',
          _react2.default.createElement('br', null),
          _react2.default.createElement(
            'a',
            { href: link, onClick: this.openRegisterSettings },
            'Upgrade to PRO2 or Enterprise'
          ),
          ' for unlimited files'
        ) : null
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      return _react2.default.createElement(
        'div',
        {
          className: (0, _utils.cn)('sidebar', { 'with-xmodules-note': this.shouldRenderMacroNote() }),
          ref: function ref(el) {
            _this3.$dom = el;
          },
          style: { minWidth: this.getSideBarMinWidth() },
          onClickCapture: this.onClickSidebar
        },
        _react2.default.createElement(
          'div',
          { className: (0, _utils.cn)('sidebar-inner', { 'no-tab': !this.props.config.showTestCaseTab }) },
          !this.props.config.showTestCaseTab ? _react2.default.createElement(_test_cases2.default, null) : _react2.default.createElement(
            _tabs2.default,
            {
              defaultActiveKey: 'macros',
              activeKey: this.props.ui.sidebarTab || 'macros',
              onChange: function onChange(activeKey) {
                return _this3.props.updateUI({ sidebarTab: activeKey });
              }
            },
            _react2.default.createElement(
              _tabs2.default.TabPane,
              { tab: this.prefixHardDisk('Macros'), key: 'macros' },
              _react2.default.createElement(_test_cases2.default, null)
            ),
            _react2.default.createElement(
              _tabs2.default.TabPane,
              { tab: this.prefixHardDisk('Test Suites'), key: 'test_suites' },
              _react2.default.createElement(_test_suites2.default, null)
            )
          )
        ),
        _react2.default.createElement(
          'div',
          { className: 'sidebar-storage-mode' },
          this.renderMacroNote(),
          _react2.default.createElement(
            'div',
            { className: 'storage-mode-header' },
            _react2.default.createElement(
              'h3',
              null,
              'Storage Mode'
            ),
            (0, _storage.getStorageManager)().isXFileMode() ? _react2.default.createElement('img', {
              src: './img/reload.svg',
              title: 'Reload all resources on hard drive',
              style: {
                height: '15px',
                cursor: 'pointer'
              },
              onClick: function onClick() {
                (0, _storage.getStorageManager)().emit(_storage.StorageManagerEvent.ForceReload);
                _message3.default.info('reloaded from hard drive');
              }
            }) : null,
            _react2.default.createElement(
              'a',
              { href: 'https://ui.vision/x/idehelp?help=storage_mode', target: '_blank' },
              'More Info'
            )
          ),
          _react2.default.createElement(
            _select2.default,
            {
              style: { width: '100%' },
              placeholder: 'Storage Mode',
              value: this.props.config.storageMode,
              onChange: this.onTryToChangeStorageMode
            },
            _react2.default.createElement(
              _select2.default.Option,
              { value: _storage.StorageStrategyType.Browser },
              'Local Storage (in browser)'
            ),
            _react2.default.createElement(
              _select2.default.Option,
              { value: _storage.StorageStrategyType.XFile },
              'File system (on hard drive)'
            )
          )
        ),
        _react2.default.createElement('div', {
          className: (0, _utils.cn)('resize-handler', { focused: this.state.drag.isDragging }),
          draggable: 'true',
          onDragStart: this.onResizeDragStart,
          onDragEnd: this.onResizeDragEnd,
          onMouseDown: function onMouseDown() {
            return _this3.setState((0, _utils.setIn)(['drag', 'isDragging'], true, _this3.state));
          }
        }),
        this.renderXFileNotInstalledModal()
      );
    }
  }]);
  return Sidebar;
}(_react2.default.Component);

exports["default"] = (0, _reactRedux.connect)(function (state) {
  return {
    status: state.status,
    testSuites: state.editor.testSuites,
    editing: state.editor.editing,
    player: state.player,
    config: state.config,
    ui: state.ui
  };
}, function (dispatch) {
  return (0, _redux.bindActionCreators)((0, _extends3.default)({}, actions), dispatch);
})(Sidebar);

/***/ }),

/***/ 8588:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _dropdown = __webpack_require__(82891);

var _dropdown2 = _interopRequireDefault(_dropdown);

var _icon = __webpack_require__(86245);

var _icon2 = _interopRequireDefault(_icon);

var _button = __webpack_require__(65400);

var _button2 = _interopRequireDefault(_button);

var _input = __webpack_require__(51024);

var _input2 = _interopRequireDefault(_input);

var _menu = __webpack_require__(12386);

var _menu2 = _interopRequireDefault(_menu);

var _taggedTemplateLiteral2 = __webpack_require__(86735);

var _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2);

var _modal = __webpack_require__(56697);

var _modal2 = _interopRequireDefault(_modal);

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

var _message2 = __webpack_require__(11187);

var _message3 = _interopRequireDefault(_message2);

var _getPrototypeOf = __webpack_require__(85105);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(49135);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(93196);

var _inherits3 = _interopRequireDefault(_inherits2);

var _templateObject = (0, _taggedTemplateLiteral3.default)([''], ['']);

var _react = __webpack_require__(67294);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(33664);

var _redux = __webpack_require__(74127);

var _antd = __webpack_require__(56318);

var _jszip = __webpack_require__(55733);

var _jszip2 = _interopRequireDefault(_jszip);

var _keycode = __webpack_require__(27537);

var _keycode2 = _interopRequireDefault(_keycode);

var _web_extension = __webpack_require__(61171);

var _web_extension2 = _interopRequireDefault(_web_extension);

var _storage = __webpack_require__(16058);

var _file_saver = __webpack_require__(18187);

var _file_saver2 = _interopRequireDefault(_file_saver);

var _search_box = __webpack_require__(70462);

var _search_box2 = _interopRequireDefault(_search_box);

var _prompt = __webpack_require__(79197);

var _tree_file = __webpack_require__(58335);

var _save_test_case = __webpack_require__(57879);

var _save_test_case2 = _interopRequireDefault(_save_test_case);

var _player = __webpack_require__(43625);

var _bookmark = __webpack_require__(75303);

var _actions = __webpack_require__(97876);

var actions = _interopRequireWildcard(_actions);

var _simple_actions = __webpack_require__(46469);

var _constant = __webpack_require__(43232);

var C = _interopRequireWildcard(_constant);

var _convert_utils = __webpack_require__(61169);

var _recomputed = __webpack_require__(78328);

var _log = __webpack_require__(77242);

var _log2 = _interopRequireDefault(_log);

var _context_menu = __webpack_require__(74199);

var _messages = __webpack_require__(29319);

var _messages2 = _interopRequireDefault(_messages);

var _config = __webpack_require__(62275);

var _config2 = _interopRequireDefault(_config);

var _state = __webpack_require__(16112);

var _resource_not_loaded = __webpack_require__(29102);

var _license = __webpack_require__(53678);

var _types = __webpack_require__(10714);

var _ts_utils = __webpack_require__(55452);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SidebarTestCases = function (_React$Component) {
  (0, _inherits3.default)(SidebarTestCases, _React$Component);

  function SidebarTestCases() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, SidebarTestCases);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = SidebarTestCases.__proto__ || (0, _getPrototypeOf2.default)(SidebarTestCases)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      showRename: false,
      rename: '',
      folderToImport: '/'
    }, _this.unbindKeydown = function () {}, _this.onClickRename = function () {
      _this.props.renameTestCase(_this.state.rename, _this.state.renameTcId).then(function () {
        _message3.default.success('successfully renamed!', 1.5);
        _this.toggleRenameModal(false);
      }).catch(function (e) {
        _message3.default.error(e.message, 1.5);
      });
    }, _this.onCancelRename = function () {
      _this.toggleRenameModal(false);
      _this.setState({
        rename: null
      });
    }, _this.onChangeRename = function (e) {
      _this.setState({
        rename: e.target.value
      });
    }, _this.toggleRenameModal = function (toShow, macroNode) {
      _this.setState({
        showRename: toShow,
        renameTcId: macroNode && macroNode.fullPath
      });

      if (toShow) {
        setTimeout(function () {
          var input = _this.inputRenameTestCase.refs.input;
          input.focus();
          input.selectionStart = input.selectionEnd = input.value.length;
        }, 100);
      }
    }, _this.changeTestCase = function (id) {
      return new _promise2.default(function (resolve) {
        if (_this.props.status !== C.APP_STATUS.NORMAL) return resolve(false);
        if (_this.props.editing.meta.src && _this.props.editing.meta.src.id === id) return resolve(true);

        var go = function go() {
          _this.props.editTestCase(id);
          resolve(true);
        };

        // Do not ask for save if it's currently on Untitled and no commands in it
        if (_this.props.editing.commands.length === 0 && !_this.props.editing.meta.src) {
          return go();
        }

        return (0, _save_test_case2.default)().saveOrNot().then(go);
      });
    }, _this.playTestCase = function (id) {
      if (_this.props.status !== C.APP_STATUS.NORMAL) return;

      _this.changeTestCase(id).then(function (shouldPlay) {
        if (!shouldPlay) return;

        setTimeout(function () {
          var commands = _this.props.editing.commands;

          var openTc = commands.find(function (item) {
            return item.cmd.toLowerCase() === 'open';
          });
          var src = _this.props.editing.meta.src;

          var getMacroName = function getMacroName() {
            return src && src.name && src.name.length ? src.name : 'Untitled';
          };
          var getMacroId = function getMacroId() {
            return src ? src.id : C.UNTITLED_ID;
          };

          _this.props.playerPlay({
            macroId: getMacroId(),
            title: getMacroName(),
            extra: { id: getMacroId() },
            mode: (0, _player.getPlayer)().C.MODE.STRAIGHT,
            startIndex: 0,
            startUrl: openTc ? openTc.target : null,
            resources: commands,
            postDelay: _this.props.player.playInterval * 1000
          });
        }, 500);
      });
    }, _this.onJsonOrZipFileChange = function (e) {
      setTimeout(function () {
        _this.jsonFileInput.value = null;
      }, 500);

      return _this.props.importMacroJsonOrZipFiles(e.target.files, _this.state.folderToImport);
    }, _this.addTestCase = function () {
      return (0, _save_test_case2.default)().saveOrNot().then(function () {
        _this.props.macroCreateFile({
          dir: '/'
        });
      });
    }, _this.onClickMacroNode = function (data, paths, e) {
      if (data.type === _tree_file.FileNodeType.File) {
        _this.changeTestCase(data.id);
      }
    }, _this.onContextMenuNode = function (data, paths, e) {
      return _this.showContextMenuForEntry(data, e);
    }, _this.onToggleNode = function (data, paths) {
      return _this.props.updateMacroExtra(data.id, { folded: !data.folded });
    }, _this.onMoveNode = function (sourceId, targetId, isDirectory) {
      _this.props.macroMoveEntry({
        entryId: sourceId,
        dirId: targetId,
        isSourceDirectory: isDirectory
      });
    }, _this.onDoubleClickNode = function (data, paths, e) {
      if (data.type === _tree_file.FileNodeType.File) {
        _this.playTestCase(data.id);
      }
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  // Rename relative


  (0, _createClass3.default)(SidebarTestCases, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.bindKeydown();
    }
  }, {
    key: 'bindKeydown',
    value: function bindKeydown() {
      var _this2 = this;

      var fn = function fn(e) {
        if (!_this2.props.canUseKeyboardShortcuts) {
          return;
        }

        if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey) {
          return;
        }

        switch ((0, _keycode2.default)(e)) {
          case 'up':
            e.preventDefault();
            return _this2.props.editMacroByOffset(-1);

          case 'down':
            e.preventDefault();
            return _this2.props.editMacroByOffset(1);
        }
      };

      document.addEventListener('keydown', fn, true);
      this.unbindKeydown = function () {
        return document.removeEventListener('keydown', fn, true);
      };
    }
  }, {
    key: 'renderMacros',
    value: function renderMacros() {
      var filteredMacroFileNodeData = this.props.filteredMacroFileNodeData;


      if (this.props.isLoadingMacros && this.props.isMacroFolderNodeListEmpty) {
        return _react2.default.createElement(
          'div',
          { className: 'no-data' },
          'Loading macros...'
        );
      }

      return _react2.default.createElement(
        'div',
        { className: 'sidebar-macros' },
        filteredMacroFileNodeData.length === 0 ? _react2.default.createElement(
          'div',
          { className: 'no-data' },
          'No macro found'
        ) : null,
        _react2.default.createElement(_tree_file.FileTree, {
          nodes: filteredMacroFileNodeData,
          rootPath: (0, _storage.getStorageManager)().getMacroStorage().dirPath(''),
          onClick: this.onClickMacroNode,
          onContextMenu: this.onContextMenuNode,
          onToggle: this.onToggleNode,
          onMove: this.onMoveNode,
          onDoubleClick: this.onDoubleClickNode
        })
      );
    }
  }, {
    key: 'showContextMenuForEntry',
    value: function showContextMenuForEntry(entry, e) {
      switch (entry.type) {
        case _tree_file.FileNodeType.File:
          return this.showContextMenuForMacro(entry, e);

        case _tree_file.FileNodeType.Folder:
          return this.showContextMenuForFolder(entry, e);
      }
    }
  }, {
    key: 'showContextMenuForFolder',
    value: function showContextMenuForFolder(folderEntry, e) {
      var _this3 = this;

      e.stopPropagation();
      e.preventDefault();

      return (0, _context_menu.showContextMenu)({
        x: e.clientX,
        y: e.clientY,
        onHide: function onHide() {},
        menuItems: [{
          type: _context_menu.MenuItemType.Button,
          disabled: !(0, _license.getLicenseService)().canPerform(_types.Feature.Edit),
          data: {
            content: 'New macro',
            onClick: function onClick() {
              return (0, _save_test_case2.default)().saveOrNot().then(function () {
                _this3.props.macroCreateFile({
                  dir: folderEntry.entryPath
                });
              });
            }
          }
        }, {
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'New folder',
            onClick: function onClick() {
              _this3.props.macroCreateFolder({
                name: 'untitled',
                dir: folderEntry.entryPath
              });
            }
          }
        }, {
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'Rename',
            onClick: function onClick() {
              _this3.props.macroRenameFolder({
                dir: folderEntry.entryPath
              });
            }
          }
        }, {
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'Delete',
            onClick: function onClick() {
              _this3.props.macroDeleteFolder({
                dir: folderEntry.entryPath
              });
            }
          }
        }, {
          type: _context_menu.MenuItemType.Divider,
          data: {}
        }, {
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'Testsuite: Play all in folder',
            onClick: function onClick() {
              var folderName = folderEntry.name;
              var macros = folderEntry.children.filter(function (item) {
                return item.type === _tree_file.FileNodeType.File;
              });

              (0, _player.getPlayer)({ name: 'testSuite' }).play({
                title: folderName,
                mode: (0, _player.getPlayer)().C.MODE.STRAIGHT,
                startIndex: 0,
                resources: macros.map(function (item) {
                  return {
                    id: item.id,
                    loops: 1
                  };
                }),
                extra: {
                  id: folderEntry.id,
                  name: folderName
                }
              });
            }
          }
        }, {
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'Testsuite: Play in loop',
            onClick: function onClick() {
              var playInLoops = function playInLoops(loopsStr) {
                var loops = parseInt(loopsStr);

                if (isNaN(loops) || loops < 1) {
                  throw new Error('Invalid loops: ' + loopsStr);
                }

                var folderName = folderEntry.name;
                var macros = folderEntry.children.filter(function (item) {
                  return item.type === _tree_file.FileNodeType.File;
                });

                (0, _player.getPlayer)({ name: 'testSuite' }).play({
                  title: folderName,
                  mode: loops === 1 ? (0, _player.getPlayer)().C.MODE.STRAIGHT : (0, _player.getPlayer)().C.MODE.LOOP,
                  loopsStart: 1,
                  loopsEnd: loops,
                  startIndex: 0,
                  resources: macros.map(function (item) {
                    return {
                      id: item.id,
                      loops: 1
                    };
                  }),
                  extra: {
                    id: folderEntry.id,
                    name: folderName
                  }
                });
              };

              var run = function run() {
                return (0, _prompt.prompt)({
                  width: 400,
                  title: 'How many loops?',
                  message: '',
                  value: '2',
                  placeholder: 'Loops',
                  inputType: 'number',
                  selectionStart: 0,
                  selectionEnd: 1,
                  okText: 'Play',
                  cancelText: 'Cancel',
                  onCancel: function onCancel() {
                    return _promise2.default.resolve(true);
                  },
                  onOk: playInLoops
                }).catch(function (e) {
                  _message3.default.error(e.message);
                  setTimeout(run, 0);
                });
              };

              return run();
            }
          }
        }, {
          type: _context_menu.MenuItemType.Divider,
          data: {}
        }, {
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'Import JSON or ZIP',
            onClick: function onClick() {
              var $selectFile = document.getElementById('select_json_files_for_macros');

              if ($selectFile) {
                _this3.setState({ folderToImport: folderEntry.entryPath });
                $selectFile.click();
              }
            }
          }
        }]
      });
    }
  }, {
    key: 'showContextMenuForMacro',
    value: function showContextMenuForMacro(macroEntry, event) {
      var _this4 = this;

      var macros = this.props.macros;

      var macroNode = macros.find(function (item) {
        return item.fullPath === macroEntry.id;
      });

      if (!macroNode) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();

      var e = {
        clientX: event.clientX,
        clientY: event.clientY,
        stopPropagation: function stopPropagation() {},
        preventDefault: function preventDefault() {}
      };

      return (0, _context_menu.showContextMenu)({
        x: e.clientX,
        y: e.clientY,
        onHide: function onHide() {},
        menuItems: [{
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'Play',
            onClick: function onClick() {
              _this4.playTestCase(macroNode.fullPath);
            }
          }
        }, {
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'Testsuite: Play from here',
            onClick: function onClick() {
              var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
              var path = macroStorage.getPathLib();
              var dirPath = path.dirname(macroEntry.entryPath);

              return macroStorage.list(dirPath).then(function (entries) {
                var macros = entries.filter(function (entry) {
                  return entry.isFile;
                });
                var index = macros.findIndex(function (macro) {
                  return macro.fullPath === macroEntry.entryPath;
                });

                if (index === -1) {
                  return;
                }

                var folderName = path.basename(dirPath);

                (0, _player.getPlayer)({ name: 'testSuite' }).play({
                  title: folderName,
                  mode: (0, _player.getPlayer)().C.MODE.STRAIGHT,
                  startIndex: index,
                  resources: macros.map(function (item) {
                    return {
                      id: item.fullPath,
                      loops: 1
                    };
                  }),
                  extra: {
                    id: dirPath,
                    name: folderName
                  }
                });
              });
            }
          }
        }, {
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'Rename..',
            onClick: function onClick() {
              return (0, _save_test_case2.default)().saveOrNot().then(function () {
                _this4.setState({
                  rename: macroNode.name
                });
                _this4.toggleRenameModal(true, macroNode);
              });
            }
          }
        }, {
          type: _context_menu.MenuItemType.Button,
          disabled: !(0, _license.getLicenseService)().canPerform(_types.Feature.Edit),
          data: {
            content: 'Duplicate..',
            onClick: function onClick() {
              return (0, _save_test_case2.default)().saveOrNot().then(function () {
                _this4.props.duplicateTestCase(macroNode);
              });
            }
          }
        }, {
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'Export as JSON',
            onClick: function onClick() {
              _this4.props.downloadMacroAsJson(macroNode.fullPath);
            }
          }
        }, {
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'Export as ZIP (json, img & csv)',
            onClick: function onClick() {
              _this4.props.downloadMacroAsZip(macroNode.fullPath);
            }
          }
        }, {
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'Create autorun HTML',
            onClick: function onClick() {
              if (!_web_extension2.default.isFirefox()) {
                _web_extension2.default.extension.isAllowedFileSchemeAccess().then(function (isAllowed) {
                  if (isAllowed) return;
                  var msg = 'To run macro from html file, you need to enable "Allow access to file URLs" in extension details page';
                  _message3.default.warn(msg);
                  _this4.props.addLog('warning', msg);
                });
              }

              function downloadUiVisionHtml() {
                var str = (0, _convert_utils.generateEmptyHtml)();
                var blob = new Blob([str], { type: 'text/plain;charset=utf-8' });

                _file_saver2.default.saveAs(blob, 'ui.vision.html', true);
              }

              function downloadEntryHtml(macroNode) {
                var str = (0, _convert_utils.generateMacroEntryHtml)(macroNode.relativePath);
                var blob = new Blob([str], { type: 'text/plain;charset=utf-8' });

                _file_saver2.default.saveAs(blob, 'start-' + macroNode.name + '.html', true);
              }

              downloadUiVisionHtml();
              downloadEntryHtml(macroNode);
            }
          }
        }, {
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'Add shortcut to bookmarks bar',
            onClick: function onClick() {
              var bookmarkTitle = window.prompt('Title for this bookmark', '#' + macroNode.name + '.rpa');
              if (bookmarkTitle === null) return;

              (0, _bookmark.createBookmarkOnBar)((0, _convert_utils.toBookmarkData)({
                bookmarkTitle: bookmarkTitle,
                path: macroNode.relativePath
              })).then(function () {
                _message3.default.success('successfully created bookmark!', 1.5);
              });
            }
          }
        }, (0, _storage.getStorageManager)().isXFileMode() ? {
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'Copy to Local Storage',
            onClick: function onClick() {
              (0, _storage.getStorageManager)().isStrategyTypeAvailable(_storage.StorageStrategyType.Browser).then(function () {
                var macroStorage = (0, _storage.getStorageManager)().getStorageForTarget(_storage.StorageTarget.Macro, _storage.StorageStrategyType.Browser);

                return (0, _storage.getStorageManager)().getStorageForTarget(_storage.StorageTarget.Macro, _storage.StorageStrategyType.XFile).read(macroNode.fullPath, 'Text').then(function (macro) {
                  var tcCopy = (0, _extends3.default)({}, macro, { id: (0, _ts_utils.uid)() });
                  delete tcCopy.status;

                  return macroStorage.write(tcCopy.name, tcCopy).then(function () {
                    return _message3.default.success('copied');
                  });
                });
              }).catch(function (e) {
                _message3.default.warn(e.message);
              });
            }
          }
        } : null, (0, _storage.getStorageManager)().isBrowserMode() ? {
          type: _context_menu.MenuItemType.Button,
          data: {
            content: 'Copy to Macro Folder',
            onClick: function onClick() {
              (0, _storage.getStorageManager)().isStrategyTypeAvailable(_storage.StorageStrategyType.XFile).then(function () {
                var macroStorage = (0, _storage.getStorageManager)().getStorageForTarget(_storage.StorageTarget.Macro, _storage.StorageStrategyType.XFile);

                return (0, _storage.getStorageManager)().getStorageForTarget(_storage.StorageTarget.Macro, _storage.StorageStrategyType.Browser).read(macroNode.fullPath, 'Text').then(function (macro) {
                  var tcCopy = (0, _extends3.default)({}, macro, { id: (0, _ts_utils.uid)() });
                  delete tcCopy.status;

                  return macroStorage.write(tcCopy.name, tcCopy).then(function () {
                    return _message3.default.success('copied');
                  });
                });
              }).catch(function (e) {
                _log2.default.error(e);
                _this4.props.updateUI({ showXFileNotInstalledDialog: 1 });
              });
            }
          }
        } : null, {
          type: _context_menu.MenuItemType.Divider,
          data: {}
        }, {
          type: _context_menu.MenuItemType.Button,
          disabled: !(0, _license.getLicenseService)().canPerform(_types.Feature.Edit),
          data: {
            content: 'Delete',
            onClick: function onClick() {
              var go = function go() {
                return _this4.props.removeTestCase(macroNode.fullPath).then(function () {
                  _message3.default.success('successfully deleted!', 1.5);
                }).catch(function (e) {
                  _modal2.default.warning({
                    title: 'Failed to delete',
                    content: e.message
                  });
                });
              };

              _modal2.default.confirm({
                title: 'Sure to delete?',
                content: 'Do you really want to delete "' + macroNode.name + '"?',
                okText: 'Delete',
                cancelText: 'Cancel',
                onOk: go,
                onCancel: function onCancel() {}
              });
            }
          }
        }].filter(function (x) {
          return x;
        })
      });
    }
  }, {
    key: 'renderTestCaseMenu',
    value: function renderTestCaseMenu() {
      var _this5 = this;

      var onClickMenuItem = function onClickMenuItem(_ref2) {
        var key = _ref2.key;

        switch (key) {
          case 'new_macro_folder':
            {
              _this5.props.macroCreateFolder({
                name: 'untitled',
                dir: '/'
              });
              break;
            }

          case 'export_all_json':
            {
              var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
              var path = macroStorage.getPathLib();
              var zip = new _jszip2.default();
              var getFolder = function getFolder(relativePath, zipRoot) {
                var dirs = relativePath.split(/\/|\\/g);

                return dirs.reduce(function (prev, dir) {
                  return prev.folder(dir);
                }, zipRoot);
              };

              if (_this5.props.macros.length === 0) {
                return _message3.default.error('No saved macros to export', 1.5)(_templateObject);
              }

              return _promise2.default.all(_this5.props.macros.map(function (macroNode) {
                var dirPath = path.dirname(macroNode.relativePath);
                var fileName = path.basename(macroNode.relativePath);
                var folder = getFolder(dirPath, zip);

                return (0, _storage.getStorageManager)().getMacroStorage().read(macroNode.fullPath, 'Text').then(function (macro) {
                  folder.file(fileName, (0, _convert_utils.toJSONString)({
                    name: macro.name,
                    commands: macro.data.commands
                  }, {
                    ignoreTargetOptions: _this5.props.ignoreTargetOptions
                  }));
                });
              })).then(function () {
                return zip.generateAsync({ type: 'blob' }).then(function (blob) {
                  _file_saver2.default.saveAs(blob, 'all_test_cases.zip');
                });
              });
            }

          case 'import_json':
            {
              var $selectFile = document.getElementById('select_json_files_for_macros');

              if ($selectFile) {
                _this5.setState({ folderToImport: '/' });
                $selectFile.click();
              }

              break;
            }
        }
      };

      return _react2.default.createElement(
        _menu2.default,
        { onClick: onClickMenuItem, selectable: false },
        _react2.default.createElement(
          _menu2.default.Item,
          {
            key: 'new_macro_folder'
          },
          'New Folder'
        ),
        _react2.default.createElement(_menu2.default.Divider, null),
        _react2.default.createElement(
          _menu2.default.Item,
          {
            key: 'import_json'
          },
          'Import JSON or ZIP'
        )
      );
    }
  }, {
    key: 'renderRenameModal',
    value: function renderRenameModal() {
      var _this6 = this;

      return _react2.default.createElement(
        _modal2.default,
        {
          title: 'Rename the macro as..',
          okText: 'Save',
          cancelText: 'Cancel',
          visible: this.state.showRename,
          onOk: this.onClickRename,
          onCancel: this.onCancelRename,
          className: 'rename-modal'
        },
        _react2.default.createElement(_input2.default, {
          style: { width: '100%' },
          value: this.state.rename,
          onKeyDown: function onKeyDown(e) {
            e.keyCode === 13 && _this6.onClickRename();
          },
          onChange: this.onChangeRename,
          placeholder: 'macro name',
          ref: function ref(el) {
            _this6.inputRenameTestCase = el;
          }
        })
      );
    }
  }, {
    key: 'renderShowListAction',
    value: function renderShowListAction() {
      var _this7 = this;

      return _react2.default.createElement(_resource_not_loaded.ResourceNotLoaded, {
        name: 'Macro list',
        from: this.props.from,
        showList: function showList() {
          _this7.props.setFrom(_state.RunBy.Manual);
        }
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this8 = this;

      if (!this.props.shouldLoadResources) {
        return this.renderShowListAction();
      }

      if (this.props.isPlaying && this.props.macros.length > _config2.default.performanceLimit.fileCount) {
        return _react2.default.createElement(
          'div',
          { className: 'hidden-during-replay' },
          _messages2.default.contentHidden
        );
      }

      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement('input', {
          multiple: true,
          type: 'file',
          accept: '.json, .zip',
          id: 'select_json_files_for_macros',
          onChange: this.onJsonOrZipFileChange,
          ref: function ref(_ref3) {
            _this8.jsonFileInput = _ref3;
          },
          style: { display: 'none' }
        }),
        _react2.default.createElement(
          'div',
          { className: 'test-case-actions' },
          _react2.default.createElement(
            _button2.default,
            {
              type: 'primary',
              disabled: !(0, _license.getLicenseService)().canPerform(_types.Feature.Edit),
              onClick: this.addTestCase
            },
            '+ Macro'
          ),
          _react2.default.createElement(
            _dropdown2.default,
            {
              overlay: this.renderTestCaseMenu(),
              trigger: ['click']
            },
            _react2.default.createElement(
              _button2.default,
              { shape: 'circle' },
              _react2.default.createElement(_icon2.default, { type: 'folder-add' })
            )
          ),
          _react2.default.createElement(_search_box2.default, {
            style: { flex: 1 },
            inputProps: {
              placeholder: 'search macro',
              value: this.props.searchText,
              onChange: function onChange(e) {
                return _this8.props.setMacroQuery(e.target.value);
              }
            }
          })
        ),
        this.renderMacros(),
        this.renderRenameModal()
      );
    }
  }]);
  return SidebarTestCases;
}(_react2.default.Component);

exports["default"] = (0, _reactRedux.connect)(function (state) {
  return {
    status: state.status,
    from: state.from,
    shouldLoadResources: (0, _recomputed.getShouldLoadResources)(state),
    isLoadingMacros: state.isLoadingMacros,
    isMacroFolderNodeListEmpty: (0, _recomputed.isMacroFolderNodeListEmpty)(state),
    macroFileNodeData: (0, _recomputed.getMacroFileNodeData)(state),
    macros: (0, _recomputed.getMacroFileNodeList)(state),
    isPlaying: (0, _recomputed.isPlaying)(state),
    testSuites: state.editor.testSuites,
    editing: state.editor.editing,
    player: state.player,
    config: state.config,
    ignoreTargetOptions: (0, _recomputed.getShouldSaveAlternativeLocators)(state),
    searchText: state.macroQuery,
    filteredMacroFileNodeData: (0, _recomputed.getFilteredMacroFileNodeData)(state),
    canUseKeyboardShortcuts: (0, _recomputed.isFocusOnSidebar)(state) && state.ui.sidebarTab !== 'test_suites'
  };
}, function (dispatch) {
  return (0, _redux.bindActionCreators)((0, _extends3.default)({}, actions, _simple_actions.Actions), dispatch);
})(SidebarTestCases);

/***/ }),

/***/ 64248:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _input = __webpack_require__(51024);

var _input2 = _interopRequireDefault(_input);

var _select = __webpack_require__(64749);

var _select2 = _interopRequireDefault(_select);

var _alert = __webpack_require__(4863);

var _alert2 = _interopRequireDefault(_alert);

var _dropdown = __webpack_require__(82891);

var _dropdown2 = _interopRequireDefault(_dropdown);

var _icon = __webpack_require__(86245);

var _icon2 = _interopRequireDefault(_icon);

var _button = __webpack_require__(65400);

var _button2 = _interopRequireDefault(_button);

var _menu = __webpack_require__(12386);

var _menu2 = _interopRequireDefault(_menu);

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

var _modal = __webpack_require__(56697);

var _modal2 = _interopRequireDefault(_modal);

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _message2 = __webpack_require__(11187);

var _message3 = _interopRequireDefault(_message2);

var _getPrototypeOf = __webpack_require__(85105);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(49135);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(93196);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(67294);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(73935);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactRedux = __webpack_require__(33664);

var _redux = __webpack_require__(74127);

var _antd = __webpack_require__(56318);

var _reactClickOutside = __webpack_require__(48683);

var _reactClickOutside2 = _interopRequireDefault(_reactClickOutside);

var _jszip = __webpack_require__(55733);

var _jszip2 = _interopRequireDefault(_jszip);

var _web_extension = __webpack_require__(61171);

var _web_extension2 = _interopRequireDefault(_web_extension);

var _file_saver = __webpack_require__(18187);

var _file_saver2 = _interopRequireDefault(_file_saver);

var _actions = __webpack_require__(97876);

var actions = _interopRequireWildcard(_actions);

var _simple_actions = __webpack_require__(46469);

var _constant = __webpack_require__(43232);

var C = _interopRequireWildcard(_constant);

var _save_test_case = __webpack_require__(57879);

var _save_test_case2 = _interopRequireDefault(_save_test_case);

var _player = __webpack_require__(43625);

var _utils = __webpack_require__(63370);

var _convert_suite_utils = __webpack_require__(36832);

var _bookmark = __webpack_require__(75303);

var _edit_test_suite = __webpack_require__(92801);

var _edit_test_suite2 = _interopRequireDefault(_edit_test_suite);

var _editable_text = __webpack_require__(33890);

var _editable_text2 = _interopRequireDefault(_editable_text);

var _recomputed = __webpack_require__(78328);

var _ts_utils = __webpack_require__(55452);

var _recomputed2 = __webpack_require__(78328);

var _state = __webpack_require__(16112);

var _storage = __webpack_require__(16058);

var _resource_not_loaded = __webpack_require__(29102);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var downloadTestSuite = function downloadTestSuite(ts, macros) {
  var str = (0, _convert_suite_utils.stringifyTestSuite)({
    name: ts.name,
    cases: ts.cases
  });
  var blob = new Blob([str], { type: 'text/plain;charset=utf-8' });

  // Note: must add third param as true here to remove BOM for UTF8 files
  // reference: https://github.com/eligrey/FileSaver.js/issues/432
  _file_saver2.default.saveAs(blob, 'suite_' + ts.name + '.json', true);
};

var downloadTestSuiteAsHTML = function downloadTestSuiteAsHTML(ts) {
  var str = (0, _convert_suite_utils.toHtml)({ name: ts.name });
  var blob = new Blob([str], { type: 'text/plain;charset=utf-8' });

  _file_saver2.default.saveAs(blob, ts.name + '.html', true);
};

var SidebarTestSuites = function (_React$Component) {
  (0, _inherits3.default)(SidebarTestSuites, _React$Component);

  function SidebarTestSuites() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, SidebarTestSuites);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = SidebarTestSuites.__proto__ || (0, _getPrototypeOf2.default)(SidebarTestSuites)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      tsContextMenu: {
        x: null,
        y: null,
        isShown: false
      },

      tscContextMenu: {
        x: null,
        y: null,
        isShown: false
      },

      tsEditingNameIndex: -1,

      editTestSuiteSource: {
        ts: null,
        visible: false
      }
    }, _this.addTestSuite = function () {
      return (0, _ts_utils.uniqueName)('__Untitled__', {
        check: function check(fullName) {
          return !_this.props.testSuites.find(function (ts) {
            return ts.name === fullName;
          });
        }
      }).then(function (newTestSuiteName) {
        return _this.props.addTestSuite({
          name: newTestSuiteName,
          cases: []
        });
      }).catch(function (e) {
        _message3.default.error(e.message, 1.5);
      });
    }, _this.addTestCaseToTestSuite = function (ts) {
      _this.props.updateTestSuite(ts.id, {
        cases: ts.cases.concat({
          testCaseId: _this.props.macros[0] && _this.props.macros[0].relativePath,
          loops: 1
        })
      });
    }, _this.removeTestCaseFromTestSuite = function (ts, index) {
      ts.cases.splice(index, 1);

      _this.props.updateTestSuite(ts.id, {
        cases: ts.cases,
        playStatus: function () {
          var _ts$playStatus = ts.playStatus,
              playStatus = _ts$playStatus === undefined ? {} : _ts$playStatus;
          var _playStatus$doneIndic = playStatus.doneIndices,
              doneIndices = _playStatus$doneIndic === undefined ? [] : _playStatus$doneIndic,
              _playStatus$errorIndi = playStatus.errorIndices,
              errorIndices = _playStatus$errorIndi === undefined ? [] : _playStatus$errorIndi;

          var updateIndex = function updateIndex(n) {
            if (n === undefined) return -1;
            if (n === index) return -1;
            if (n > index) return n - 1;
            return n;
          };

          return {
            errorIndices: errorIndices.map(updateIndex).filter(function (i) {
              return i !== -1;
            }),
            doneIndices: doneIndices.map(updateIndex).filter(function (i) {
              return i !== -1;
            })
          };
        }()
      });
    }, _this.toggleTestSuiteFold = function (ts) {
      _this.props.updateTestSuite(ts.id, {
        fold: !ts.fold
      });
    }, _this.foldAllTestSuites = function () {
      _this.props.testSuites.forEach(function (ts) {
        _this.props.updateTestSuite(ts.id, {
          fold: true
        });
      });
    }, _this.onClickTestSuiteMore = function (e, ts, tsIndex) {
      e.stopPropagation();
      e.preventDefault();

      var updated = {
        tsContextMenu: {
          x: e.clientX,
          y: e.clientY,
          isShown: true,
          ts: ts,
          tsIndex: tsIndex
        }

        // Note: to make it work in Firefox, have to delay this new state a little bit
        // Because hideTcContextMenu could be executed at the same time via clickOutside
      };setTimeout(function () {
        return _this.setState(updated);
      }, 20);
    }, _this.onClickTsTestCaseMore = function (e, tc, tcIndex, ts, tsIndex) {
      e.stopPropagation();
      e.preventDefault();

      var updated = {
        tscContextMenu: {
          x: e.clientX,
          y: e.clientY,
          isShown: true,
          tc: tc,
          ts: ts,
          tcIndex: tcIndex,
          tsIndex: tsIndex
        }

        // Note: to make it work in Firefox, have to delay this new state a little bit
        // Because hideTcContextMenu could be executed at the same time via clickOutside
      };setTimeout(function () {
        return _this.setState(updated);
      }, 20);
    }, _this.hideTsContextMenu = function () {
      _this.setState({
        tsContextMenu: (0, _extends3.default)({}, _this.state.tsContextMenu, {
          isShown: false
        })
      });
    }, _this.hideTscContextMenu = function () {
      _this.setState({
        tscContextMenu: (0, _extends3.default)({}, _this.state.tscContextMenu, {
          isShown: false
        })
      });
    }, _this.onTsMenuClick = function (_ref2, ts, tsIndex) {
      var key = _ref2.key;

      _this.hideTsContextMenu();

      switch (key) {
        case 'play':
          (0, _player.getPlayer)({ name: 'testSuite' }).play({
            title: ts.name,
            extra: {
              id: ts.id,
              name: ts.name
            },
            mode: (0, _player.getPlayer)().C.MODE.STRAIGHT,
            startIndex: 0,
            resources: ts.cases.map(function (item) {
              return {
                id: item.testCaseId,
                loops: item.loops
              };
            })
          });
          break;

        case 'edit_source':
          _this.setState({
            editTestSuiteSource: {
              ts: ts,
              visible: true
            }
          });
          break;

        case 'rename':
          _this.setState({
            tsEditingNameIndex: tsIndex
          });
          break;

        case 'export':
          downloadTestSuite(ts, _this.props.macros);
          break;

        case 'create_bookmark':
          {
            var bookmarkTitle = prompt('Title for this bookmark', '#' + ts.name + '.rpa');
            if (bookmarkTitle === null) return;

            return (0, _bookmark.createBookmarkOnBar)((0, _convert_suite_utils.toBookmarkData)({
              bookmarkTitle: bookmarkTitle,
              name: ts.name
            })).then(function () {
              _message3.default.success('successfully created bookmark!', 1.5);
            });
          }

        case 'export_html':
          {
            if (!_web_extension2.default.isFirefox()) {
              _web_extension2.default.extension.isAllowedFileSchemeAccess().then(function (isAllowed) {
                if (isAllowed) return;
                var msg = 'To run test suite from html file, you need to enable "Allow access to file URLs" in extension details page';
                _message3.default.warn(msg);
                _this.props.addLog('warning', msg);
              });
            }

            return downloadTestSuiteAsHTML(ts);
          }

        case 'delete':
          _modal2.default.confirm({
            title: 'Are your sure to delete this test suite?',
            okText: 'Confirm',
            onOk: function onOk() {
              return _this.props.removeTestSuite(ts.id);
            }
          });
          break;
      }
    }, _this.onTscMenuClick = function (_ref3, tc, tcIndex, ts, tsIndex) {
      var key = _ref3.key;

      _this.hideTscContextMenu();

      switch (key) {
        case 'play_from_here':
          (0, _player.getPlayer)({ name: 'testSuite' }).play({
            title: ts.name,
            extra: {
              id: ts.id,
              name: ts.name
            },
            mode: (0, _player.getPlayer)().C.MODE.STRAIGHT,
            startIndex: tcIndex,
            resources: ts.cases.map(function (item) {
              return {
                id: item.testCaseId,
                loops: item.loops
              };
            })
          });
          break;
      }
    }, _this.onChangeTsName = function (val, ts, tsIndex) {
      _this.setState({
        tsEditingNameIndex: -1
      });

      return _this.props.updateTestSuite(ts.id, {
        name: val
      }).then(function () {
        return true;
      }, function (e) {
        _message3.default.error(e.message, 1.5);
        return false;
      });
    }, _this.onChangeTsCase = function (key, val, tcIndex, ts, tsIndex) {
      _this.props.updateTestSuite(ts.id, {
        cases: (0, _utils.setIn)([tcIndex, key], val, ts.cases)
      });
    }, _this.getTsTestCaseClass = function (tcIndex, tsPlayStatus) {
      if (!tsPlayStatus) return '';
      var _tsPlayStatus$doneInd = tsPlayStatus.doneIndices,
          doneIndices = _tsPlayStatus$doneInd === undefined ? [] : _tsPlayStatus$doneInd,
          _tsPlayStatus$errorIn = tsPlayStatus.errorIndices,
          errorIndices = _tsPlayStatus$errorIn === undefined ? [] : _tsPlayStatus$errorIn,
          currentIndex = tsPlayStatus.currentIndex;


      if (tcIndex === currentIndex) {
        return 'current-tc';
      } else if (errorIndices.indexOf(tcIndex) !== -1) {
        return 'error-tc';
      } else if (doneIndices.indexOf(tcIndex) !== -1) {
        return 'done-tc';
      } else {
        return '';
      }
    }, _this.onJSONFileChange = function (e) {
      setTimeout(function () {
        _this.jsonFileInput.value = null;
      }, 500);
      return _this.onReadFile(function (str) {
        return (0, _convert_suite_utils.parseTestSuite)(str);
      })(e);
    }, _this.onReadFile = function (process) {
      return function (e) {
        var files = [].slice.call(e.target.files);
        if (!files || !files.length) return;

        var read = function read(file) {
          return new _promise2.default(function (resolve, reject) {
            var reader = new FileReader();

            reader.onload = function (readerEvent) {
              try {
                var text = readerEvent.target.result;
                var obj = process(text, file.name);
                resolve({ data: obj });
              } catch (e) {
                resolve({ err: e, fileName: file.name });
              }
            };

            reader.readAsText(file);
          });
        };

        _promise2.default.all(files.map(read)).then(function (list) {
          var doneList = list.filter(function (x) {
            return x.data;
          });
          var failList = list.filter(function (x) {
            return x.err;
          });

          _this.props.addTestSuites(doneList.map(function (x) {
            return x.data;
          })).then(function (_ref4) {
            var passCount = _ref4.passCount,
                failCount = _ref4.failCount,
                failTcs = _ref4.failTcs;

            _message3.default.info([passCount + ' test suite' + (passCount > 1 ? 's' : '') + ' imported!', failList.length + failCount + ' test suite' + (failList.length + failCount > 1 ? 's' : '') + ' failed!'].join(', '), 3);

            failList.forEach(function (fail) {
              _this.props.addLog('error', 'in parsing ' + fail.fileName + ': ' + fail.err.message);
            });

            failTcs.forEach(function (fail) {
              _this.props.addLog('error', 'duplicated test suite name: ' + fail.name);
            });
          });
        });
      };
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  (0, _createClass3.default)(SidebarTestSuites, [{
    key: 'getPortalContainer',
    value: function getPortalContainer() {
      var id = '__context_menu_container__';
      var $el = document.getElementById(id);
      if ($el) return $el;

      var $new = document.createElement('div');
      $new.id = id;
      document.body.appendChild($new);
      return $new;
    }
  }, {
    key: 'renderTestSuiteContextMenu',
    value: function renderTestSuiteContextMenu() {
      var _this2 = this;

      var contextMenu = this.state.tsContextMenu;
      var mw = 230;
      var x = contextMenu.x + window.scrollX;
      var y = contextMenu.y + window.scrollY;

      if (x - mw > 0) x -= mw;

      var style = {
        position: 'absolute',
        top: y,
        left: x,
        display: contextMenu.isShown ? 'block' : 'none'
      };

      var menuStyle = {
        width: mw + 'px'
      };

      var content = _react2.default.createElement(
        'div',
        { style: style, className: 'context-menu' },
        _react2.default.createElement(
          _reactClickOutside2.default,
          { onClickOutside: this.hideTsContextMenu },
          _react2.default.createElement(
            _menu2.default,
            {
              onClick: function onClick(e) {
                return _this2.onTsMenuClick(e, contextMenu.ts, contextMenu.tsIndex);
              },
              style: menuStyle,
              mode: 'vertical',
              selectable: false
            },
            _react2.default.createElement(
              _menu2.default.Item,
              { key: 'play' },
              'Play'
            ),
            _react2.default.createElement(
              _menu2.default.Item,
              { key: 'edit_source' },
              'Edit source..'
            ),
            _react2.default.createElement(
              _menu2.default.Item,
              { key: 'rename' },
              'Rename..'
            ),
            _react2.default.createElement(
              _menu2.default.Item,
              { key: 'export' },
              'Export'
            ),
            _react2.default.createElement(
              _menu2.default.Item,
              { key: 'create_bookmark' },
              'Add to Bookmarks'
            ),
            _react2.default.createElement(_menu2.default.Divider, null),
            _react2.default.createElement(
              _menu2.default.Item,
              { key: 'delete' },
              'Delete'
            )
          )
        )
      );

      return _reactDom2.default.createPortal(content, this.getPortalContainer());
    }
  }, {
    key: 'renderTestSuiteCaseContextMenu',
    value: function renderTestSuiteCaseContextMenu() {
      var _this3 = this;

      var contextMenu = this.state.tscContextMenu;
      var mw = 150;
      var x = contextMenu.x + window.scrollX;
      var y = contextMenu.y + window.scrollY;

      if (x - mw > 0) x -= mw;

      var style = {
        position: 'absolute',
        top: y,
        left: x,
        display: contextMenu.isShown ? 'block' : 'none'
      };

      var menuStyle = {
        width: mw + 'px'
      };

      var content = _react2.default.createElement(
        'div',
        { style: style, className: 'context-menu' },
        _react2.default.createElement(
          _reactClickOutside2.default,
          { onClickOutside: this.hideTscContextMenu },
          _react2.default.createElement(
            _menu2.default,
            {
              onClick: function onClick(e) {
                return _this3.onTscMenuClick(e, contextMenu.tc, contextMenu.tcIndex, contextMenu.ts, contextMenu.tsIndex);
              },
              style: menuStyle,
              mode: 'vertical',
              selectable: false
            },
            _react2.default.createElement(
              _menu2.default.Item,
              { key: 'play_from_here' },
              'Replay from here'
            )
          )
        )
      );

      return _reactDom2.default.createPortal(content, this.getPortalContainer());
    }
  }, {
    key: 'renderTestSuiteMenu',
    value: function renderTestSuiteMenu() {
      var _this4 = this;

      var onClickMenuItem = function onClickMenuItem(_ref5) {
        var key = _ref5.key;

        switch (key) {
          case 'export_all':
            {
              var zip = new _jszip2.default();

              if (_this4.props.testSuites.length === 0) {
                return _message3.default.error('No saved test suites to export', 1.5);
              }

              var genName = (0, _utils.nameFactory)();

              _this4.props.testSuites.forEach(function (ts) {
                var name = genName(ts.name);
                zip.file(name + '.json', (0, _convert_suite_utils.stringifyTestSuite)(ts));
              });

              zip.generateAsync({ type: 'blob' }).then(function (blob) {
                _file_saver2.default.saveAs(blob, 'all_suites.zip');
              });

              break;
            }

          case 'import':
            {
              break;
            }
        }
      };

      return _react2.default.createElement(
        _menu2.default,
        { onClick: onClickMenuItem, selectable: false },
        _react2.default.createElement(
          _menu2.default.Item,
          { key: 'export_all' },
          'Export all (JSON)'
        ),
        _react2.default.createElement(
          _menu2.default.Item,
          { key: '4' },
          _react2.default.createElement(
            'label',
            { htmlFor: 'select_json_files_for_ts' },
            'Import JSON'
          ),
          _react2.default.createElement('input', {
            multiple: true,
            type: 'file',
            accept: '.json',
            id: 'select_json_files_for_ts',
            onChange: this.onJSONFileChange,
            style: { display: 'none' },
            ref: function ref(el) {
              _this4.jsonFileInput = el;
            }
          })
        )
      );
    }
  }, {
    key: 'renderEditTestSuiteSource',
    value: function renderEditTestSuiteSource() {
      var _this5 = this;

      if (!this.state.editTestSuiteSource.visible) return null;
      var ts = this.state.editTestSuiteSource.ts;
      var source = (0, _convert_suite_utils.stringifyTestSuite)(ts);

      return _react2.default.createElement(_edit_test_suite2.default, {
        visible: true,
        value: source,
        validate: function validate(text) {
          return (0, _convert_suite_utils.validateTestSuiteText)(text, _this5.props.macros);
        },
        onClose: function onClose() {
          return _this5.setState({ editTestSuiteSource: { visible: false } });
        },
        onChange: function onChange(text) {
          var newTestSuite = (0, _convert_suite_utils.parseTestSuite)(text);

          _this5.props.updateTestSuite(ts.id, newTestSuite);
          _this5.setState({ editTestSuiteSource: { visible: false } });
        }
      });
    }
  }, {
    key: 'renderTestSuites',
    value: function renderTestSuites() {
      var _this6 = this;

      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(
          'div',
          { className: 'test-suite-actions' },
          _react2.default.createElement(
            _button2.default,
            { type: 'primary', onClick: this.addTestSuite },
            '+ Test Suite'
          ),
          _react2.default.createElement(
            _button2.default,
            { type: 'default', onClick: this.foldAllTestSuites },
            'Fold'
          ),
          _react2.default.createElement(
            _dropdown2.default,
            { overlay: this.renderTestSuiteMenu(), trigger: ['click'] },
            _react2.default.createElement(
              _button2.default,
              { shape: 'circle' },
              _react2.default.createElement(_icon2.default, { type: 'setting' })
            )
          )
        ),
        !this.props.config.hidePlayTestSuiteTip && this.props.testSuites.length > 0 ? _react2.default.createElement(_alert2.default, {
          type: 'info',
          message: 'Right click to play test suite',
          onClose: function onClose() {
            _this6.props.updateConfig({
              hidePlayTestSuiteTip: true
            });
          },
          closable: true,
          showIcon: true,
          style: { margin: '10px', paddingRight: '30px' }
        }) : null,
        !this.props.config.hideFolderAsTestSuiteTip ? _react2.default.createElement(_alert2.default, {
          type: 'info',
          message: _react2.default.createElement(
            'span',
            null,
            'New: ',
            _react2.default.createElement(
              'a',
              { href: 'https://ui.vision/x/idehelp?help=folder_as_testsuites', target: '_blank' },
              'Use folders as test suites'
            )
          ),
          onClose: function onClose() {
            _this6.props.updateConfig({
              hideFolderAsTestSuiteTip: true
            });
          },
          closable: true,
          showIcon: true,
          style: { margin: '10px', paddingRight: '30px' }
        }) : null,
        this.props.testSuites.length === 0 ? _react2.default.createElement(
          'div',
          { className: 'no-data' },
          'No test suite'
        ) : null,
        _react2.default.createElement(
          'ul',
          { className: 'sidebar-test-suites' },
          this.props.testSuites.map(function (ts, tsIndex) {
            return _react2.default.createElement(
              'li',
              {
                key: ts.id,
                className: (0, _utils.cn)('test-suite-item ', {
                  fold: ts.fold,
                  playing: ts.playStatus && ts.playStatus.isPlaying
                })
              },
              _react2.default.createElement(
                'div',
                { className: 'test-suite-row',
                  onClick: function onClick() {
                    return _this6.toggleTestSuiteFold(ts);
                  },
                  onContextMenu: function onContextMenu(e) {
                    return _this6.onClickTestSuiteMore(e, ts, tsIndex);
                  }
                },
                _react2.default.createElement(_icon2.default, { type: ts.fold ? 'folder' : 'folder-open' }),
                _react2.default.createElement(_editable_text2.default, {
                  className: 'test-suite-title',
                  value: ts.name,
                  onChange: function onChange(val) {
                    return _this6.onChangeTsName(val, ts, tsIndex);
                  },
                  isEditing: tsIndex === _this6.state.tsEditingNameIndex,
                  inputProps: {
                    onClick: function onClick(e) {
                      return e.stopPropagation();
                    },
                    onContextMenu: function onContextMenu(e) {
                      return e.stopPropagation();
                    }
                  }
                }),
                tsIndex === _this6.state.tsEditingNameIndex ? null : _react2.default.createElement(_icon2.default, {
                  type: 'bars',
                  className: 'more-button',
                  onClick: function onClick(e) {
                    return _this6.onClickTestSuiteMore(e, ts, tsIndex);
                  }
                })
              ),
              ts.cases.length > 0 ? _react2.default.createElement(
                'ul',
                { className: 'test-suite-cases' },
                ts.cases.map(function (item, tcIndex) {
                  return _react2.default.createElement(
                    'li',
                    {
                      key: tcIndex,
                      className: _this6.getTsTestCaseClass(tcIndex, ts.playStatus),
                      onContextMenu: function onContextMenu(e) {
                        return _this6.onClickTsTestCaseMore(e, item, tcIndex, ts, tsIndex);
                      }
                    },
                    _react2.default.createElement(_icon2.default, {
                      type: 'file',
                      style: { marginRight: '10px', cursor: 'pointer' },
                      onClick: function onClick() {
                        var src = _this6.props.editing.meta.src;

                        var go = function go() {
                          _this6.props.editTestCase(item.testCaseId);
                          return _promise2.default.resolve();
                        };

                        return (0, _save_test_case2.default)().saveOrNot().then(go);
                      }
                    }),
                    _react2.default.createElement(
                      _select2.default,
                      {
                        showSearch: true,
                        optionFilterProp: 'children',
                        value: item.testCaseId,
                        onChange: function onChange(val) {
                          return _this6.onChangeTsCase('testCaseId', val, tcIndex, ts, tsIndex);
                        },
                        filterOption: function filterOption(input, data) {
                          return data.props.children.toLowerCase().indexOf(input.toLowerCase()) !== -1;
                        },
                        style: { flex: 1, marginRight: '10px', maxWidth: '50%' },
                        dropdownClassName: 'macros-dropdown'
                      },
                      _this6.props.macros.map(function (macro) {
                        return _react2.default.createElement(
                          _select2.default.Option,
                          { value: macro.relativePath, key: macro.relativePath },
                          macro.relativePath.replace(/\.json$/, '')
                        );
                      })
                    ),
                    _react2.default.createElement(_input2.default, {
                      type: 'number',
                      min: 1,
                      value: item.loops,
                      onChange: function onChange(e) {
                        return _this6.onChangeTsCase('loops', e.target.value.trim().length === 0 ? '1' : e.target.value, tcIndex, ts, tsIndex);
                      },
                      style: { width: '45px', marginRight: '10px' }
                    }),
                    _react2.default.createElement(_icon2.default, {
                      type: 'close',
                      style: { cursor: 'pointer' },
                      onClick: function onClick() {
                        return _this6.removeTestCaseFromTestSuite(ts, tcIndex);
                      }
                    })
                  );
                })
              ) : null,
              _react2.default.createElement(
                'div',
                { className: 'test-suite-more-actions' },
                _react2.default.createElement(
                  _button2.default,
                  {
                    type: 'default',
                    onClick: function onClick() {
                      return _this6.addTestCaseToTestSuite(ts);
                    }
                  },
                  '+ Macro'
                )
              )
            );
          })
        )
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _this7 = this;

      if (!this.props.shouldLoadResources) {
        return _react2.default.createElement(_resource_not_loaded.ResourceNotLoaded, {
          name: 'Test suite list',
          from: this.props.from,
          showList: function showList() {
            _this7.props.setFrom(_state.RunBy.Manual);
          }
        });
      }

      return _react2.default.createElement(
        'div',
        null,
        this.renderTestSuites(),
        this.renderTestSuiteContextMenu(),
        this.renderTestSuiteCaseContextMenu(),
        this.renderEditTestSuiteSource()
      );
    }
  }]);
  return SidebarTestSuites;
}(_react2.default.Component);

exports["default"] = (0, _reactRedux.connect)(function (state) {
  return {
    status: state.status,
    from: state.from,
    shouldLoadResources: (0, _recomputed2.getShouldLoadResources)(state),
    macros: (0, _recomputed.getMacroFileNodeList)(state),
    testSuites: (0, _recomputed.getTestSuitesWithAllInfo)(state),
    editing: state.editor.editing,
    player: state.player,
    config: state.config
  };
}, function (dispatch) {
  return (0, _redux.bindActionCreators)((0, _extends3.default)({}, actions, _simple_actions.Actions), dispatch);
})(SidebarTestSuites);

/***/ }),

/***/ 55579:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _slicedToArray2 = __webpack_require__(12424);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _defineProperty2 = __webpack_require__(88106);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _stringify = __webpack_require__(63239);

var _stringify2 = _interopRequireDefault(_stringify);

var _message2 = __webpack_require__(11187);

var _message3 = _interopRequireDefault(_message2);

var _keys = __webpack_require__(88902);

var _keys2 = _interopRequireDefault(_keys);

var _toConsumableArray2 = __webpack_require__(85315);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _extends3 = __webpack_require__(88239);

var _extends4 = _interopRequireDefault(_extends3);

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

var _localeProvider = __webpack_require__(53594);

var _localeProvider2 = _interopRequireDefault(_localeProvider);

var _react = __webpack_require__(67294);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(73935);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactRouterDom = __webpack_require__(27597);

var _antd = __webpack_require__(56318);

var _en_US = __webpack_require__(64868);

var _en_US2 = _interopRequireDefault(_en_US);

var _reactDndHtml5Backend = __webpack_require__(93557);

var _reactDndHtml5Backend2 = _interopRequireDefault(_reactDndHtml5Backend);

var _reactDnd = __webpack_require__(84785);

var _fuzzyset = __webpack_require__(54263);

var _fuzzyset2 = _interopRequireDefault(_fuzzyset);

var _semver = __webpack_require__(36625);

var _semver2 = _interopRequireDefault(_semver);

var _config = __webpack_require__(62275);

var _config2 = _interopRequireDefault(_config);

var _path = __webpack_require__(84037);

var _path2 = _interopRequireDefault(_path);

var _file_saver = __webpack_require__(18187);

var _file_saver2 = _interopRequireDefault(_file_saver);

var _app = __webpack_require__(29541);

var _app2 = _interopRequireDefault(_app);

var _redux = __webpack_require__(56819);

var _init_player = __webpack_require__(42322);

var _web_extension = __webpack_require__(61171);

var _web_extension2 = _interopRequireDefault(_web_extension);

var _ipc_cs = __webpack_require__(41471);

var _ipc_cs2 = _interopRequireDefault(_ipc_cs);

var _storage = __webpack_require__(16058);

var _cs_timeout = __webpack_require__(28411);

var _storage2 = __webpack_require__(92687);

var _xfile = __webpack_require__(1577);

var _test_case_model = __webpack_require__(77278);

var _test_suite_model = __webpack_require__(64580);

var _storage3 = __webpack_require__(67585);

var _storage4 = _interopRequireDefault(_storage3);

var _utils = __webpack_require__(63370);

var _ts_utils = __webpack_require__(55452);

var _convert_utils = __webpack_require__(61169);

var _constant = __webpack_require__(43232);

var C = _interopRequireWildcard(_constant);

var _log = __webpack_require__(77242);

var _log2 = _interopRequireDefault(_log);

var _macro_log = __webpack_require__(41010);

var _variables = __webpack_require__(52476);

var _player = __webpack_require__(43625);

var _save_test_case = __webpack_require__(57879);

var _save_test_case2 = _interopRequireDefault(_save_test_case);

var _actions = __webpack_require__(97876);

var _download_man = __webpack_require__(89412);

var _macro_extra_data = __webpack_require__(24577);

var _test_suite_extra_data = __webpack_require__(34945);

var _04_01_macro_suite_storage = __webpack_require__(93915);

var _migration = __webpack_require__(93298);

var _types = __webpack_require__(36402);

var _simple_actions = __webpack_require__(46469);

var _log3 = __webpack_require__(30399);

var _recomputed = __webpack_require__(78328);

var _state = __webpack_require__(16112);

var _license = __webpack_require__(53678);

var _delegate = __webpack_require__(52152);

var _capture_screenshot = __webpack_require__(89145);

var _ipc_cache = __webpack_require__(54105);

var _tab_utils = __webpack_require__(96836);

var _timeout_counter = __webpack_require__(82759);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global PREINSTALL_CSV_LIST PREINSTALL_VISION_LIST */

(0, _cs_timeout.polyfillTimeoutFunctions)(_ipc_cs2.default);

(0, _delegate.handleDelegatedBrowserFileSystemAPI)();

var store = (0, _redux.createStore)(_redux.reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());

var captureScreenshotService = new _capture_screenshot.CaptureScreenshotService({
  captureVisibleTab: function captureVisibleTab(windowId, options) {
    return _ipc_cs2.default.ask('PANEL_CAPTURE_VISIBLE_TAB', { windowId: windowId, options: options });
  }
});

// FIXME: better not passing store via `window` object
window['store'] = store;

var rootEl = document.getElementById('root');
var render = function render(Component) {
  return _reactDom2.default.render(_react2.default.createElement(
    _reactDnd.DndProvider,
    { backend: _reactDndHtml5Backend2.default },
    _react2.default.createElement(
      _localeProvider2.default,
      { locale: _en_US2.default },
      _react2.default.createElement(
        _redux.Provider,
        { store: store },
        _react2.default.createElement(
          _reactRouterDom.HashRouter,
          null,
          _react2.default.createElement(_app2.default, null)
        )
      )
    )
  ), rootEl);
};

var timestampCache = {};
var DURATION = 2000;

// Note: listen to any db changes and restore all data from db to redux store
// All test cases are stored in indexeddb (dexie)
var bindMacroAndTestSuites = function bindMacroAndTestSuites() {
  var curStorageMode = (0, _storage.getStorageManager)().getCurrentStrategyType();
  var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
  var suiteStorage = (0, _storage.getStorageManager)().getTestSuiteStorage();
  var onError = function onError(errorList) {
    errorList.filter(function (item) {
      return item.fileName !== '__Untitled__';
    }).forEach(function (errorItem) {
      var key = errorItem.fullFilePath;

      if (!timestampCache[key] || new Date() * 1 - timestampCache[key] > DURATION) {
        timestampCache[key] = new Date() * 1;
        store.dispatch((0, _actions.addLog)('warning', errorItem.error.message));
      }
    });
  };

  var restoreTestCases = function restoreTestCases() {
    store.dispatch(_simple_actions.Actions.setIsLoadingMacros(true));

    var pMacrosExtra = (0, _macro_extra_data.getMacroExtraKeyValueData)().getAll().then(function (data) {
      (0, _log2.default)('restoreMacrosExtra', data);

      store.dispatch((0, _actions.setMacrosExtra)(data));
    });

    var pFolderStructure = function () {
      if (!(0, _recomputed.getShouldLoadResources)(store.getState())) {
        return _promise2.default.resolve();
      }

      return macroStorage.listR().then(function (entryNodes) {
        (0, _log2.default)('restoreMacroFolderStructure', entryNodes);

        store.dispatch(_simple_actions.Actions.setMacroFolderStructure(entryNodes));
      });
    }();

    return _promise2.default.all([pMacrosExtra, pFolderStructure]).finally(function () {
      return store.dispatch(_simple_actions.Actions.setIsLoadingMacros(false));
    });
  };

  var restoreTestSuites = function restoreTestSuites() {
    if (!(0, _recomputed.getShouldLoadResources)(store.getState())) {
      return _promise2.default.resolve();
    }

    return (0, _ts_utils.until)('macros', function () {
      var macroFolderStructure = store.getState().editor.macroFolderStructure;


      return {
        pass: macroFolderStructure.length >= 0,
        result: true
      };
    }).then(function () {
      var pTestSuites = suiteStorage.readR('/', 'Text', onError).then(function (items) {
        return items.map(function (item) {
          return (0, _test_suite_model.normalizeTestSuite)(item.content);
        });
      }).then(function (tss) {
        tss.sort(function (a, b) {
          var aname = a.name.toLowerCase();
          var bname = b.name.toLowerCase();

          if (aname < bname) return -1;
          if (aname > bname) return 1;
          if (aname === bname) {
            return b.updateTime - a.updateTime;
          }
        });

        (0, _log2.default)('restoreTestSuites - suiteStorage - tss', tss);

        store.dispatch((0, _actions.setTestSuites)(tss));
      });

      var pTestSuitesExtra = (0, _test_suite_extra_data.getTestSuiteExtraKeyValueData)().getAll().then(function (data) {
        (0, _log2.default)('restoreTestSuitesExtra', data);

        store.dispatch((0, _actions.setTestSuitesExtra)(data));
      });

      var pFolderStructure = suiteStorage.listR().then(function (entryNodes) {
        (0, _log2.default)('restoreTestSuiteFolderStructure', entryNodes);

        store.dispatch(_simple_actions.Actions.setTestSuiteFolderStructure(entryNodes));
      });

      return _promise2.default.all([pTestSuites, pTestSuitesExtra, pFolderStructure]);
    });
  }

  // FIXME: need to unbind previous listeners when bindMacroAndTestSuites is called for more than once
  ;[_storage2.FlatStorageEvent.ListChanged, _storage2.FlatStorageEvent.FilesChanged].forEach(function (eventName) {
    macroStorage.off(eventName);
    macroStorage.on(eventName, function () {
      if (curStorageMode !== (0, _storage.getStorageManager)().getCurrentStrategyType()) return;
      (0, _log2.default)('macroStorage - eventName', eventName);
      setTimeout(restoreTestCases, 50);
    });
  });[_storage2.FlatStorageEvent.ListChanged, _storage2.FlatStorageEvent.FilesChanged].forEach(function (eventName) {
    suiteStorage.off(eventName);
    suiteStorage.on(eventName, function () {
      if (curStorageMode !== (0, _storage.getStorageManager)().getCurrentStrategyType()) return;
      (0, _log2.default)('suiteStorage - eventName', eventName);
      setTimeout(restoreTestSuites, 50);
    });
  });

  return (0, _ts_utils.flow)((0, _ts_utils.guardVoidPromise)(restoreTestCases), (0, _ts_utils.guardVoidPromise)(restoreTestSuites));
};

// Note: editing is stored in localstorage
var restoreEditing = function restoreEditing() {
  return _storage4.default.get('editing').then(function (editing) {
    if (!editing) return;

    var finalEditing = editing;

    if (editing.baseUrl) {
      finalEditing = (0, _extends4.default)({}, editing);
      finalEditing.commands = finalEditing.commands.map((0, _test_case_model.commandWithoutBaseUrl)(editing.baseUrl));
      delete finalEditing.baseUrl;
    }

    store.dispatch((0, _actions.setEditing)(finalEditing));
  });
};

var restoreConfig = function restoreConfig() {
  return _storage4.default.get('config').then(function (config) {
    var cfg = (0, _extends4.default)({
      showSidebar: true,
      showBottomArea: true,
      playScrollElementsIntoView: true,
      playHighlightElements: true,
      playCommandInterval: 0.3,
      // selenium related
      saveAlternativeLocators: true,
      recordNotification: true,
      recordClickType: 'click',
      showTestCaseTab: true,
      logFilter: 'All',
      onErrorInLoop: 'continue_next_loop',
      // Run macros from outside
      allowRunFromBookmark: true,
      allowRunFromFileSchema: true,
      allowRunFromHttpSchema: true,
      // timeout in seconds
      timeoutPageLoad: 60,
      timeoutElement: 10,
      timeoutMacro: 0,
      timeoutDownload: 60,
      // backup relative
      lastBackupActionTime: new Date() * 1,
      enableAutoBackup: true,
      autoBackupInterval: 7,
      autoBackupTestCases: true,
      autoBackupTestSuites: true,
      autoBackupScreenshots: true,
      autoBackupCSVFiles: true,
      autoBackupVisionImages: true,
      // security relative
      shouldEncryptPassword: 'no',
      masterPassword: '',
      // variable relative
      showCommonInternalVariables: true,
      showAdvancedInternalVariables: false,
      // xmodules related
      storageMode: _storage.StorageStrategyType.Browser,
      xmodulesStatus: 'unregistered',
      // orc related
      ocrEngine: 1,
      ocrMode: 'disabled',
      ocrLanguage: 'eng',
      ocrOfflineURL: '',
      ocrOfflineAPIKey: '',
      // vision related
      cvScope: 'browser',
      defaultVisionSearchConfidence: 0.6,
      useDesktopScreenCapture: true,
      waitBeforeDesktopScreenCapture: false,
      secondsBeforeDesktopScreenCapture: 3,
      // proxy related,
      defaultProxy: '',
      defaultProxyAuth: '',
      turnOffProxyAfterReplay: true
    }, config);
    store.dispatch((0, _actions.updateConfig)(cfg));
    return cfg;
  });
};

var restoreCSV = function restoreCSV() {
  if (!(0, _recomputed.getShouldLoadResources)(store.getState())) {
    return _promise2.default.resolve();
  }

  // Note: just try to init storage. Eg. For browser fs, it will try to create root folder
  (0, _storage.getStorageManager)().getCSVStorage();
  return store.dispatch((0, _actions.listCSV)());
};

var restoreScreenshots = function restoreScreenshots() {
  (0, _storage.getStorageManager)().getScreenshotStorage();
  return store.dispatch((0, _actions.listScreenshots)());
};

var restoreVisions = function restoreVisions() {
  if (!(0, _recomputed.getShouldLoadResources)(store.getState())) {
    return _promise2.default.resolve();
  }

  (0, _storage.getStorageManager)().getVisionStorage();
  return store.dispatch((0, _actions.listVisions)());
};

var downloadTextFile = function downloadTextFile(text, fileName) {
  var blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
  _file_saver2.default.saveAs(blob, fileName);
};

var prepareBeforeRun = function prepareBeforeRun(options) {
  if (options.savelog) {
    store.dispatch((0, _actions.clearLogs)());
  }
};

var genPlayerPlayCallback = function genPlayerPlayCallback(_ref) {
  var options = _ref.options;

  // Only run this callback once, we've added it to two places
  // 1. Player callback
  // 2. Promise finally of the entire macro run
  var alreadyRun = false;

  return function (err, reason) {
    if (alreadyRun) {
      return;
    }

    alreadyRun = true;

    var pSaveLog = (0, _utils.delay)(function () {}, 1000);

    if (options.savelog) {
      var isFullPath = /\\|\//.test(options.savelog);
      var logs = store.getState().logs;
      var errorLog = logs.find(function (log) {
        return log.type === 'error' && !(log.options && log.options.ignored);
      });
      var error = err || errorLog && { message: errorLog.text };
      var logTitle = error ? 'Status=Error: ' + error.message : 'Status=OK';
      var logContent = logs.map(function (log) {
        return (0, _macro_log.renderLog)(log, false);
      });
      var text = [logTitle, '###'].concat((0, _toConsumableArray3.default)(logContent)).join('\n');

      if (!isFullPath || !(0, _storage.getStorageManager)().isXFileMode()) {
        pSaveLog = (0, _utils.delay)(function () {}, 500).then(function () {
          downloadTextFile(text, decodeURIComponent(options.savelog));
          // Note: We have to wait until savelog download completes if there is any
          return (0, _download_man.getDownloadMan)().prepareDownload(options.savelog);
        });
      } else {
        pSaveLog = (0, _log3.getLogService)().logTo(options.savelog, text);
      }
    }

    var closeBrowser = (0, _ts_utils.parseBoolLike)(options.closeBrowser, false);
    var closeRPA = (0, _ts_utils.parseBoolLike)(options.closeRPA !== undefined ? options.closeRPA : options.closeKantu, true);

    if (closeBrowser && reason !== _player.Player.C.END_REASON.MANUAL) {
      // Close all tabs If close option is set
      pSaveLog.catch(function (e) {
        _log2.default.warn('Save log error: ', e.message);
      }).then(function () {
        return _ipc_cs2.default.ask('PANEL_CLOSE_ALL_WINDOWS', {});
      });
    }

    // Note: it's better to keep kantu open if it's opened manually before
    if (!err && reason === _player.Player.C.END_REASON.COMPLETE && closeRPA && !closeBrowser) {
      // Close kantu panel
      setTimeout(function () {
        window.close();
      }, 1000);
    }
  };
};

var genOverrideScope = function genOverrideScope(_ref2) {
  var options = _ref2.options;

  return (0, _keys2.default)(options || {}).reduce(function (prev, key) {
    var m = key.match(/^cmd_var(1|2|3)$/i);
    if (!m) return prev;

    prev['!CMD_VAR' + m[1]] = options[key];
    return prev;
  }, {});
};

var validParams = ['direct', 'closeBrowser', 'closeKantu', 'closeRPA', 'continueInLastUsedTab', 'nodisplay', 'folder', 'savelog', 'storage', 'macro', 'testsuite', 'storageMode', 'loadmacrotree', 'cmd_var1', 'cmd_var2', 'cmd_var3', 'cmd_var4', 'cmd_var5', 'cmd_var6', 'cmd_var7', 'cmd_var8', 'cmd_var9', 'cmd_var10'];

var fuzzyObj = new _fuzzyset2.default(validParams);

var initFromCommandLineArgs = function initFromCommandLineArgs(args) {
  var loadMacroTree = (0, _ts_utils.parseBoolLike)(args.loadmacrotree);
  var noDisplay = (0, _ts_utils.parseBoolLike)(args.nodisplay, false);

  if (loadMacroTree) {
    store.dispatch(_simple_actions.Actions.setFrom(_state.RunBy.Manual));
  }

  if (noDisplay) {
    store.dispatch(_simple_actions.Actions.setNoDisplayInPlay(true));
  }
};

var guardCommandLineArgs = function guardCommandLineArgs(args, storageMode) {
  // Check params
  var keys = (0, _keys2.default)(args);
  var checkName = function checkName(pattern, str) {
    if (typeof pattern === 'string') {
      return pattern === str;
    } else {
      return pattern.test(str);
    }
  };
  var checkValue = function checkValue(name, value) {
    switch (name) {
      case 'continueInLastUsedTab':
      case 'closeKantu':
      case 'closeRPA':
      case 'closeBrowser':
      case 'direct':
      case 'loadmacrotree':
      case 'nodisplay':
        if (/^0|1|true|false$/i.test(value)) {
          return true;
        } else {
          throw new Error('"' + name + '" should be 0, 1, true or false, but now it\'s ' + value);
        }

      case 'storage':
        if (['browser', 'xfile'].indexOf(value) !== -1) {
          return true;
        } else {
          throw new Error('"' + name + '" should be either browser or xfile, but now it\'s ' + value);
        }

      default:
        return true;
    }
  };

  keys.forEach(function (key) {
    if (key.trim().length === 0) {
      return;
    }

    var isValid = validParams.find(function (name) {
      return checkName(name, key);
    });

    if (!isValid) {
      var match = fuzzyObj.get(key);
      var guess = !match || !match[0] || !match[0][1] ? '' : ', do you mean "' + match[0][1] + '"?';
      store.dispatch((0, _actions.addLog)('warning', 'Unknown command line parameter: "' + key + '"' + guess));
    }

    try {
      checkValue(key, args[key]);
    } catch (e) {
      store.dispatch((0, _actions.addLog)('warning', 'Invalid value for cmd line arg: ' + e.message));
    }
  });
};

var bindIpcEvent = function bindIpcEvent() {
  var prepareByOptions = function prepareByOptions() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var lowerCaseOptions = (0, _keys2.default)(options).reduce(function (prev, key) {
      prev[key.toLowerCase()] = options[key];
      return prev;
    }, {});

    if ((0, _ts_utils.parseBoolLike)(lowerCaseOptions.continueinlastusedtab, false)) {
      return _ipc_cs2.default.ask('PANEL_CLOSE_CURRENT_TAB_AND_SWITCH_TO_LAST_PLAYED');
    } else {
      return _promise2.default.resolve();
    }
  };

  var handleCommand = function handleCommand(cmd, args) {
    (0, _log2.default)(cmd, args);

    switch (cmd) {
      case 'PROXY_UPDATE':
        {
          store.dispatch((0, _actions.updateProxy)(args.proxy));
          return true;
        }

      case 'OPEN_SETTINGS':
        store.dispatch((0, _actions.updateUI)({ showSettings: true }));
        return true;

      case 'INSPECT_RESULT':
        store.dispatch((0, _actions.doneInspecting)());
        store.dispatch((0, _actions.updateSelectedCommand)({
          target: args.locatorInfo.target,
          targetOptions: args.locatorInfo.targetOptions
        }));
        return true;

      case 'RECORD_ADD_COMMAND':
        (0, _log2.default)('got add command', cmd, args);
        var state = store.getState();
        var commandCount = (0, _recomputed.editorCommandCount)(state);
        var recordIndex = (0, _recomputed.getIndexToInsertRecorded)(state);
        var shouldSkip = state.recorder.skipOpen && args.cmd === 'open';

        store.dispatch(_simple_actions.Actions.toggleRecorderSkipOpen(false));

        if (shouldSkip) {
          return false;
        }

        if (recordIndex > 0 && recordIndex <= commandCount) {
          store.dispatch((0, _actions.insertCommand)(args, recordIndex, true));
        } else {
          store.dispatch((0, _actions.appendCommand)(args, true));
        }

        return true;

      case 'RUN_TEST_CASE':
        {
          if (store.getState().status !== C.APP_STATUS.NORMAL) {
            _message3.default.error('can only run macros when it is not recording or playing');
            return false;
          }

          var testCase = args.testCase,
              options = args.options;


          guardCommandLineArgs(options);
          initFromCommandLineArgs(options);

          var storageMan = (0, _storage.getStorageManager)();
          var storageMode = testCase.storageMode || storageMan.getCurrentStrategyType();

          storageMan.isStrategyTypeAvailable(storageMode).catch(function (e) {
            _message3.default.error(e.message);
            throw e;
          }).then(function () {
            var needChange = storageMan.setCurrentStrategyType(storageMode);
            store.dispatch((0, _actions.updateConfig)({ storageMode: storageMode }));
            return needChange ? (0, _utils.delay)(function () {
              return reloadResources.onLastReloadFinished();
            }, 100) : undefined;
          }).then(function () {
            return prepareByOptions(options);
          }).then(function () {
            var state = store.getState();
            var shouldLoadResources = (0, _recomputed.getShouldLoadResources)(state);

            if (!shouldLoadResources) {
              return _promise2.default.resolve(true);
            }

            return new _promise2.default(function (resolve) {
              resolve(reloadResources.onLastReloadFinished ? reloadResources.onLastReloadFinished() : null);
            }).then(function () {
              return (0, _ts_utils.until)('macros ready', function () {
                var state = store.getState();
                var macroNodes = (0, _recomputed.getMacroFileNodeList)(state);

                return {
                  pass: macroNodes && macroNodes.length > 0,
                  result: true
                };
              }, 1000, 20 * 1000);
            });
          }).then(function () {
            // Note: for backward compatibility, still use `name` field (which makes sense in flat fs mode) to store `path`
            // after we migrate to standard folder mode
            var state = store.getState();
            var shouldLoadResources = (0, _recomputed.getShouldLoadResources)(state);
            var macroPath = testCase.name;

            if (shouldLoadResources) {
              var found = (0, _recomputed.findMacroNodeWithCaseInsensitiveRelativePath)(state, testCase.name);

              if (!found) {
                throw new Error('Can\'t find macro with name "' + testCase.name + '"');
              }

              macroPath = found.fullPath;
            } else if (_path2.default.isAbsolute(macroPath) && (0, _storage.getStorageManager)().isXFileMode()) {
              var msg = ['Absolute path locations like "' + macroPath + '" are not supported yet. ', 'Macro location must be relative to macro root folder (currently "' + (0, _xfile.getXFile)().getCachedConfig().rootDir + '")'].join('');

              throw new Error(msg);
            }

            var errorMsg = 'No macro found with path \'' + macroPath + '\'';

            return storageMan.getMacroStorage().read(macroPath, 'Text').then(function (macro) {
              if (!macro) {
                _message3.default.error(errorMsg);
                throw new Error(errorMsg);
              }

              return macro;
            }, function (e) {
              if (/File size cannot be determined.|A requested file or directory could not be found/.test(e.message)) {
                throw new Error(errorMsg);
              } else {
                return _promise2.default.reject(e);
              }
            }).then(function (tc) {
              var openTc = tc.data.commands.find(function (item) {
                return item.cmd.toLowerCase() === 'open';
              });

              prepareBeforeRun(options);

              var callback = genPlayerPlayCallback({ options: options });

              store.dispatch((0, _actions.editTestCase)(tc.id));
              store.dispatch((0, _actions.playerPlay)({
                macroId: tc && tc.id,
                title: macroPath,
                extra: {
                  id: tc && tc.id
                },
                mode: _player.Player.C.MODE.STRAIGHT,
                startIndex: 0,
                startUrl: openTc ? openTc.target : null,
                resources: tc.data.commands,
                postDelay: state.player.playInterval * 1000,
                overrideScope: genOverrideScope({ options: options }),
                callback: callback
              })).finally(callback);

              store.dispatch((0, _actions.updateUI)({ sidebarTab: 'macros' }));
            });
          }).catch(function (e) {
            store.dispatch((0, _actions.addLog)('error', e.message));
          });

          return true;
        }

      case 'RUN_TEST_SUITE':
        {
          if (store.getState().status !== C.APP_STATUS.NORMAL) {
            _message3.default.error('can only run test suites when it is not recording or playing');
            return false;
          }

          var testSuite = args.testSuite,
              _options = args.options;


          guardCommandLineArgs(_options);
          initFromCommandLineArgs(_options);

          var _storageMode = testSuite.storageMode || _storage.StorageStrategyType.Browser;
          var _storageMan = (0, _storage.getStorageManager)();

          _storageMan.isStrategyTypeAvailable(_storageMode).catch(function (e) {
            _message3.default.error(e.message);
            throw e;
          }).then(function () {
            var needChange = _storageMan.setCurrentStrategyType(_storageMode);
            return needChange ? (0, _utils.delay)(function () {}, 1000) : undefined;
          }).then(function () {
            return prepareByOptions(_options);
          }).then(function () {
            var state = store.getState();
            var shouldLoadResources = (0, _recomputed.getShouldLoadResources)(state);

            if (testSuite.macroFolder && testSuite.macroFolder.length > 0) {
              var pMacroNodes = function () {
                if (shouldLoadResources) {
                  return (0, _ts_utils.until)('macros ready', function () {
                    var state = store.getState();
                    var macroNodes = (0, _recomputed.getMacroFileNodeList)(state);

                    return {
                      pass: macroNodes && macroNodes.length > 0,
                      result: macroNodes
                    };
                  }, 1000, 20 * 1000).then(function () {
                    var folder = (0, _recomputed.findMacroFolderWithCaseInsensitiveRelativePath)(store.getState(), testSuite.macroFolder);
                    return folder && folder.children || [];
                  });
                }

                return _storageMan.getMacroStorage().listR(testSuite.macroFolder).then(function (nodes) {
                  return nodes.filter(function (node) {
                    return node.isFile;
                  });
                });
              }();

              return pMacroNodes.then(function (foundNodes) {
                var macroStorage = _storageMan.getMacroStorage();
                var dirPath = macroStorage.dirPath(testSuite.macroFolder.replace(/\\/g, '/'));
                var path = macroStorage.getPathLib();
                var folderName = path.basename(dirPath);

                if (foundNodes.length === 0) {
                  throw new Error('No folder found for ' + testSuite.macroFolder + ', or no macro found in it');
                }

                prepareBeforeRun(_options);

                (0, _player.getPlayer)({ name: 'testSuite' }).play({
                  title: folderName,
                  mode: (0, _player.getPlayer)().C.MODE.STRAIGHT,
                  startIndex: 0,
                  resources: foundNodes.map(function (item) {
                    return {
                      id: item.fullPath,
                      loops: 1
                    };
                  }),
                  extra: {
                    id: dirPath,
                    name: folderName
                  },
                  public: {
                    scope: genOverrideScope({ options: _options })
                  },
                  callback: genPlayerPlayCallback({ options: _options })
                });
              });
            }

            if (testSuite.name && testSuite.name.length > 0) {
              var pTestSuite = function () {
                if (shouldLoadResources) {
                  return (0, _ts_utils.until)('testSuites ready', function () {
                    var state = store.getState();
                    var testSuites = state.editor.testSuites;


                    return {
                      pass: testSuites && testSuites.length > 0,
                      result: true
                    };
                  }).then(function () {
                    var state = store.getState();
                    return (0, _actions.findSameNameTestSuite)(testSuite.name, state.editor.testSuites);
                  });
                }

                return _storageMan.getTestSuiteStorage().read(testSuite.name, 'Text');
              }();

              return pTestSuite.then(function (ts) {
                if (!ts) {
                  _message3.default.error('no macro found with name \'' + testSuite.name + '\'');
                  return false;
                }

                prepareBeforeRun(_options);

                (0, _player.getPlayer)({ name: 'testSuite' }).play({
                  title: ts.name,
                  extra: {
                    id: ts.id,
                    name: ts.name
                  },
                  mode: (0, _player.getPlayer)().C.MODE.STRAIGHT,
                  startIndex: 0,
                  resources: ts.cases.map(function (item) {
                    return {
                      id: item.testCaseId,
                      loops: item.loops
                    };
                  }),
                  public: {
                    scope: genOverrideScope({ options: _options })
                  },
                  callback: genPlayerPlayCallback({ options: _options })
                });

                return store.dispatch((0, _actions.updateUI)({ sidebarTab: 'test_suites' }));
              });
            }
          }).catch(function (e) {
            store.dispatch((0, _actions.addLog)('error', e.message));
          });

          return true;
        }

      case 'IMPORT_AND_RUN':
        {
          var _options2 = args.options;

          var _testCase = void 0;

          if (args.html) {
            try {
              _testCase = (0, _convert_utils.fromHtml)(args.html);
            } catch (e) {
              _message3.default.error('Failed to parse html', 1.5);
              return false;
            }
          }

          if (args.json) {
            try {
              var jsonStr = typeof args.json === 'string' ? args.json : (0, _stringify2.default)(args.json);
              _testCase = (0, _convert_utils.fromJSONString)(jsonStr);
            } catch (e) {
              _message3.default.error('Failed to parse json', 1.5);
              return false;
            }
          }

          if (!_testCase) {
            _message3.default.error('Nothing to import');
            return false;
          }

          guardCommandLineArgs(_options2);

          var _storageMode2 = args.storageMode || _storage.StorageStrategyType.Browser;
          var _storageMan2 = (0, _storage.getStorageManager)();

          return _storageMan2.isStrategyTypeAvailable(_storageMode2).catch(function (e) {
            _message3.default.error(e.message);
            throw e;
          }).then(function () {
            var needChange = _storageMan2.setCurrentStrategyType(_storageMode2);
            return needChange ? (0, _utils.delay)(function () {}, 1000) : undefined;
          }).then(function () {
            return prepareByOptions(_options2);
          }).then(function () {
            var state = store.getState();
            var shouldLoadResources = (0, _recomputed.getShouldLoadResources)(state);

            if (!shouldLoadResources) {
              return _promise2.default.resolve(true);
            }

            return new _promise2.default(function (resolve) {
              resolve(reloadResources.onLastReloadFinished ? reloadResources.onLastReloadFinished() : null);
            }).then(function () {
              return (0, _ts_utils.until)('macros ready', function () {
                var state = store.getState();
                var macroNodes = (0, _recomputed.getMacroFileNodeList)(state);

                return {
                  pass: macroNodes && macroNodes.length > 0,
                  result: true
                };
              }, 1000, 20 * 1000);
            });
          }).then(function () {
            return store.dispatch((0, _actions.upsertTestCase)(_testCase)).then(function () {
              return store.dispatch((0, _actions.editTestCase)(_testCase.name));
            }).then(function (macro) {
              var state = store.getState();
              var openTc = macro.data.commands.find(function (command) {
                return command.cmd.toLowerCase() === 'open';
              });

              store.dispatch((0, _actions.playerPlay)({
                macroId: macro.id,
                title: macro.name,
                extra: {
                  id: macro.id
                },
                mode: _player.Player.C.MODE.STRAIGHT,
                startIndex: 0,
                startUrl: openTc ? openTc.target : null,
                resources: macro.data.commands,
                postDelay: state.player.playInterval * 1000,
                overrideScope: genOverrideScope({ options: _options2 }),
                callback: genPlayerPlayCallback({ options: _options2 })
              }));
              return true;
            }).catch(function (e) {
              _log2.default.error(e.stack);
              throw e;
            });
          });
        }

      case 'ADD_VISION_IMAGE':
        {
          var dataUrl = args.dataUrl,
              _args$requireRename = args.requireRename,
              requireRename = _args$requireRename === undefined ? false : _args$requireRename;

          var fileName = (0, _utils.randomName)() + '_dpi_' + (0, _utils.getPageDpi)() + '.png';

          return (0, _storage.getStorageManager)().getVisionStorage().write(fileName, (0, _utils.dataURItoBlob)(dataUrl)).then(restoreVisions).then(function () {
            if (!requireRename) return { fileName: fileName };

            return store.dispatch((0, _actions.renameVisionImage)(fileName)).then(function (fileName) {
              restoreVisions();
              return { fileName: fileName };
            });
          });
        }

      case 'RESTORE_SCREENSHOTS':
        {
          restoreScreenshots();
          return true;
        }

      case 'UPDATE_ACTIVE_TAB':
        {
          updatePageTitle(args);
          return true;
        }

      case 'ADD_LOG':
        {
          if (!args) return false;
          if (args.info) store.dispatch((0, _actions.addLog)('info', args.info, args.options));
          if (args.warning) store.dispatch((0, _actions.addLog)('warning', args.warning));
          if (args.error) store.dispatch((0, _actions.addLog)('error', args.error));

          return true;
        }

      case 'SCREEN_AREA_SELECTED':
        {
          return captureScreenshotService.captureScreenInSelectionSimple(args.tabId, {
            rect: args.rect,
            devicePixelRatio: args.devicePixelRatio
          }).then(function (dataUrl) {
            return handleCommand('ADD_VISION_IMAGE', { dataUrl: dataUrl, requireRename: false });
          });
        }

      case 'STORE_SCREENSHOT_IN_SELECTION':
        {
          var tabId = args.tabId,
              rect = args.rect,
              devicePixelRatio = args.devicePixelRatio,
              _fileName = args.fileName;


          return (0, _ipc_cache.getIpcCache)().get(tabId).then(function (ipc) {
            return (0, _tab_utils.activateTab)(tabId, true).then(function () {
              return (0, _utils.delay)(function () {}, C.SCREENSHOT_DELAY);
            }).then(function () {
              return captureScreenshotService.captureScreenInSelection(tabId, { rect: rect, devicePixelRatio: devicePixelRatio }, {
                startCapture: function startCapture() {
                  return ipc.ask('START_CAPTURE_FULL_SCREENSHOT', { hideScrollbar: false });
                },
                endCapture: function endCapture(pageInfo) {
                  return ipc.ask('END_CAPTURE_FULL_SCREENSHOT', { pageInfo: pageInfo });
                },
                scrollPage: function scrollPage(offset) {
                  return ipc.ask('SCROLL_PAGE', { offset: offset });
                }
              });
            }).then(function (dataUrl) {
              return (0, _storage.getStorageManager)().getScreenshotStorage().overwrite(_fileName, (0, _utils.dataURItoBlob)(dataUrl)).then(function () {
                handleCommand('RESTORE_SCREENSHOTS');
                return _fileName;
              });
            });
          });
        }
    }
  };

  _ipc_cs2.default.onAsk(handleCommand);

  // It's for the call from popup page
  window.handleCommand = handleCommand;
};

var bindWindowEvents = function bindWindowEvents() {
  // reset status to normal when panel closed
  window.addEventListener('beforeunload', function () {
    _ipc_cs2.default.ask('PANEL_STOP_RECORDING', {});
    _ipc_cs2.default.ask('PANEL_STOP_PLAYING', {});
  });

  window.addEventListener('resize', function () {
    var size = {
      width: window.outerWidth,
      height: window.outerHeight
    };
    var state = store.getState();
    store.dispatch((0, _actions.updateConfig)({
      size: (0, _extends4.default)({}, state.config.size, (0, _defineProperty3.default)({}, state.config.showSidebar ? 'with_sidebar' : 'standard', size))
    }));
  });

  window.addEventListener('message', function (e) {
    switch (e.data && e.data.type) {
      case 'RELOAD_VISIONS':
        return store.dispatch((0, _actions.listVisions)());
    }
  });

  (0, _timeout_counter.onTimeoutStatus)(function (payload) {
    if (store.getState().status !== C.APP_STATUS.PLAYER) {
      return;
    }
    if (payload.playUID && !(0, _player.getPlayer)().checkPlayUID(payload.playUID)) {
      return;
    }

    store.dispatch((0, _actions.setTimeoutStatus)(payload));
  });
};

var bindVariableChange = function bindVariableChange() {
  // Note: bind to onChange in next tick, to make sure vars instance is already initialized
  // so that `bindVariableChange` could be executed before `initPlayer`
  setTimeout(function () {
    (0, _variables.getVarsInstance)().onChange(function (_ref3) {
      var vars = _ref3.vars;

      var variables = (0, _keys2.default)(vars).map(function (key) {
        return { key: key, value: vars[key] };
      });
      store.dispatch((0, _actions.setVariables)(variables));
    });
  }, 0);
};

var initSaveTestCase = function initSaveTestCase() {
  (0, _save_test_case2.default)(store);
};

var updatePageTitle = function updatePageTitle(args) {
  // Note: Firefox includes page url in title, there could be not enough space for tab title
  if (_web_extension2.default.isFirefox()) return true;
  var origTitle = document.title.replace(/ - .*$/, '');
  document.title = origTitle + ' - (Tab: ' + args.title + ')';
};

function tryPreinstall() {
  return _storage4.default.get('preinstall_info').then(function (info) {
    var status = function () {
      if (!info) return 'fresh';

      var _info$askedVersions = info.askedVersions,
          askedVersions = _info$askedVersions === undefined ? [] : _info$askedVersions;

      if (askedVersions.indexOf(_config2.default.preinstall.version) === -1) return 'new_version_available';

      return 'up_to_date';
    }();

    switch (status) {
      case 'fresh':
        return store.dispatch((0, _actions.preinstall)());

      case 'new_version_available':
        return store.dispatch((0, _actions.updateUI)({ newPreinstallVersion: true }));

      case 'up_to_date':
      default:
        return false;
    }
  });
}

function reloadResources() {
  var p = bindMacroAndTestSuites().then(function () {
    return (0, _ts_utils.flow)((0, _ts_utils.guardVoidPromise)(restoreCSV), (0, _ts_utils.guardVoidPromise)(restoreVisions), (0, _ts_utils.guardVoidPromise)(restoreScreenshots), (0, _ts_utils.guardVoidPromise)(function () {
      return store.dispatch((0, _actions.resetEditingIfNeeded)());
    }));
  });

  reloadResources.onLastReloadFinished = function (callback) {
    return callback ? p.then(callback) : p;
  };
  return p;
}

function checkXFileVersion() {
  return (0, _xfile.getXFile)().getVersion().then(function (versionInfo) {
    if (!versionInfo.version) {
      return;
    }

    if (_semver2.default.lt(versionInfo.version, _config2.default.xfile.minVersionToReadBigFile)) {
      var msg = 'Can not read/save screenshot on hard-drive. Please upgrade FileAccess XModule to latest version (>= ' + _config2.default.xfile.minVersionToReadBigFile + ').';

      _message3.default.warn(msg);
      store.dispatch((0, _actions.addLog)('warning', msg));
    }
  });
}

function bindStorageModeChanged() {
  var first = true;

  (0, _storage.getStorageManager)().on(_storage.StorageManagerEvent.StrategyTypeChanged, function (type) {
    if (first) {
      first = false;
      return;
    }

    try {
      var p = function () {
        if (type === _storage.StorageStrategyType.XFile) {
          return checkXFileVersion();
        }

        return _promise2.default.resolve();
      }();

      p.then(reloadResources).then(function () {
        store.dispatch(_simple_actions.Actions.selectInitialMacro(type));
      });
    } catch (e) {
      _log2.default.warn(e);
    }
  });

  (0, _storage.getStorageManager)().on(_storage.StorageManagerEvent.RootDirChanged, function (type) {
    reloadResources();
  });

  (0, _storage.getStorageManager)().on(_storage.StorageManagerEvent.ForceReload, function (type) {
    reloadResources();
  });
}

function remedyMigrationIfNeeded() {
  var todo = [];
  var shouldRemedyMacroFsMigration = (0, _04_01_macro_suite_storage.getMigrateMacroTestSuiteToBrowserFileSystem)().shouldMigrate() && !(0, _migration.getKantuMigrationService)().isMigrated(_types.MigrationJobType.MigrateMacroTestSuiteToBrowserFileSystem);

  if (shouldRemedyMacroFsMigration || _config2.default.forceMigrationRemedy) {
    alert('Kantu introduced an internal storage migration in this version. It isn\'t supposed to disturb you, but looks like there is some unexpected error: \n\n=> Solution: After you click OK Kantu is going to download your macros and test suites from the old storage into a ZIP file. You can then manually import the macros back into the new Kantu version.\n\nIf you see this dialog, please also inform us at team@a9t9.com or in the user forum about the issue.');
    todo.push(function () {
      return (0, _04_01_macro_suite_storage.getMigrateMacroTestSuiteToBrowserFileSystem)().remedy();
    });
  }

  return _ts_utils.flow.apply(undefined, todo);
}

function initFromQuery() {
  var queries = (0, _utils.parseQuery)(window.location.search);

  store.dispatch(_simple_actions.Actions.setFrom(queries.from || _state.RunBy.Manual));

  if (queries.settings) {
    store.dispatch((0, _actions.updateUI)({
      showSettings: true
    }));
  }
}

function initProxyState() {
  _ipc_cs2.default.ask('PANEL_GET_PROXY').then(function (proxy) {
    store.dispatch((0, _actions.updateProxy)(proxy));
  });
}

function init() {
  initFromQuery();
  bindIpcEvent();
  bindWindowEvents();
  bindVariableChange();
  bindStorageModeChanged();
  (0, _init_player.initPlayer)(store);
  restoreEditing();
  restoreConfig();
  initSaveTestCase();
  initProxyState();

  tryPreinstall().catch(function (e) {
    _log2.default.warn('Error in preinstall', e);
  }).then(function () {
    reloadResources();
  });

  setTimeout(function () {
    remedyMigrationIfNeeded();
  }, 1000);

  _ipc_cs2.default.ask('I_AM_PANEL', {});

  document.title = document.title + ' ' + _web_extension2.default.runtime.getManifest().version;

  _ipc_cs2.default.ask('PANEL_CURRENT_PLAY_TAB_INFO').then(updatePageTitle);

  render(_app2.default);
}

_promise2.default.all([restoreConfig(), (0, _xfile.getXFile)().getConfig(), (0, _license.getLicenseService)().getLatestInfo()]).then(function (_ref4) {
  var _ref5 = (0, _slicedToArray3.default)(_ref4, 2),
      config = _ref5[0],
      xFileConfig = _ref5[1];

  // Note: This is the first call of getStorageManager
  // and it must passed in `getMacros` to make test suite work
  (0, _storage.getStorageManager)(config.storageMode, {
    getConfig: function getConfig() {
      return store.getState().config;
    },
    getMacros: function getMacros() {
      return (0, _recomputed.getMacroFileNodeList)(store.getState());
    },
    getMaxMacroCount: function getMaxMacroCount(strategyType) {
      var count = function () {
        switch (strategyType) {
          case _storage.StorageStrategyType.XFile:
            return (0, _license.getLicenseService)().getMaxXFileMacros();

          case _storage.StorageStrategyType.Browser:
          default:
            return Infinity;
        }
      }();

      return _promise2.default.resolve(count);
    }
  });

  init();
}, init);

/***/ }),

/***/ 42322:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.initPlayer = exports.ocrViewport = undefined;

var _message4 = __webpack_require__(11187);

var _message5 = _interopRequireDefault(_message4);

var _keys = __webpack_require__(88902);

var _keys2 = _interopRequireDefault(_keys);

var _from = __webpack_require__(24043);

var _from2 = _interopRequireDefault(_from);

var _sign = __webpack_require__(39730);

var _sign2 = _interopRequireDefault(_sign);

var _toConsumableArray2 = __webpack_require__(85315);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _defineProperty2 = __webpack_require__(88106);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _extends3 = __webpack_require__(88239);

var _extends4 = _interopRequireDefault(_extends3);

var _promise = __webpack_require__(46593);

var _promise2 = _interopRequireDefault(_promise);

var _slicedToArray2 = __webpack_require__(12424);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _classCallCheck2 = __webpack_require__(99663);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(22600);

var _createClass3 = _interopRequireDefault(_createClass2);

var _react = __webpack_require__(67294);

var _react2 = _interopRequireDefault(_react);

var _antd = __webpack_require__(56318);

var _variables = __webpack_require__(52476);

var _variables2 = _interopRequireDefault(_variables);

var _interpreter2 = __webpack_require__(77669);

var _interpreter3 = _interopRequireDefault(_interpreter2);

var _eval = __webpack_require__(53867);

var _storage = __webpack_require__(16058);

var _csv = __webpack_require__(80334);

var _player = __webpack_require__(43625);

var _ipc_cs = __webpack_require__(41471);

var _ipc_cs2 = _interopRequireDefault(_ipc_cs);

var _log = __webpack_require__(77242);

var _log2 = _interopRequireDefault(_log);

var _utils = __webpack_require__(63370);

var _constant = __webpack_require__(43232);

var C = _interopRequireWildcard(_constant);

var _actions = __webpack_require__(97876);

var act = _interopRequireWildcard(_actions);

var _simple_actions = __webpack_require__(46469);

var _web_extension = __webpack_require__(61171);

var _web_extension2 = _interopRequireDefault(_web_extension);

var _file_saver = __webpack_require__(18187);

var _file_saver2 = _interopRequireDefault(_file_saver);

var _macro_log = __webpack_require__(41010);

var _xy = __webpack_require__(18677);

var _desktop = __webpack_require__(1885);

var _x_user_io = __webpack_require__(35073);

var _ocr = __webpack_require__(13549);

var _ts_utils = __webpack_require__(55452);

var _storage2 = __webpack_require__(92687);

var _types = __webpack_require__(37161);

var _counter = __webpack_require__(36465);

var _command_counter = __webpack_require__(29159);

var _endpoint_picker = __webpack_require__(94901);

var _prompt = __webpack_require__(79197);

var _types2 = __webpack_require__(34322);

var _call_stack = __webpack_require__(61364);

var _macro = __webpack_require__(72767);

var _types3 = __webpack_require__(77697);

var _macro_monitor = __webpack_require__(95324);

var _recomputed = __webpack_require__(78328);

var _types4 = __webpack_require__(75391);

var _command = __webpack_require__(69396);

var _filesystem = __webpack_require__(65065);

var _proxy = __webpack_require__(51829);

var _types5 = __webpack_require__(41559);

var _xfile = __webpack_require__(1577);

var _macro_extra_data = __webpack_require__(24577);

var _dom_utils = __webpack_require__(24874);

var _path2 = __webpack_require__(84037);

var _path3 = _interopRequireDefault(_path2);

var _encrypt = __webpack_require__(77930);

var _license = __webpack_require__(53678);

var _cv_utils = __webpack_require__(21063);

var _search_vision = __webpack_require__(94826);

var _config = __webpack_require__(62275);

var _config2 = _interopRequireDefault(_config);

var _tab_utils = __webpack_require__(96836);

var _capture_screenshot = __webpack_require__(89145);

var _global_state = __webpack_require__(13426);

var _tab = __webpack_require__(65277);

var _run_command = __webpack_require__(77204);

var _clipboard = __webpack_require__(41191);

var _clipboard2 = _interopRequireDefault(_clipboard);

var _timeout_counter = __webpack_require__(82759);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TimeTracker = function () {
  function TimeTracker() {
    (0, _classCallCheck3.default)(this, TimeTracker);

    this.reset();
  }

  (0, _createClass3.default)(TimeTracker, [{
    key: 'reset',
    value: function reset() {
      this.startTime = new Date();
    }
  }, {
    key: 'elapsed',
    value: function elapsed() {
      return new Date() - this.startTime;
    }
  }, {
    key: 'elapsedInSeconds',
    value: function elapsedInSeconds() {
      var diff = this.elapsed();
      return (diff / 1000).toFixed(2) + 's';
    }
  }]);
  return TimeTracker;
}();

var captureScreenshotService = new _capture_screenshot.CaptureScreenshotService({
  captureVisibleTab: function captureVisibleTab(windowId, options) {
    return _ipc_cs2.default.ask('PANEL_CAPTURE_VISIBLE_TAB', { windowId: windowId, options: options });
  }
});

var setProxy = function setProxy(proxy) {
  return _ipc_cs2.default.ask('PANEL_SET_PROXY', { proxy: proxy });
};

var replaceEscapedChar = function replaceEscapedChar(str, command, field) {
  var shouldEscape = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  if (!shouldEscape) {
    return str;
  }

  if (['csvRead', 'csvReadArray', 'csvSave', 'gotoIf', 'if', 'while', 'gotoIf_v2', 'if_v2', 'while_v2', 'XType', 'elseif', 'repeatIf', 'executeScript', 'executeScript_Sandbox', 'executeAsyncScript', 'executeAsyncScript_Sandbox'].indexOf(command.cmd) !== -1 && field === 'target') {
    return str;
  }

  if (['csvSaveArray'].indexOf(command.cmd) !== -1 && field === 'value') {
    return str;
  }

  if (['XRun', 'XRunAndWait'].indexOf(command.cmd) !== -1) {
    return str;
  }

  return [[/\\n/g, '\n'], [/\\t/g, '\t'], [/\\b/g, '\b'], [/\\f/g, '\f'], [/\\t/g, '\t'], [/\\v/g, '\v']].reduce(function (prev, _ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        reg = _ref2[0],
        c = _ref2[1];

    return prev.replace(reg, c);
  }, str);
};

function captureImage(args) {
  var searchArea = args.searchArea,
      storedImageRect = args.storedImageRect,
      scaleDpi = args.scaleDpi,
      isDesktop = args.isDesktop,
      devicePixelRatio = args.devicePixelRatio;


  if (isDesktop) {
    var cvApi = (0, _desktop.getNativeCVAPI)();
    var crop = function crop(imgSrc) {
      switch (searchArea) {
        case 'rect':
          {
            if (!storedImageRect) {
              throw new Error('storedImageRect is required');
            }
            // Note: Must scale up rect to screen coordinates
            return (0, _dom_utils.subImage)(imgSrc, (0, _dom_utils.scaleRect)(storedImageRect, devicePixelRatio)).then(function (dataUrl) {
              return {
                dataUrl: dataUrl,
                offset: {
                  x: storedImageRect.x,
                  y: storedImageRect.y
                }
              };
            });
          }

        default:
          {
            return _promise2.default.resolve({
              dataUrl: imgSrc,
              offset: { x: 0, y: 0 }
            });
          }
      }
    };

    return cvApi.captureDesktop({ path: undefined }).then(function (hardDrivePath) {
      return cvApi.readFileAsDataURL(hardDrivePath, true);
    }).then(function (originalDataUrl) {
      return crop(originalDataUrl).then(function (_ref3) {
        var dataUrl = _ref3.dataUrl,
            offset = _ref3.offset;

        return _promise2.default.all([(0, _search_vision.saveDataUrlToLastScreenshot)(dataUrl), (0, _search_vision.saveDataUrlToLastDesktopScreenshot)(originalDataUrl)]).then(function () {
          return {
            dataUrl: dataUrl,
            offset: offset,
            viewportOffset: offset,
            scale: 1 / devicePixelRatio
          };
        });
      });
    });
  } else {
    return (0, _search_vision.getScreenshotInSearchArea)({
      searchArea: searchArea,
      storedImageRect: storedImageRect,
      devicePixelRatio: devicePixelRatio,
      captureScreenshotService: captureScreenshotService,
      dpiScale: scaleDpi ? 96 / (0, _utils.getPageDpi)() : 1
    });
  }
}

var retryIfHeartBeatExpired = function retryIfHeartBeatExpired(mainFunc, command) {
  var isOpen = command.cmd === 'open';
  var isSelectWindowTabOpen =  true && /^\s*tab=open\s*$/i.test(command.target);
  var shouldNotCheckHeartBeat = isOpen || isSelectWindowTabOpen;
  var runWithHeartBeat = function runWithHeartBeat() {
    var stop = false;

    var infiniteCheckHeartBeat = function () {
      var startTime = new Date().getTime();
      var stop = false;
      var lastSecret = null;

      var fn = function fn() {
        if (shouldNotCheckHeartBeat) {
          return new _promise2.default(function () {});
        }

        (0, _log2.default)('start to send heart beat to background');
        if (stop) return _promise2.default.resolve();

        return _ipc_cs2.default.ask('PANEL_HEART_BEAT', {}, 300).then(function (secret) {
          // Note: secret === -1 means no heart beat available
          if (secret === -1) return new _promise2.default(function () {});

          if (secret === lastSecret) {
            throw new Error('lost background heart beat when running command');
          } else {
            lastSecret = secret;
          }

          return (0, _utils.delay)(function () {}, 3000).then(fn);
        }, function (e) {
          _log2.default.error('lost background heart beart!!', e.stack);
          throw new Error('lost background heart beat when running command');
        });
      };
      fn.stop = function () {
        (0, _log2.default)('stopping background heart beat');
        stop = true;
      };

      return fn;
    }();

    return _promise2.default.race([mainFunc().then(function (data) {
      infiniteCheckHeartBeat.stop();
      return data;
    }).catch(function (e) {
      infiniteCheckHeartBeat.stop();
      throw e;
    }), infiniteCheckHeartBeat()]);
  };

  var retryFn = (0, _utils.retry)(runWithHeartBeat, {
    timeout: 999999,
    shouldRetry: function shouldRetry(e, retryCount) {
      return e && e.message && e.message.indexOf('lost background heart beat when running command') !== -1 && retryCount < 10;
    },
    retryInterval: function retryInterval(retryCount, lastRetryInterval) {
      return Math.max(5 * 1000, Math.min(20 * 1000, lastRetryInterval * 1.2));
    }
  });

  return retryFn();
};

var getOcrResponse = function getOcrResponse(_ref4) {
  var searchArea = _ref4.searchArea,
      storedImageRect = _ref4.storedImageRect,
      ocrApiTimeout = _ref4.ocrApiTimeout,
      store = _ref4.store,
      lang = _ref4.lang,
      engine = _ref4.engine,
      scale = _ref4.scale,
      isTable = _ref4.isTable,
      isDesktop = _ref4.isDesktop;

  var ocrScale = scale;

  return new _promise2.default(function (resolve, reject) {
    // Note: must make sure `getOcrCommandCounter` is called with args before this (currently it's in `initPlayer`)
    var ocrCmdCounter = (0, _command_counter.getOcrCommandCounter)();
    var getApiAndKey = function getApiAndKey() {
      var _store$getState$confi = store.getState().config,
          ocrMode = _store$getState$confi.ocrMode,
          ocrOfflineURL = _store$getState$confi.ocrOfflineURL,
          ocrOfflineAPIKey = _store$getState$confi.ocrOfflineAPIKey;


      switch (ocrMode) {
        case 'enabled':
          {
            return (0, _endpoint_picker.getOcrEndpointPicker)().bestPick();
          }

        case 'offline_enabled':
          {
            if (!/^https?:\/\//.test(ocrOfflineURL)) {
              throw new Error('Please set local OCR API first');
            }

            if (!ocrOfflineAPIKey || !ocrOfflineAPIKey.length) {
              throw new Error('Please set local OCR API key first');
            }

            return _promise2.default.resolve({
              url: ocrOfflineURL,
              key: ocrOfflineAPIKey
            });
          }

        default:
          {
            throw new Error('Please enable OCR first');
          }
      }
    };
    var prepare = function () {
      // If version is not free version and the user reaches the 100th online OCR conversions,
      // then - before making the 101 conversion - call the API for a license check.
      // Of course, only if we've cached the license key and previous license check result
      if ((0, _license.getLicenseService)().hasNoLicense() || ocrCmdCounter.get() !== _config2.default.xmodulesLimit.unregistered.ocrCommandCount) {
        return _promise2.default.resolve();
      }

      return (0, _license.getLicenseService)().recheckLicenseIfPossible().then(function () {
        var isExpired = (0, _license.getLicenseService)().isLicenseExpired();

        if (isExpired) {
          throw new Error('Activation check failed. Reset to free edition. If you believe this was an error, please contact tech support');
        }
      });
    }();

    return prepare.then(function () {
      return isDesktop ? _promise2.default.resolve() : _ipc_cs2.default.ask('PANEL_CLEAR_OCR_MATCHES_ON_PLAYING_PAGE');
    })
    // Note: add 1s delay here to make sure old OCR overlayed are cleared before taking new screenshot
    .then(function () {
      return (0, _utils.delay)(function () {}, 1000);
    }).then(function () {
      return captureImage({
        isDesktop: isDesktop,
        storedImageRect: storedImageRect,
        searchArea: /\.png/i.test(searchArea) ? 'rect' : searchArea,
        scaleDpi: true,
        devicePixelRatio: window.devicePixelRatio
      });
    }).then(function (_ref5) {
      var dataUrl = _ref5.dataUrl,
          offset = _ref5.offset,
          viewportOffset = _ref5.viewportOffset,
          _ref5$scale = _ref5.scale,
          scale = _ref5$scale === undefined ? 1 : _ref5$scale;

      var blob = (0, _utils.dataURItoBlob)(dataUrl);
      var fileSize = (0, _storage2.readableSize)(blob.size);
      var startTime = new Date() * 1;
      var getDuration = function getDuration(startTime, endTime) {
        return ((endTime - startTime) / 1000).toFixed(1) + 's';
      };
      var cancelCountDown = (0, _ts_utils.countDown)({
        interval: 1000,
        timeout: ocrApiTimeout,
        onTick: function onTick(_ref6) {
          var past = _ref6.past,
              total = _ref6.total;

          store.dispatch(act.setTimeoutStatus({
            past: past,
            total: total,
            type: 'OCR in progress'
          }));
        }
      });

      // Note: check in advance so that it throws error before making OCR requests
      ocrCmdCounter.check();
      store.dispatch(act.addLog('info', 'OCR (' + lang + ') started (' + fileSize + ')'));

      return (0, _ocr.runOCR)({
        engine: engine,
        isTable: isTable,
        scale: ocrScale,
        image: dataUrl,
        language: lang,
        totalTimeout: ocrApiTimeout,
        singleApiTimeout: _config2.default.ocr.singleApiTimeout,
        isOverlayRequired: true,
        getApiUrlAndApiKey: function getApiUrlAndApiKey() {
          return getApiAndKey().then(function (data) {
            //  store.dispatch(act.addLog('info', `OCR request is sent to ${data.url}`))
            return data;
          });
        },
        shouldRetry: function shouldRetry() {
          var ocrMode = store.getState().config.ocrMode;


          switch (ocrMode) {
            case 'enabled':
              return (0, _endpoint_picker.getOcrEndpointPicker)().isAllDown().then(function (down) {
                return !down;
              });

            case 'offline_enabled':
            case 'disabled':
              return false;
          }
        },
        didGetResponse: function didGetResponse(data) {
          var server = data.server,
              startTime = data.startTime,
              endTime = data.endTime,
              response = data.response,
              error = data.error;

          var id = server.id || server.url;

          return (0, _endpoint_picker.getOcrEndpointPicker)().validServers().then(function (result) {
            // It hasn't marked current api, so it's safer to tell we have next to try if there are gte 2 servers.
            var hasNextToTry = result.servers.length >= 2;

            if (response) {
              store.dispatch(act.addLog('info', 'OCR result received (' + getDuration(startTime, endTime) + ' from endpoint ' + id + ')'));
            } else if (error) {
              store.dispatch(act.addLog('warning', 'Error in OCR endpoint ' + id + ' after ' + getDuration(startTime, endTime) + ': ' + error.message + (hasNextToTry ? ' - trying next.' : '')));
            }

            if (id && response) {
              (0, _endpoint_picker.getOcrEndpointPicker)().use(id);
            }

            if (!id) return _promise2.default.resolve();
            // Note: only mark server as error if browser is online
            if (!window.navigator.onLine) return _promise2.default.resolve();

            return (0, _endpoint_picker.getOcrEndpointPicker)().report(id, {
              lastError: error,
              lastOcrExitCode: response ? response.OCRExitCode : undefined,
              lastRequestTimestamp: startTime,
              lastResponseTimestamp: endTime,
              lastTotalMilliseconds: endTime - startTime
            }).then(function () {});
          });
        }
      }).then(function (data) {
        cancelCountDown();

        // Don't increase ocr counter if it's a local ocr requests
        if (store.getState().config.ocrMode === 'enabled') {
          ocrCmdCounter.inc();
        }

        return {
          offset: offset,
          viewportOffset: viewportOffset,
          response: (0, _ocr.scaleOcrResponseCoordinates)(data, scale)
        };
      }, function (e) {
        cancelCountDown();

        if (/All OCR servers are down/i.test(e.message)) {
          (0, _endpoint_picker.getOcrEndpointPicker)().reset();
        }

        throw e;
      });
    }).then(resolve, reject);
  });
};

var ocrViewport = exports.ocrViewport = function ocrViewport(_ref7) {
  var store = _ref7.store,
      isDesktop = _ref7.isDesktop;

  var clearBadge = function clearBadge() {
    return _ipc_cs2.default.ask('PANEL_UPDATE_BADGE', { type: 'play', clear: true });
  };

  return getOcrResponse({
    store: store,
    isDesktop: isDesktop,
    lang: store.getState().config.ocrLanguage,
    engine: store.getState().config.ocrEngine,
    scale: 'true',
    searchArea: 'viewport',
    storedImageRect: null,
    ocrApiTimeout: _config2.default.ocr.apiTimeout
  }).then(function (_ref8) {
    var response = _ref8.response,
        offset = _ref8.offset,
        viewportOffset = _ref8.viewportOffset;

    var documentBasedParseResults = (0, _ts_utils.safeUpdateIn)(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
      return (0, _extends4.default)({}, word, {
        Top: word.Top + offset.y,
        Left: word.Left + offset.x
      });
    }, response.ParsedResults);

    var ocrMatches = [
    // All words identified by OCR into one group
    {
      similarity: 1,
      highlight: _types.OcrHighlightType.Matched,
      words: (0, _ocr.allWordsWithPosition)(documentBasedParseResults, [])
    }];

    // show overlay on website
    return _ipc_cs2.default.ask('PANEL_HIGHLIGHT_OCR_MATCHES', {
      ocrMatches: ocrMatches,
      isDesktop: isDesktop,
      screenAvailableSize: {
        width: screen.availWidth,
        height: screen.availHeight
      }
    });
  }).then(function () {
    clearBadge();
  }, function (e) {
    clearBadge();
    throw e;
  });
};

var withVisualHighlightHidden = function withVisualHighlightHidden(fn) {
  var hide = function hide() {
    return _ipc_cs2.default.ask('PANEL_HIDE_VISION_HIGHLIGHT').catch(function () {});
  };
  var show = function show() {
    return _ipc_cs2.default.ask('PANEL_SHOW_VISION_HIGHLIGHT').catch(function () {});
  };

  return hide().then(function () {
    return fn();
  }).then(function (data) {
    show();
    return data;
  }, function (e) {
    show();
    throw e;
  });
};

var hideDownloadBar = function hideDownloadBar() {
  return _ipc_cs2.default.ask('PANEL_DISABLE_DOWNLOAD_BAR', {}).catch(function (e) {
    return true;
  });
};
var showDownloadbar = function showDownloadbar() {
  return _ipc_cs2.default.ask('PANEL_ENABLE_DOWNLOAD_BAR', {}).catch(function (e) {
    return true;
  });
};
var showDownloadBarFinally = function showDownloadBarFinally(hasXCommand, fn) {
  return _promise2.default.resolve(fn()).then(function (data) {
    if (!hasXCommand()) {
      return data;
    }

    return showDownloadbar().then(function () {
      return data;
    });
  }, function (e) {
    if (!hasXCommand()) {
      return _promise2.default.reject(e);
    }

    return showDownloadbar().then(function () {
      return _promise2.default.reject(e);
    });
  });
};

var interpretSpecialCommands = function interpretSpecialCommands(_ref9) {
  var store = _ref9.store,
      vars = _ref9.vars,
      getTcPlayer = _ref9.getTcPlayer,
      getInterpreter = _ref9.getInterpreter,
      xCmdCounter = _ref9.xCmdCounter;

  var commandRunners = [interpretCSVCommands({ store: store, vars: vars, getTcPlayer: getTcPlayer, getInterpreter: getInterpreter, xCmdCounter: xCmdCounter }), interpretCsFreeCommands({ store: store, vars: vars, getTcPlayer: getTcPlayer, getInterpreter: getInterpreter, xCmdCounter: xCmdCounter })];

  return function (command, index) {
    return commandRunners.reduce(function (prev, cur) {
      if (prev !== undefined) return prev;
      return cur(command, index);
    }, undefined);
  };
};

var interpretCsFreeCommands = function interpretCsFreeCommands(_ref10) {
  var store = _ref10.store,
      vars = _ref10.vars,
      getTcPlayer = _ref10.getTcPlayer,
      getInterpreter = _ref10.getInterpreter,
      xCmdCounter = _ref10.xCmdCounter;

  var runCsFreeCommands = function runCsFreeCommands(command, index) {
    var csvStorage = (0, _storage.getStorageManager)().getCSVStorage();
    var ssStorage = (0, _storage.getStorageManager)().getScreenshotStorage();
    var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
    var path = macroStorage.getPathLib();
    var cmd = command.cmd,
        target = command.target,
        value = command.value,
        extra = command.extra;

    var result = {
      isFlowLogic: true
    };
    var runCommand = function runCommand(command) {
      return askBackgroundToRunCommand({
        vars: vars,
        store: store,
        command: command,
        state: getTcPlayer().getState(),
        preRun: function preRun(command, state, askBgToRun) {
          return askBgToRun(command);
        }
      });
    };
    var guardOcrSettings = function guardOcrSettings() {
      if (store.getState().config.ocrMode === 'disabled') {
        throw new Error('OCR feature disabled.');
      }
    };

    (0, _log2.default)('interpretCsFreeCommands', command);

    var playerState = getTcPlayer().getState();
    var curMacroRelativePath = (0, _storage.getStorageManager)().getMacroStorage().relativePath(playerState.extra.macroId);
    var curMacroDirPath = path.dirname(curMacroRelativePath);
    var resolvePath = function resolvePath(subpath) {
      subpath = subpath.replace(/\\/g, '/');

      if (subpath.indexOf('/') === 0) {
        return path.normalize(subpath).replace(/^(\/|\\)/, '');
      } else {
        return path.join(curMacroDirPath, subpath);
      }
    };

    switch (cmd) {
      case 'repeatIf':
      case 'elseif':
      case 'if_v2':
      case 'while_v2':
      case 'gotoIf_v2':
        {
          (0, _log2.default)('Executing ' + cmd + ': ' + target);

          return (0, _eval.evaluateScript)(target).then(function (result) {
            return {
              condition: result,
              byPass: true
            };
          }, function (e) {
            throw new Error('Error in condition of ' + cmd + ': ' + e.message);
          });
        }

      case 'times':
        {
          var interpreter = getInterpreter();
          var timesKey = interpreter.getKeyForTimes(index);
          var cursor = 1 + (interpreter.getExtraByKey(timesKey) || 0);
          var max = parseInt(target, 10);

          if (isNaN(max)) {
            throw new Error('target must be a positive number');
          }

          if (max < 1) {
            return {
              condition: false,
              byPass: true
            };
          }

          var shouldContinue = cursor <= max;

          if (shouldContinue) {
            interpreter.setExtraByKey(timesKey, cursor);
            vars.set({ '!TIMES': cursor }, true);
          } else {
            interpreter.removeExtraByKey(timesKey);

            var key = interpreter.getKeyForSurroundingTimes(index);
            var nextCursor = interpreter.getExtraByKey(key);

            if (nextCursor !== undefined) {
              vars.set({ '!TIMES': nextCursor }, true);
            } else {
              vars.set({ '!TIMES': cursor }, true);
            }
          }

          return {
            condition: shouldContinue,
            byPass: true
          };
        }

      case 'forEach':
        {
          var _interpreter = getInterpreter();
          var forEachKey = 'forEach_' + index;
          var current = _interpreter.getExtraByKey(forEachKey);
          var _cursor = 1 + (current === undefined ? -1 : current);
          var list = vars.get(target);

          if (!Array.isArray(list)) {
            throw new Error('target must be an array');
          }

          var len = list.length;
          var _shouldContinue = _cursor < len;
          var varsToSet = _shouldContinue ? (0, _defineProperty3.default)({}, value, list[_cursor]) : null;

          vars.set({
            '!FOREACH': _cursor
          }, true);

          if (!_shouldContinue) {
            _interpreter.removeExtraByKey(forEachKey);
          } else {
            _interpreter.setExtraByKey(forEachKey, _cursor);
          }

          return {
            vars: varsToSet,
            condition: _shouldContinue,
            byPass: true
          };
        }

      case 'assert':
      case 'verify':
        {
          var isAssert = cmd === 'assert';
          var varName = target;

          if (!varName || !varName.length) {
            throw new Error(cmd + ': target is required as variable name');
          }

          var actualString = '' + vars.get(varName);
          var expectedString = '' + value;

          if (actualString === expectedString) {
            return { byPass: true };
          }

          var _message = 'Expected variable ' + varName + ' to be ' + expectedString + ', but it is ' + actualString;

          if (isAssert) {
            throw new Error(_message);
          }

          return {
            byPass: true,
            log: {
              error: _message
            }
          };
        }

      case 'executeScript_Sandbox':
      case 'executeAsyncScript_Sandbox':
        {
          var code = ';(function () { ' + target + ' })();';

          return (0, _eval.evaluateScript)(code).then(function (result) {
            if (value && value.length) {
              return {
                byPass: true,
                vars: (0, _defineProperty3.default)({}, value, result)
              };
            }

            return {
              byPass: true
            };
          }).catch(function (e) {
            throw new Error('Error in executeScript_Sandbox code: ' + e.message);
          });
        }

      case 'setProxy':
        {
          var p = function () {
            if (/direct/i.test(target && target.trim())) {
              return setProxy(null).then(function () {
                return store.dispatch(act.addLog('info', 'Proxy reset to none'));
              });
            }

            var _ref12 = function () {
              if (/default/i.test(target && target.trim())) {
                return [store.getState().config.defaultProxy, store.getState().config.defaultProxyAuth];
              }
              return [target, value];
            }(),
                _ref13 = (0, _slicedToArray3.default)(_ref12, 2),
                proxyUrl = _ref13[0],
                auth = _ref13[1];

            var proxy = (0, _proxy.parseProxyUrl)(proxyUrl, auth);
            var isSocks = proxy.type === _types5.ProxyScheme.Socks4 || proxy.type === _types5.ProxyScheme.Socks5;
            var hasAuth = !!proxy.username;

            if (isSocks && hasAuth && !(0, _dom_utils.isFirefox)()) {
              store.dispatch(act.addLog('warning', 'Browser doesn\'t support authentication on socks proxy'));
            }

            return setProxy(proxy).then(function () {
              vars.set({
                '!PROXY_EXEC_COUNT': 1 + (vars.get('!PROXY_EXEC_COUNT') || 0)
              }, true);

              store.dispatch(act.addLog('info', 'Proxy set to ' + proxyUrl));
            });
          }();

          return p.then(function () {
            return { byPass: true };
          });
        }

      case 'run':
        {
          var state = store.getState();
          var macroRelativePath = resolvePath(target);
          var macroNode = (0, _recomputed.findMacroNodeWithCaseInsensitiveRelativePath)(state, macroRelativePath);
          var _macroStorage = (0, _storage.getStorageManager)().getMacroStorage();

          return _macroStorage.read(macroNode && macroNode.fullPath || macroRelativePath, 'Text').then(function (macro) {
            var openCmd = macro.data.commands.find(function (command) {
              return command.cmd.toLowerCase() === 'open';
            });
            var playerState = act.commonPlayerState(store.getState(), {
              extra: {
                id: macro.id
              },
              mode: (0, _player.getPlayer)().C.MODE.STRAIGHT,
              startIndex: 0,
              startUrl: openCmd ? openCmd.target : null,
              resources: macro.data.commands,
              postDelay: state.config.playCommandInterval * 1000,
              isStep: (0, _player.getPlayer)().getState().isStep,
              loopsCursor: 1,
              loopsStart: 1,
              loopsEnd: 1
            }, macro.id, macro.name);

            return (0, _utils.delay)(function () {}, 500).then(function () {
              return (0, _call_stack.getMacroCallStack)().call(macro, {
                playerState: playerState,
                status: _macro.MacroStatus.Running,
                nextIndex: 0,
                commandResults: []
              });
            }).then(function () {
              store.dispatch(act.updateMacroPlayStatus(macro.id, _macro_extra_data.MacroResultStatus.Success));

              return {
                byPass: true
              };
            });
          });
        }

      case 'store':
        {
          return {
            byPass: true,
            vars: (0, _defineProperty3.default)({}, value, target)
          };
        }

      case 'echo':
        {
          var _extra = function () {
            if (value === '#shownotification') return { options: { notification: true } };
            if (value) return { options: { color: value } };
            return {};
          }();

          return {
            byPass: true,
            log: (0, _extends4.default)({
              info: target
            }, _extra)
          };
        }

      case 'prompt':
        {
          var _target$match = target.match(/^([^@]+)(?:@(.+))?$/),
              _target$match2 = (0, _slicedToArray3.default)(_target$match, 3),
              _ = _target$match2[0],
              _message2 = _target$match2[1],
              defaultAnswer = _target$match2[2];

          return _ipc_cs2.default.ask('PANEL_BRING_PANEL_TO_FOREGROUND').then(function () {
            return (0, _prompt.prompt)({ message: _message2, value: defaultAnswer || '' });
          }).then(function (text) {
            return {
              byPass: true,
              vars: (0, _defineProperty3.default)({}, value, text)
            };
          });
        }

      case 'throwError':
        {
          throw new Error(target);
        }

      case 'pause':
        {
          var n = parseInt(target);

          if (!target || !target.length || n === 0) {
            return {
              byPass: true,
              control: {
                type: 'pause'
              }
            };
          }

          if (isNaN(n) || n < 0) {
            throw new Error('target of pause command must be a positive integer');
          }

          var currentPlayUID = getTcPlayer().getPlayUID();

          return (0, _ts_utils.withCountDown)({
            timeout: n,
            interval: 1000,
            onTick: function onTick(_ref14) {
              var total = _ref14.total,
                  past = _ref14.past,
                  cancel = _ref14.cancel;

              if (store.getState().player.status !== C.PLAYER_STATUS.PLAYING) {
                return cancel();
              }

              if (!getTcPlayer().checkPlayUID(currentPlayUID)) {
                return cancel();
              }

              store.dispatch(act.setTimeoutStatus({
                past: past,
                total: total,
                type: 'pause'
              }));
            }
          }).then(function () {
            return { byPass: true };
          });
        }

      case 'localStorageExport':
        {
          var deleteAfterExport = /\s*#DeleteAfterExport\s*/i.test(value);

          if (/^\s*log\s*$/i.test(target)) {
            var text = store.getState().logs.map(_macro_log.renderLog).join('\n');
            _file_saver2.default.saveAs(new Blob([text]), 'uivision_log.txt');

            if (deleteAfterExport) {
              store.dispatch(act.clearLogs());
            }

            return result;
          }

          if (/\.csv$/i.test(target)) {
            return csvStorage.exists(target).then(function (existed) {
              if (!existed) throw new Error(target + ' doesn\'t exist');

              return csvStorage.read(target, 'Text').then(function (text) {
                _file_saver2.default.saveAs(new Blob([text]), target);

                if (deleteAfterExport) {
                  csvStorage.remove(target).then(function () {
                    return store.dispatch(act.listCSV());
                  });
                }

                return result;
              });
            });
          }

          if (/\.png$/i.test(target)) {
            return ssStorage.exists(target).then(function (existed) {
              if (!existed) throw new Error(target + ' doesn\'t exist');

              return ssStorage.read(target, 'ArrayBuffer').then(function (buffer) {
                _file_saver2.default.saveAs(new Blob([new Uint8Array(buffer)]), target);

                if (deleteAfterExport) {
                  ssStorage.remove(target).then(function () {
                    return store.dispatch(act.listScreenshots());
                  });
                }

                return result;
              });
            });
          }

          throw new Error(target + ' doesn\'t exist');
        }

      case 'OCRSearch':
        {
          guardOcrSettings();

          if (!value || !value.length) {
            throw new Error('value is required');
          }

          var lang = vars.get('!ocrLanguage').toLowerCase();
          var engine = vars.get('!ocrEngine');
          var scale = vars.get('!ocrScale');
          var isTable = vars.get('!ocrTableExtraction');
          var searchArea = vars.get('!visualSearchArea');
          var storedImageRect = vars.get('!storedImageRect');
          var ocrApiTimeout = _config2.default.ocr.apiTimeout;

          var _ref15 = function () {
            var match = target.match(/^(.+)@POS=(\d+)$/i);
            if (!match) return [target, 0, false];
            return [match[1], parseInt(match[2]) - 1, true];
          }(),
              _ref16 = (0, _slicedToArray3.default)(_ref15, 3),
              str = _ref16[0],
              _index = _ref16[1],
              hasPos = _ref16[2];

          var run = function run() {
            return getOcrResponse({
              store: store,
              lang: lang,
              scale: scale,
              engine: engine,
              isTable: isTable,
              searchArea: searchArea,
              storedImageRect: storedImageRect,
              ocrApiTimeout: ocrApiTimeout,
              isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'))
            }).then(function (_ref17) {
              var response = _ref17.response,
                  offset = _ref17.offset,
                  viewportOffset = _ref17.viewportOffset;

              var viewportBasedParseResults = (0, _ts_utils.safeUpdateIn)(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
                return (0, _extends4.default)({}, word, {
                  Top: word.Top + viewportOffset.y,
                  Left: word.Left + viewportOffset.x
                });
              }, response.ParsedResults);
              var documentBasedParseResults = (0, _ts_utils.safeUpdateIn)(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
                return (0, _extends4.default)({}, word, {
                  Top: word.Top + offset.y,
                  Left: word.Left + offset.x
                });
              }, response.ParsedResults);
              var searchResult = (0, _ocr.searchTextInOCRResponse)({
                text: str,
                index: _index,
                exhaust: true,
                parsedResults: viewportBasedParseResults
              });
              var hit = searchResult.hit,
                  all = searchResult.all;

              var newVars = function () {
                if (!hit) {
                  var _ref18;

                  return _ref18 = {}, (0, _defineProperty3.default)(_ref18, value, 0), (0, _defineProperty3.default)(_ref18, '!ocrx', 0), (0, _defineProperty3.default)(_ref18, '!ocry', 0), _ref18;
                } else {
                  var _ref19;

                  var center = (0, _ocr.ocrMatchCenter)(hit);

                  // Note: when '@POS=xx' is used, the possible values are only 0 and 1
                  return _ref19 = {}, (0, _defineProperty3.default)(_ref19, value, hasPos ? 1 : all.length), (0, _defineProperty3.default)(_ref19, '!ocrx', center.x), (0, _defineProperty3.default)(_ref19, '!ocry', center.y), _ref19;
                }
              }();

              var ocrMatches = [
              // All words identified by OCR into one group
              {
                similarity: 1,
                highlight: _types.OcrHighlightType.Identified,
                words: (0, _ocr.allWordsWithPosition)(documentBasedParseResults, (0, _ts_utils.flatten)(all.map(function (item) {
                  return item.words.map(function (word) {
                    return word.position;
                  });
                })))
              }].concat((0, _toConsumableArray3.default)((0, _ts_utils.compose)(all[_index] ? (0, _utils.setIn)([_index, 'highlight'], _types.OcrHighlightType.TopMatched) : function (x) {
                return x;
              }, (0, _utils.setIn)(['[]', 'highlight'], _types.OcrHighlightType.Matched), (0, _utils.updateIn)(['[]', 'words', '[]', 'word'], function (word) {
                return (0, _extends4.default)({}, word, {
                  Top: word.Top + offset.y - viewportOffset.y,
                  Left: word.Left + offset.x + viewportOffset.x
                });
              }))(all)));

              if (extra && extra.debugVisual) {
                // show overlay on website
                _ipc_cs2.default.ask('PANEL_HIGHLIGHT_OCR_MATCHES', {
                  ocrMatches: ocrMatches,
                  isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')),
                  screenAvailableSize: {
                    width: screen.availWidth,
                    height: screen.availHeight
                  }
                });
              }

              var pScaleFactor = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')) ? (0, _xy.getNativeXYAPI)().getScalingFactor() : _promise2.default.resolve(1);

              // Note: In desktop mode, `!ocrx`, `!ocry` and `best` should be desktop coordinates
              return pScaleFactor.then(function (factor) {
                return (0, _ts_utils.compose)(newVars['!ocrx'] === undefined ? _ts_utils.id : (0, _ts_utils.safeUpdateIn)(['vars', '!ocrx'], function (n) {
                  return n * factor;
                }), newVars['!ocry'] === undefined ? _ts_utils.id : (0, _ts_utils.safeUpdateIn)(['vars', '!ocry'], function (n) {
                  return n * factor;
                }), (0, _ts_utils.safeUpdateIn)(['best'], function (match) {
                  return match && match.similarity ? (0, _ocr.scaleOcrTextSearchMatch)(match, factor) : null;
                }))({
                  vars: newVars,
                  byPass: true,
                  best: hit
                });
              });
            });
          };

          return run();
        }

      case 'OCRExtract':
      case 'OCRExtractRelative':
        {
          guardOcrSettings();

          if (!value || !value.length) {
            throw new Error('value is required');
          }

          var _lang = vars.get('!ocrLanguage').toLowerCase();
          var _engine = vars.get('!ocrEngine');
          var _scale = vars.get('!ocrScale');
          var _isTable = vars.get('!ocrTableExtraction');
          var _ocrApiTimeout = _config2.default.ocr.apiTimeout;
          var isRelative = /relative/i.test(cmd);

          return _ipc_cs2.default.ask('PANEL_CLEAR_OCR_MATCHES_ON_PLAYING_PAGE').catch(function () {}).then(function () {
            return (0, _utils.delay)(function () {}, 1000);
          }).then(function () {
            return _promise2.default.all([runCsFreeCommands((0, _extends4.default)({}, command, {
              cmd: 'visualAssert',
              target: target,
              value: '',
              extra: (0, _extends4.default)({}, command.extra || {}, {
                // Note: `relativeVisual` is used in bg.js, for call of `visualAssert` that doesn't specify relativeVisual,
                // it still uses file name postfix "_relative" to tell whether it's relative (green/pink boxes) or not
                relativeVisual: isRelative,
                debugVisual: false
              })
            })), (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')) ? (0, _xy.getNativeXYAPI)().getScalingFactor() : _promise2.default.resolve(1)]);
          }).then(function (_ref20) {
            var _ref21 = (0, _slicedToArray3.default)(_ref20, 2),
                result = _ref21[0],
                scalingFactor = _ref21[1];

            var best = result.best;

            if (!best) throw new Error('no matched vision found for \'' + target + '\'');

            return withVisualHighlightHidden(function () {
              return getOcrResponse({
                store: store,
                lang: _lang,
                scale: _scale,
                engine: _engine,
                isTable: _isTable,
                ocrApiTimeout: _ocrApiTimeout,
                searchArea: 'rect',
                storedImageRect: {
                  // Note: In desktop mode, coordinates returned by `visualXXX` is already desktop mouse coordinates
                  // must convert it back to css coordinates (for later use in image cropping or preview highlight)
                  x: best.viewportLeft / scalingFactor,
                  y: best.viewportTop / scalingFactor,
                  width: best.width / scalingFactor,
                  height: best.height / scalingFactor
                },
                isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'))
              }).then(function (_ref22) {
                var response = _ref22.response,
                    offset = _ref22.offset,
                    viewportOffset = _ref22.viewportOffset;

                var documentBasedParseResults = (0, _ts_utils.safeUpdateIn)(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
                  return (0, _extends4.default)({}, word, {
                    Top: word.Top + offset.y,
                    Left: word.Left + offset.x
                  });
                }, response.ParsedResults);

                var ocrMatches = [
                // All words identified by OCR into one group
                {
                  similarity: 1,
                  highlight: _types.OcrHighlightType.Matched,
                  words: (0, _ocr.allWordsWithPosition)(documentBasedParseResults, [])
                }];

                if (extra && extra.debugVisual) {
                  // show overlay on website
                  _ipc_cs2.default.ask('PANEL_HIGHLIGHT_OCR_MATCHES', {
                    ocrMatches: ocrMatches,
                    isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')),
                    screenAvailableSize: {
                      width: screen.availWidth,
                      height: screen.availHeight
                    }
                  });
                }

                return {
                  byPass: true,
                  vars: (0, _defineProperty3.default)({}, value, response.ParsedResults && response.ParsedResults[0] ? response.ParsedResults[0].ParsedText : '')
                };
              });
            });
          });
        }

      case 'visualVerify':
      case 'visualAssert':
      case 'visualSearch':
      case 'visionFind':
        {
          if (cmd === 'visualSearch') {
            if (!value || !value.length) {
              throw new Error(cmd + ': Must specify a variable to save the result');
            }
          }

          var verifyPatternImage = function verifyPatternImage(fileName, command) {
            return (0, _storage.getStorageManager)().getVisionStorage().exists(fileName).then(function (existed) {
              if (!existed) throw new Error('Error #120: ' + command + ': No input image found for file name \'' + fileName + '\'');
            });
          };

          var imageTarget = (0, _command.parseImageTarget)(target);

          if (!target) {
            throw new Error('Target should be like \'abc.png@0.8#1\'');
          }

          var imageUrl = imageTarget.imageUrl,
              visionFileName = imageTarget.fileName,
              _imageTarget$confiden = imageTarget.confidence,
              minSimilarity = _imageTarget$confiden === undefined ? store.getState().config.defaultVisionSearchConfidence : _imageTarget$confiden,
              rawIndex = imageTarget.index;


          var resultIndex = typeof rawIndex !== 'number' || isNaN(rawIndex) ? 0 : rawIndex;
          var isNotVerifyOrAssert = ['visualVerify', 'visualAssert'].indexOf(cmd) === -1;
          var _searchArea = vars.get('!visualSearchArea');
          var timeout = vars.get('!TIMEOUT_WAIT') * 1000;
          var cvScope = vars.get('!CVSCOPE');

          var saveImageFirstIfNeeded = function saveImageFirstIfNeeded() {
            if (!imageUrl || !imageUrl.length) {
              return _promise2.default.resolve();
            }

            var getBlob = function getBlob() {
              if (imageUrl.indexOf('data:') === 0) {
                return _promise2.default.resolve((0, _utils.dataURItoBlob)(imageUrl));
              }

              return (0, _utils.loadImage)(imageUrl);
            };

            return getBlob().then(function (blob) {
              return (0, _storage.getStorageManager)().getVisionStorage().write(visionFileName, blob);
            }).then(function () {
              store.dispatch(act.listVisions());
            });
          };

          var _run = function _run() {
            var prepare = (0, _cv_utils.isCVTypeForDesktop)(cvScope) ? _promise2.default.resolve() : _ipc_cs2.default.ask('PANEL_CLEAR_VISION_RECTS_ON_PLAYING_PAGE');
            // #324 .then(() => delay(() => {}, 500))

            return prepare.then(saveImageFirstIfNeeded).then(function () {
              return (0, _search_vision.searchVision)({
                visionFileName: visionFileName,
                minSimilarity: minSimilarity,
                searchArea: _searchArea,
                cvScope: cvScope,
                command: command,
                captureScreenshotService: captureScreenshotService,
                devicePixelRatio: window.devicePixelRatio,
                storedImageRect: vars.get('!storedImageRect')
              });
            }).then(function (_ref23) {
              var regions = _ref23.regions,
                  imageInfo = _ref23.imageInfo;

              (0, _log2.default)('regions', regions, imageInfo);

              var notFound = regions.length === 0;
              var outOfRange = regions.length <= resultIndex;

              if (notFound || outOfRange) {
                // Reset image related vars to 0 if not found
                vars.set({
                  '!imageX': 0,
                  '!imageY': 0,
                  '!imageWidth': 0,
                  '!imageHeight': 0
                }, true);

                if (notFound) {
                  throw new Error('Image \'' + visionFileName + '\' (conf. = ' + minSimilarity + ') not found');
                }

                if (outOfRange) {
                  throw new Error('Found ' + regions.length + ' ' + (regions.length > 1 ? 'matches' : 'match') + ', but you are looking for #' + (resultIndex + 1));
                }
              }

              // Note: if rawIndex is set, sort by top > left (treat all matches above threshold equally)
              // otherwise, by score > top > left (= BEST match from all above threshold, see #836)
              if (resultIndex === rawIndex) {
                regions.sort(function (a, b) {
                  var vSign = (0, _sign2.default)(a.matched.offsetTop - b.matched.offsetTop);
                  var hSign = (0, _sign2.default)(a.matched.offsetLeft - b.matched.offsetLeft);

                  return vSign || hSign;
                });
              } else {
                regions.sort(function (a, b) {
                  var scoreSign = (0, _sign2.default)(b.matched.score - a.matched.score);
                  var vSign = (0, _sign2.default)(a.matched.offsetTop - b.matched.offsetTop);
                  var hSign = (0, _sign2.default)(a.matched.offsetLeft - b.matched.offsetLeft);

                  return scoreSign || vSign || hSign;
                });
              }

              var best = regions[resultIndex].matched;

              if (!(0, _cv_utils.isCVTypeForDesktop)(cvScope)) {
                var shouldHighlightElements = store.getState().config.playHighlightElements || extra && extra.debugVisual;

                if (shouldHighlightElements) {
                  _ipc_cs2.default.ask('PANEL_HIGHLIGHT_RECTS', {
                    selectedIndex: resultIndex,
                    scoredRects: regions.map(function (r) {
                      return (0, _extends4.default)({}, r.matched, {
                        left: r.matched.pageLeft,
                        top: r.matched.pageTop
                      });
                    })
                  });
                }
              } else if (extra && extra.debugVisual) {
                var convert = function convert(rect, index, type) {
                  if (!rect) return null;

                  return {
                    type: type,
                    index: index,
                    x: rect.viewportLeft,
                    y: rect.viewportTop,
                    width: rect.width,
                    height: rect.height,
                    score: rect.score
                  };
                };

                _ipc_cs2.default.ask('PANEL_HIGHLIGHT_DESKTOP_RECTS', {
                  imageInfo: imageInfo,
                  screenAvailableSize: {
                    width: screen.availWidth,
                    height: screen.availHeight
                  },
                  selectedIndex: resultIndex,
                  scoredRects: (0, _ts_utils.flatten)(regions.map(function (r, i) {
                    return [convert(r.reference, i, i === resultIndex ? _types2.DesktopScreenshot.RectType.ReferenceOfBestMatch : _types2.DesktopScreenshot.RectType.Reference), convert(r.matched, i, i === resultIndex ? _types2.DesktopScreenshot.RectType.BestMatch : _types2.DesktopScreenshot.RectType.Match)].filter(function (x) {
                      return x;
                    });
                  }))
                });
              }

              var pScaleFactor = (0, _cv_utils.isCVTypeForDesktop)(cvScope) ? (0, _xy.getNativeXYAPI)().getScalingFactor() : _promise2.default.resolve(1);

              // Note: Make sure `best`, `!imageX` and `!imageY` are all desktop coordinates (for later use in XClick)
              // While in PANEL_HIGHLIGHT_DESKTOP_RECTS, it uses css coordinates
              var top = best.viewportTop;
              var left = best.viewportLeft;

              return pScaleFactor.then(function (factor) {
                return {
                  byPass: true,
                  vars: (0, _extends4.default)({
                    '!imageX': Math.round(factor * (left + best.width / 2)),
                    '!imageY': Math.round(factor * (top + best.height / 2)),
                    '!imageWidth': Math.round(factor * best.width),
                    '!imageHeight': Math.round(factor * best.height)
                  }, isNotVerifyOrAssert && value && value.length ? (0, _defineProperty3.default)({}, value, regions.length) : {}),
                  best: (0, _utils.objMap)(function (n) {
                    return n * factor;
                  }, best)
                };
              }).then(function (res) {
                return (0, _utils.delay)(function () {
                  return res;
                }, 100);
              });
            });
          };
          var runWithRetry = (0, _utils.retry)(_run, {
            timeout: timeout,
            shouldRetry: function shouldRetry(e) {
              return store.getState().status === C.APP_STATUS.PLAYER && /Image.*\(conf\. =.*\) not found/.test(e.message);
            },
            retryInterval: function retryInterval(retryCount, lastRetryInterval) {
              return 0.5 + 0.25 * retryCount;
            },
            onFirstFail: function onFirstFail() {
              (0, _timeout_counter.startSendingTimeoutStatus)(timeout, 'Vision waiting');
            },
            onFinal: function onFinal() {
              (0, _timeout_counter.clearTimerForTimeoutStatus)();
            }
          });

          return verifyPatternImage(visionFileName, cmd).then(function () {
            return runWithRetry().catch(function (e) {
              // Note: extra.throwError === true, when "Find" button is used
              if (cmd === 'visualAssert' || extra && extra.throwError) {
                throw e;
              }

              return (0, _extends4.default)({
                byPass: true
              }, isNotVerifyOrAssert && value && value.length ? {
                vars: (0, _defineProperty3.default)({}, value, 0)
              } : {}, cmd === 'visualVerify' ? {
                log: {
                  error: e.message
                }
              } : {});
            });
          });
        }

      case 'visionLimitSearchArea':
      case 'visionLimitSearchAreaRelative':
        {
          var _isRelative = /relative/i.test(cmd);
          var area = target.trim();
          var _p = _promise2.default.resolve({ byPass: true });

          // This method is helping you to debug visionLimitSearchArea
          // It takes screenshot according to coordinates to be set
          //
          // Overall, visionLimitSearchArea takes screenshot on the search area if its value is not viewport or full
          // `element: xxx` achieve that by sharing same logic as storeImage (you can find it in command_runner.js)
          var setImageRectVarAndTakeScreenshot = function setImageRectVarAndTakeScreenshot(_ref25) {
            var rect = _ref25.rect,
                isDesktop = _ref25.isDesktop,
                searchArea = _ref25.searchArea;

            vars.set({ '!storedImageRect': rect }, true);

            return captureImage({
              isDesktop: isDesktop,
              storedImageRect: rect,
              searchArea: /\.png/i.test(searchArea) ? 'rect' : searchArea,
              scaleDpi: true,
              devicePixelRatio: window.devicePixelRatio
            });
          };

          // Note: In desktop mode, we assume coordinates users provide in 'area=...' are returned by `visualXXX`,
          // which is already desktop mouse coordinates, we must convert it back to css coordinates (for later use in image cropping or preview highlight)
          var _scale2 = function _scale2(rect) {
            switch (vars.get('!CVSCOPE')) {
              case _cv_utils.ComputerVisionType.Browser:
                return _promise2.default.resolve(rect);

              case _cv_utils.ComputerVisionType.Desktop:
              case _cv_utils.ComputerVisionType.DesktopScreenCapture:
                return (0, _xy.getNativeXYAPI)().getScalingFactor().then(function (factor) {
                  return {
                    x: rect.x / factor,
                    y: rect.y / factor,
                    width: rect.width / factor,
                    height: rect.height / factor
                  };
                });
            }
          };

          if (_isRelative && !/\.png/i.test(area)) {
            throw new Error(cmd + ' only accepts a vision image as target');
          }

          if (/^viewport$/.test(area)) {
            vars.set({ '!visualSearchArea': 'viewport' }, true);
            return _p;
          }

          if (/^full$/.test(area)) {
            vars.set({ '!visualSearchArea': 'full' }, true);
            return _p;
          }

          if (/^area=/i.test(area)) {
            var coordinates = area.replace(/^area=/i, '').split(/\s*,\s*/g).map(function (str) {
              return parseFloat(str.trim());
            });

            var isValid = coordinates.length === 4 && _utils.and.apply(undefined, (0, _toConsumableArray3.default)(coordinates.map(function (n) {
              return typeof n === 'number' && !isNaN(n);
            })));

            if (!isValid) {
              throw new Error('area should be in format of "area=x1,y1,x2,y2"');
            }

            var rect = {
              x: coordinates[0],
              y: coordinates[1],
              width: coordinates[2] - coordinates[0],
              height: coordinates[3] - coordinates[1]
            };

            vars.set({ '!visualSearchArea': 'rect' }, true);

            return _scale2(rect).then(function (finalRect) {
              return setImageRectVarAndTakeScreenshot({
                isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')),
                searchArea: 'rect',
                rect: finalRect
              }).then(function () {
                return { byPass: true };
              });
            });
          }

          if (/\.png/.test(area)) {
            return runCsFreeCommands((0, _extends4.default)({}, command, {
              cmd: 'visualAssert',
              target: area,
              value: '',
              extra: (0, _extends4.default)({}, command.extra || {}, {
                // Note: `relativeVisual` is used in bg.js, for call of `visualAssert` that doesn't specify relativeVisual,
                // it still uses file name postfix "_relative" to tell whether it's relative (green/pink boxes) or not
                relativeVisual: _isRelative
              })
            })).then(function (result) {
              var best = result.best;

              if (!best) throw new Error('No match found for ' + area + ' in screenshot');

              vars.set({ '!visualSearchArea': area }, true);

              return _scale2({
                // Note: In desktop mode, coordinates returned by `visualXXX` is already desktop mouse coordinates
                // must convert it back to css coordinates (for later use in image cropping or preview highlight)
                x: best.offsetLeft,
                y: best.offsetTop,
                width: best.width,
                height: best.height
              }).then(function (rect) {
                return setImageRectVarAndTakeScreenshot({
                  rect: rect,
                  searchArea: area,
                  isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'))
                });
              }).then(function () {
                return { byPass: true };
              });
            });
          }

          // If it doesn't match patterns above, we assume it's element in browser mode, or an vision image in desktop mode
          switch (vars.get('!CVSCOPE')) {
            case _cv_utils.ComputerVisionType.Browser:
              if (/^element:/.test(area)) {
                vars.set({ '!visualSearchArea': area }, true);

                return _ipc_cs2.default.ask('PANEL_CLEAR_VISION_RECTS_ON_PLAYING_PAGE').then(function () {
                  // Note: let cs page to process this case, it acts almost the same as a `storeImage` command
                  return _promise2.default.resolve({ byPass: false });
                });
              } else {
                throw new Error('Target of visionLimitSearchArea could only be either \'viewport\', \'full\' or \'element:...\'');
              }

            case _cv_utils.ComputerVisionType.Desktop:
            case _cv_utils.ComputerVisionType.DesktopScreenCapture:
              throw new Error('In desktop mode, target of visionLimitSearchArea could only be a vision image name or area');
          }

          break;
        }

      case 'visualGetPixelColor':
        {
          var targetReg = /^\s*(\d+)\s*,\s*(\d+)\s*$/;

          if (!targetReg.test(target)) {
            throw new Error('visualGetPixelColor: target must be a position in this fomrat: 100,200');
          }

          if (!value || !value.length) {
            throw new Error('visualGetPixelColor: must specify a variable name as value');
          }

          var isDesktopMode = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));

          var _target$match3 = target.match(targetReg),
              _target$match4 = (0, _slicedToArray3.default)(_target$match3, 3),
              _2 = _target$match4[0],
              xStr = _target$match4[1],
              yStr = _target$match4[2];

          var x = parseInt(xStr, 10);
          var y = parseInt(yStr, 10);
          var rectSize = 16;
          var type = vars.get('!CVSCOPE');
          var getScreenshot = function getScreenshot(state) {
            switch (type) {
              case 'browser':
                {
                  var toPlayTabId = state.tabIds.toPlay;

                  return (0, _tab_utils.activateTab)(toPlayTabId, true).then(function () {
                    return (0, _utils.delay)(function () {}, C.SCREENSHOT_DELAY);
                  })
                  // Set scale factor to 1 / devicePixelRatio, so that the screenshot is in css pixel.
                  .then(function () {
                    return captureScreenshotService.captureScreen(toPlayTabId, devicePixelRatio, (0, _dom_utils.isFirefox)() ? 1 : 1 / devicePixelRatio);
                  }).then(function (dataUrl) {
                    (0, _search_vision.saveDataUrlToLastScreenshot)(dataUrl);
                    return dataUrl;
                  });
                }

              case 'desktop':
                {
                  var cvApi = (0, _desktop.getNativeCVAPI)();

                  // On the other hand, desktop screenshot is in device pixel
                  return cvApi.captureDesktop({ path: undefined }).then(function (hardDrivePath) {
                    return cvApi.readFileAsDataURL(hardDrivePath, true);
                  }).then(function (dataUrl) {
                    (0, _search_vision.saveDataUrlToLastDesktopScreenshot)(dataUrl);
                    return dataUrl;
                  });
                }

              default:
                throw new Error('Unsupported type: ' + type);
            }
          };

          return (0, _global_state.getState)().then(getScreenshot).then(function (dataUrl) {
            return (0, _dom_utils.getPixel)({ dataUrl: dataUrl, x: x, y: y });
          }).then(function (colorHex) {
            if (isDesktopMode) {
              if (extra && extra.debugVisual) {
                // This scaling is due to we show desktop screenshot in its base size, so retina screens like 2560 x 1440
                // are shown as 2560 x 1440 (css px) images instead of its device size 5120 x 2880.
                // That said, the image is scaled down by 2, so we need to do the same to rects
                var _scale3 = 1 / window.devicePixelRatio;

                _ipc_cs2.default.ask('PANEL_HIGHLIGHT_DESKTOP_RECTS', {
                  imageInfo: {
                    source: _types2.DesktopScreenshot.ImageSource.Storage,
                    path: (0, _utils.ensureExtName)('.png', C.LAST_DESKTOP_SCREENSHOT_FILE_NAME)
                  },
                  screenAvailableSize: {
                    width: screen.availWidth,
                    height: screen.availHeight
                  },
                  selectedIndex: 0,
                  scoredRects: [{
                    x: _scale3 * (y - rectSize / 2),
                    y: _scale3 * (x - rectSize / 2),
                    width: _scale3 * rectSize,
                    height: _scale3 * rectSize,
                    text: colorHex,
                    type: _types2.DesktopScreenshot.RectType.BestMatch
                  }]
                });
              }
            } else {
              _ipc_cs2.default.ask('PANEL_SCREENSHOT_PAGE_INFO').then(function (pageInfo) {
                _ipc_cs2.default.ask('PANEL_HIGHLIGHT_RECT', {
                  rect: {
                    top: pageInfo.originalY + y - rectSize / 2,
                    left: pageInfo.originalX + x - rectSize / 2,
                    width: rectSize,
                    height: rectSize,
                    text: colorHex
                  }
                });
              });
            }

            vars.set((0, _defineProperty3.default)({}, value, colorHex));
            return { byPass: true };
          });
        }

      case 'XRun':
      case 'XRunAndWait':
        {
          var fileName = target;
          var args = value;
          var waitForExit = /AndWait/.test(cmd);

          return (0, _xfile.getXFile)().sanityCheck().then(function () {
            return (0, _filesystem.getNativeFileSystemAPI)().runProcess({
              fileName: fileName,
              waitForExit: waitForExit,
              arguments: args
            });
          }).then(function (result) {
            if (cmd === 'XRunAndWait') {
              vars.set({
                '!XRUN_EXITCODE': result.exitCode
              }, true);

              store.dispatch(act.addLog('info', 'App close detected, Exit code=' + result.exitCode));
            }

            return { byPass: true };
          });
        }

      case 'XDesktopAutomation':
        {
          var shouldEnableDesktopAutomation = (0, _ts_utils.parseBoolLike)(target, false);

          store.dispatch(act.updateUI({ shouldEnableDesktopAutomation: shouldEnableDesktopAutomation }));
          vars.set({
            '!CVSCOPE': shouldEnableDesktopAutomation ? 'desktop' : 'browser'
          }, true);

          return _promise2.default.resolve({ byPass: true });
        }

      case 'bringBrowserToForeground':
        {
          var shouldHide = void 0;

          try {
            shouldHide = target === '' || target === undefined ? false : !(0, _ts_utils.strictParseBoolLike)(target);
          } catch (e) {
            throw new Error('Invalid target for bringBrowserToForeground. It should be true / false or leave it blank');
          }

          var _p2 = shouldHide ? _ipc_cs2.default.ask('PANEL_MINIMIZE_ALL_WINDOWS_BUT_PANEL') : _ipc_cs2.default.ask('PANEL_BRING_PLAYING_WINDOW_TO_FOREGROUND');

          return _p2.then(function () {
            return { byPass: true };
          });
        }

      case 'bringIDEandBrowserToBackground':
        {
          return _ipc_cs2.default.ask('PANEL_MINIMIZE_ALL_WINDOWS').then(function () {
            return { byPass: true };
          });
        }

      case 'setWindowSize':
      case 'resize':
        {
          var _ref26 = function () {
            if (cmd === 'resize') {
              if (!/\s*\d+@\d+\s*/.test(target)) {
                throw new Error('Syntax for target of resize command is x@y, e.g. 800@600');
              }
              return target.split('@');
            } else {
              if (!/\s*\d+x\d+\s*/i.test(target)) {
                throw new Error('Syntax for target of setWindowSize command is WidthxHeight, e.g. 800x600');
              }
              return target.split(/x/i);
            }
          }(),
              _ref27 = (0, _slicedToArray3.default)(_ref26, 2),
              strWidth = _ref27[0],
              strHeight = _ref27[1];

          var width = parseInt(strWidth, 10);
          var height = parseInt(strHeight, 10);

          (0, _log2.default)('resize', width, height);
          return _ipc_cs2.default.ask('PANEL_RESIZE_PLAY_TAB', {
            viewportSize: { width: width, height: height },
            screenAvailableRect: {
              x: window.screen.availLeft,
              y: window.screen.availTop,
              width: window.screen.availWidth,
              height: window.screen.availHeight
            }
          }).then(function (_ref28) {
            var actual = _ref28.actual,
                desired = _ref28.desired,
                diff = _ref28.diff;

            if (diff.length === 0) return { byPass: true };

            return {
              byPass: true,
              log: {
                warning: 'Only able to resize it to ' + actual.width + '@' + actual.height + ', given ' + desired.width + '@' + desired.height
              }
            };
          });
        }

      case 'XType':
        {
          return (0, _x_user_io.getXUserIO)().sanityCheck()
          // .then(() => csIpc.ask('PANEL_IS_PLAYING_WINDOW_IN_FOREGROUND'))
          // .then(isInForeGround => {
          //   if (isInForeGround) return
          //   return runCsFreeCommands({ cmd: 'bringBrowserToForeground' })
          // })
          .then(function () {
            if (xCmdCounter.get() === 1) {
              return hideDownloadBar();
            }
          }).then(function () {
            return (0, _utils.delay)(function () {}, 300);
          }).then(function () {
            return (0, _encrypt.decryptIfNeeded)(target);
          }).then(function (text) {
            return (0, _xy.getNativeXYAPI)().sendText({ text: text }).then(function (success) {
              if (!success) throw new Error('Failed to XType \'' + target + '\'');
              return { byPass: true };
            });
          });
        }

      case 'XMouseWheel':
        {
          var deltaX = parseFloat(target);

          if (isNaN(deltaX)) {
            throw new Error('Target of XMouseWheel must be a number');
          }

          return (0, _x_user_io.getXUserIO)().sanityCheck().then(function () {
            if (xCmdCounter.get() === 1) {
              return hideDownloadBar();
            }
          }).then(function () {
            return (0, _xy.getNativeXYAPI)().sendMouseWheelEvent({
              deltaX: deltaX,
              deltaY: 0,
              deltaZ: 0
            }).then(function (success) {
              if (!success) throw new Error('Failed to XMouseWheel \'' + target + '\'');
              return { byPass: true };
            });
          });
        }

      case 'XMove':
      case 'XMoveRelative':
      case 'XClickRelative':
      case 'XClick':
        {
          var parseTarget = function parseTarget() {
            var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

            var trimmedTarget = target.trim();
            var isDesktopMode = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));

            if (/^ocr=/i.test(trimmedTarget)) {
              guardOcrSettings();

              return {
                type: 'ocr',
                value: { query: trimmedTarget.substr(4) }
              };
            }

            if ((0, _dom_utils.isLocator)(trimmedTarget)) {
              if (isDesktopMode) {
                throw new Error('Locator is not support in desktop mode');
              }

              return {
                type: 'locator',
                value: { locator: trimmedTarget }
              };
            }

            if (/^[dD](\d+(\.\d+)?)\s*,\s*(\d+(\.\d+)?)$/.test(trimmedTarget)) {
              return {
                type: 'desktop_coordinates',
                value: { coordinates: trimmedTarget.substr(1).split(/\s*,\s*/) }
              };
            }

            if (/^(\d+(\.\d+)?)\s*,\s*(\d+(\.\d+)?)$/.test(trimmedTarget)) {
              return {
                type: isDesktopMode ? 'desktop_coordinates' : 'viewport_coordinates',
                value: { coordinates: trimmedTarget.split(/\s*,\s*/) }
              };
            }

            if (/^.*\.png(@\d\.\d+)?(#\d+)?(\[[^\]]+\])?$/.test(trimmedTarget)) {
              return {
                type: 'visual_search',
                value: { query: trimmedTarget }
              };
            }

            throw new Error('XClick: invalid target, \'' + target + '\'');
          };
          var parseValueForXClick = function parseValueForXClick() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

            var normalValue = value.trim().toLowerCase();

            switch (normalValue) {
              case '':
                return '#left';

              case '#left':
              case '#middle':
              case '#right':
              case '#doubleclick':
              case '#tripleclick':
              case '#shiftclick':
              case '#ctrlclick':
                return normalValue;

              default:
                throw new Error('XClick: invalid value, \'' + value + '\'');
            }
          };
          var parseValueForXMove = function parseValueForXMove() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

            var normalValue = value.trim().toLowerCase();

            switch (normalValue) {
              case '':
                return '#move';

              case '#move':
              case '#up':
              case '#down':
                return normalValue;

              default:
                throw new Error('XMove: invalid value, \'' + value + '\'');
            }
          };
          var parseValue = {
            XClick: parseValueForXClick,
            XClickRelative: parseValueForXClick,
            XMove: parseValueForXMove,
            XMoveRelative: parseValueForXMove
          }[cmd];

          var _isRelative2 = /relative/i.test(cmd);

          return (0, _x_user_io.getXUserIO)().sanityCheck().then(function () {
            if (xCmdCounter.get() === 1) {
              return hideDownloadBar();
            }
          }).then(function () {
            var realTarget = parseTarget(target);
            var realValue = parseValue(value);

            var pNativeXYParams = function () {
              if (_isRelative2 && realTarget.type !== 'visual_search') {
                throw new Error(cmd + ' only accepts a vision image as target');
              }

              switch (realTarget.type) {
                case 'locator':
                  {
                    return runCommand((0, _extends4.default)({}, command, {
                      cmd: 'locate',
                      target: realTarget.value.locator,
                      value: ''
                    })).then(function (result) {
                      var rect = result.rect;

                      if (!rect) throw new Error('no rect data returned');

                      var x = rect.x + rect.width / 2;
                      var y = rect.y + rect.height / 2;

                      if (isNaN(x)) throw new Error('empty x');
                      if (isNaN(y)) throw new Error('empty y');

                      return {
                        type: 'viewport',
                        offset: { x: x, y: y }
                      };
                    });
                  }

                case 'visual_search':
                  {
                    return runCsFreeCommands((0, _extends4.default)({}, command, {
                      cmd: 'visualAssert',
                      target: realTarget.value.query,
                      value: '',
                      extra: (0, _extends4.default)({}, command.extra || {}, {
                        // Note: `relativeVisual` is used in bg.js, for call of `visualAssert` that doesn't specify relativeVisual,
                        // it still uses file name postfix "_relative" to tell whether it's relative (green/pink boxes) or not
                        relativeVisual: _isRelative2
                      })
                    })).then(function (result) {
                      var best = result.best;

                      if (!best) throw new Error('no best found from result of verifyAssert triggered by XClick');

                      var isForDesktop = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
                      var x = best.viewportLeft + best.width / 2;
                      var y = best.viewportTop + best.height / 2;

                      if (isNaN(x)) throw new Error('empty x');
                      if (isNaN(y)) throw new Error('empty y');

                      return {
                        type: isForDesktop ? 'desktop' : 'viewport',
                        offset: { x: x, y: y },
                        originalResult: result
                      };
                    });
                  }

                case 'ocr':
                  {
                    return runCsFreeCommands((0, _extends4.default)({}, command, {
                      cmd: 'OCRSearch',
                      target: realTarget.value.query,
                      value: '__ocrResult__'
                    })).then(function (result) {
                      var best = result.best;

                      if (!best) throw new Error('no match found for \'' + target + '\'');

                      return {
                        type: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')) ? 'desktop' : 'viewport',
                        offset: (0, _ocr.ocrMatchCenter)(best),
                        originalResult: result
                      };
                    });
                  }

                case 'desktop_coordinates':
                  {
                    var _coordinates = realTarget.value.coordinates;


                    return _promise2.default.resolve({
                      type: 'desktop',
                      offset: {
                        x: parseFloat(_coordinates[0]),
                        y: parseFloat(_coordinates[1])
                      }
                    });
                  }

                case 'viewport_coordinates':
                  {
                    var _coordinates2 = realTarget.value.coordinates;


                    return _promise2.default.resolve({
                      type: 'viewport',
                      offset: {
                        x: parseFloat(_coordinates2[0]),
                        y: parseFloat(_coordinates2[1])
                      }
                    });
                  }
              }
            }();

            return pNativeXYParams.then(function (_ref29) {
              var type = _ref29.type,
                  offset = _ref29.offset,
                  _ref29$originalResult = _ref29.originalResult,
                  originalResult = _ref29$originalResult === undefined ? {} : _ref29$originalResult;

              // Note: should not bring play tab to front if it's in desktop mode
              var prepare = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')) ? _promise2.default.resolve() : runCsFreeCommands({ cmd: 'bringBrowserToForeground' });

              return prepare.then(function () {
                return (0, _utils.delay)(function () {}, 300);
              }).then(function () {
                var api = (0, _xy.getNativeXYAPI)();

                var _ref30 = function () {
                  switch (realValue) {
                    case '#left':
                      return [_xy.MouseButton.Left, _xy.MouseEventType.Click];
                    case '#middle':
                      return [_xy.MouseButton.Middle, _xy.MouseEventType.Click];
                    case '#right':
                      return [_xy.MouseButton.Right, _xy.MouseEventType.Click];
                    case '#doubleclick':
                      return [_xy.MouseButton.Left, _xy.MouseEventType.DoubleClick];
                    case '#tripleclick':
                      return [_xy.MouseButton.Left, _xy.MouseEventType.TripleClick];
                    case '#shiftclick':
                      return [_xy.MouseButton.Left, _xy.MouseEventType.ShiftClick];
                    case '#ctrlclick':
                      return [_xy.MouseButton.Left, _xy.MouseEventType.CtrlClick];
                    case '#move':
                      return [_xy.MouseButton.Left, _xy.MouseEventType.Move];
                    case '#up':
                      return [_xy.MouseButton.Left, _xy.MouseEventType.Up];
                    case '#down':
                      return [_xy.MouseButton.Left, _xy.MouseEventType.Down];
                    default:
                      throw new Error('Unsupported realValue: ' + realValue);
                  }
                }(),
                    _ref31 = (0, _slicedToArray3.default)(_ref30, 2),
                    button = _ref31[0],
                    eventType = _ref31[1];

                var event = {
                  button: button,
                  x: offset.x,
                  y: offset.y,
                  type: eventType
                };

                var pSendMouseEvent = type === 'desktop' ? api.sendMouseEvent(event) : api.sendViewportMouseEvent(event, {
                  getViewportRectInScreen: function getViewportRectInScreen() {
                    return _ipc_cs2.default.ask('PANEL_GET_VIEWPORT_RECT_IN_SCREEN');
                  }
                });

                return pSendMouseEvent.then(function (success) {
                  if (!success) throw new Error('E201: Failed to ' + cmd + ' ' + type + ' coordinates at [' + offset.x + ', ' + offset.y + ']');

                  // Note: `originalResult` is used by visualAssert to update !imageX and !imageY
                  return (0, _extends4.default)({}, originalResult, {
                    byPass: true
                  });
                });
              });
            });
          });
        }

      case 'captureDesktopScreenshot':
        {
          var cvApi = (0, _desktop.getNativeCVAPI)();
          var isJustFileName = function isJustFileName(str) {
            return !/[\\/]/.test(str);
          };
          var _path = target && target.trim();
          var filePath = _path && _path.length > 0 ? (0, _utils.ensureExtName)('.png', _path) : undefined;
          var next = filePath && isJustFileName(filePath) ? function (actualPath) {
            return cvApi.readFileAsBlob(actualPath).then(function (blob) {
              return (0, _storage.getStorageManager)().getScreenshotStorage().overwrite(_path, blob).then(function () {
                store.dispatch(act.listScreenshots());
                store.dispatch(act.addLog('info', 'desktop screenshot saved to screenshot storage with file name \'' + _path + '\''));
              });
            });
          } : function (actualPath) {
            store.dispatch(act.addLog('info', 'desktop screenshot saved to hard drive at \'' + actualPath + '\''));
          };

          return cvApi.captureDesktop().then(next).then(function () {
            return {
              byPass: true
            };
          });
        }

      case 'captureScreenshot':
        {
          var _fileName = (0, _utils.ensureExtName)('.png', target);
          var _devicePixelRatio = window.devicePixelRatio;

          return (0, _global_state.getState)().then(function (state) {
            return (0, _tab_utils.activateTab)(state.tabIds.toPlay, true).then(function () {
              return (0, _utils.delay)(function () {}, C.SCREENSHOT_DELAY);
            }).then(function () {
              return captureScreenshotService.saveScreen((0, _storage.getStorageManager)().getScreenshotStorage(), state.tabIds.toPlay, _fileName, _devicePixelRatio);
            });
          }).then(function (_ref32) {
            var fileName = _ref32.fileName,
                url = _ref32.url;
            return {
              screenshot: {
                url: url,
                name: fileName
              },
              byPass: true
            };
          });
        }

      case 'captureEntirePageScreenshot':
        {
          var _fileName2 = (0, _utils.ensureExtName)('.png', target);

          return (0, _global_state.getState)().then(function (state) {
            return (0, _tab_utils.activateTab)(state.tabIds.toPlay, true).then(function () {
              return (0, _utils.delay)(function () {}, C.SCREENSHOT_DELAY);
            }).then(_tab.getPlayTabIpc).then(function (ipc) {
              return captureScreenshotService.saveFullScreen((0, _storage.getStorageManager)().getScreenshotStorage(), state.tabIds.toPlay, _fileName2, {
                startCapture: function startCapture() {
                  return ipc.ask('START_CAPTURE_FULL_SCREENSHOT', {}, C.CS_IPC_TIMEOUT);
                },
                endCapture: function endCapture(pageInfo) {
                  return ipc.ask('END_CAPTURE_FULL_SCREENSHOT', { pageInfo: pageInfo }, C.CS_IPC_TIMEOUT);
                },
                scrollPage: function scrollPage(offset) {
                  return ipc.ask('SCROLL_PAGE', { offset: offset }, C.CS_IPC_TIMEOUT);
                }
              });
            });
          }).then(function (_ref33) {
            var fileName = _ref33.fileName,
                url = _ref33.url;
            return {
              screenshot: {
                url: url,
                name: fileName
              },
              byPass: true
            };
          });
        }

      case 'selectWindow':
        {
          var _p3 = function () {
            switch (target && target.toUpperCase()) {
              case 'TAB=CLOSEALLOTHER':
                return _ipc_cs2.default.ask('PANEL_CLOSE_OTHER_TABS', {});

              case 'TAB=CLOSE':
                return _ipc_cs2.default.ask('PANEL_CLOSE_CURRENT_TAB', {});

              default:
                return _ipc_cs2.default.ask('PANEL_SELECT_WINDOW', { target: target, value: value });
            }
          }();

          // Note: let `selectWindow` pass through cs and back to background,
          // to keep the flow more consistent with the other commands
          return _p3.then(function () {
            return (0, _tab.getPlayTab)().then(function (tab) {
              return {
                byPass: true,
                pageUrl: tab.url
              };
            });
          });
        }

      default:
        return undefined;
    }
  };

  return runCsFreeCommands;
};

var interpretCSVCommands = function interpretCSVCommands(_ref34) {
  var store = _ref34.store,
      vars = _ref34.vars;
  return function (command, index) {
    var csvStorage = (0, _storage.getStorageManager)().getCSVStorage();
    var cmd = command.cmd,
        target = command.target,
        value = command.value;

    var assertCsvExist = function assertCsvExist(target) {
      return csvStorage.exists(target).then(function (isExisted) {
        if (isExisted) {
          return;
        }

        vars.set({ '!CsvReadStatus': 'FILE_NOT_FOUND' }, true);

        var errMsg = 'csv file \'' + target + '\' does not exist';

        if ((0, _storage.getStorageManager)().isBrowserMode() && (_path2.posix.isAbsolute(target) || _path2.win32.isAbsolute(target))) {
          errMsg += '. Full path works only in hard-drive mode.';
        }

        throw new Error(errMsg);
      });
    };

    switch (cmd) {
      case 'csvRead':
        {
          if (value && value.length > 0) {
            store.dispatch(act.addLog('warning', 'csvRead: Value field should be empty (not used)'));
          }

          return assertCsvExist(target).then(function () {
            return csvStorage.read(target, 'Text').then(_csv.parseFromCSV).then(function (rows) {
              // Note: !CsvReadLineNumber starts from 1
              var index = vars.get('!CsvReadLineNumber') - 1;
              var row = rows[index];

              if (index >= rows.length) {
                vars.set({ '!CsvReadStatus': 'END_OF_FILE' }, true);
                throw new Error('end of csv file reached');
              } else {
                vars.set({
                  '!CsvReadStatus': 'OK',
                  '!CsvReadMaxRow': rows.length
                }, true);
              }

              vars.clear(/^!COL\d+$/i);

              row.forEach(function (data, i) {
                vars.set((0, _defineProperty3.default)({}, '!COL' + (i + 1), data));
              });

              return {
                isFlowLogic: true
              };
            });
          });
        }

      case 'csvSave':
        {
          var csvLine = vars.get('!CSVLINE');

          if (!csvLine || !csvLine.length) {
            throw new Error('No data to save to csv');
          }

          return (0, _csv.stringifyToCSV)([csvLine]).then(function (newLineText) {
            var fileName = /\.csv$/i.test(target) ? target : target + '.csv';

            return csvStorage.exists(fileName).then(function (isExisted) {
              if (!isExisted) {
                return csvStorage.write(fileName, new Blob([newLineText]));
              }

              return csvStorage.read(fileName, 'Text').then(function (originalText) {
                var text = (originalText + '\n' + newLineText).replace(/\n+/g, '\n');
                return csvStorage.overwrite(fileName, new Blob([text]));
              });
            });
          }).then(function () {
            vars.clear(/^!CSVLINE$/);
            store.dispatch(act.listCSV());
          }).then(function () {
            return {
              isFlowLogic: true
            };
          });
        }

      case 'csvReadArray':
        {
          if (!value || !value.length) {
            throw new Error('Please provide variable name as value');
          }

          return assertCsvExist(target).then(function () {
            return csvStorage.read(target, 'Text').then(_csv.parseFromCSV).then(function (rows) {
              vars.set({
                '!CsvReadStatus': true,
                '!CsvReadMaxRow': rows.length
              }, true);

              return {
                byPass: true,
                vars: (0, _defineProperty3.default)({}, value, rows)
              };
            }, function (e) {
              vars.set({ '!CsvReadStatus': false }, true);
              return _promise2.default.reject(e);
            });
          });
        }

      case 'csvSaveArray':
        {
          if (!value || !value.length) {
            throw new Error('Please provide csv file name as value');
          }

          if (!target || !target.length) {
            throw new Error('Please provide array variable name as target');
          }

          var arr = vars.get(target);

          if (!arr) {
            throw new Error('No variable found with name \'' + target + '\'');
          }

          var isValidCsvArray = Array.isArray(arr) && (0, _from2.default)(arr).every(function (item) {
            return Array.isArray(item);
          });

          if (!isValidCsvArray) {
            throw new Error('Array must be two dimensional array');
          }

          return (0, _csv.stringifyToCSV)(arr).then(function (csvText) {
            var fileName = /\.csv$/i.test(value) ? value : value + '.csv';
            return csvStorage.overwrite(fileName, new Blob([csvText]));
          }).then(function () {
            store.dispatch(act.listCSV());
          }).then(function () {
            return {
              isFlowLogic: true
            };
          });
        }

      default:
        return undefined;
    }
  };
};

// Note: initialize the player, and listen to all events it emits
var initPlayer = exports.initPlayer = function initPlayer(store) {
  var vars = (0, _variables2.default)('main', {}, { '!TESTSUITE_LOOP': 1 });
  var macroCallStack = (0, _call_stack.createMacroCallStack)({
    getCurrentMacroRunningStatus: function getCurrentMacroRunningStatus() {
      var playerState = tcPlayer.getState();
      var reducerState = store.getState();
      var commandResults = (0, _macro.getCommandResults)({
        count: playerState.resources.length,
        doneIndices: (0, _recomputed.getDoneCommandIndices)(reducerState),
        errorIndices: (0, _recomputed.getErrorCommandIndices)(reducerState),
        warningIndices: (0, _recomputed.getWarningCommandIndices)(reducerState)
      });

      return {
        playerState: playerState,
        commandResults: commandResults,
        status: _macro.MacroStatus.Running,
        nextIndex: playerState.nextIndex,
        interpreterState: interpreter.backupState()
      };
    },
    updateSelectedMacro: function updateSelectedMacro(macro, runningStatus) {
      return store.dispatch(act.editTestCase(macro.id));
    },
    restorePlayerState: function restorePlayerState(macro, runningStatus) {
      // Steps:
      // 1. Restore macro player state
      // 2. Restore player state in reducer
      var playerState = runningStatus.playerState,
          _runningStatus$interp = runningStatus.interpreterState,
          interpreterState = _runningStatus$interp === undefined ? (0, _ts_utils.clone)(_interpreter3.default.DefaultState) : _runningStatus$interp;


      tcPlayer.setState(playerState);

      store.dispatch(act.setPlayerState({
        // Note: since we don't show loop info for subroutines,
        // `currentLoop` and `loops` in reducer state is always for initial call frame,
        // so no neep to restore that info from call stack before playing any frame
        //
        // currentLoop:         playerState.loopsCursor - playerState.loopsStart + 1,
        // loops:               playerState.loopsEnd - playerState.loopsStart + 1,
        nextCommandIndex: playerState.nextIndex
      }));

      interpreter.restoreState(interpreterState);
    },
    playMacro: function playMacro(macro, runningStatus, _ref35) {
      var isBottom = _ref35.isBottom,
          isResume = _ref35.isResume,
          frameId = _ref35.frameId;

      // Note: do not use clone here, otherwise will lose `callback` in playerState
      var playerState = (0, _extends4.default)({}, runningStatus.playerState);

      playerState.noEndEvent = !isBottom;

      // Note: frameId in extra will be available in all kinds of player events,
      // frameId is used as id for monitor, so that we can control monitors in player events
      playerState.extra = (0, _extends4.default)({}, playerState.extra || {}, {
        frameId: frameId,
        macroId: macro.id,
        isBottomFrame: isBottom,
        isBackFromCalling: isResume
      });

      return showDownloadBarFinally(function () {
        return xCmdCounter.get() > 0;
      }, function () {
        if (isResume) {
          tcPlayer.setState(playerState);
          // Note: already increase `nextIndex` by one
          tcPlayer.__setNext(runningStatus.nextIndex);

          return tcPlayer.play(tcPlayer.getState());
        } else {
          var needDelayAfterLoop = _utils.and.apply(undefined, (0, _toConsumableArray3.default)(playerState.resources.map(function (command) {
            return (0, _command.isExtensionResourceOnlyCommand)(command.cmd);
          })));
          var args = (0, _extends4.default)({}, playerState, {
            needDelayAfterLoop: needDelayAfterLoop
          });
          return tcPlayer.play(args);
        }
      });
    }
  });

  var ocrCmdCounter = (0, _command_counter.getOcrCommandCounter)({
    initial: 0,
    getMax: function getMax() {
      return (0, _license.getLicenseService)().getMaxOcrCalls();
    },
    onMax: function onMax(cur, max, initial) {
      throw new Error('OCR conversion limit reached');
    }
  });
  var xCmdCounter = new _counter.Counter({
    initial: 0,
    getMax: function getMax() {
      return (0, _license.getLicenseService)().getMaxXCommandCalls();
    },
    onMax: function onMax(cur, max, initial) {
      throw new Error('XClick/XMove/XType ' + max + ' commands limit reached');
    }
  });
  var proxyCounter = new _counter.Counter({
    initial: 0,
    getMax: function getMax() {
      return (0, _license.getLicenseService)().getMaxProxyCalls();
    },
    onMax: function onMax(cur, max, initial) {
      throw new Error('PROXY ' + max + ' commands limit reached');
    }
  });
  var interpreter = new _interpreter3.default({
    run: interpretSpecialCommands({
      vars: vars,
      store: store,
      xCmdCounter: xCmdCounter,
      getTcPlayer: function getTcPlayer() {
        return tcPlayer;
      },
      getInterpreter: function getInterpreter() {
        return interpreter;
      }
    })
  });
  var tcPlayer = initTestCasePlayer({ store: store, vars: vars, interpreter: interpreter, xCmdCounter: xCmdCounter, ocrCmdCounter: ocrCmdCounter, proxyCounter: proxyCounter });
  var tsPlayer = initTestSuitPlayer({ store: store, vars: vars, tcPlayer: tcPlayer, xCmdCounter: xCmdCounter, ocrCmdCounter: ocrCmdCounter, proxyCounter: proxyCounter });

  initMacroMonitor({ vars: vars, store: store });

  macroCallStack.on(_types3.CallStackEvent.BeforeRun, function (macroInfoList) {
    var lastMacroInfo = macroInfoList[macroInfoList.length - 1];
    var lastName = lastMacroInfo.name;
    var prevNames = macroInfoList.slice(0, -1).map(function (item) {
      return '\'' + item.name + '\'';
    });

    if (prevNames.length > 0) {
      store.dispatch(act.addLog('status', 'Running \'' + lastName + '\', called by ' + prevNames.join(' > ')));
    }
  });

  macroCallStack.on(_types3.CallStackEvent.AfterReturn, function (macroInfoList) {
    var lastMacroInfo = macroInfoList[macroInfoList.length - 1];
    var lastName = lastMacroInfo.name;
    var lastFrameId = lastMacroInfo.frameId;
    var prevNames = macroInfoList.slice(0, -1).map(function (item) {
      return '\'' + item.name + '\'';
    });

    (0, _macro_monitor.getMacroMonitor)().removeTarget(lastFrameId);

    if (prevNames.length > 0) {
      store.dispatch(act.addLog('status', 'Finished running \'' + lastName + '\', returning to ' + prevNames.join(' > ')));
    }
  });

  _ipc_cs2.default.onAsk(function (cmd, args) {
    switch (cmd) {
      case 'DOWNLOAD_COMPLETE':
        {
          var fileName = args ? _path3.default.basename(args.filename) : null;

          if (!fileName) {
            return false;
          }

          vars.set({ '!LAST_DOWNLOADED_FILE_NAME': fileName }, true);
          return true;
        }
    }
  });

  // Note: No need to return anything in this method.
  // Because both test case player and test suite player are cached in player.js
  // All later usage of player utilize `getPlayer` method
};

// Note: Standalone function to ask background to run a command
var askBackgroundToRunCommand = function askBackgroundToRunCommand(_ref36) {
  var command = _ref36.command,
      state = _ref36.state,
      store = _ref36.store,
      vars = _ref36.vars,
      preRun = _ref36.preRun;

  var useClipboard = /!clipboard/i.test(command.target + ';' + command.value);
  var prepare = !useClipboard ? _promise2.default.resolve({ useClipboard: false }) : _promise2.default.resolve({ useClipboard: true, clipboard: _clipboard2.default.get() });

  if (_web_extension2.default.isFirefox()) {
    switch (command.cmd) {
      case 'onDownload':
        store.dispatch(act.addLog('warning', 'onDownload - changing file names not supported by Firefox extension api yet'));
        break;
    }
  }

  switch (command.cmd) {
    case 'XType':
      if (command.value && command.value.length > 0) {
        throw new Error('XType currently doesn\'t use the "Value" field');
      }

      break;
  }

  return prepare.then(function (_ref37) {
    var useClipboard = _ref37.useClipboard,
        _ref37$clipboard = _ref37.clipboard,
        clipboard = _ref37$clipboard === undefined ? '' : _ref37$clipboard;

    // Set clipboard variable if it is used
    if (useClipboard) {
      vars.set({ '!CLIPBOARD': clipboard });
    }

    if (state.extra.isBottomFrame) {
      vars.set({
        '!LOOP': state.loopsCursor
      }, true);
    }

    vars.set({
      '!RUNTIME': (0, _ts_utils.milliSecondsToStringInSecond)((0, _macro_monitor.getMacroMonitor)().getDataFromInspector((0, _call_stack.getMacroCallStack)().bottom().id, _types4.MacroInspector.LoopTimer))
    }, true);

    if (command.cmd === 'open') {
      command = (0, _extends4.default)({}, command, { href: state.startUrl });
    }

    // Note: translate shorthand '#efp'
    if (command.target && /^#efp$/i.test(command.target.trim())) {
      // eslint-disable-next-line no-template-curly-in-string
      command.target = '#elementfrompoint (${!imageX}, ${!imageY})';
    }

    var isRelatedToExecuteScript = ['executeScript', 'executeScript_Sandbox', 'executeAsyncScript', 'executeAsyncScript_Sandbox', 'if_v2', 'while_v2', 'gotoIf_v2', 'elseif', 'repeatIf'].indexOf(command.cmd) !== -1;

    if (command.cmd !== 'comment') {
      // Replace variables in 'target' and 'value' of commands
      ;['target', 'value'].forEach(function (field) {
        if (command[field] === undefined) return;

        var oldEval = command.cmd === 'storeEval' && field === 'target' || command.cmd === 'gotoIf' && field === 'target' || command.cmd === 'if' && field === 'target' || command.cmd === 'while' && field === 'target';

        var opts = oldEval ? { withHashNotation: true } : {};

        opts.shouldStringify = oldEval || isRelatedToExecuteScript;

        command = (0, _extends4.default)({}, command, (0, _defineProperty3.default)({}, field, vars.render(replaceEscapedChar(command.cmd === 'type' ? command[field] : command[field].trim(), command, field, vars.get('!StringEscape')), opts)));
      });
    }

    // add timeout info to each command's extra
    // Please note that we must set the timeout info at runtime for each command,
    // so that timeout could be modified by some 'store' commands and affect
    // the rest of commands
    command = (0, _utils.updateIn)(['extra'], function (extra) {
      return (0, _extends4.default)({}, extra || {}, {
        timeoutPageLoad: vars.get('!TIMEOUT_PAGELOAD'),
        timeoutElement: vars.get('!TIMEOUT_WAIT'),
        timeoutDownload: vars.get('!TIMEOUT_DOWNLOAD'),
        timeoutDownloadStart: vars.get('!TIMEOUT_DOWNLOAD_START') || Math.max(10, vars.get('!TIMEOUT_WAIT')),
        lastCommandOk: vars.get('!LASTCOMMANDOK'),
        errorIgnore: !!vars.get('!ERRORIGNORE'),
        waitForVisible: !!vars.get('!WAITFORVISIBLE')
      });
    }, command);

    return preRun(command, state, function (command) {
      return (0, _run_command.runCommandInPlayTab)(command);
    });
  });
};

function initMacroMonitor(_ref38) {
  var store = _ref38.store,
      vars = _ref38.vars;

  (0, _macro_monitor.getMacroMonitor)(function (actionType, name, id, notBatch) {
    switch (actionType) {
      case _macro_monitor.MacroParamsProviderType.Constructor:
        {
          switch (name) {
            case _types4.MacroInspector.Countdown:
              return [function () {
                (0, _player.getPlayer)().stopWithError(new Error('macro \'' + (0, _call_stack.getMacroCallStack)().peek().resource.name + '\' timeout ' + vars.get('!TIMEOUT_MACRO') + 's (change the value in the settings if needed)'));
              }];

            case _types4.MacroInspector.Timer:
            case _types4.MacroInspector.LoopTimer:
            default:
              return [];
          }
        }

      case _macro_monitor.MacroParamsProviderType.Restart:
        {
          switch (name) {
            case _types4.MacroInspector.Countdown:
              return [vars.get('!TIMEOUT_MACRO') * 1000, true];

            case _types4.MacroInspector.Timer:
            case _types4.MacroInspector.LoopTimer:
            default:
              return [];
          }
        }
    }
  });
}

function isPausedOrStopped(str) {
  return (/player: paused or stopped/.test(str)
  );
}

var initTestCasePlayer = function initTestCasePlayer(_ref39) {
  var store = _ref39.store,
      vars = _ref39.vars,
      interpreter = _ref39.interpreter,
      xCmdCounter = _ref39.xCmdCounter,
      ocrCmdCounter = _ref39.ocrCmdCounter,
      proxyCounter = _ref39.proxyCounter;

  // Note: use this to track `onError` command
  // `onError` works like a global try catch, it takes effects on any commands coming after `onError`
  // Multilple `onError` are allowed, latter one overwrites previous one.
  // The scope of `onError` is current loop
  var onErrorCommand = null;
  var player = (0, _player.getPlayer)({
    prepare: function prepare(state) {
      // Each 'replay' has an independent variable scope,
      // with global variables as initial scope

      if (state.extra.isBottomFrame && !state.extra.isBackFromCalling) {
        vars.reset({ keepGlobal: true });
        vars.set(state.public.scope || {}, true);
        vars.set({
          '!StatusOK': true,
          '!WaitForVisible': false,
          '!StringEscape': true,
          '!IMAGEX': 0,
          '!IMAGEY': 0,
          '!OCRX': 0,
          '!OCRY': 0,
          '!OCRENGINE': store.getState().config.ocrEngine,
          '!BROWSER': _web_extension2.default.isFirefox() ? 'firefox' : 'chrome',
          '!OS': function () {
            var ua = window.navigator.userAgent;
            if (/windows/i.test(ua)) return 'windows';
            if (/mac/i.test(ua)) return 'mac';
            return 'linux';
          }()
        }, true);
      }

      if (!state.extra.isBackFromCalling) {
        interpreter.reset();
        interpreter.preprocess(state.resources);
      }

      return _ipc_cs2.default.ask('PANEL_START_PLAYING', {
        url: state.startUrl,
        shouldNotActivateTab: true
      });
    },
    run: function run(command, state) {
      return askBackgroundToRunCommand({
        command: command,
        state: state,
        store: store,
        vars: vars,
        preRun: function preRun(command, state, askBgToRun) {
          // Note: all commands need to be run by interpreter before it is sent to bg
          // so that interpreter could pick those flow logic commands and do its job

          return new _promise2.default(function (resolve, reject) {
            // Note: inc() has a chance to throw xCommand limit reached error,
            // so it's easier to keep it in the Promise constructor
            if (/^(XType|XClick|XMove|XClickRelative|XMoveRelative|XMouseWheel)$/i.test(command.cmd)) {
              xCmdCounter.inc();
            }

            if (command.cmd === 'setProxy') {
              proxyCounter.inc();
            }

            interpreter.run(command, state.nextIndex).then(function (result) {
              var byPass = result.byPass,
                  isFlowLogic = result.isFlowLogic,
                  nextIndex = result.nextIndex,
                  resetVars = result.resetVars;

              // Record onError command

              if (command.cmd === 'onError') {
                onErrorCommand = command;
              }

              if (byPass) return _promise2.default.resolve(result);
              if (isFlowLogic) return _promise2.default.resolve({ nextIndex: nextIndex });

              return askBgToRun(command);
            }).then(resolve, reject);
          });
        }
      }).catch(function (e) {
        // Note: it will just log errors instead of a stop of whole macro, in following situations
        // 1. variable !ERRORIGNORE is set to true
        // 2. There is an `onError` command ahead in current loop.
        // 3. it's in loop mode, and it's not the last loop, and onErrorInLoop is continue_next_loop,
        if (vars.get('!ERRORIGNORE')) {
          return {
            log: {
              error: e.message
            }
          };
        }

        if (onErrorCommand) {
          var value = onErrorCommand.value && onErrorCommand.value.trim();
          var target = onErrorCommand.target && onErrorCommand.target.trim();

          if (/^#restart$/i.test(target)) {
            store.dispatch(act.addLog('status', 'onError - about to restart'));

            e.restart = true;
            throw e;
          } else if (/^#goto$/i.test(target)) {
            store.dispatch(act.addLog('status', 'onError - about to goto label \'' + value + '\''));

            return _promise2.default.resolve({
              log: {
                error: e.message
              },
              nextIndex: interpreter.commandIndexByLabel(value)
            });
          }
        }

        var isPausedStopped = isPausedOrStopped(e.message);
        var continueNextLoop = state.mode === _player.Player.C.MODE.LOOP && state.loopsCursor < state.loopsEnd && store.getState().config.onErrorInLoop === 'continue_next_loop';

        if (continueNextLoop) {
          if (isPausedStopped) {
            return {
              // Note: simply set nextIndex to command count, it will enter next loop
              nextIndex: state.resources.length
            };
          }

          return {
            log: {
              error: e.message
            },
            // Note: simply set nextIndex to command count, it will enter next loop
            nextIndex: state.resources.length
          };
        }

        // Note: set these status values to false
        // status of those logs above will be taken care of by `handleResult`
        vars.set({
          '!LastCommandOK': false,
          '!StatusOK': false
        }, true);

        throw e;
      });
    },
    handleResult: function handleResult(result, command, state) {
      var prepares = [];
      var getCurrentPlayer = function getCurrentPlayer() {
        var state = store.getState();

        switch (state.player.mode) {
          case C.PLAYER_MODE.TEST_CASE:
            return (0, _player.getPlayer)({ name: 'testCase' });

          case C.PLAYER_MODE.TEST_SUITE:
            return (0, _player.getPlayer)({ name: 'testSuite' });
        }
      };

      // Every command should return its window.url
      if (result && result.pageUrl) {
        vars.set({ '!URL': result.pageUrl }, true);
      }

      if (result && result.vars) {
        var newVars = (0, _utils.objMap)(function (val) {
          if (val && val.__undefined__) return undefined;
          return val;
        }, result.vars);

        (0, _log2.default)('set vars', newVars);

        try {
          vars.set(newVars);

          // Note: if set value to !Clipboard, there is an async job we must get done before handleResult could return
          var clipBoardKey = (0, _keys2.default)(result.vars).find(function (key) {
            return (/!clipboard/i.test(key)
            );
          });
          if (clipBoardKey) {
            prepares.push(_promise2.default.resolve(_clipboard2.default.set(result.vars[clipBoardKey])));
          }

          // Note: if user sets !timeout_macro to some other value, re-calculate the time left
          var timeoutMacroKey = (0, _keys2.default)(result.vars).find(function (key) {
            return (/!timeout_macro/i.test(key)
            );
          });

          if (timeoutMacroKey) {
            var frameId = (0, _call_stack.getMacroCallStack)().peek().id;
            (0, _macro_monitor.getMacroMonitor)().restartInspector(frameId, _types4.MacroInspector.Countdown);
          }
        } catch (e) {
          return _promise2.default.reject(e);
        }
      }

      var hasError = false;

      if (result && result.log) {
        if (result.log.info) {
          store.dispatch(act.addLog('echo', result.log.info, result.log.options));

          if (result.log.options && result.log.options.notification) {
            _ipc_cs2.default.ask('PANEL_NOTIFY_ECHO', { text: result.log.info });
          }
        }

        if (result.log.warning) {
          store.dispatch(act.addLog('warning', result.log.warning, result.log.options));
        }

        if (result.log.error && !isPausedOrStopped(result.log.error)) {
          store.dispatch(act.addPlayerWarningCommandIndex(state.nextIndex));
          store.dispatch(act.addLog('error', result.log.error, { ignored: true }));
          hasError = true;
        }
      }

      // From spec: !StatusOK, very similar to !LastCommandOK but it does not get reset by a “good” command.
      // If set to error, it remains like this. But a user can use store | true | !StatusOK to manually reset it.
      if (command.cmd !== 'echo') {
        vars.set({ '!LastCommandOK': !hasError }, true);
      }

      if (hasError) {
        vars.set({ '!StatusOK': false }, true);
      }

      if (result && result.screenshot) {
        store.dispatch(act.addLog('info', 'a new screenshot captured'));

        (0, _storage.getStorageManager)().getScreenshotStorage().getLink(result.screenshot.name).then(function (link) {
          return (0, _extends4.default)({}, result.screenshot, {
            url: link
          });
        }).then(function (ss) {
          store.dispatch(act.listScreenshots());
        }).catch(function (e) {
          _log2.default.error('screenshot obj error 1', e);
          _log2.default.error('screenshot obj error stack', e.stack);
        });
      }

      if (result && result.control) {
        switch (result.control.type) {
          case 'pause':
            // Important: should only pause test case player, not test suite player
            // Because once test suite player is paused, it is supposed to run the test case from start again
            _ipc_cs2.default.ask('PANEL_NOTIFY_AUTO_PAUSE', {});

            // pause() returns a promise that doesn't resolve,
            // must return that promise here to pause any further execution
            return (0, _player.getPlayer)({ name: 'testCase' }).pause();

          default:
            throw new Error('Control type \'' + result.control.type + '\' not supported yet');
        }
      }

      if (/^(fast|medium|slow|nodisplay)$/i.test(vars.get('!REPLAYSPEED'))) {
        var val = vars.get('!REPLAYSPEED').toUpperCase();

        player.setPostDelay({
          NODISPLAY: 1,
          FAST: 1, // avoid UI freezing (DemoCsvReadArray: Fast=0 is ~30-40% faster as no UI updates)
          MEDIUM: 300,
          SLOW: 2000
        }[val]);
      }

      var replaySpeedKey = (0, _keys2.default)(result.vars || {}).find(function (key) {
        return key.toUpperCase() === '!REPLAYSPEED';
      });

      // Save nodisplay to store to reflect it in rendering
      // if !REPLAYSPEED is updated in vars
      if (replaySpeedKey) {
        store.dispatch(_simple_actions.Actions.setNoDisplayInPlay(/^nodisplay$/i.test(vars.get('!REPLAYSPEED'))));
      }

      // For those flow logic that set nextIndex directly in Interpreter.run method
      if (result && result.nextIndex !== undefined) {
        return _promise2.default.all(prepares).then(function () {
          return result.nextIndex;
        });
      }

      // For those flow logic that has to get result from bg
      // and return nextIndex in Interpreter.postRun
      return _promise2.default.all(prepares).then(function () {
        return interpreter.postRun(command, state.nextIndex, result);
      }).then(function () {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return data.nextIndex;
      });
    }
  }, {
    preDelay: 0
  });

  player.on('BREAKPOINT', function () {
    _ipc_cs2.default.ask('PANEL_NOTIFY_BREAKPOINT', {});
  });

  player.on('LOOP_START', function (_ref40) {
    var loopsCursor = _ref40.loopsCursor,
        extra = _ref40.extra;

    if (extra.isBottomFrame) {
      // Note: set 'csv read line number' to loops whenever a new loop starts
      vars.set({
        '!CsvReadLineNumber': loopsCursor,
        '!visualSearchArea': 'viewport',
        '!StatusOK': true
      }, true);
    }

    var frameId = extra.frameId;

    // Note: reset macro timeout, and loop timer on each loop

    (0, _macro_monitor.getMacroMonitor)().restartInspector(frameId, _types4.MacroInspector.LoopTimer);
    (0, _macro_monitor.getMacroMonitor)().restartInspector(frameId, _types4.MacroInspector.Countdown);

    if (extra.isBottomFrame) {
      // Note: reset onErrorCommand on each loop
      onErrorCommand = null;
    }
  });

  player.on('LOOP_RESTART', function (_ref41) {
    var currentLoop = _ref41.currentLoop,
        loopsCursor = _ref41.loopsCursor;

    _ipc_cs2.default.ask('PANEL_STOP_PLAYING', {});
    _ipc_cs2.default.ask('PANEL_START_PLAYING', { shouldNotActivateTab: true });
    store.dispatch(act.addLog('status', 'Current loop: ' + currentLoop));
  });

  player.on('START', function (_ref42) {
    var title = _ref42.title,
        extra = _ref42.extra,
        loopsCursor = _ref42.loopsCursor;

    (0, _log2.default)('START');

    if (store.getState().player.mode === C.PLAYER_MODE.TEST_CASE && extra.isBottomFrame && !extra.isBackFromCalling) {
      xCmdCounter.reset();
      proxyCounter.reset();
    }

    store.dispatch(act.startPlaying());

    store.dispatch(act.setPlayerState({
      status: C.PLAYER_STATUS.PLAYING,
      nextCommandIndex: null
    }));

    if (!extra.isBackFromCalling) {
      store.dispatch(act.updateMacroExtra((0, _recomputed.getCurrentMacroId)(store.getState()), {
        doneCommandIndices: [],
        errorCommandIndices: [],
        warningCommandIndices: []
      }));
    }

    store.dispatch(act.addLog('status', 'Playing macro ' + title));
  });

  player.on('PREPARED', function (_ref43) {
    var extra = _ref43.extra;

    if (!extra.isBackFromCalling) {
      // PREPARED event means all variables are already set
      var frameId = extra.frameId;

      (0, _macro_monitor.getMacroMonitor)().addTarget(frameId);
    }
  });

  player.on('PAUSED', function () {
    (0, _log2.default)('PAUSED');
    store.dispatch(act.setPlayerState({
      status: C.PLAYER_STATUS.PAUSED
    }));

    store.dispatch(act.addLog('status', 'Macro paused'));

    // Pause all monitors (timers, coundown)
    (0, _macro_monitor.getMacroMonitor)().pause();
  });

  player.on('RESUMED', function () {
    (0, _log2.default)('RESUMED');
    store.dispatch(act.setPlayerState({
      status: C.PLAYER_STATUS.PLAYING
    }));

    store.dispatch(act.addLog('status', 'Macro resumed'));

    // Resume all monitors (timers, coundown)
    (0, _macro_monitor.getMacroMonitor)().resume();
  });

  player.on('END', function (obj) {
    var _logMsg;

    (0, _log2.default)('END', obj);

    _ipc_cs2.default.ask('PANEL_STOP_PLAYING', {});

    store.dispatch(act.stopPlaying());

    var state = store.getState();
    var extraState = state.player.nextCommandIndex !== null ? { lastNextCommandIndex: state.player.nextCommandIndex } : {};

    store.dispatch(act.setPlayerState((0, _extends4.default)({
      status: C.PLAYER_STATUS.STOPPED,
      stopReason: obj.reason,
      nextCommandIndex: null,
      timeoutStatus: null
    }, extraState)));

    if (vars.get('!PROXY_EXEC_COUNT') > 0 && store.getState().config.turnOffProxyAfterReplay) {
      setProxy(null);
      store.dispatch(act.addLog('info', 'Proxy reset to none'));
    }

    var tcId = obj.extra && obj.extra.id;

    switch (obj.reason) {
      case player.C.END_REASON.COMPLETE:
        if (tcId) store.dispatch(act.updateMacroPlayStatus(tcId, _macro_extra_data.MacroResultStatus.Success));
        _message5.default.success('Macro completed running', 1.5);
        break;

      case player.C.END_REASON.ERROR:
        var stacks = (0, _call_stack.getMacroCallStack)().toArray();
        var len = stacks.length;

        stacks.forEach(function (item, i) {
          var status = i === len - 1 ? _macro_extra_data.MacroResultStatus.Error : _macro_extra_data.MacroResultStatus.ErrorInSub;
          store.dispatch(act.updateMacroPlayStatus(item.resource.id, status));
        });

        _message5.default.error('Macro encountered some error', 1.5);
        break;
    }

    var logMsg = (_logMsg = {}, (0, _defineProperty3.default)(_logMsg, player.C.END_REASON.COMPLETE, 'Macro completed'), (0, _defineProperty3.default)(_logMsg, player.C.END_REASON.ERROR, 'Macro failed'), (0, _defineProperty3.default)(_logMsg, player.C.END_REASON.MANUAL, 'Macro was stopped manually'), _logMsg);

    var frameId = obj.extra.frameId;

    var ms = (0, _macro_monitor.getMacroMonitor)().getDataFromInspector(frameId, _types4.MacroInspector.Timer);

    store.dispatch(act.addLog('info', logMsg[obj.reason] + (' (Runtime ' + (0, _ts_utils.milliSecondsToStringInSecond)(ms) + ')')));

    (0, _macro_monitor.getMacroMonitor)().stopInspector(frameId, _types4.MacroInspector.Timer);
    (0, _macro_monitor.getMacroMonitor)().stopInspector(frameId, _types4.MacroInspector.LoopTimer);
    (0, _macro_monitor.getMacroMonitor)().stopInspector(frameId, _types4.MacroInspector.Countdown);

    // Note: show in badage the play result
    if (obj.reason === player.C.END_REASON.COMPLETE || obj.reason === player.C.END_REASON.ERROR) {
      _ipc_cs2.default.ask('PANEL_UPDATE_BADGE', (0, _extends4.default)({
        type: 'play',
        blink: 5000,
        text: obj.reason === player.C.END_REASON.COMPLETE ? 'done' : 'err'
      }, obj.reason === player.C.END_REASON.COMPLETE ? {} : { color: 'orange' }));
    }

    if (store.getState().player.mode !== C.PLAYER_MODE.TEST_SUITE) {
      store.dispatch(act.updateUI({ shouldEnableDesktopAutomation: undefined }));
    }
  });

  player.on('TO_PLAY', function (_ref44) {
    var index = _ref44.index,
        currentLoop = _ref44.currentLoop,
        loops = _ref44.loops,
        resource = _ref44.resource,
        extra = _ref44.extra;

    (0, _log2.default)('TO_PLAY', index, resource, 'currentLoop', currentLoop);

    store.dispatch(act.setPlayerState((0, _extends4.default)({
      timeoutStatus: null,
      nextCommandIndex: index
    }, extra.isBottomFrame ? {
      currentLoop: currentLoop,
      loops: loops
    } : {})));

    var triple = [resource.cmd, resource.target, resource.value];
    var str = [''].concat(triple, ['']).join(' | ');
    store.dispatch(act.addLog('reflect', 'Executing: ' + str));

    // Note: show in badage the current command index (start from 1)
    _ipc_cs2.default.ask('PANEL_UPDATE_BADGE', {
      type: 'play',
      text: '' + (index + 1)
    });
  });

  player.on('PLAYED_LIST', function (_ref45) {
    var indices = _ref45.indices;

    (0, _log2.default)('PLAYED_LIST', indices);

    store.dispatch(act.updateMacroDoneCommandsIndices((0, _recomputed.getCurrentMacroId)(store.getState()), indices));
  });

  player.on('ERROR', function (_ref46) {
    var errorIndex = _ref46.errorIndex,
        msg = _ref46.msg,
        stack = _ref46.stack,
        restart = _ref46.restart;

    _log2.default.error('command index: ' + errorIndex + ', Error: ' + msg + ', Stack: ' + stack);
    store.dispatch(act.addPlayerErrorCommandIndex(errorIndex));
    store.dispatch(act.addLog('error', msg));

    // Note: restart this player if restart is set to true in error, and it's not in test suite mode
    // Delay the execution so that 'END' event is emitted, and player is in stopped state
    if (restart && store.getState().player.mode === C.PLAYER_MODE.TEST_CASE) {
      setTimeout(function () {
        return player.replayLastConfig();
      }, 50);
    }
  });

  player.on('DELAY', function (_ref47) {
    var total = _ref47.total,
        past = _ref47.past;

    store.dispatch(act.setPlayerState({
      timeoutStatus: {
        type: 'delay',
        total: total,
        past: past
      }
    }));
  });

  return player;
};

var initTestSuitPlayer = function initTestSuitPlayer(_ref48) {
  var store = _ref48.store,
      vars = _ref48.vars,
      tcPlayer = _ref48.tcPlayer,
      xCmdCounter = _ref48.xCmdCounter,
      ocrCmdCounter = _ref48.ocrCmdCounter,
      proxyCounter = _ref48.proxyCounter;

  var tsTracker = new TimeTracker();
  var tcTracker = new TimeTracker();
  var state = {
    isPlaying: false,
    tsId: null,
    lastErrMsg: '',
    testCasePromiseHandlers: null,
    reports: [],
    stopReason: null

  };
  var setState = function setState(st) {
    state = (0, _extends4.default)({}, state, st);
  };
  var addReport = function addReport(report) {
    setState({
      reports: state.reports.concat(report)
    });
  };
  var tsPlayer = (0, _player.getPlayer)({
    name: 'testSuite',
    prepare: function prepare() {
      setState({
        isPlaying: true,
        reports: []
      });

      vars.set({
        '!TESTSUITE_LOOP': 1,
        '!GLOBAL_TESTSUITE_STOP_ON_ERROR': false
      }, true);
    },
    run: function run(testCase, playerState) {
      var tcId = testCase.id;
      var tcLoops = testCase.loops > 1 ? parseInt(testCase.loops, 10) : 1;
      var state = store.getState();

      return (0, _storage.getStorageManager)().getMacroStorage().read(tcId, 'Text').then(function (tc) {
        var openTc = tc && tc.data.commands.find(function (c) {
          return c.cmd.toLowerCase() === 'open';
        });

        if (!tc) {
          throw new Error('macro does not exist');
        }

        // update editing && start to play tcPlayer
        store.dispatch(act.editTestCase(tc.id));
        store.dispatch(act.playerPlay({
          macroId: tc.id,
          title: tc.name,
          extra: {
            id: tc.id,
            name: tc.name,
            shouldNotActivateTab: true
          },
          mode: tcLoops === 1 ? _player.Player.C.MODE.STRAIGHT : _player.Player.C.MODE.LOOP,
          loopsStart: 1,
          loopsEnd: tcLoops,
          startIndex: 0,
          startUrl: openTc ? openTc.target : null,
          resources: tc.data.commands,
          postDelay: state.config.playCommandInterval * 1000,
          // Note: This logic is to make sure !CMD_VAR${n} only take effect on first macro in a test suite
          overrideScope: playerState.nextIndex !== 0 ? {} : playerState.public.scope
        }));

        return new _promise2.default(function (resolve, reject) {
          setState({
            testCasePromiseHandlers: { resolve: resolve, reject: reject }
          });
        });
      });
    },
    handleResult: function handleResult(result, testCase, state) {
      // return undefined, so that player will play the next one
      return _promise2.default.resolve(undefined);
    }
  }, { preDelay: 0 });

  tsPlayer.on('START', function (_ref49) {
    var title = _ref49.title,
        extra = _ref49.extra;

    (0, _log2.default)('START SUITE');
    tsTracker.reset();
    xCmdCounter.reset();
    proxyCounter.reset();

    setState({
      tsId: extra.id,
      isPlaying: true,
      stopReason: null
    });

    store.dispatch(act.addLog('status', 'Playing test suite ' + title));
    store.dispatch(act.setPlayerMode(C.PLAYER_MODE.TEST_SUITE));
    store.dispatch(_simple_actions.Actions.updateTestSuite(extra.id, function (ts) {
      return (0, _extends4.default)({}, ts, {
        playStatus: {
          isPlaying: true,
          currentIndex: -1,
          errorIndices: [],
          doneIndices: []
        }
      });
    }));
  });

  tsPlayer.on('LOOP_START', function (_ref50) {
    var loopsCursor = _ref50.loopsCursor;

    vars.set({
      '!TESTSUITE_LOOP': loopsCursor
    }, true);
  });

  tsPlayer.on('LOOP_RESTART', function (_ref51) {
    var currentLoop = _ref51.currentLoop;

    store.dispatch(act.addLog('status', 'Current test suite loop: ' + currentLoop));
  });

  tsPlayer.on('PAUSED', function (_ref52) {
    var extra = _ref52.extra;

    (0, _log2.default)('PAUSED SUITE');
    store.dispatch(act.addLog('status', 'Test suite paused'));
    tcPlayer.pause();
  });

  tsPlayer.on('RESUMED', function (_ref53) {
    var extra = _ref53.extra;

    (0, _log2.default)('RESUMED SUIITE');
    store.dispatch(act.addLog('status', 'Test suite resumed'));
    tcPlayer.resume();
  });

  tsPlayer.on('TO_PLAY', function (_ref54) {
    var index = _ref54.index,
        extra = _ref54.extra;

    tcTracker.reset();

    setState({
      lastErrMsg: '',
      tcIndex: index
    });

    store.dispatch(_simple_actions.Actions.updateTestSuite(extra.id, function (ts) {
      return (0, _extends4.default)({}, ts, {
        playStatus: (0, _extends4.default)({}, ts.playStatus, {
          currentIndex: index
        })
      });
    }));
  });

  tsPlayer.on('PLAYED_LIST', function (_ref55) {
    var indices = _ref55.indices,
        extra = _ref55.extra;

    store.dispatch(_simple_actions.Actions.updateTestSuite(extra.id, function (ts) {
      return (0, _extends4.default)({}, ts, {
        playStatus: (0, _extends4.default)({}, ts.playStatus, {
          doneIndices: indices
        })
      });
    }));
  });

  tsPlayer.on('END', function (_ref56) {
    var reason = _ref56.reason,
        extra = _ref56.extra,
        opts = _ref56.opts;

    if (!state.isPlaying) return;

    vars.set({
      '!TESTSUITE_LOOP': 1
    }, true);

    setState({
      isPlaying: false
    });

    // Note: reset player mode to 'test case', it will only be 'test suite'
    // during replays of test suites
    store.dispatch(act.setPlayerMode(C.PLAYER_MODE.TEST_CASE));
    store.dispatch(_simple_actions.Actions.updateTestSuite(extra.id, function (ts) {
      return (0, _extends4.default)({}, ts, {
        playStatus: (0, _extends4.default)({}, ts.playStatus, {
          isPlaying: false,
          currentIndex: -1
        })
      });
    }));

    store.dispatch(act.updateUI({ shouldEnableDesktopAutomation: undefined }));

    if (reason === _player.Player.C.END_REASON.MANUAL && (!opts || !opts.tcPlayerStopped)) {
      tcPlayer.stop();
    }

    // Note: give it some time, in case we're stopping tc player above
    setTimeout(function () {
      var _statusMap;

      var totalCount = state.reports.length;
      var failureCount = state.reports.filter(function (r) {
        return r.stopReason === _player.Player.C.END_REASON.ERROR;
      }).length;
      var successCount = totalCount - failureCount;

      var statusMap = (_statusMap = {}, (0, _defineProperty3.default)(_statusMap, _player.Player.C.END_REASON.MANUAL, 'Manually stopped'), (0, _defineProperty3.default)(_statusMap, _player.Player.C.END_REASON.COMPLETE, 'OK'), (0, _defineProperty3.default)(_statusMap, _player.Player.C.END_REASON.ERROR, 'Error'), _statusMap);
      var tsStatus = statusMap[state.stopReason || reason];
      var lines = ['Test Suite name: ' + extra.name, 'Start Time: ' + tsTracker.startTime.toString(), 'Overall status: ' + tsStatus + ', Runtime: ' + tsTracker.elapsedInSeconds(), 'Macro run: ' + totalCount, 'Success: ' + successCount, 'Failure: ' + failureCount, 'Macro executed:'];

      var render = function render(_ref57) {
        var renderText = _ref57.renderText;

        return [_react2.default.createElement(
          'span',
          null,
          lines.join('\n')
        )].concat((0, _toConsumableArray3.default)(state.reports.map(function (r, i) {
          return _react2.default.createElement(
            'div',
            null,
            r.name,
            '\xA0 (',
            statusMap[r.stopReason],
            r.stopReason === _player.Player.C.END_REASON.ERROR ? ': ' : '',
            r.stopReason === _player.Player.C.END_REASON.ERROR ? renderText({ type: 'error', text: r.errMsg, stack: r.stack }) : null,
            ', Runtime: ',
            r.usedTime,
            ')'
          );
        })));
      };

      store.dispatch(act.addLog('report', render));
    }, 200);
  });

  // Test Case Player: we should handle cases when test case player stops automatically
  tcPlayer.on('END', function (_ref58) {
    var reason = _ref58.reason,
        extra = _ref58.extra;

    if (store.getState().player.mode !== C.PLAYER_MODE.TEST_SUITE) return;

    var btm = (0, _call_stack.getMacroCallStack)().bottom();
    var callStack = (0, _call_stack.getMacroCallStack)().toArray();
    var storeState = store.getState();
    var nextCommandIndex = storeState.player.lastNextCommandIndex;

    addReport({
      id: btm.resource.id,
      name: btm.resource.name,
      errMsg: state.lastErrMsg,
      stopReason: reason,
      usedTime: tcTracker.elapsedInSeconds(),
      stack: callStack.map(function (item, i) {
        return {
          macroId: item.resource.id,
          macroName: item.resource.name,
          commandIndex: i === callStack.length - 1 ? nextCommandIndex : item.runningStatus.nextIndex,
          isSubroutine: i !== 0
        };
      })
    });

    // Avoid a 'stop' loop between tsPlayer and tcPlayer
    switch (reason) {
      case _player.Player.C.END_REASON.MANUAL:
        break;

      case _player.Player.C.END_REASON.COMPLETE:
        // Note: delay the next macro run of test suite for a little bit,
        // so call stack has time to take care of itself first (like pop current frame)
        setTimeout(function () {
          state.testCasePromiseHandlers.resolve(true);
        }, 10);
        break;

      case _player.Player.C.END_REASON.ERROR:
        store.dispatch(_simple_actions.Actions.updateTestSuite(state.tsId, function (ts) {
          return (0, _extends4.default)({}, ts, {
            playStatus: (0, _extends4.default)({}, ts.playStatus, {
              errorIndices: ts.playStatus.errorIndices.concat([tsPlayer.state.nextIndex])
            })
          });
        }));

        setState({
          stopReason: _player.Player.C.END_REASON.ERROR
        });

        if (vars.get('!GLOBAL_TESTSUITE_STOP_ON_ERROR')) {
          state.testCasePromiseHandlers.reject(new Error());
          tsPlayer.stop({ tcPlayerStopped: true });
          break;
        }

        // Updated on 2017-12-15, Even if there is error, test suite should move on to next macro
        // Note: tell tsPlayer not to trigger tcPlayer stop again
        // tsPlayer.stop({ tcPlayerStopped: true })
        state.testCasePromiseHandlers.resolve(true);
        break;
    }
  });

  tcPlayer.on('ERROR', function (_ref59) {
    var msg = _ref59.msg,
        restart = _ref59.restart;

    setState({
      lastErrMsg: msg
    });

    // Note: restart this player if restart is set to true in error, and it's not in test suite mode
    // Delay the execution so that 'END' event is emitted, and player is in stopped state
    //
    // Note that a couple moments after tcPlayer encounters an error and enter stopped state, it tries to set player mode
    // back to test case mode  (in tsPlayer 'END' event)
    if (restart && store.getState().player.mode === C.PLAYER_MODE.TEST_SUITE) {
      setTimeout(function () {
        return tsPlayer.replayLastConfig();
      }, 50);
    }
  });

  return tsPlayer;
};

/***/ }),

/***/ 7281:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _dexie = __webpack_require__(40081);

var _dexie2 = _interopRequireDefault(_dexie);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var db = new _dexie2.default('selenium-ide');

db.version(1).stores({
  testCases: 'id,name,updateTime'
});

db.version(2).stores({
  testCases: 'id,name,updateTime',
  testSuites: 'id,name,updateTime'
});

db.open();

exports["default"] = db;

/***/ }),

/***/ 77278:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.eliminateBaseUrl = exports.commandWithoutBaseUrl = exports.normalizeTestCase = exports.normalizeCommand = undefined;

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _utils = __webpack_require__(63370);

var _ts_utils = __webpack_require__(55452);

var _db = __webpack_require__(7281);

var _db2 = _interopRequireDefault(_db);

var _command = __webpack_require__(69396);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var model = {
  table: _db2.default.testCases,
  list: function list() {
    return _db2.default.testCases.toArray();
  },
  insert: function insert(data) {
    if (!data.name) {
      throw new Error('Model TestCase - insert: missing name');
    }

    if (!data.data) {
      throw new Error('Model TestCase - insert: missing data');
    }

    data.updateTime = new Date() * 1;
    data.id = (0, _utils.uid)();
    return _db2.default.testCases.add(normalizeTestCase(data));
  },
  bulkInsert: function bulkInsert(tcs) {
    var list = tcs.map(function (data) {
      if (!data.name) {
        throw new Error('Model TestCase - insert: missing name');
      }

      if (!data.data) {
        throw new Error('Model TestCase - insert: missing data');
      }

      data.updateTime = new Date() * 1;
      data.id = (0, _utils.uid)();

      return normalizeTestCase(data);
    });

    return _db2.default.testCases.bulkAdd(list);
  },
  update: function update(id, data) {
    return _db2.default.testCases.update(id, normalizeTestCase(data));
  },
  remove: function remove(id) {
    return _db2.default.testCases.delete(id);
  }
};

exports["default"] = model;
var normalizeCommand = exports.normalizeCommand = function normalizeCommand(command) {
  var result = (0, _ts_utils.pickIfExist)(['cmd', 'target', 'value', 'targetOptions', 'description'], command);

  if (!(0, _command.doesCommandSupportTargetOptions)(result.cmd)) {
    delete result.targetOptions;
  }

  return result;
};

var normalizeTestCase = exports.normalizeTestCase = function normalizeTestCase(testCase) {
  var intermediate = (0, _utils.compose)((0, _utils.on)('data'), (0, _utils.on)('commands'), _utils.map)(normalizeCommand)(testCase);

  return (0, _ts_utils.pickIfExist)(['id', 'data', 'name', 'path'], intermediate);
};

var commandWithoutBaseUrl = exports.commandWithoutBaseUrl = function commandWithoutBaseUrl(baseUrl) {
  return function (command) {
    if (command.cmd !== 'open') return command;

    return (0, _extends3.default)({}, command, {
      target: (baseUrl + '/' + command.target).replace(/\/+/g, '/')
    });
  };
};

var eliminateBaseUrl = exports.eliminateBaseUrl = function eliminateBaseUrl(testCase) {
  if (!testCase.baseUrl) return testCase;
  return (0, _utils.compose)((0, _utils.on)('data'), (0, _utils.on)('commands'), _utils.map)(commandWithoutBaseUrl(testCase.baseUrl))(testCase);
};

/***/ }),

/***/ 64580:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.normalizeTestSuite = normalizeTestSuite;

var _utils = __webpack_require__(63370);

var _ts_utils = __webpack_require__(55452);

var _db = __webpack_require__(7281);

var _db2 = _interopRequireDefault(_db);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var model = {
  table: _db2.default.testSuites,
  list: function list() {
    return _db2.default.testSuites.toArray();
  },
  insert: function insert(data) {
    if (!data.name) {
      throw new Error('Model TestSuite - insert: missing name');
    }

    if (!Array.isArray(data.cases)) {
      throw new Error('Model TestSuite - insert: cases should an array');
    }

    data.updateTime = new Date() * 1;
    data.id = (0, _utils.uid)();
    return _db2.default.testSuites.add(data);
  },
  bulkInsert: function bulkInsert(tcs) {
    var list = tcs.map(function (data) {
      if (!data.name) {
        throw new Error('Model TestSuite - insert: missing name');
      }

      if (!Array.isArray(data.cases)) {
        throw new Error('Model TestSuite - insert: cases should an array');
      }

      data.updateTime = new Date() * 1;
      data.id = (0, _utils.uid)();

      return data;
    });

    return _db2.default.testSuites.bulkAdd(list);
  },
  update: function update(id, data) {
    return _db2.default.testSuites.update(id, data);
  },
  remove: function remove(id) {
    return _db2.default.testSuites.delete(id);
  }
};

exports["default"] = model;
function normalizeTestSuite(ts) {
  return (0, _ts_utils.pickIfExist)(['id', 'name', 'cases'], ts);
}

/***/ }),

/***/ 50170:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _defineProperty2 = __webpack_require__(88106);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _toConsumableArray2 = __webpack_require__(85315);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _extends3 = __webpack_require__(88239);

var _extends4 = _interopRequireDefault(_extends3);

var _objectWithoutProperties2 = __webpack_require__(42723);

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

exports["default"] = reducer;

var _urlParse = __webpack_require__(84564);

var _urlParse2 = _interopRequireDefault(_urlParse);

var _lodash = __webpack_require__(72307);

var _lodash2 = _interopRequireDefault(_lodash);

var _action_types = __webpack_require__(17304);

var _simple_actions = __webpack_require__(46469);

var _utils = __webpack_require__(63370);

var _test_case_model = __webpack_require__(77278);

var _convert_utils = __webpack_require__(61169);

var _constant = __webpack_require__(43232);

var C = _interopRequireWildcard(_constant);

var _log = __webpack_require__(77242);

var _log2 = _interopRequireDefault(_log);

var _ts_utils = __webpack_require__(55452);

var _recomputed = __webpack_require__(78328);

var _state = __webpack_require__(16112);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Note: for update the `hasUnsaved` status in editing.meta
var updateHasUnSaved = function updateHasUnSaved(state) {
  var _state$editor$editing = state.editor.editing,
      meta = _state$editor$editing.meta,
      data = (0, _objectWithoutProperties3.default)(_state$editor$editing, ['meta']);

  var id = meta.src && meta.src.id;
  if (!id) return state;

  var currentMacro = state.editor.currentMacro;
  var normalizedEditing = (0, _test_case_model.normalizeTestCase)({ data: data });
  var hasUnsaved = !(0, _lodash2.default)(currentMacro && currentMacro.data, normalizedEditing.data);

  return (0, _utils.setIn)(['editor', 'editing', 'meta', 'hasUnsaved'], hasUnsaved, state);
};

var updateBreakpointIndices = function updateBreakpointIndices(indices, action, actionIndex) {
  var handleSingleAction = function handleSingleAction(indices, action, actionIndex) {
    switch (action) {
      case 'add':
        {
          var result = indices.slice();

          for (var i = 0, len = indices.length; i < len; i++) {
            if (result[i] >= actionIndex) {
              result[i] += 1;
            }
          }

          return result;
        }

      case 'delete':
        {
          var _result = indices.slice();

          for (var _i = indices.length - 1; _i >= 0; _i--) {
            if (_result[_i] > actionIndex) {
              _result[_i] -= 1;
            } else if (_result[_i] === actionIndex) {
              _result.splice(_i, 1);
            }
          }

          return _result;
        }

      default:
        throw new Error('updateBreakpointIndices: unknown action, \'' + action + '\'');
    }
  };

  if (typeof actionIndex === 'number') {
    return handleSingleAction(indices, action, actionIndex);
  }

  if (Array.isArray(actionIndex)) {
    // Note: sort action indices as desc.  Bigger indice will be handled earlier, so that it won't affect others
    var actionIndices = actionIndex.slice();
    actionIndices.sort(function (a, b) {
      return b - a;
    });

    return actionIndices.reduce(function (indices, actionIndex) {
      return handleSingleAction(indices, action, actionIndex);
    }, indices);
  }

  throw new Error('updateBreakpointIndices: actionIndex should be either number or an array of number');
};

var resetEditingSource = (0, _utils.partial)(function (macro, state) {
  (0, _log2.default)('resetEditingSource', macro);
  var str = (0, _convert_utils.toJSONString)(macro, {
    ignoreTargetOptions: (0, _recomputed.getShouldSaveAlternativeLocators)(state)
  });
  return (0, _utils.setIn)(['editor', 'editingSource'], {
    original: str,
    pure: str,
    current: str,
    error: null
  }, state);
});

var setEditingSourceCurrent = function setEditingSourceCurrent(state) {
  var macro = {
    name: state.editor.editing.meta.src ? state.editor.editing.meta.src.name : 'Untitled',
    commands: state.editor.editing.commands
  };
  (0, _log2.default)('setEditingSourceCurrent', macro);

  var str = (0, _convert_utils.toJSONString)(macro, {
    ignoreTargetOptions: (0, _recomputed.getShouldSaveAlternativeLocators)(state)
  });
  return (0, _utils.updateIn)(['editor', 'editingSource'], function (editingSource) {
    return (0, _extends4.default)({}, editingSource, { pure: str, current: str });
  }, state);
};

var saveEditingSourceCurrent = function saveEditingSourceCurrent(state) {
  var current = state.editor.editingSource.current;

  return (0, _utils.updateIn)(['editor', 'editingSource'], function (editingSource) {
    return (0, _extends4.default)({}, editingSource, { pure: current, original: current });
  }, state);
};

var setEditingSourceOriginalAndPure = function setEditingSourceOriginalAndPure(macro, state) {
  var str = (0, _convert_utils.toJSONString)(macro, {
    ignoreTargetOptions: (0, _recomputed.getShouldSaveAlternativeLocators)(state)
  });
  return (0, _utils.updateIn)(['editor', 'editingSource'], function (editingSource) {
    return (0, _extends4.default)({}, editingSource, { pure: str, original: str });
  }, state);
};

function reducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _state.initialState;
  var action = arguments[1];

  switch (action.type) {
    case _action_types.types.START_RECORDING_SUCCESS:
      return (0, _extends4.default)({}, state, {
        status: C.APP_STATUS.RECORDER,
        recorderStatus: C.APP_STATUS.PENDING,
        player: (0, _extends4.default)({}, state.player, {
          nextCommandIndex: null
        })
      });
    case _action_types.types.STOP_RECORDING_SUCCESS:
      return (0, _extends4.default)({}, state, {
        status: C.APP_STATUS.NORMAL,
        recorderStatus: C.RECORDER_STATUS.STOPPED
      });
    case _action_types.types.START_INSPECTING_SUCCESS:
      return (0, _extends4.default)({}, state, {
        status: C.APP_STATUS.INSPECTOR,
        inspectorStatus: C.INSPECTOR_STATUS.PENDING
      });
    case _action_types.types.STOP_INSPECTING_SUCCESS:
    case _action_types.types.DONE_INSPECTING:
      return (0, _extends4.default)({}, state, {
        status: C.APP_STATUS.NORMAL,
        recorderStatus: C.INSPECTOR_STATUS.STOPPED
      });

    case _action_types.types.START_PLAYING:
      return (0, _extends4.default)({}, state, {
        status: C.APP_STATUS.PLAYER
      });

    case _action_types.types.STOP_PLAYING:
      return (0, _extends4.default)({}, state, {
        status: C.APP_STATUS.NORMAL
      });

    case _action_types.types.APPEND_COMMAND:
      return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (commands) {
        return [].concat((0, _toConsumableArray3.default)(commands), [action.data.command]);
      }))(state);

    case _action_types.types.DUPLICATE_COMMAND:
      return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.setIn)(['editor', 'editing', 'meta', 'selectedIndex'], action.data.index + 1), (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (commands) {
        var index = action.data.index;

        var newCommands = commands.slice();
        newCommands.splice(index + 1, 0, commands[index]);
        return newCommands;
      }), (0, _ts_utils.safeUpdateIn)(['editor', 'macrosExtra', (0, _recomputed.getCurrentMacroId)(state), 'breakpointIndices'], function (indices) {
        return updateBreakpointIndices(indices || [], 'add', action.data.index + 1);
      }))(state);

    case _action_types.types.INSERT_COMMAND:
      return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.setIn)(['editor', 'editing', 'meta', 'selectedIndex'], action.data.index), (0, _utils.updateIn)(['editor', 'editing', 'meta', 'indexToInsertRecorded'], function (recordIndex) {
        if (recordIndex === undefined || recordIndex === null || recordIndex < 0) {
          return recordIndex;
        }
        return recordIndex + (action.data.index <= recordIndex ? 1 : 0);
      }), (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (commands) {
        var _action$data = action.data,
            index = _action$data.index,
            command = _action$data.command;

        var newCommands = commands.slice();
        newCommands.splice(index, 0, command);
        return newCommands;
      }), (0, _ts_utils.safeUpdateIn)(['editor', 'macrosExtra', (0, _recomputed.getCurrentMacroId)(state), 'breakpointIndices'], function (indices) {
        return updateBreakpointIndices(indices || [], 'add', action.data.index);
      }))(state);

    case _action_types.types.UPDATE_COMMAND:
      return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.updateIn)(['editor', 'editing', 'commands', action.data.index], function (cmdObj) {
        return (0, _extends4.default)({}, cmdObj, action.data.command);
      }))(state);

    case _action_types.types.REMOVE_COMMAND:
      return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, function (state) {
        var _state$editor$editing2 = state.editor.editing,
            commands = _state$editor$editing2.commands,
            meta = _state$editor$editing2.meta;

        var isSelectedIndexStillValid = meta.selectedIndex >= 0 && meta.selectedIndex < commands.length;

        if (isSelectedIndexStillValid) {
          return state;
        }

        var startDistance = action.data.index;
        var endDistance = commands.length - action.data.index - 1;
        var nextSelectedIndex = startDistance < endDistance ? 0 : commands.length - 1;

        return (0, _utils.setIn)(['editor', 'editing', 'meta', 'selectedIndex'], nextSelectedIndex, state);
      }, (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (commands) {
        var index = action.data.index;

        var newCommands = commands.slice();
        newCommands.splice(index, 1);
        return newCommands;
      }), (0, _ts_utils.safeUpdateIn)(['editor', 'macrosExtra', (0, _recomputed.getCurrentMacroId)(state), 'breakpointIndices'], function (indices) {
        return updateBreakpointIndices(indices || [], 'delete', action.data.index);
      }))(state);

    case _action_types.types.SELECT_COMMAND:
      return (0, _utils.compose)((0, _utils.setIn)(['editor', 'editing', 'meta', 'selectedIndex'], action.data.forceClick || state.editor.editing.meta.selectedIndex !== action.data.index ? action.data.index : -1),
      // Note: normalize commands whenever switching between commands in normal mode
      state.status === C.APP_STATUS.NORMAL ? (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (cmds) {
        return cmds.map(_test_case_model.normalizeCommand);
      }) : function (x) {
        return x;
      })(state);

    case _action_types.types.CUT_COMMAND:
      {
        var commands = action.data.indices.map(function (i) {
          return state.editor.editing.commands[i];
        });

        return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.setIn)(['editor', 'clipboard', 'commands'], commands), (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (commands) {
          var newCommands = commands.slice();
          return newCommands.filter(function (c, i) {
            return action.data.indices.indexOf(i) === -1;
          });
        }), (0, _ts_utils.safeUpdateIn)(['editor', 'macrosExtra', (0, _recomputed.getCurrentMacroId)(state), 'breakpointIndices'], function (indices) {
          return updateBreakpointIndices(indices || [], 'delete', action.data.indices);
        }))(state);
      }

    case _action_types.types.COPY_COMMAND:
      {
        var _commands = action.data.indices.map(function (i) {
          return state.editor.editing.commands[i];
        });
        return (0, _utils.setIn)(['editor', 'clipboard', 'commands'], _commands, state);
      }

    case _action_types.types.PASTE_COMMAND:
      {
        var _commands2 = state.editor.clipboard.commands;


        return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (cmds) {
          var newCmds = cmds.slice();
          newCmds.splice.apply(newCmds, [action.data.index + 1, 0].concat((0, _toConsumableArray3.default)(_commands2)));
          return newCmds;
        }), (0, _ts_utils.safeUpdateIn)(['editor', 'macrosExtra', (0, _recomputed.getCurrentMacroId)(state), 'breakpointIndices'], function (indices) {
          return updateBreakpointIndices(indices || [], 'add', _commands2.map(function (_) {
            return action.data.index + 1;
          }));
        }))(state);
      }

    case _simple_actions.ActionTypes.moveCommands:
      {
        var _state$editor$editing3 = state.editor.editing.commands,
            _commands3 = _state$editor$editing3 === undefined ? [] : _state$editor$editing3;

        var _action$data2 = action.data,
            startIndex = _action$data2.startIndex,
            endIndex = _action$data2.endIndex;


        if (startIndex < 0 || startIndex >= _commands3.length) {
          throw new Error('startIndex is out of range');
        }

        if (endIndex < 0 || endIndex >= _commands3.length) {
          throw new Error('endIndex is out of range');
        }

        if (endIndex === startIndex) {
          throw new Error('startIndex and endIndex must be different');
        }

        var newCommands = [].concat((0, _toConsumableArray3.default)(_commands3));

        newCommands.splice(startIndex, 1);
        newCommands.splice(endIndex, 0, _commands3[startIndex]);

        return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.setIn)(['editor', 'editing', 'commands'], newCommands), (0, _utils.updateIn)(['editor', 'editing', 'meta', 'selectedIndex'], function (selectedIndex) {
          switch (selectedIndex) {
            case startIndex:
              return endIndex;
            case endIndex:
              return startIndex;
            default:
              return selectedIndex;
          }
        }))(state);
      }

    case _action_types.types.NORMALIZE_COMMANDS:
      return (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (cmds) {
        return cmds.map(_test_case_model.normalizeCommand);
      }, state);

    case _action_types.types.UPDATE_SELECTED_COMMAND:
      if (state.editor.editing.meta.selectedIndex === -1) {
        return state;
      }

      return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.updateIn)(['editor', 'editing', 'commands', state.editor.editing.meta.selectedIndex], function (cmdObj) {
        return (0, _test_case_model.normalizeCommand)((0, _extends4.default)({}, cmdObj, action.data));
      }))(state);

    case _action_types.types.SAVE_EDITING_AS_EXISTED:
      return (0, _utils.compose)((0, _utils.setIn)(['editor', 'editing', 'meta', 'hasUnsaved'], false), saveEditingSourceCurrent)(state);

    case _action_types.types.SAVE_EDITING_AS_NEW:
      return (0, _utils.compose)((0, _utils.updateIn)(['editor', 'editing', 'meta'], function (meta) {
        return (0, _extends4.default)({}, meta, {
          hasUnsaved: false,
          src: (0, _utils.pick)(['id', 'name'], action.data)
        });
      }), saveEditingSourceCurrent)(state);

    case _action_types.types.SET_TEST_CASES:
      {
        return (0, _utils.compose)(function (state) {
          var src = state.editor.editing.meta.src;

          if (!src) return state;

          var tc = state.editor.testCases.find(function (tc) {
            return tc.id === src.id;
          });
          if (!tc) return state;

          return setEditingSourceOriginalAndPure({
            name: tc.name,
            commands: tc.data.commands
          }, state);
        }, (0, _utils.setIn)(['editor', 'testCases'], action.data))(state);
      }

    case _action_types.types.SET_TEST_SUITES:
      return (0, _utils.setIn)(['editor', 'testSuites'], action.data, state);

    case _simple_actions.ActionTypes.updateTestSuite:
      {
        var _action$data3 = action.data,
            id = _action$data3.id,
            updated = _action$data3.updated;

        var index = state.editor.testSuites.findIndex(function (ts) {
          return ts.id === id;
        });

        if (index === -1) return state;
        return (0, _utils.setIn)(['editor', 'testSuites', index], updated, state);
      }

    case _action_types.types.UPDATE_TEST_SUITE_STATUS:
      {
        var _action$data4 = action.data,
            _id = _action$data4.id,
            extra = _action$data4.extra;

        if (!_id) return state;

        return (0, _utils.updateIn)(['editor', 'testSuitesExtra'], function (data) {
          return (0, _extends4.default)({}, data, (0, _defineProperty3.default)({}, _id, extra));
        }, state);
      }

    case _action_types.types.SET_EDITING:
      (0, _log2.default)('REDUCER SET_EDITING', action.data);

      if (!action.data) return state;
      return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.setIn)(['editor', 'editing'], action.data))(state);

    case _action_types.types.EDIT_TEST_CASE:
      {
        var _ref = state.editor.editing.meta.src || {},
            _id2 = _ref.id;

        if (!action.data.macro) return state;

        var macro = action.data.macro;

        return (0, _utils.compose)((0, _utils.setIn)(['editor', 'editing'], (0, _extends4.default)({}, macro.data, {
          meta: {
            selectedIndex: -1,
            hasUnsaved: false,
            src: (0, _utils.pick)(['id', 'name'], macro)
          }
        })), (0, _utils.updateIn)(['player'], function (player) {
          return (0, _extends4.default)({}, player, {
            status: C.PLAYER_STATUS.STOPPED,
            stopReason: null,
            nextCommandIndex: null
          });
        }), resetEditingSource({
          name: macro.name,
          commands: macro.data.commands
        }), updateHasUnSaved)(state);
      }

    case _action_types.types.SET_ONE_MACRO_EXTRA:
      {
        var _action$data5 = action.data,
            _id3 = _action$data5.id,
            _extra = _action$data5.extra;


        if (!_id3) return state;

        return (0, _ts_utils.safeSetIn)(['editor', 'macrosExtra', _id3], _extra, state);
      }

    case _action_types.types.UPDATE_ONE_MACRO_EXTRA:
      {
        var _action$data6 = action.data,
            _id4 = _action$data6.id,
            _extra2 = _action$data6.extra;


        if (!_id4) return state;

        return (0, _ts_utils.safeUpdateIn)(['editor', 'macrosExtra', _id4], function (data) {
          return (0, _extends4.default)({}, data, _extra2);
        }, state);
      }

    case _simple_actions.ActionTypes.renameTestCase:
      return (0, _utils.setIn)(['editor', 'editing', 'meta', 'src', 'name'], action.data, state);

    case _action_types.types.REMOVE_TEST_CASE:
      {
        if (!action.data.isCurrent) return state;

        var _id5 = state.editor.editing.meta.src.id;
        var selectedIndex = state.editor.editing.meta.selectedIndex;

        var candidates = state.editor.testCases.filter(function (tc) {
          return tc.id !== _id5;
        });
        var lastIndex = state.editor.testCases.findIndex(function (tc) {
          return tc.id === _id5;
        });
        var editing = void 0;

        if (candidates.length === 0) {
          editing = (0, _extends4.default)({}, _state.newTestCaseEditing);
        } else {
          var _index = lastIndex === -1 ? 0 : lastIndex < candidates.length ? lastIndex : lastIndex - 1;
          var tc = candidates[_index];

          editing = (0, _extends4.default)({}, tc.data, {
            meta: {
              src: (0, _utils.pick)(['id', 'name'], tc),
              hasUnsaved: false,
              selectedIndex: _index
            }
          });
        }

        return (0, _utils.setIn)(['editor', 'editing'], editing, state);
      }

    case _action_types.types.EDIT_NEW_TEST_CASE:
      {
        return (0, _utils.compose)((0, _utils.setIn)(['editor', 'editing'], (0, _extends4.default)({}, _state.newTestCaseEditing)), (0, _utils.updateIn)(['player'], function (player) {
          return (0, _extends4.default)({}, player, {
            nextCommandIndex: null
          });
        }), resetEditingSource({
          name: 'Untitled',
          commands: []
        }))(state);
      }

    case _action_types.types.SET_MACROS_EXTRA:
      {
        return (0, _utils.setIn)(['editor', 'macrosExtra'], action.data, state);
      }

    case _action_types.types.SET_TEST_SUITES_EXTRA:
      {
        return (0, _utils.setIn)(['editor', 'testSuitesExtra'], action.data, state);
      }

    case _simple_actions.ActionTypes.setMacroFolderStructure:
      {
        return (0, _utils.setIn)(['editor', 'macroFolderStructure'], action.data, state);
      }

    case _simple_actions.ActionTypes.setTestSuiteFolderStructure:
      {
        return (0, _utils.setIn)(['editor', 'testSuiteFolderStructure'], action.data, state);
      }

    case _action_types.types.SET_PLAYER_STATE:
      return (0, _utils.compose)((0, _utils.updateIn)(['player'], function (playerState) {
        return (0, _extends4.default)({}, playerState, action.data);
      }), (0, _utils.updateIn)(['noDisplayInPlay'], function (noDisplayInPlay) {
        // Reset noDisplay to false when macro stops playing
        return action.data.status === C.PLAYER_STATUS.STOPPED ? false : noDisplayInPlay;
      }))(state);

    case _action_types.types.ADD_LOGS:
      return (0, _extends4.default)({}, state, {
        logs: [].concat((0, _toConsumableArray3.default)(state.logs), (0, _toConsumableArray3.default)(action.data)).slice(-500)
      });

    case _action_types.types.CLEAR_LOGS:
      return (0, _extends4.default)({}, state, {
        logs: []
      });

    case _action_types.types.ADD_SCREENSHOT:
      return (0, _extends4.default)({}, state, {
        screenshots: [].concat((0, _toConsumableArray3.default)(state.screenshots), [action.data])
      });

    case _action_types.types.CLEAR_SCREENSHOTS:
      return (0, _extends4.default)({}, state, {
        screenshots: []
      });

    case _action_types.types.UPDATE_CONFIG:
      return (0, _utils.updateIn)(['config'], function (cfg) {
        return (0, _extends4.default)({}, cfg, action.data);
      }, state);

    case _action_types.types.SET_CSV_LIST:
      return (0, _extends4.default)({}, state, {
        csvs: action.data
      });

    case _action_types.types.SET_SCREENSHOT_LIST:
      return (0, _extends4.default)({}, state, {
        screenshots: action.data
      });

    case _action_types.types.SET_VISION_LIST:
      return (0, _extends4.default)({}, state, {
        visions: action.data
      });

    case _action_types.types.SET_VARIABLE_LIST:
      return (0, _extends4.default)({}, state, {
        variables: action.data
      });

    case _action_types.types.UPDATE_UI:
      {
        return (0, _utils.updateIn)(['ui'], function (ui) {
          return (0, _extends4.default)({}, ui, action.data);
        }, state);
      }

    case _action_types.types.SET_EDITOR_ACTIVE_TAB:
      {
        return (0, _utils.setIn)(['editor', 'activeTab'], action.data, state);
      }

    case _action_types.types.SET_SOURCE_ERROR:
      {
        return (0, _utils.setIn)(['editor', 'editingSource', 'error'], action.data, state);
      }

    case _action_types.types.SET_SOURCE_CURRENT:
      {
        return (0, _utils.setIn)(['editor', 'editingSource', 'current'], action.data, state);
      }

    case _action_types.types.UPDATE_PROXY:
      {
        return (0, _extends4.default)({}, state, {
          proxy: action.data
        });
      }

    case _simple_actions.ActionTypes.setIsDraggingCommand:
      {
        return (0, _utils.setIn)(['editor', 'isDraggingCommand'], action.data, state);
      }

    case _simple_actions.ActionTypes.setCurrentMacro:
      {
        return (0, _utils.setIn)(['editor', 'currentMacro'], action.data, state);
      }

    case _simple_actions.ActionTypes.setIsLoadingMacros:
      {
        return (0, _utils.setIn)(['isLoadingMacros'], action.data, state);
      }

    case _simple_actions.ActionTypes.setFrom:
      {
        return (0, _utils.setIn)(['from'], action.data, state);
      }

    case _simple_actions.ActionTypes.setNoDisplayInPlay:
      {
        return (0, _utils.setIn)(['noDisplayInPlay'], action.data, state);
      }

    case _simple_actions.ActionTypes.setMacroQuery:
      {
        return (0, _utils.setIn)(['macroQuery'], action.data, state);
      }

    case _simple_actions.ActionTypes.setIndexToInsertRecorded:
      {
        return (0, _utils.setIn)(['editor', 'editing', 'meta', 'indexToInsertRecorded'], action.data, state);
      }

    case _simple_actions.ActionTypes.toggleRecorderSkipOpen:
      {
        return (0, _utils.updateIn)(['recorder', 'skipOpen'], function (skipOpen) {
          return action.data !== undefined ? action.data : !skipOpen;
        }, state);
      }

    default:
      return state;
  }
}

/***/ }),

/***/ 56819:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createStore = exports.reducer = exports.Provider = undefined;

var _reactRedux = __webpack_require__(33664);

var _redux = __webpack_require__(74127);

var _reduxThunk = __webpack_require__(53894);

var _reduxThunk2 = _interopRequireDefault(_reduxThunk);

var _promise_middleware = __webpack_require__(91952);

var _promise_middleware2 = _interopRequireDefault(_promise_middleware);

var _post_logic_middleware = __webpack_require__(62343);

var _post_logic_middleware2 = _interopRequireDefault(_post_logic_middleware);

var _reducers = __webpack_require__(50170);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createStore = (0, _redux.applyMiddleware)(_reduxThunk2.default, (0, _promise_middleware2.default)(), (0, _post_logic_middleware2.default)())(_redux.createStore);

exports.Provider = _reactRedux.Provider;
exports.reducer = _reducers2.default;
exports.createStore = createStore;

/***/ }),

/***/ 62343:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _objectWithoutProperties2 = __webpack_require__(42723);

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

exports["default"] = postLogicMiddleWare;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Note: if `post` field provided, it will call `post`
// after the action dispatched and state updated
function postLogicMiddleWare(extra) {
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        var post = action.post,
            rest = (0, _objectWithoutProperties3.default)(action, ['post']);


        if (post && typeof post === 'function') {
          setTimeout(function () {
            post({ dispatch: dispatch, getState: getState }, action, extra);
          }, 0);
        } else if (Array.isArray(post)) {
          post.forEach(function (fn) {
            setTimeout(function () {
              fn({ dispatch: dispatch, getState: getState }, action, extra);
            }, 0);
          });
        }

        return next(action);
      };
    };
  };
}

/***/ }),

/***/ 91952:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _extends2 = __webpack_require__(88239);

var _extends3 = _interopRequireDefault(_extends2);

var _slicedToArray2 = __webpack_require__(12424);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _objectWithoutProperties2 = __webpack_require__(42723);

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

exports["default"] = promiseMiddleWare;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Note: if a `promise` field and a `types` provied, this middleware will dispatch
// 3 actions REQUEST, SUCCESS, FAILURE based on the status of the promise it returns
function promiseMiddleWare() {
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;

    return function (next) {
      return function (action) {
        var promise = action.promise,
            types = action.types,
            rest = (0, _objectWithoutProperties3.default)(action, ["promise", "types"]);


        if (!promise) {
          return next(action);
        }

        var _types = (0, _slicedToArray3.default)(types, 3),
            REQUEST = _types[0],
            SUCCESS = _types[1],
            FAILURE = _types[2];

        next((0, _extends3.default)({}, rest, { type: REQUEST }));
        return promise().then(function (data) {
          return next((0, _extends3.default)({}, rest, { data: data, type: SUCCESS }));
        }, function (error) {
          return next((0, _extends3.default)({}, rest, { err: error, type: FAILURE }));
        });
      };
    };
  };
};

/***/ }),

/***/ 98389:
/***/ ((module, exports, __webpack_require__) => {

exports = module.exports = __webpack_require__(9252)(false);
// imports


// module
exports.push([module.id, "body{margin:0;padding:0;font-size:16px}*{-webkit-box-sizing:border-box;box-sizing:border-box}.app{position:absolute;top:0;bottom:0;left:0;right:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.app.no-display .status{margin-bottom:20px;font-size:14px}.app.no-display .content{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.app.with-alert .backup-alert{display:block}.app .app-inner{-webkit-box-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.app .backup-alert{display:none;padding:5px 0;text-align:center;font-size:14px;background:#fdfdc2}.app .backup-alert .backup-actions{margin-left:20px}.app .backup-alert .backup-actions button{margin-right:10px}.app .content{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:3;-ms-flex:3;flex:3;min-width:520px;background:#fff;overflow-y:auto}.app .hidden-during-replay{-webkit-box-orient:horizontal;-ms-flex-direction:row;flex-direction:row;padding-top:15px;font-size:14px;color:#999}.app .hidden-during-replay,.app .list-not-loaded{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-direction:normal;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.app .list-not-loaded{-webkit-box-orient:vertical;-ms-flex-direction:column;flex-direction:column}.app .list-not-loaded button{margin-top:20px}", ""]);

// exports


/***/ }),

/***/ 29773:
/***/ ((module, exports, __webpack_require__) => {

exports = module.exports = __webpack_require__(9252)(false);
// imports


// module
exports.push([module.id, ".header{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;overflow:hidden;padding:0 20px;width:100%;height:44px;border-bottom:2px solid #ccc;background-color:#f9f9f9}.header .status{float:right;line-height:42px;font-size:14px}.header .status h1{margin:0;font-size:20px;line-height:44px}.header .select-case{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;line-height:44px;font-size:13px}.header .select-case .test-case-name{margin-right:15px;line-height:35px;max-width:100px;overflow:hidden;display:inline-block;white-space:nowrap;text-overflow:ellipsis}.header .select-case .test-case-name.unsaved{color:orange}.header .select-case .test-case-name.unsaved:after{content:\"*\";margin-left:3px}.header .actions{margin-top:6px}.header .actions .ant-btn-group>.ant-btn-group{float:none}.header .actions .play-actions{margin:0 10px}.ant-dropdown-menu{max-height:300px;overflow-y:auto}.ant-dropdown-menu .editing{color:blue!important}.settings-modal .ant-tabs-nav .ant-tabs-tab{margin-right:12px;padding:8px 6px}.settings-modal .ant-checkbox-wrapper+.ant-checkbox-wrapper{margin-left:0}.settings-modal .tip{margin-left:15px;color:#aaa}.settings-modal .xmodule-item{margin-bottom:25px;padding:15px;border:2px solid #333;font-size:14px;-webkit-box-shadow:rgba(0,0,0,.5) 0 2px 5px 0;box-shadow:0 2px 5px 0 rgba(0,0,0,.5)}.settings-modal .xmodule-item label{margin-right:15px;width:100px;font-size:14px}.settings-modal .xmodule-item .xmodule-title{margin-bottom:10px;font-size:14px}.settings-modal .xmodule-item .xmodule-title>*{margin-right:20px}.settings-modal .xmodule-item .xmodule-title>:last-child{margin-right:0}.settings-modal .xmodule-item .xmodule-status{display:-webkit-box;display:-ms-flexbox;display:flex;margin-bottom:20px}.settings-modal .xmodule-item .xmodule-status .status-box>*{margin-right:15px}.settings-modal .xmodule-item .xmodule-status .status-box>:last-child{margin-right:0}.settings-modal .xmodule-item .xmodule-settings h3{margin-bottom:10px;font-size:14px;font-weight:700}.settings-modal .xmodule-item .xmodule-settings .xmodule-settings-item .settings-detail{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;margin-bottom:10px}.settings-modal .xmodule-item .xmodule-settings .xmodule-settings-item .settings-detail .settings-detail-content{-webkit-box-flex:1;-ms-flex:1;flex:1}.settings-modal .xmodule-item .xmodule-settings .check-result{margin-top:5px;color:red;font-size:13px}.settings-modal .backup-pane{padding:0 20px}.settings-modal .backup-pane h4{font-size:16px;margin-bottom:10px}.settings-modal .backup-pane .row{margin-bottom:10px}.settings-modal .backup-pane p,.settings-modal .backup-pane ul li{margin-bottom:5px}.settings-modal .api-pane{padding:0 20px 20px}.settings-modal .api-pane p{margin:20px 0}.settings-modal .selenium-pane{padding:0 20px 20px}.settings-modal .selenium-pane h4{font-size:16px;margin-bottom:10px}.settings-modal .selenium-pane .import-row{margin-top:20px;margin-bottom:20px}.settings-modal .selenium-pane .import-row button{margin-right:20px}.settings-modal .security-pane{padding:0 20px 20px}.settings-modal .security-pane h4{font-size:16px;margin-bottom:10px}.settings-modal .security-pane p{margin-bottom:10px}.settings-modal .security-pane label{margin-right:10px}.settings-modal .security-pane .ant-radio-wrapper{display:block;height:30px;line-height:30px}.settings-modal .security-pane .input-line{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-bottom:10px}.settings-modal .security-pane .input-line .input-label{width:120px}.settings-modal .security-pane .input-line .ant-checkbox-wrapper{margin-left:15px}.settings-modal .security-pane .input-line a{margin-left:20px}.settings-modal .ocr-pane{padding:0 20px 20px}.settings-modal .ocr-pane p{margin-bottom:10px}.settings-modal .ocr-pane .row{margin-bottom:20px}.settings-modal .ocr-pane .radio-block .ant-radio-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;line-height:30px}.settings-modal .ocr-pane .radio-block .ant-radio-wrapper.need-pro{color:gray}.settings-modal .ocr-pane .radio-block .ant-radio-wrapper .ant-radio{margin-top:8px}.settings-modal .ocr-pane .radio-block .ant-radio-wrapper .offline-label{display:inline-block;width:80px}.settings-modal .ocr-pane .label-text{margin-right:15px}.settings-modal .vision-pane{padding:0 20px 20px}.settings-modal .vision-pane .row,.settings-modal .vision-pane p{margin-bottom:10px}.settings-modal .vision-pane .ant-radio-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;line-height:30px}.settings-modal .vision-pane .ant-radio-wrapper .ant-radio{margin-top:8px}.settings-modal .vision-pane .ant-form-item label{width:280px;color:rgba(0,0,0,.65)}.settings-modal .xmodules-pane{padding:0 0 20px}.settings-modal .register-pane .register-note{width:80%}.settings-modal .register-pane .register-note .actions{margin-top:15px}.settings-modal .register-pane .register-note.inactive,.settings-modal .register-pane .register-note.inactive a{color:#aaa}.settings-modal .register-pane .register-form{margin-top:25px}.settings-modal .register-pane .register-form label{display:block;margin-bottom:10px;font-weight:700}.settings-modal .register-pane .register-form .register-row{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.settings-modal .register-pane .register-form .register-row input{margin-right:15px;width:40%}.settings-modal .register-pane .register-status{margin-top:25px}.settings-modal .register-pane .register-status a{margin-left:15px}", ""]);

// exports


/***/ }),

/***/ 51749:
/***/ ((module, exports, __webpack_require__) => {

exports = module.exports = __webpack_require__(9252)(false);
// imports


// module
exports.push([module.id, ".select-input{position:relative}.select-input input{padding-right:24px}.select-input .arrow-icon{position:absolute;top:50%;right:8px;-webkit-transform:scale(.75) rotate(0deg);transform:scale(.75) rotate(0deg);color:rgba(0,0,0,.43);-webkit-transition:-webkit-transform .2s ease;transition:-webkit-transform .2s ease;transition:transform .2s ease;transition:transform .2s ease,-webkit-transform .2s ease;pointer-events:none;cursor:pointer}.select-input.opened .arrow-icon{-webkit-transform:scale(.75) rotate(180deg);transform:scale(.75) rotate(180deg)}.drop-down .option-list{position:absolute;z-index:1000;border-radius:4px;font-size:12px;background:#fff;-webkit-box-shadow:0 1px 6px rgba(0,0,0,.2);box-shadow:0 1px 6px rgba(0,0,0,.2)}.drop-down .option-list .plain-text-option{padding:7px 8px;cursor:pointer}.drop-down .option-list .plain-text-option.selected{background-color:#f7f7f7;font-weight:600}.drop-down .option-list .plain-text-option:hover{background-color:#ecf6fd}", ""]);

// exports


/***/ }),

/***/ 3286:
/***/ ((module, exports, __webpack_require__) => {

exports = module.exports = __webpack_require__(9252)(false);
// imports


// module
exports.push([module.id, ".file-root{padding-top:10px;font-size:14px;line-height:18px}.file-root.drag-over{background:#d5d6f9}.file-root .tree-node-content{position:relative;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:5px 10px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.file-root .tree-node-content,.file-root .tree-node-content .tree-node-icon-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.file-root .tree-node-content .tree-node-icon-wrapper{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:5px;width:20px}.file-root .tree-node-content .more-button{display:none;position:absolute;top:50%;right:10px;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.file-root .tree-node-content:hover .more-button{display:block}.file-root .file-node.drag-over{background:#d5d6f9}.file-root .file-node.success>.tree-node-content{background:#d1ffd8}.file-root .file-node.success.blur>.tree-node-content{background:rgba(209,255,216,.6)}.file-root .file-node.error>.tree-node-content{background:#f7c1c1}.file-root .file-node.error.blur>.tree-node-content{background:hsla(0,77%,86%,.6)}.file-root .file-node.error-in-sub>.tree-node-content{background:#f8cf9d}.file-root .file-node.error-in-sub.blur>.tree-node-content{background:hsla(33,87%,79%,.6)}.file-root .file-node.selected>.tree-node-content{background:#fdffd1}.file-root .file-node.selected.blur>.tree-node-content{background:rgba(253,255,209,.6)}.file-root .file-node.selected.error-in-sub>.tree-node-content,.file-root .file-node.selected.error>.tree-node-content,.file-root .file-node.selected.success>.tree-node-content{position:relative}.file-root .file-node.selected.error-in-sub>.tree-node-content:after,.file-root .file-node.selected.error>.tree-node-content:after,.file-root .file-node.selected.success>.tree-node-content:after{content:\"\";position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:none}.file-root .file-node.selected.error>.tree-node-content:after{border:4px solid #f7c1c1}.file-root .file-node.selected.error.blur>.tree-node-content:after{border-color:hsla(0,77%,86%,.6)}.file-root .file-node.selected.error-in-sub>.tree-node-content:after{border:4px solid #f8cf9d}.file-root .file-node.selected.error-in-sub.blur>.tree-node-content:after{border-color:hsla(33,87%,79%,.6)}.file-root .file-node.selected.success>.tree-node-content:after{border:4px solid #d1ffd8}.file-root .file-node.selected.success.blur>.tree-node-content:after{border-color:rgba(209,255,216,.6)}.file-root .file-node .file-icon,.file-root .file-node .folder-icon{height:16px}.file-root .tree-node .tree-node .tree-node-content{padding-left:25px}.file-root .tree-node .tree-node .tree-node .tree-node-content{padding-left:40px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:55px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:70px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:85px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:100px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:115px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:130px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:145px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:160px}", ""]);

// exports


/***/ }),

/***/ 35153:
/***/ ((module, exports, __webpack_require__) => {

exports = module.exports = __webpack_require__(9252)(false);
// imports


// module
exports.push([module.id, ".dashboard{-webkit-box-orient:vertical;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-ms-flex:1;flex:1;margin:15px 15px 0}.dashboard,.dashboard .flex-row{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-direction:normal}.dashboard .flex-row{-webkit-box-orient:horizontal;-ms-flex-direction:row;flex-direction:row}.dashboard .form-group{margin-bottom:15px}.dashboard .toolbox{display:-webkit-box;display:-ms-flexbox;display:flex}.dashboard .toolbox .record-ops{-webkit-box-flex:1;-ms-flex:1;flex:1;text-align:right}.dashboard .toolbox .play-ops{margin-left:15px}.dashboard .ant-table-pagination{display:none}.dashboard .ant-table-header{overflow:hidden!important;margin-bottom:0!important;padding-bottom:0!important}.dashboard .ant-table-header .ant-table-thead>tr>th{padding:13px 8px}.dashboard .ant-table-body .ant-table-thead>tr>th{padding:10px 8px}.dashboard .ant-table-tbody>tr>td{padding:8px}.dashboard tr.selected-command>td{background-color:#fdffd1!important}.dashboard tr.error-command>td{background-color:#f7c1c1!important}.dashboard tr.running-command>td{background-color:#d5d6f9!important}.dashboard tr.done-command>td{background-color:#d1ffd8!important}.dashboard .ant-btn-group>.ant-btn-group{float:none}.dashboard .ant-form-item{margin-bottom:8px}.dashboard .editor-wrapper{-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:2;-ms-flex:2;flex:2}.dashboard .editor-wrapper,.dashboard .editor-wrapper .tabs-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal}.dashboard .editor-wrapper .tabs-wrapper{position:relative;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-ms-flex:1;flex:1}.dashboard .editor-wrapper .tabs-wrapper .vision-type{position:absolute;right:0;top:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer}.dashboard .editor-wrapper .tabs-wrapper .vision-type img{display:block;margin-right:10px;width:20px;height:20px}.dashboard .editor-wrapper .tabs-wrapper .vision-type span{text-decoration:underline;color:#108ee9;font-size:16px}.dashboard .commands-view{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:2;-ms-flex:2;flex:2}.dashboard .commands-view .ant-tabs-bar{margin-bottom:0}.dashboard .commands-view .ant-tabs-content{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-ms-flex:1;flex:1;padding:10px;border:1px solid #d9d9d9;border-width:0 1px 1px}.dashboard .commands-view .ant-tabs-content .ant-tabs-tabpane{-webkit-box-flex:1;-ms-flex:1;flex:1;-ms-flex-negative:unset!important;flex-shrink:unset!important;position:relative}.dashboard .commands-view .ant-tabs-content .table-wrapper{position:absolute;top:0;bottom:165px;left:0;right:0;overflow-y:auto}.dashboard .commands-view .ant-tabs-content .fields-wrapper{position:absolute;left:0;right:0;bottom:0;height:155px}.dashboard .commands-view .ant-tabs-content .fields-wrapper .ant-form-item-label{text-align:left}.dashboard .commands-view .ant-tabs-content .fields-wrapper .target-row .flex-row{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.dashboard .commands-view .ant-tabs-content .fields-wrapper .target-row .select-input{-webkit-box-flex:1;-ms-flex:1;flex:1}.dashboard .commands-view .ant-tabs-content .fields-wrapper .target-row .select-input input{width:100%}.dashboard .commands-view .ant-tabs-content .fields-wrapper .target-row .textarea-wrapper{position:relative;-webkit-box-flex:1;-ms-flex:1;flex:1;max-width:60%;margin-right:10px}.dashboard .commands-view .ant-tabs-content .fields-wrapper .target-row .textarea-wrapper .open-full-editor{position:absolute;bottom:5px;right:15px;cursor:pointer}.dashboard .commands-view .ant-tabs-content .fields-wrapper .target-row .textarea-wrapper .open-full-editor:hover{color:#108ee9}.dashboard .commands-view .ant-tabs-content .fields-wrapper .target-row button{margin-left:10px}.dashboard .commands-view .ant-tabs-content .react-codemirror2{position:relative}.dashboard .commands-view .ant-tabs-content .react-codemirror2.has-error{height:calc(100% - 70px)}.dashboard .commands-view .ant-tabs-content .react-codemirror2.no-error{height:calc(100% - 0px)}.dashboard .commands-view .ant-tabs-content .react-codemirror2 .CodeMirror{position:absolute;top:0;bottom:0;left:0;right:0;height:auto;font-size:13px}.dashboard .commands-view .ant-tabs-content .ant-spin-container,.dashboard .commands-view .ant-tabs-content .ant-spin-nested-loading,.dashboard .commands-view .ant-tabs-content .ant-table,.dashboard .commands-view .ant-tabs-content .ant-table-content,.dashboard .commands-view .ant-tabs-content .ant-table-scroll,.dashboard .commands-view .ant-tabs-content .ant-table-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-ms-flex:1;flex:1}.dashboard .commands-view .ant-tabs-content .ant-table-scroll{overflow-y:auto}.dashboard .commands-view.target-as-textarea .ant-tabs-content .table-wrapper{bottom:179px}.dashboard .commands-view.target-as-textarea .ant-tabs-content .fields-wrapper{height:169px}.dashboard .commands-view.target-as-textarea .ant-tabs-content .fields-wrapper textarea{resize:none}.dashboard .commands-view .command-row{position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding-left:5px;border-bottom:1px solid #e9e9e9;line-height:35px;font-size:13px}.dashboard .commands-view .command-row:hover{background:#ecf6fd}.dashboard .commands-view .command-row.dragging{opacity:0}.dashboard .commands-view .command-row.footer-row,.dashboard .commands-view .command-row.header-row{background-color:#f7f7f7;font-weight:700}.dashboard .commands-view .command-row.footer-row{display:block;text-align:center;cursor:pointer}.dashboard .commands-view .command-row.breakpoint-command:before{content:\"\";position:absolute;top:50%;left:0;-webkit-transform:translateY(-50%);transform:translateY(-50%);width:0;height:0;border:8px solid transparent;border-left-color:green}.dashboard .commands-view .command-row.error-command{background-color:#f7c1c1;color:red}.dashboard .commands-view .command-row.error-command.blur{background-color:hsla(0,77%,86%,.6)}.dashboard .commands-view .command-row.warning-command{background-color:hsla(33,87%,79%,.7);color:orange}.dashboard .commands-view .command-row.warning-command.blur{background-color:hsla(33,87%,79%,.3)}.dashboard .commands-view .command-row.running-command{background-color:#d5d6f9}.dashboard .commands-view .command-row.running-command.blur{background-color:rgba(213,214,249,.6)}.dashboard .commands-view .command-row.done-command{background-color:#d1ffd8}.dashboard .commands-view .command-row.done-command.blur{background-color:rgba(209,255,216,.6)}.dashboard .commands-view .command-row.selected-command{background-color:#fdffd1}.dashboard .commands-view .command-row.selected-command.blur{background-color:rgba(253,255,209,.6)}.dashboard .commands-view .command-row.comment-command{background-color:transparent;color:#ccc;font-style:italic}.dashboard .commands-view .command-row.comment-command.selected-command{background-color:#fdffd1}.dashboard .commands-view .command-row.comment-command.selected-command.blur{background-color:rgba(253,255,209,.6)}.dashboard .commands-view .command-row .row-col{padding:0 8px}.dashboard .commands-view .command-row .row-col.index-col{padding:0;width:25px;text-align:center}.dashboard .commands-view .command-row .row-col.command-col{min-width:130px}.dashboard .commands-view .command-row .row-col.command-col,.dashboard .commands-view .command-row .row-col.target-col,.dashboard .commands-view .command-row .row-col.value-col{-webkit-box-flex:1;-ms-flex:1;flex:1;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.dashboard .commands-view .command-row .row-col.op-col{width:80px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.dashboard .table-footer{position:absolute;left:0;right:0;top:0;bottom:0;line-height:32px;text-align:center;font-weight:700;background:#f7f7f7;cursor:pointer}.dashboard .table-footer:hover{background:#e0e0e0}.dashboard .logs-screenshots{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;position:relative;margin-top:15px}.dashboard .logs-screenshots.fold{height:32px!important;overflow:hidden}.dashboard .logs-screenshots.fold .ant-tabs-content{display:none}.dashboard .logs-screenshots .resize-handler{position:absolute;top:-10px;left:0;width:100%;height:6px;background:transparent;cursor:row-resize}.dashboard .logs-screenshots .resize-handler.focused,.dashboard .logs-screenshots .resize-handler:hover{height:6px;background:#ccc}.dashboard .logs-screenshots .ant-tabs.ant-tabs-card>.ant-tabs-bar .ant-tabs-tab{padding:5px 12px 4px}.dashboard .logs-screenshots .ant-tabs{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-ms-flex:1;flex:1}.dashboard .logs-screenshots .ant-tabs-bar{margin-bottom:0}.dashboard .logs-screenshots .ant-tabs-content{-webkit-box-flex:1;-ms-flex:1;flex:1;overflow-y:auto;min-height:70px;border:1px solid #d9d9d9;border-width:0 1px 1px}.dashboard .logs-screenshots .ls-toolbox{position:absolute;right:0;top:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.dashboard .logs-screenshots .ls-toolbox>*{margin-right:5px}.dashboard .logs-screenshots .ls-toolbox>:last-child{margin-right:0}.dashboard .logs-screenshots .log-content,.dashboard .logs-screenshots .screenshot-content{padding:10px 0}.dashboard .logs-screenshots .screenshot-content li{padding:0 20px 20px}.dashboard .logs-screenshots .screenshot-content li .timestamp{display:block;margin-bottom:10px;font-size:14px}.dashboard .logs-screenshots .screenshot-content li .filename{font-weight:700}.dashboard .logs-screenshots .log-content{list-style:none;margin:0;padding:0 10px;height:calc(100% - 38px);overflow-y:auto}.dashboard .logs-screenshots .log-content li{padding:5px 0;font-size:12px;border-bottom:1px solid #f3f3f3}.dashboard .logs-screenshots .log-content li:after{content:\"\";display:table;clear:both}.dashboard .logs-screenshots .log-content li a.info{color:#108ee9!important}.dashboard .logs-screenshots .log-content li.error{color:red;font-weight:700}.dashboard .logs-screenshots .log-content li.error a{color:red;text-decoration:underline}.dashboard .logs-screenshots .log-content li.warning{color:orange}.dashboard .logs-screenshots .log-content li .log-type{float:left;margin-right:10px}.dashboard .logs-screenshots .log-content li .log-detail{white-space:pre-wrap}.dashboard .logs-screenshots .csv-content{padding:10px}.dashboard .logs-screenshots .csv-content button{margin-right:5px}.dashboard .logs-screenshots .variable-content{padding:10px}.dashboard .logs-screenshots .variable-content .variable-options{margin-bottom:10px}.dashboard .logs-screenshots .variable-content .ant-checkbox-wrapper{margin-left:0!important;margin-right:10px}.dashboard .logs-screenshots .variable-content .read-only{color:#ccc}.dashboard .logs-screenshots .vision-content{padding:10px}.dashboard .logs-screenshots .vision-content .vision-top-actions{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-bottom:15px}.dashboard .logs-screenshots .vision-content .vision-top-actions .main-actions{-webkit-box-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;margin-right:15px}.dashboard .logs-screenshots .vision-content .vision-top-actions .main-actions .main-actions-left{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.dashboard .logs-screenshots .vision-content .vision-top-actions .main-actions .main-actions-left>*{margin-right:15px}.dashboard .logs-screenshots .vision-content .vision-top-actions .main-actions .main-actions-left>:last-child{margin-right:0}.dashboard .logs-screenshots .vision-content .vision-top-actions .main-actions .load-image-button{padding:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.dashboard .logs-screenshots .vision-content .vision-top-actions .main-actions .load-image-button label{padding:0 15px;cursor:pointer}.dashboard .logs-screenshots .vision-content .vision-top-actions .more-info{font-size:14px}.dashboard .logs-screenshots .vision-content .vision-image{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center;overflow:hidden;width:100px;height:100px;border:1px solid #ccc}.dashboard .logs-screenshots .vision-content .vision-image img{max-height:100px}.dashboard .logs-screenshots .vision-content .vision-name{font-size:14px;word-break:break-all}.dashboard .logs-screenshots .vision-content .vision-actions{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.dashboard .logs-screenshots .vision-content .vision-actions button{margin-right:5px}.dashboard .logs-screenshots .vision-content .vision-actions button:last-child{margin-right:0}.dashboard .online-help{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;margin-top:15px;padding:0 10px;height:25px;line-height:25px;font-size:14px;text-align:right}.dashboard #context_menu{z-index:10}.dashboard #context_menu .ant-menu{border:\"1px solid #ccc\";border-radius:4px;-webkit-box-shadow:0 1px 6px rgba(0,0,0,.2);box-shadow:0 1px 6px rgba(0,0,0,.2)}.dashboard #context_menu .ant-menu .ant-menu-item{height:36px;line-height:36px}.dashboard #context_menu .ant-menu .ant-menu-item:hover{background:#ecf6fd}.dashboard #context_menu .ant-menu .ant-menu-item .shortcut{float:right;color:#999}.dashboard .target-full-editor .mask{position:fixed;z-index:100;top:0;bottom:0;left:0;right:0;background:#000;opacity:.4}.dashboard .target-full-editor .react-codemirror2{position:fixed;z-index:100;top:40px;bottom:40px;left:40px;right:40px}.dashboard .target-full-editor .react-codemirror2 .CodeMirror{height:100%}.dashboard .target-full-editor .close-button{position:fixed;z-index:101;top:25px;right:25px}.source-error{color:red;white-space:pre-wrap;font-size:12px}.ant-dropdown .ant-dropdown-menu{max-height:none}@media (max-width:768px){.duplicate-modal,.play-loop-modal,.rename-modal,.save-modal{width:400px!important;margin:0 auto}}", ""]);

// exports


/***/ }),

/***/ 98048:
/***/ ((module, exports, __webpack_require__) => {

exports = module.exports = __webpack_require__(9252)(false);
// imports


// module
exports.push([module.id, ".sidebar{position:relative;-webkit-box-flex:1;-ms-flex:1;flex:1;min-width:260px;height:100%;border-right:2px solid #ccc}.sidebar .sidebar-inner{position:absolute;top:0;bottom:80px;right:0;left:0;overflow-y:auto}.sidebar .sidebar-inner.no-tab{padding-top:8px;overflow-x:hidden}.sidebar .no-data{margin-top:20px;text-align:center;font-size:14px;color:#aaa}.sidebar .sidebar-macros .untitled{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:5px 10px;font-size:14px}.sidebar .sidebar-macros .untitled.selected{background:#fdffd1}.sidebar .sidebar-macros .untitled .icon-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-right:5px;width:20px}.sidebar .sidebar-macros .untitled .icon-wrapper .file-icon{display:block;height:16px}.sidebar .test-case-actions,.sidebar .test-suite-actions{padding:0 10px 10px}.sidebar .test-case-actions button,.sidebar .test-suite-actions button{margin-right:10px}.sidebar .test-case-actions{display:-webkit-box;display:-ms-flexbox;display:flex;padding-bottom:0}.sidebar .sidebar-test-suites .test-suite-item{padding:0 0 10px;margin-bottom:5px}.sidebar .sidebar-test-suites .test-suite-item.playing{background:#fdffd1}.sidebar .sidebar-test-suites .test-suite-item.fold{margin-bottom:0;padding-bottom:0}.sidebar .sidebar-test-suites .test-suite-item.fold .test-suite-cases,.sidebar .sidebar-test-suites .test-suite-item.fold .test-suite-more-actions{display:none}.sidebar .sidebar-test-suites .test-suite-item .test-suite-row{padding:5px 10px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer}.sidebar .sidebar-test-suites .test-suite-item .test-suite-row .test-suite-title{-webkit-box-flex:1;-ms-flex:1;flex:1;margin-left:10px}.sidebar .sidebar-test-suites .test-suite-item .test-suite-row .more-button{display:none}.sidebar .sidebar-test-suites .test-suite-item .test-suite-row:hover .more-button{display:block}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases{padding:3px 5px}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases li{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:3px 5px 3px 20px;margin-bottom:5px}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases li.done-tc{background-color:#d1ffd8}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases li.done-tc.blur{background-color:rgba(209,255,216,.6)}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases li.error-tc{background-color:#f7c1c1}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases li.error-tc.blur{background-color:hsla(0,77%,86%,.6)}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases li.current-tc{background-color:#d5d6f9}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases li.current-tc.blur{background-color:rgba(213,214,249,.6)}.sidebar .sidebar-test-suites .test-suite-item .test-suite-more-actions{padding-left:27px}.sidebar .sidebar-storage-mode{position:absolute;bottom:0;left:0;right:0;height:80px;padding:0 10px 15px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end}.sidebar .sidebar-storage-mode .storage-mode-header{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-bottom:5px;font-size:12px}.sidebar .sidebar-storage-mode .storage-mode-header h3{font-size:14px}.sidebar .ant-tabs{min-height:100%}.sidebar .ant-tabs-bar{border-bottom:2px solid #ccc}.sidebar .ant-tabs-nav-container-scrolling{padding-left:0;padding-right:0}.sidebar .ant-tabs-tab-next.ant-tabs-tab-arrow-show,.sidebar .ant-tabs-tab-prev.ant-tabs-tab-arrow-show{display:none}.sidebar .ant-tabs-nav{height:44px}.sidebar .ant-tabs-nav .ant-tabs-tab{margin-right:0;line-height:27px}.sidebar .ant-tabs-nav-scroll{text-align:center}.sidebar .resize-handler{position:absolute;right:-2px;top:0;bottom:0;width:2px;background:#ccc;cursor:col-resize}.sidebar .resize-handler.focused,.sidebar .resize-handler:hover{right:-4px;width:6px;background:#aaa}.sidebar.with-xmodules-note .sidebar-inner{bottom:160px}.sidebar.with-xmodules-note .sidebar-storage-mode{height:160px}.sidebar.with-xmodules-note .note-for-macros{margin-bottom:20px;padding:10px 10px 0;border-top:1px solid #333;font-size:12px}.with-sidebar .sidebar{display:block}.context-menu{z-index:10}.context-menu .ant-menu{border:\"1px solid #ccc\";border-radius:4px;-webkit-box-shadow:0 1px 6px rgba(0,0,0,.2);box-shadow:0 1px 6px rgba(0,0,0,.2)}.context-menu .ant-menu .ant-menu-item{height:36px;line-height:36px}.context-menu .ant-menu .ant-menu-item:hover{background:#ecf6fd}.xfile-not-installed-modal.left-bottom{position:absolute;top:auto!important;bottom:100px;left:100px}.xfile-not-installed-modal p{margin-bottom:20px;font-size:16px;font-weight:700}.macros-dropdown{width:auto!important}", ""]);

// exports


/***/ }),

/***/ 25941:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(98389);
if(typeof content === 'string') content = [[module.id, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(76723)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 33607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(29773);
if(typeof content === 'string') content = [[module.id, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(76723)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 11264:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(51749);
if(typeof content === 'string') content = [[module.id, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(76723)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 83518:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(3286);
if(typeof content === 'string') content = [[module.id, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(76723)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 8776:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(35153);
if(typeof content === 'string') content = [[module.id, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(76723)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 2047:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(98048);
if(typeof content === 'string') content = [[module.id, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(76723)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 46469:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createThunkAction = exports.createAction = exports.Actions = exports.ActionTypes = exports.ActionFactories = exports.fileFolderNotShown = exports.checkNodeShowUp = exports.withMacroIdChanges = exports.getMacroIdChanges = void 0;
const react_1 = __importDefault(__webpack_require__(67294));
const antd_1 = __webpack_require__(56318);
const scroll_into_view_if_needed_1 = __importDefault(__webpack_require__(13727));
const ts_utils_1 = __webpack_require__(55452);
const storage_1 = __webpack_require__(16058);
const ts_utils_2 = __webpack_require__(55452);
const prompt_1 = __webpack_require__(79197);
const log_1 = __importDefault(__webpack_require__(77242));
const index_1 = __webpack_require__(97876);
const recomputed_1 = __webpack_require__(78328);
const tree_file_1 = __webpack_require__(58335);
const test_suite_extra_data_1 = __webpack_require__(34945);
const test_suite_model_1 = __webpack_require__(64580);
const utils_1 = __webpack_require__(63370);
const convert_utils_1 = __webpack_require__(61169);
const state_1 = __webpack_require__(16112);
const misc_data_1 = __webpack_require__(19878);
const constant_1 = __webpack_require__(43232);
const save_test_case_1 = __importDefault(__webpack_require__(57879));
const file_saver_1 = __importDefault(__webpack_require__(18187));
const command_1 = __webpack_require__(69396);
const jszip_1 = __importDefault(__webpack_require__(55733));
const config_1 = __importDefault(__webpack_require__(62275));
const license_1 = __webpack_require__(53678);
function getMacroIdChanges(options) {
    const { entryPath, isDirectory, getNewFilePath } = options;
    const macroStorage = storage_1.getStorageManager().getMacroStorage();
    const entryFullPath = macroStorage.entryPath(entryPath, isDirectory);
    if (!isDirectory) {
        return Promise.resolve({
            [entryFullPath]: getNewFilePath(entryFullPath)
        });
    }
    return macroStorage.listR(entryFullPath)
        .then((entryNodes) => {
        const listOfNodes = entryNodes.map(node => ts_utils_1.flatternTree(node));
        const nodes = ts_utils_1.flatten(listOfNodes);
        return nodes
            .map((node) => node.fullPath)
            .reduce((prev, oldMacroPath) => {
            prev[oldMacroPath] = getNewFilePath(oldMacroPath);
            return prev;
        }, {});
    });
}
exports.getMacroIdChanges = getMacroIdChanges;
function withMacroIdChanges(options) {
    return getMacroIdChanges(options)
        .then(macroIdChanges => {
        return Promise.resolve(options.run())
            // Note: the delay is waiting for macro ids updated in state
            .then(() => ts_utils_1.delay(() => { }, 1000))
            .then(() => {
            options.dispatch(exports.Actions.updateMacroIdsInTestSuites(macroIdChanges));
        });
    });
}
exports.withMacroIdChanges = withMacroIdChanges;
function checkNodeShowUp(params) {
    const { dispatch, getState, fullPath, message, switchToIt = true } = params;
    return ts_utils_1.until('node shows up', () => {
        const state = getState();
        const { macroFolderStructure } = getState().editor;
        const macroNodes = recomputed_1.getMacroFileNodeList(state);
        const nodes = ts_utils_1.flatten(macroFolderStructure.map(ts_utils_1.flatternTree));
        const found = nodes.find((item) => item.fullPath === fullPath);
        const foundInTestCases = macroNodes.find((item) => item.fullPath === fullPath);
        // Note: testCases are slower than macorFolderStructure, because testCases need to read file
        // So have to wait for both
        return {
            pass: !!found && !!foundInTestCases,
            result: found
        };
    }, 100, 10 * 1000)
        .then(() => {
        if (switchToIt) {
            dispatch(index_1.editTestCase(fullPath));
        }
        dispatch(exports.Actions.ensureTreeNodeUnfoldedForCurrentMacroNode());
    }, (e) => {
        log_1.default.error(e);
        fileFolderNotShown({
            dispatch,
            getState,
            message
        });
    });
}
exports.checkNodeShowUp = checkNodeShowUp;
function fileFolderNotShown(params) {
    const { dispatch, getState, message } = params;
    const { config } = getState();
    const { storageMode, xmodulesStatus = 'unregistered' } = config;
    if (storageMode !== storage_1.StorageStrategyType.XFile) {
        return;
    }
    if (license_1.getLicenseService().isProLicense() || license_1.getLicenseService().isPlayerLicense()) {
        return;
    }
    const reason = (() => {
        if (license_1.getLicenseService().hasNoLicense()) {
            return `${license_1.getLicenseService().getMaxXFileMacros()} macro/folder limit in free version`;
        }
        if (license_1.getLicenseService().isPersonalLicense()) {
            return `${license_1.getLicenseService().getMaxXFileMacros()} macro/folder limit in PRO1 version`;
        }
        throw new Error('Unknown cases');
    })();
    antd_1.Modal.warn({
        title: 'Please upgrade your XModule plan',
        content: `${message}, but not displayed due to ${reason}`,
        okText: 'OK',
        onOk: () => {
            dispatch(index_1.updateUI({ showSettings: true, settingsTab: 'register' }));
        }
    });
}
exports.fileFolderNotShown = fileFolderNotShown;
exports.ActionFactories = {
    setNoDisplayInPlay: (name) => (noDisplayInPlay) => {
        return createAction(name, noDisplayInPlay);
    },
    setFrom: (name) => (from) => {
        return createThunkAction((dispatch, getState) => {
            const { from: oldFrom } = getState();
            if (from === state_1.RunBy.Manual && oldFrom !== state_1.RunBy.Manual) {
                storage_1.getStorageManager().emit(storage_1.StorageManagerEvent.ForceReload);
            }
            dispatch(createAction(name, from));
        });
    },
    setIsLoadingMacros: (name) => (isLoading) => {
        return createAction(name, isLoading);
    },
    setCurrentMacro: (name) => (macro) => {
        return createAction(name, macro);
    },
    copyCurrentCommand: (name) => () => {
        return createThunkAction((dispatch, getState) => {
            const { selectedIndex } = getState().editor.editing.meta;
            if (selectedIndex === -1) {
                return;
            }
            dispatch(index_1.copyCommand(selectedIndex));
        });
    },
    cutCurrentCommand: (name) => () => {
        return createThunkAction((dispatch, getState) => {
            const { selectedIndex } = getState().editor.editing.meta;
            if (selectedIndex === -1) {
                return;
            }
            dispatch(index_1.cutCommand(selectedIndex));
        });
    },
    pasteAtCurrentCommand: (name) => () => {
        return createThunkAction((dispatch, getState) => {
            const { selectedIndex } = getState().editor.editing.meta;
            if (selectedIndex === -1) {
                return;
            }
            dispatch(index_1.pasteCommand(selectedIndex));
        });
    },
    selectNextCommand: (name) => () => {
        return createThunkAction((dispatch, getState) => {
            const { meta, commands } = getState().editor.editing;
            const { selectedIndex } = meta;
            if (selectedIndex < commands.length - 1) {
                dispatch(index_1.selectCommand(selectedIndex + 1, true));
            }
        });
    },
    selectPrevCommand: (name) => () => {
        return createThunkAction((dispatch, getState) => {
            const { meta, commands } = getState().editor.editing;
            const { selectedIndex } = meta;
            if (selectedIndex > 0) {
                dispatch(index_1.selectCommand(selectedIndex - 1, true));
            }
        });
    },
    moveCommands: (name) => (startIndex, endIndex) => {
        return createAction(name, { startIndex, endIndex });
    },
    setIsDraggingCommand: (name) => (isDraggingCommand) => {
        return createAction(name, isDraggingCommand);
    },
    setMacroFolderStructure: (name) => (entryNodes) => {
        return createAction(name, entryNodes);
    },
    setTestSuiteFolderStructure: (name) => (entryNodes) => {
        return createAction(name, entryNodes);
    },
    macroCreateFolder: (name) => (options) => {
        return createThunkAction((dispatch, getState) => {
            const macroStorage = storage_1.getStorageManager().getMacroStorage();
            const path = macroStorage.getPathLib();
            const parentDir = macroStorage.dirPath(options.dir);
            return prompt_1.prompt({
                width: 400,
                title: 'Create folder as..',
                message: '',
                value: '',
                placeholder: 'Folder name',
                selectionStart: 0,
                selectionEnd: 0,
                okText: 'Create',
                cancelText: 'Cancel',
                onCancel: () => Promise.resolve(true),
                onOk: (newName) => {
                    const newFullPath = path.join(parentDir, utils_1.sanitizeFileName(newName));
                    return macroStorage.directoryExists(newFullPath)
                        .then(exists => {
                        if (exists) {
                            const msg = `'${newName}' already exists`;
                            antd_1.message.error(msg);
                            throw new Error(msg);
                        }
                        return storage_1.getStorageManager().getMacroStorage().createDirectory(newFullPath)
                            .then(() => {
                            antd_1.message.success(`Created folder '${newName}'`);
                            checkNodeShowUp({
                                getState,
                                dispatch,
                                fullPath: newFullPath,
                                switchToIt: false,
                                message: 'Folder created'
                            });
                            return true;
                        }, (e) => {
                            log_1.default.error(e);
                            const msg = 'Failed to create folder: ' + e.message;
                            antd_1.message.error(msg);
                            throw new Error(msg);
                        });
                    });
                }
            });
        });
    },
    macroDeleteFolder: (name) => (options) => {
        // TODO: check if any macro is in use of some test suite
        return createThunkAction((dispatch, getState) => {
            const { dir } = options;
            const macroStorage = storage_1.getStorageManager().getMacroStorage();
            const assertNoMacroInUse = () => {
                return getMacroIdChanges({
                    entryPath: macroStorage.dirPath(dir),
                    isDirectory: true,
                    getNewFilePath: (str) => str
                })
                    .then(macroIdChanges => {
                    const state = getState();
                    const testSuites = recomputed_1.getTestSuitesWithAllInfo(state);
                    const oldMacroIds = Object.keys(macroIdChanges);
                    const problems = [];
                    oldMacroIds.forEach((oldMacroId) => {
                        testSuites.forEach((ts) => {
                            if (ts.cases.find(obj => obj.testCaseId === oldMacroId)) {
                                problems.push({
                                    macroPath: macroStorage.relativePath(oldMacroId),
                                    testSuiteName: ts.name
                                });
                            }
                        });
                    });
                    if (problems.length > 0) {
                        const cnt = 3;
                        const main = problems.slice(0, cnt)
                            .map(obj => `"${obj.macroPath}" is still used in test suite "${obj.testSuiteName}"`)
                            .join('\n');
                        const extra = problems.length <= cnt ? '' : `\n...\n(And ${problems.length - 1} more macro references)`;
                        const msg = main + extra;
                        throw new Error(msg);
                    }
                });
            };
            if (confirm(`Sure to delete ${dir} and all its content?`)) {
                return assertNoMacroInUse()
                    .then(() => macroStorage.remove(dir, true))
                    .catch((e) => {
                    antd_1.Modal.warn({
                        title: 'Failed to delete folder',
                        content: e.message.split('\n').map(str => react_1.default.createElement('li', null, str)),
                        okText: 'OK'
                    });
                });
            }
        });
    },
    macroMoveEntry: (name) => (data) => {
        return createThunkAction((dispatch, getState) => {
            const macroStorage = storage_1.getStorageManager().getMacroStorage();
            const path = macroStorage.getPathLib();
            const getNewFilePath = (oldMacroPath) => {
                const dirName = path.basename(data.entryId);
                const oldDirFullPath = macroStorage.dirPath(data.entryId);
                const relativePath = path.relative(oldMacroPath, oldDirFullPath);
                return path.join(data.dirId, dirName, relativePath);
            };
            const moveEntry = () => macroStorage.move(data.entryId, data.dirId, data.isSourceDirectory, true);
            return withMacroIdChanges({
                dispatch,
                getNewFilePath,
                run: moveEntry,
                entryPath: data.entryId,
                isDirectory: data.isSourceDirectory
            })
                .catch((e) => {
                antd_1.message.error(e.message);
            });
        });
    },
    macroRenameFolder: (name) => (options) => {
        return createThunkAction((dispatch, getState) => {
            const { dir } = options;
            const macroStorage = storage_1.getStorageManager().getMacroStorage();
            const path = macroStorage.getPathLib();
            const dirFullPath = macroStorage.dirPath(dir);
            const folderName = path.basename(dirFullPath);
            const parentDir = path.dirname(dirFullPath);
            const editingId = getState().editor.editing.meta.src.id;
            const isEditingCur = editingId.indexOf(dirFullPath + path.sep) === 0;
            return prompt_1.prompt({
                width: 400,
                title: 'Rename the folder as..',
                message: '',
                value: folderName,
                placeholder: 'Folder name',
                selectionStart: 0,
                selectionEnd: folderName.length,
                okText: 'Rename',
                cancelText: 'Cancel',
                onCancel: () => Promise.resolve(true),
                onOk: (newName) => {
                    const newFullPath = path.join(parentDir, utils_1.sanitizeFileName(newName));
                    return macroStorage.directoryExists(newFullPath)
                        .then(exists => {
                        if (exists) {
                            const msg = `'${newName}' already exists`;
                            antd_1.message.error(msg);
                            throw new Error(msg);
                        }
                        return withMacroIdChanges({
                            dispatch,
                            isDirectory: true,
                            entryPath: dirFullPath,
                            getNewFilePath: (oldMacroPath) => {
                                const relativePath = path.relative(oldMacroPath, dirFullPath);
                                return path.join(newFullPath, relativePath);
                            },
                            run: () => {
                                return macroStorage.moveDirectory(dirFullPath, newFullPath)
                                    .then(() => {
                                    antd_1.message.success(`Renamed to '${newName}'`);
                                    checkNodeShowUp({
                                        getState,
                                        dispatch,
                                        fullPath: newFullPath,
                                        switchToIt: false,
                                        message: 'Folder renamed'
                                    });
                                    if (isEditingCur) {
                                        const newMacroPath = editingId.replace(dirFullPath, newFullPath);
                                        dispatch(index_1.editTestCase(newMacroPath));
                                    }
                                }, (e) => {
                                    log_1.default.error(e);
                                    const msg = 'Failed to rename: ' + e.message;
                                    antd_1.message.error(msg);
                                    throw new Error(msg);
                                });
                            }
                        })
                            .then(() => true);
                    });
                }
            });
        });
    },
    macroCreateFile: (name) => (options) => {
        return createThunkAction((dispatch, getState) => {
            const { dir } = options;
            const macroStorage = storage_1.getStorageManager().getMacroStorage();
            const path = macroStorage.getPathLib();
            return prompt_1.prompt({
                width: 400,
                title: 'Create new macro as..',
                message: '',
                value: '',
                placeholder: 'Macro name',
                selectionStart: 0,
                selectionEnd: 0,
                okText: 'Confirm',
                cancelText: 'Cancel',
                onCancel: () => Promise.resolve(true),
                onOk: (macroName) => {
                    const filePath = path.join(dir, `${utils_1.sanitizeFileName(macroName)}.json`);
                    const fullPath = macroStorage.filePath(filePath);
                    return macroStorage.fileExists(fullPath)
                        .then(exists => {
                        if (exists) {
                            const msg = `'${macroName}' already exists`;
                            antd_1.message.error(msg);
                            throw new Error(msg);
                        }
                        return macroStorage.write(filePath, {
                            name: macroName,
                            data: {
                                commands: []
                            }
                        })
                            .then(() => {
                            antd_1.message.success(`Created macro '${macroName}'`);
                            checkNodeShowUp({
                                getState,
                                dispatch,
                                fullPath,
                                message: 'New macro created'
                            });
                            return true;
                        }, (e) => {
                            log_1.default.error(e);
                            const msg = 'Failed to create macro: ' + e.message;
                            antd_1.message.error(msg);
                            throw new Error(msg);
                        });
                    });
                }
            });
        });
    },
    ensureTreeNodeUnfoldedForCurrentMacroNode: (name) => (options) => {
        const opts = Object.assign({ scrollIntoView: true }, (options || {}));
        return createThunkAction((dispatch, getState) => {
            const state = getState();
            const macroId = recomputed_1.getCurrentMacroId(state);
            const macrosExtra = recomputed_1.getMacrosExtra(state);
            const fileNodes = recomputed_1.getMacroFileNodeData(state);
            const ancestors = ts_utils_1.ancestorsInNodesList((node) => node.id === macroId, fileNodes);
            const scrollIfNeeded = () => {
                if (opts.scrollIntoView) {
                    setTimeout(() => {
                        const id = ts_utils_1.normalizeHtmlId(macroId);
                        const $el = document.getElementById(id);
                        if ($el) {
                            scroll_into_view_if_needed_1.default($el, { behavior: 'smooth', block: 'nearest' });
                        }
                    }, 100);
                }
            };
            if (!ancestors || !ancestors.length) {
                return scrollIfNeeded();
            }
            const updates = ancestors.map((node) => {
                return ts_utils_1.safeUpdateIn([node.id], (data) => (Object.assign(Object.assign({}, (data || {})), { folded: false })));
            });
            const newMacrosExtra = ts_utils_2.compose(...updates)(macrosExtra);
            dispatch(index_1.setMacrosExtra(newMacrosExtra, { shouldPersist: true }));
            scrollIfNeeded();
        });
    },
    updateMacroIdsInTestSuites: (name) => (macroIdChanges) => {
        return createThunkAction((dispatch, getState) => {
            const state = getState();
            const testSuites = recomputed_1.getTestSuitesWithAllInfo(state);
            const oldMacroIds = Object.keys(macroIdChanges);
            oldMacroIds.forEach((oldMacroId) => {
                const newMacroId = macroIdChanges[oldMacroId];
                testSuites.forEach((ts) => {
                    const indices = ts.cases.reduce((prev, obj, i) => {
                        if (obj.testCaseId === oldMacroId) {
                            prev.push(i);
                        }
                        return prev;
                    }, []);
                    if (indices.length === 0) {
                        return;
                    }
                    const cases = ts_utils_2.compose(...indices.map(i => ts_utils_1.setIn([i, 'testCaseId'], newMacroId)))(ts.cases);
                    dispatch(exports.Actions.updateTestSuite(ts.id, { cases }));
                });
            });
        });
    },
    updateTestSuite: (name) => (id, data) => {
        return createThunkAction((dispatch, getState) => {
            const state = getState();
            const testSuites = recomputed_1.getTestSuitesWithAllInfo(state);
            const ts = testSuites.find(ts => ts.id === id);
            if (!ts) {
                return;
            }
            const realData = typeof data === 'function' ? data(ts) : data;
            const hasRename = realData.name && ts.name !== realData.name;
            if (hasRename) {
                const hasDuplciateName = !!testSuites.find(ts => ts.id !== id && ts.name === realData.name);
                if (hasDuplciateName) {
                    return Promise.reject(new Error(`The test suite name '${realData.name}' already exists!`));
                }
            }
            // Note: revised may contain `playStatus`
            const revised = Object.assign(Object.assign({}, ts), realData);
            const suiteStorage = storage_1.getStorageManager().getTestSuiteStorage();
            const suiteName = hasRename ? realData.name : ts.name;
            const pRename = hasRename ? suiteStorage.rename(ts.name, realData.name)
                : Promise.resolve();
            const pStoreExtra = hasRename && storage_1.getStorageManager().isXFileMode()
                ? test_suite_extra_data_1.getTestSuiteExtraKeyValueData()
                    .set(id, {
                    fold: false,
                    playStatus: {}
                })
                : test_suite_extra_data_1.getTestSuiteExtraKeyValueData()
                    .set(id, {
                    fold: revised.fold,
                    playStatus: revised.playStatus || {}
                });
            dispatch({
                type: name,
                data: {
                    id: id,
                    updated: test_suite_model_1.normalizeTestSuite(revised)
                }
            });
            if (hasRename && storage_1.getStorageManager().isXFileMode()) {
                // Reset test suite status
                dispatch({
                    type: 'UPDATE_TEST_SUITE_STATUS',
                    data: {
                        id,
                        extra: {
                            fold: false,
                            playStatus: {}
                        }
                    }
                });
            }
            else {
                dispatch({
                    type: 'UPDATE_TEST_SUITE_STATUS',
                    data: {
                        id,
                        extra: {
                            fold: revised.fold,
                            playStatus: revised.playStatus || {}
                        }
                    }
                });
            }
            return Promise.all([
                pRename,
                pStoreExtra
            ])
                .then(() => suiteStorage.write(suiteName, revised));
        });
    },
    renameTestCase: (name) => (newName, fullPath) => {
        return createThunkAction((dispatch, getState) => {
            const macroStorage = storage_1.getStorageManager().getMacroStorage();
            const path = macroStorage.getPathLib();
            const state = getState();
            const editingId = state.editor.editing.meta.src.id;
            const newPath = macroStorage.filePath(path.join(path.dirname(fullPath), utils_1.sanitizeFileName(newName)));
            return macroStorage.fileExists(fullPath)
                .then(exists => {
                if (!exists) {
                    throw new Error(`No macro found with id '${fullPath}'!`);
                }
                return macroStorage.fileExists(newPath)
                    .then(exists => {
                    if (exists) {
                        throw new Error('The macro name already exists!');
                    }
                });
            })
                .then(() => {
                if (storage_1.getStorageManager().isXFileMode()) {
                    // Reset test case status
                    dispatch(index_1.updateMacroPlayStatus(fullPath, null));
                }
                return withMacroIdChanges({
                    dispatch,
                    entryPath: fullPath,
                    isDirectory: false,
                    getNewFilePath: (_) => newPath,
                    run: () => {
                        return storage_1.getStorageManager()
                            .getMacroStorage()
                            .rename(fullPath, newPath)
                            .then(() => {
                            if (editingId === fullPath) {
                                dispatch({
                                    type: name,
                                    data: newName,
                                    post: index_1.saveEditing
                                });
                            }
                        });
                    }
                })
                    .then(() => {
                    const isRenamingCurrentMacro = editingId === fullPath;
                    if (isRenamingCurrentMacro) {
                        dispatch(index_1.editTestCase(newPath));
                    }
                    checkNodeShowUp({
                        getState,
                        dispatch,
                        fullPath: newPath,
                        switchToIt: false,
                        message: 'Macro renamed'
                    });
                });
            });
        });
    },
    duplicateTestCase: (name) => (macro) => {
        return createThunkAction((dispatch, getState) => {
            const macroStorage = storage_1.getStorageManager().getMacroStorage();
            const path = macroStorage.getPathLib();
            const dirPath = path.dirname(macro.fullPath);
            const getNewPath = (newName) => path.join(dirPath, `${newName}.json`);
            const getNewName = () => {
                return utils_1.uniqueName(macro.name, {
                    generate: (old, step = 1) => {
                        const reg = /-(\d+)$/;
                        const m = old.match(reg);
                        if (!m)
                            return `${old}-${step}`;
                        return old.replace(reg, (_, n) => `-${parseInt(n, 10) + step}`);
                    },
                    check: (fileName) => {
                        return macroStorage.fileExists(getNewPath(fileName)).then(exists => !exists);
                    }
                });
            };
            return getNewName()
                .then(newMacroName => {
                return prompt_1.prompt({
                    width: 400,
                    title: 'Duplicate macro as..',
                    message: '',
                    value: newMacroName,
                    placeholder: 'Macro name',
                    selectionStart: 0,
                    selectionEnd: newMacroName.length,
                    okText: 'Duplicate',
                    cancelText: 'Cancel',
                    onCancel: () => Promise.resolve(true),
                    onOk: (macroName) => {
                        const fullPath = macroStorage.filePath(getNewPath(utils_1.sanitizeFileName(macroName)));
                        return macroStorage.fileExists(fullPath)
                            .then(exists => {
                            if (exists) {
                                const msg = `'${macroName}' already exists`;
                                antd_1.message.error(msg);
                                throw new Error(msg);
                            }
                            return macroStorage.copy(macro.fullPath, fullPath, false, false)
                                .then(() => {
                                antd_1.message.success(`Successfully duplicated as '${macroName}'`);
                                // Note: need to wait until it's reflected in redux
                                checkNodeShowUp({
                                    getState,
                                    dispatch,
                                    fullPath,
                                    message: 'Macro duplicated'
                                });
                                return true;
                            }, (e) => {
                                log_1.default.error(e);
                                const msg = 'Failed to duplicate macro: ' + e.message;
                                antd_1.message.error(msg);
                                throw new Error(msg);
                            });
                        });
                    }
                });
            });
        });
    },
    duplicateVisionImage: (name) => (imageName) => {
        return createThunkAction((dispatch, getState) => {
            const visionStorage = storage_1.getStorageManager().getVisionStorage();
            const path = visionStorage.getPathLib();
            const dirPath = path.dirname(imageName);
            const getNewPath = (newName) => path.join(dirPath, newName);
            const getNewName = () => {
                return utils_1.uniqueName(imageName, {
                    generate: (old, step = 1) => {
                        const reg = /-(\d+)$/;
                        const m = old.match(reg);
                        if (!m)
                            return `${old}-${step}`;
                        return old.replace(reg, (_, n) => `-${parseInt(n, 10) + step}`);
                    },
                    check: (fileName) => {
                        return visionStorage.fileExists(getNewPath(fileName)).then(exists => {
                            return !exists;
                        });
                    }
                });
            };
            return getNewName()
                .then(newImageName => {
                return prompt_1.prompt({
                    width: 400,
                    title: 'Duplicate vision image as..',
                    message: '',
                    value: newImageName,
                    placeholder: 'Macro name',
                    selectionStart: 0,
                    selectionEnd: newImageName.length,
                    okText: 'Duplicate',
                    cancelText: 'Cancel',
                    onCancel: () => Promise.resolve(true),
                    onOk: (finalImageName) => {
                        const fullPath = visionStorage.filePath(getNewPath(utils_1.sanitizeFileName(finalImageName)));
                        return visionStorage.fileExists(fullPath)
                            .then(exists => {
                            if (exists) {
                                const msg = `'${finalImageName}' already exists`;
                                antd_1.message.error(msg);
                                throw new Error(msg);
                            }
                            return visionStorage.copy(imageName, fullPath, false, false)
                                .then(() => {
                                antd_1.message.success(`Successfully duplicated as '${finalImageName}'`);
                                dispatch(index_1.listVisions());
                                return true;
                            }, (e) => {
                                log_1.default.error(e);
                                const msg = 'Failed to duplicate vision image: ' + e.message;
                                antd_1.message.error(msg);
                                throw new Error(msg);
                            });
                        });
                    }
                });
            });
        });
    },
    selectInitialMacro: (name) => (mode) => {
        return createThunkAction((dispatch, getState) => {
            const key = (() => {
                switch (mode) {
                    case storage_1.StorageStrategyType.Browser:
                        return misc_data_1.MiscKey.BrowserModeLastMacroId;
                    case storage_1.StorageStrategyType.XFile:
                        return misc_data_1.MiscKey.XFileModeLastMacroId;
                    default:
                        throw new Error(`Invalid mode: ${mode}`);
                }
            })();
            return misc_data_1.getMiscData().get(key)
                .then((macroFullPath) => {
                const state = getState();
                const found = macroFullPath ? recomputed_1.findMacroNodeWithCaseInsensitiveFullPath(state, macroFullPath) : null;
                log_1.default('selectInitialMacro', key, macroFullPath, found, state);
                if (found) {
                    return macroFullPath;
                }
                const rootNodes = recomputed_1.getMacroFolderNodeList(state);
                const first = ts_utils_1.findNodeInForest(node => node.isFile, rootNodes);
                return first ? first.fullPath : null;
            })
                .then((macroFullPath) => {
                if (macroFullPath) {
                    dispatch(index_1.editTestCase(macroFullPath));
                }
                else {
                    dispatch(index_1.editNewTestCase());
                }
            });
        });
    },
    editMacroByOffset: (name) => (offset) => {
        return createThunkAction((dispatch, getState) => {
            const state = getState();
            if (state.ui.isSaving) {
                return;
            }
            const trees = recomputed_1.getFilteredMacroFileNodeData(state);
            const macroId = recomputed_1.getCurrentMacroId(state);
            if (macroId === constant_1.UNTITLED_ID) {
                return;
            }
            const found = ts_utils_1.nodeByOffset({
                offset,
                tree: trees,
                isTargetQualified: (node) => {
                    return node.id === macroId;
                },
                isCandidateQualified: (node) => {
                    return node.type === tree_file_1.FileNodeType.File;
                }
            });
            if (!found) {
                return;
            }
            return dispatch(index_1.editTestCase(found.id))
                .then(() => {
                dispatch(exports.Actions.ensureTreeNodeUnfoldedForCurrentMacroNode({ scrollIntoView: true }));
            });
        });
    },
    setMacroQuery: (name) => (query) => {
        return createAction(name, query);
    },
    setIndexToInsertRecorded: (name) => (index) => {
        return createAction(name, index);
    },
    toggleRecorderSkipOpen: (name) => (force) => {
        return createAction(name, force);
    },
    scrollToCommandAtIndex: (name) => (commandIndex) => {
        return createThunkAction(() => {
            const $tableBody = document.querySelector('.table-wrapper');
            const itemHeight = config_1.default.ui.commandItemHeight;
            if (!$tableBody) {
                return;
            }
            const totalHeight = $tableBody.clientHeight;
            const scrollTop = $tableBody.scrollTop;
            const isAboveScrollArea = itemHeight * commandIndex < scrollTop;
            const isBelowScrollArea = itemHeight * (commandIndex + 3) > scrollTop + totalHeight;
            if (isAboveScrollArea) {
                $tableBody.scrollTop = itemHeight * commandIndex;
            }
            else if (isBelowScrollArea) {
                $tableBody.scrollTop = itemHeight * (commandIndex + 3) - totalHeight;
            }
        });
    },
    gotoLineInMacro: (name) => (macroId, commandIndex) => {
        return createThunkAction((dispatch, getState) => {
            const state = getState();
            const currentMacroId = recomputed_1.getCurrentMacroId(state);
            const saveMacro = macroId === currentMacroId
                ? () => Promise.resolve(true)
                : () => {
                    return save_test_case_1.default({ dispatch, getState }).saveOrNot({
                        cancelText: 'Cancel'
                    });
                };
            const gotoLine = () => {
                return Promise.resolve(dispatch(index_1.editTestCase(macroId)))
                    .then(() => {
                    dispatch(index_1.selectCommand(commandIndex, true));
                    dispatch(exports.Actions.scrollToCommandAtIndex(commandIndex));
                });
            };
            saveMacro().then(success => {
                if (success) {
                    return gotoLine();
                }
            })
                .catch(e => {
                log_1.default.warn(e);
            });
        });
    },
    downloadMacroAsJson: (name) => (macroId) => {
        return createThunkAction((dispatch, getState) => {
            return storage_1.getStorageManager().getMacroStorage().read(macroId, 'Text')
                .then(content => {
                const macro = content;
                const downloadJson = () => {
                    const str = convert_utils_1.toJSONString({ name: macro.name, commands: macro.data.commands }, {
                        ignoreTargetOptions: recomputed_1.getShouldSaveAlternativeLocators(getState())
                    });
                    const blob = new Blob([str], { type: 'text/plain;charset=utf-8' });
                    file_saver_1.default.saveAs(blob, `${macro.name}.json`, true);
                };
                const involveOtherResources = () => {
                    const imageRelatedCommands = macro.data.commands.filter(command => {
                        var _a;
                        return !command_1.canCommandReadImage(command.cmd) ? false : (_a = command_1.parseImageTarget(command.target)) === null || _a === void 0 ? void 0 : _a.fileName;
                    });
                    const csvRelatedCommands = macro.data.commands.filter(cmd => command_1.canCommandReadCsv(cmd.cmd));
                    const macroRelatedCommands = macro.data.commands.filter(cmd => command_1.canCommandRunMacro(cmd.cmd));
                    if (imageRelatedCommands.length === 0 &&
                        csvRelatedCommands.length === 0 &&
                        macroRelatedCommands.length === 0) {
                        return false;
                    }
                    return true;
                };
                if (!involveOtherResources()) {
                    return downloadJson();
                }
                return prompt_1.prompt({
                    width: 400,
                    title: 'Export as zip instead?',
                    message: 'This macro contains images/csv.\nDo you want to use the ZIP export option instead?',
                    noInput: true,
                    closable: false,
                    okText: 'ZIP',
                    cancelText: 'JSON',
                    onCancel: () => {
                        downloadJson();
                        return Promise.resolve(true);
                    },
                    onOk: () => {
                        dispatch(exports.Actions.downloadMacroAsZip(macroId));
                        return Promise.resolve(true);
                    }
                })
                    .then(() => { });
            });
        });
    },
    downloadMacroAsHTML: (name) => (macroId) => {
        return createThunkAction((dispatch, getState) => {
            return storage_1.getStorageManager().getMacroStorage().read(macroId, 'Text')
                .then(content => {
                const macro = content;
                const str = convert_utils_1.toHtml({ name: macro.name, commands: macro.data.commands });
                const blob = new Blob([str], { type: 'text/plain;charset=utf-8' });
                file_saver_1.default.saveAs(blob, `${macro.name}.html`, true);
            });
        });
    },
    downloadMacroAsZip: (name) => (macroId) => {
        return createThunkAction((dispatch, getState) => {
            const zip = new jszip_1.default();
            const warn = (msg) => dispatch(index_1.addLog('warning', msg));
            const imageDict = {};
            const csvDict = {};
            const macroDict = {};
            const bundleMacroIntoZip = (macroId, isSubMacro) => {
                const macroStorage = storage_1.getStorageManager().getMacroStorage();
                const path = macroStorage.getPathLib();
                return macroStorage.read(macroId, 'Text')
                    .then(content => {
                    const macro = content;
                    const macroToSave = ts_utils_1.clone(macro);
                    const imageRelatedCommands = macro.data.commands.filter(cmd => command_1.canCommandReadImage(cmd.cmd));
                    const csvRelatedCommands = macro.data.commands.filter(cmd => command_1.canCommandReadCsv(cmd.cmd));
                    const macroRelatedCommands = [];
                    // Since all macros are saved in the same folder now,
                    // macro paths in `run` commands should be changed accordingly
                    macro.data.commands.forEach((cmd, i) => {
                        if (command_1.canCommandRunMacro(cmd.cmd)) {
                            macroRelatedCommands.push(cmd);
                            macroToSave.data.commands[i].target = path.basename(cmd.target);
                        }
                    });
                    Promise.all([
                        ...imageRelatedCommands.map(command => {
                            var _a;
                            const imageFileName = (_a = command_1.parseImageTarget(command.target)) === null || _a === void 0 ? void 0 : _a.fileName;
                            if (!imageFileName || imageDict[imageFileName]) {
                                return Promise.resolve();
                            }
                            imageDict[imageFileName] = true;
                            return storage_1.getStorageManager().getVisionStorage().read(imageFileName, 'ArrayBuffer')
                                .then(buffer => {
                                zip.file(imageFileName, buffer, { binary: true });
                            })
                                .catch((e) => {
                                warn(`Failed to add ${imageFileName} into zip: ${e.message}`);
                            });
                        }),
                        ...csvRelatedCommands.map(command => {
                            const csvFileName = command.target;
                            if (!csvFileName || csvDict[csvFileName]) {
                                return Promise.resolve();
                            }
                            csvDict[csvFileName] = true;
                            return storage_1.getStorageManager().getCSVStorage().read(csvFileName, 'Text')
                                .then(text => {
                                zip.file(csvFileName, text);
                            })
                                .catch((e) => {
                                warn(`Failed to add ${csvFileName} into zip: ${e.message}`);
                            });
                        }),
                        ...macroRelatedCommands.map(command => {
                            const subMacroRelativePath = ts_utils_1.resolvePath(macroStorage.getPathLib(), macroStorage.relativePath(macroId), command.target);
                            const subMacroNode = recomputed_1.findMacroNodeWithCaseInsensitiveRelativePath(getState(), subMacroRelativePath);
                            const subMacroId = subMacroNode ? subMacroNode.fullPath : subMacroRelativePath;
                            if (macroDict[subMacroId]) {
                                return Promise.resolve();
                            }
                            return bundleMacroIntoZip(subMacroId, true);
                        })
                    ])
                        .then(() => {
                        zip.file(macroToSave.name + '.json', convert_utils_1.toJSONString({ name: macroToSave.name, commands: macroToSave.data.commands }));
                        if (isSubMacro) {
                            return;
                        }
                        return zip.generateAsync({ type: 'blob' })
                            .then((blob) => file_saver_1.default.saveAs(blob, `${macroToSave.name}.zip`));
                    });
                });
            };
            return bundleMacroIntoZip(macroId)
                .catch((e) => {
                warn(`Failed to save zip file: ${e.message}`);
            });
        });
    },
    readFilesAndImportTestCases: (name) => (params) => {
        const { type, process, folder, files: rawFiles } = params;
        return createThunkAction((dispatch, getState) => {
            const files = Array.from(rawFiles);
            if (!files || !files.length) {
                return;
            }
            const read = (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        var _a;
                        const content = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;
                        new Promise(resolve => resolve(process(content, file.name, file)))
                            .then(result => {
                            if (!result || !result.macros.length) {
                                return resolve({
                                    err: new Error('Failed to parse macro'),
                                    fileName: file.name
                                });
                            }
                            const { macros, images = [], csvs = [] } = result;
                            resolve({
                                data: { macros, images, csvs }
                            });
                        })
                            .catch((e) => {
                            resolve({ err: e, fileName: file.name });
                        });
                    };
                    switch (type) {
                        case 'text':
                            return reader.readAsText(file);
                        case 'data_url':
                            return reader.readAsDataURL(file);
                        case 'binary_string':
                            return reader.readAsBinaryString(file);
                        case 'array_buffer':
                            return reader.readAsArrayBuffer(file);
                    }
                });
            };
            const saveResource = (storage, fileName, type, content) => {
                const blob = type === 'text' ? new Blob([content]) : content;
                return storage.fileExists(fileName)
                    .then(exists => {
                    if (exists) {
                        return { error: `${fileName} already exists` };
                    }
                    return storage.write(fileName, blob)
                        .then(() => ({ fileName }))
                        .catch((e) => ({ error: `Failed to save ${fileName}: ${e.message}` }));
                });
            };
            const saveAllForMacro = (item) => {
                return Promise.all([
                    Promise.all(item.csvs.map(csv => {
                        return saveResource(storage_1.getStorageManager().getCSVStorage(), csv.fileName, 'text', csv.content);
                    })),
                    Promise.all(item.images.map(csv => {
                        return saveResource(storage_1.getStorageManager().getVisionStorage(), csv.fileName, 'blob', csv.content);
                    }))
                ])
                    .then((tuple) => {
                    const [csvResult, pngResult] = tuple;
                    return Promise.resolve({
                        macros: item.macros,
                        csvImported: csvResult.filter(x => x.fileName).map(x => x.fileName),
                        pngImported: pngResult.filter(x => x.fileName).map(x => x.fileName),
                        errors: [
                            ...csvResult.filter(x => x.error).map(x => x.error),
                            ...pngResult.filter(x => x.error).map(x => x.error)
                        ]
                    });
                });
            };
            Promise.all(files.map(read))
                .then(list => {
                const doneList = list.filter(x => x.data);
                const failList = list.filter(x => x.err);
                return Promise.all(doneList.map(item => saveAllForMacro(item.data)))
                    .then(saveResourceResults => {
                    return dispatch(index_1.addTestCases({
                        folder,
                        macros: ts_utils_1.flatten(doneList.map(x => x.data.macros))
                    }))
                        .then(({ passCount, failCount, failTcs }) => {
                        antd_1.message.info([
                            `${passCount} macro${passCount > 1 ? 's' : ''} imported!`,
                            `${failList.length + failCount} macro${(failList.length + failCount) > 1 ? 's' : ''} failed!`
                        ].join(', '), 3);
                        failList.forEach(fail => {
                            dispatch(index_1.addLog('error', `in parsing ${fail.fileName}: ${fail.err.message}`));
                        });
                        failTcs.forEach((fail) => {
                            dispatch(index_1.addLog('error', `duplicated macro name: ${fail.name}`, {
                                noStack: true
                            }));
                        });
                        const allCsvs = ts_utils_1.flatten(saveResourceResults.map(item => item.csvImported));
                        const allPngs = ts_utils_1.flatten(saveResourceResults.map(item => item.pngImported));
                        const allErrors = ts_utils_1.flatten(saveResourceResults.map(item => item.errors));
                        const allMacroNames = ts_utils_1.flatten(saveResourceResults.map(item => item.macros))
                            .filter(item => !failTcs.find((fail) => fail.name == item.name))
                            .map(item => item.name);
                        if (allMacroNames.length > 0) {
                            dispatch(index_1.addLog('info', `${allMacroNames.length} ${allMacroNames.length > 1 ? 'macros' : 'macro'} imported:\n${allMacroNames.join('\n')}`));
                        }
                        if (allCsvs.length > 0) {
                            dispatch(index_1.addLog('info', `${allCsvs.length} CSV imported:\n${allCsvs.join('\n')}`));
                            dispatch(index_1.listCSV());
                        }
                        if (allPngs.length > 0) {
                            dispatch(index_1.addLog('info', `${allPngs.length} PNG imported:\n${allPngs.join('\n')}`));
                            dispatch(index_1.listVisions());
                        }
                        if (allErrors.length > 0) {
                            dispatch(index_1.addLog('error', `${allErrors.length} ${allErrors.length > 1 ? 'errors' : 'error'} in importing csv/png:\n${allErrors.join('\n')}`));
                        }
                    });
                })
                    .catch(e => {
                    dispatch(index_1.addLog('error', e.message, {
                        noStack: true
                    }));
                });
            });
        });
    },
    importMacroHtml: (name) => (files, folder) => {
        return createThunkAction((dispatch, getState) => {
            const process = (content, fileName) => ({
                macros: [convert_utils_1.fromHtml(content)],
                csvs: [],
                images: []
            });
            dispatch(exports.Actions.readFilesAndImportTestCases({
                folder,
                files,
                process,
                type: 'text'
            }));
        });
    },
    importMacroJsonOrZipFiles: (name) => (files, folder) => {
        return createThunkAction((dispatch, getState) => {
            const process = (content, fileName, file) => {
                if (/.json$/i.test(fileName)) {
                    const str = utils_1.arrayBufferToString(content);
                    return Promise.resolve({
                        macros: [convert_utils_1.fromJSONString(str, fileName)],
                        csvs: [],
                        images: []
                    });
                }
                return jszip_1.default.loadAsync(content)
                    .then(zip => {
                    const pJsonList = [];
                    const pCsvList = [];
                    const pPngList = [];
                    zip.forEach((relativePath, file) => {
                        const extName = ts_utils_1.getExtName(relativePath).toLowerCase();
                        switch (extName) {
                            case '.csv':
                                pCsvList.push(file.async('text').then(content => ({ content, fileName: relativePath })));
                                break;
                            case '.png':
                                pPngList.push(file.async('blob').then(content => ({ content, fileName: relativePath })));
                                break;
                            case '.json':
                                pJsonList.push(file.async('text').then(content => ({ content, fileName: relativePath })));
                                break;
                        }
                    });
                    if (pJsonList.length === 0) {
                        throw new Error('No json file found in zip');
                    }
                    return Promise.all([
                        Promise.all(pJsonList),
                        Promise.all(pCsvList),
                        Promise.all(pPngList)
                    ])
                        .then(triple => {
                        const macros = triple[0].map(obj => convert_utils_1.fromJSONString(obj.content, obj.fileName));
                        return {
                            macros,
                            csvs: triple[1],
                            images: triple[2]
                        };
                    });
                });
            };
            dispatch(exports.Actions.readFilesAndImportTestCases({
                files,
                folder,
                process,
                type: 'array_buffer'
            }));
        });
    }
};
exports.ActionTypes = ts_utils_1.objMap((_, key) => key, exports.ActionFactories);
exports.Actions = ts_utils_1.objMap((factory, key, i) => {
    return factory(exports.ActionTypes[key]);
}, exports.ActionFactories);
function createAction(type, data) {
    return {
        type,
        data
    };
}
exports.createAction = createAction;
function createThunkAction(thunk) {
    return thunk;
}
exports.createThunkAction = createThunkAction;


/***/ }),

/***/ 89145:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* globals chrome */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.captureClientAPI = exports.CaptureScreenshotService = exports.scaleDataURI = exports.getScreenshotRatio = exports.imageSizeFromDataURI = void 0;
const web_extension_1 = __importDefault(__webpack_require__(61171));
const utils_1 = __webpack_require__(63370);
const ts_utils_1 = __webpack_require__(55452);
function imageSizeFromDataURI(dataURI) {
    return createImageBitmap(utils_1.dataURItoBlob(dataURI))
        .then((img) => ({
        width: img.width,
        height: img.height
    }));
}
exports.imageSizeFromDataURI = imageSizeFromDataURI;
function getScreenshotRatio(dataURI, tabId, devicePixelRatio) {
    return Promise.all([
        imageSizeFromDataURI(dataURI),
        web_extension_1.default.tabs.get(tabId)
    ])
        .then(tuple => {
        const [size, tab] = tuple;
        return tab.width * devicePixelRatio / size.width;
    });
}
exports.getScreenshotRatio = getScreenshotRatio;
function scaleDataURI(dataURI, scale) {
    if (scale === 1)
        return Promise.resolve(dataURI);
    return imageSizeFromDataURI(dataURI)
        .then(size => {
        const canvas = createCanvas(size.width, size.height, scale);
        return drawOnCanvas({
            canvas,
            dataURI,
            x: 0,
            y: 0,
            width: size.width * scale,
            height: size.height * scale
        })
            .then(() => canvas.toDataURL());
    });
}
exports.scaleDataURI = scaleDataURI;
function pCompose(list) {
    return list.reduce((prev, fn) => {
        return prev.then(fn);
    }, Promise.resolve());
}
class CaptureScreenshotService {
    constructor(params) {
        this.params = params;
        this.captureVisibleTab =
            typeof chrome !== 'undefined' &&
                typeof chrome.tabs !== 'undefined' &&
                typeof chrome.tabs.MAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND === 'number'
                ? ts_utils_1.throttlePromiseFunc(this.params.captureVisibleTab, chrome.tabs.MAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND * 1000 + 100)
                : this.params.captureVisibleTab;
    }
    saveScreen(screenshotStorage, tabId, fileName, devicePixelRatio) {
        return this.captureScreenBlob(tabId, devicePixelRatio)
            .then(screenBlob => {
            return screenshotStorage.overwrite(fileName, screenBlob)
                .then(() => {
                return screenshotStorage.getLink(fileName);
            })
                .then((url) => {
                return ({ url, fileName });
            }, (e) => {
                return Promise.reject(e);
            });
        });
    }
    saveFullScreen(screenshotStorage, tabId, fileName, clientAPI) {
        return this.captureFullScreen(tabId, clientAPI, { blob: true })
            .then(screenBlob => {
            return screenshotStorage.overwrite(fileName, screenBlob)
                .then(() => screenshotStorage.getLink(fileName))
                .then(url => ({ url, fileName }));
        });
    }
    captureScreen(tabId, devicePixelRatio, presetScreenshotRatio) {
        const is2ndArgFunction = typeof presetScreenshotRatio === 'function';
        const hasScreenshotRatio = !!presetScreenshotRatio && !is2ndArgFunction;
        const pDataURI = this.captureVisibleTab(null, { format: 'png' });
        const pRatio = hasScreenshotRatio ? Promise.resolve(presetScreenshotRatio)
            : pDataURI.then((dataURI) => getScreenshotRatio(dataURI, tabId, devicePixelRatio));
        return Promise.all([pDataURI, pRatio])
            .then(tuple => {
            const [dataURI, screenshotRatio] = tuple;
            // Note: leak the info about screenshotRatio on purpose
            if (!hasScreenshotRatio && is2ndArgFunction)
                presetScreenshotRatio(screenshotRatio);
            if (screenshotRatio === 1)
                return dataURI;
            return scaleDataURI(dataURI, screenshotRatio);
        });
    }
    captureFullScreen(tabId, { startCapture, scrollPage, endCapture } = exports.captureClientAPI, options = {}) {
        const opts = Object.assign({ blob: false }, options);
        return withPageInfo(startCapture, endCapture, pageInfo => {
            const devicePixelRatio = pageInfo.devicePixelRatio;
            // Note: cut down page width and height
            // reference: https://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element/11585939#11585939
            const maxSide = Math.floor(32767 / devicePixelRatio);
            pageInfo.pageWidth = Math.min(maxSide, pageInfo.pageWidth);
            pageInfo.pageHeight = Math.min(maxSide, pageInfo.pageHeight);
            const captureScreen = this.createCaptureScreenWithCachedScreenshotRatio(devicePixelRatio);
            const canvas = createCanvas(pageInfo.pageWidth, pageInfo.pageHeight, devicePixelRatio);
            const scrollOffsets = getAllScrollOffsets(pageInfo);
            const todos = scrollOffsets.map((offset, i) => () => {
                return scrollPage(offset, { index: i, total: scrollOffsets.length })
                    .then(realOffset => {
                    return captureScreen(tabId)
                        .then(dataURI => drawOnCanvas({
                        canvas,
                        dataURI,
                        x: realOffset.x * devicePixelRatio,
                        y: realOffset.y * devicePixelRatio,
                        width: pageInfo.windowWidth * devicePixelRatio,
                        height: pageInfo.windowHeight * devicePixelRatio
                    }));
                });
            });
            const convert = opts.blob ? utils_1.dataURItoBlob : (x) => x;
            return pCompose(todos)
                .then(() => convert(canvas.toDataURL()));
        });
    }
    captureScreenInSelectionSimple(tabId, { rect, devicePixelRatio }, options = {}) {
        const opts = Object.assign({ blob: false }, options);
        const convert = opts.blob ? utils_1.dataURItoBlob : (x) => x;
        const canvas = createCanvas(rect.width, rect.height, devicePixelRatio);
        return this.captureScreen(tabId, devicePixelRatio)
            .then(dataURI => drawOnCanvas({
            canvas,
            dataURI,
            x: -1 * rect.x * devicePixelRatio,
            y: -1 * rect.y * devicePixelRatio
        }))
            .then(() => convert(canvas.toDataURL()));
    }
    captureScreenInSelection(tabId, { rect, devicePixelRatio }, { startCapture, scrollPage, endCapture }, options = {}) {
        const opts = Object.assign({ blob: false }, options);
        const convert = opts.blob ? utils_1.dataURItoBlob : (x) => x;
        return withPageInfo(startCapture, endCapture, pageInfo => {
            const maxSide = Math.floor(32767 / devicePixelRatio);
            pageInfo.pageWidth = Math.min(maxSide, pageInfo.pageWidth);
            pageInfo.pageHeight = Math.min(maxSide, pageInfo.pageHeight);
            const captureScreen = this.createCaptureScreenWithCachedScreenshotRatio(devicePixelRatio);
            const canvas = createCanvas(rect.width, rect.height, devicePixelRatio);
            const scrollOffsets = getAllScrollOffsetsForRect(rect, pageInfo);
            const todos = scrollOffsets.map((offset, i) => () => {
                return scrollPage(offset, { index: i, total: scrollOffsets.length })
                    .then(realOffset => {
                    return captureScreen(tabId)
                        .then(dataURI => drawOnCanvas({
                        canvas,
                        dataURI,
                        x: (realOffset.x - rect.x) * devicePixelRatio,
                        y: (realOffset.y - rect.y) * devicePixelRatio,
                        width: pageInfo.windowWidth * devicePixelRatio,
                        height: pageInfo.windowHeight * devicePixelRatio
                    }));
                });
            });
            return pCompose(todos)
                .then(() => convert(canvas.toDataURL()));
        });
    }
    createCaptureScreenWithCachedScreenshotRatio(devicePixelRatio) {
        let screenshotRatio;
        return (tabId) => {
            return this.captureScreen(tabId, devicePixelRatio, screenshotRatio || function (ratio) { screenshotRatio = ratio; });
        };
    }
    captureScreenBlob(tabId, devicePixelRatio) {
        return this.captureScreen(tabId, devicePixelRatio).then(utils_1.dataURItoBlob);
    }
}
exports.CaptureScreenshotService = CaptureScreenshotService;
function getAllScrollOffsets({ pageWidth, pageHeight, windowWidth, windowHeight, topPadding = 150 }) {
    const topPad = windowHeight > topPadding ? topPadding : 0;
    const xStep = windowWidth;
    const yStep = windowHeight - topPad;
    const result = [];
    // Note: bottom comes first so that when we render those screenshots one by one to the final canvas,
    // those at top will overwrite top padding part of those at bottom, it is useful if that page has some fixed header
    for (let y = pageHeight - windowHeight; y > -1 * yStep; y -= yStep) {
        for (let x = 0; x < pageWidth; x += xStep) {
            result.push({ x, y });
        }
    }
    return result;
}
function getAllScrollOffsetsForRect({ x, y, width, height }, { windowWidth, windowHeight, topPadding = 150 }) {
    const topPad = windowHeight > topPadding ? topPadding : 0;
    const xStep = windowWidth;
    const yStep = windowHeight - topPad;
    const result = [];
    for (let sy = y + height - windowHeight; sy > y - yStep; sy -= yStep) {
        for (let sx = x; sx < x + width; sx += xStep) {
            result.push({ x: sx, y: sy });
        }
    }
    if (result.length === 0) {
        result.push({ x: x, y: y + height - windowHeight });
    }
    return result;
}
function createCanvas(width, height, pixelRatio = 1) {
    if (typeof window === 'undefined') {
        return new self.OffscreenCanvas(width * pixelRatio, height * pixelRatio);
    }
    const canvas = document.createElement('canvas');
    canvas.width = width * pixelRatio;
    canvas.height = height * pixelRatio;
    return canvas;
}
function drawOnCanvas({ canvas, dataURI, x, y, width, height }) {
    return createImageBitmap(utils_1.dataURItoBlob(dataURI))
        .then((image) => {
        canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height, x, y, width || image.width, height || image.height);
        return { x, y, width, height };
    });
}
function withPageInfo(startCapture, endCapture, callback) {
    return startCapture()
        .then(pageInfo => {
        // Note: in case sender contains any non-serializable data
        delete pageInfo.sender;
        return callback(pageInfo)
            .then(result => {
            endCapture(pageInfo);
            return result;
        });
    });
}
exports.captureClientAPI = {
    getPageInfo: () => {
        const body = document.body;
        const widths = [
            document.documentElement.clientWidth,
            document.documentElement.scrollWidth,
            document.documentElement.offsetWidth,
            body ? body.scrollWidth : 0,
            body ? body.offsetWidth : 0
        ];
        const heights = [
            document.documentElement.clientHeight,
            document.documentElement.scrollHeight,
            document.documentElement.offsetHeight,
            body ? body.scrollHeight : 0,
            body ? body.offsetHeight : 0
        ];
        const data = {
            pageWidth: Math.max(...widths),
            pageHeight: Math.max(...heights),
            windowWidth: window.innerWidth,
            windowHeight: window.innerHeight,
            hasBody: !!body,
            originalX: window.scrollX,
            originalY: window.scrollY,
            originalOverflowStyle: document.documentElement.style.overflow,
            originalBodyOverflowYStyle: body && body.style.overflowY,
            devicePixelRatio: window.devicePixelRatio
        };
        return data;
    },
    startCapture: ({ hideScrollbar = true } = {}) => {
        const body = document.body;
        const pageInfo = exports.captureClientAPI.getPageInfo();
        // Note: try to make pages with bad scrolling work, e.g., ones with
        // `body { overflow-y: scroll; }` can break `window.scrollTo`
        if (body) {
            body.style.overflowY = 'visible';
        }
        if (hideScrollbar) {
            // Disable all scrollbars. We'll restore the scrollbar state when we're done
            // taking the screenshots.
            document.documentElement.style.overflow = 'hidden';
        }
        return Promise.resolve(pageInfo);
    },
    scrollPage: ({ x, y }, opts) => {
        window.scrollTo(x, y);
        return utils_1.delay(() => ({
            x: window.scrollX,
            y: window.scrollY
        }), 100);
    },
    endCapture: (pageInfo) => {
        const { originalX, originalY, hasBody, originalOverflowStyle, originalBodyOverflowYStyle } = pageInfo;
        if (hasBody) {
            document.body.style.overflowY = originalBodyOverflowYStyle !== null && originalBodyOverflowYStyle !== void 0 ? originalBodyOverflowYStyle : '';
        }
        document.documentElement.style.overflow = originalOverflowStyle;
        window.scrollTo(originalX, originalY);
        return Promise.resolve(true);
    }
};


/***/ }),

/***/ 41191:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function setStyle($dom, obj) {
    Object.keys(obj).forEach((key) => {
        $dom.style[key] = obj[key];
    });
}
function createTextarea() {
    // [legacy code] Used to use textarea for copy/paste
    //
    // const $input = document.createElement('textarea')
    // // Note: Firefox requires 'contenteditable' attribute, even on textarea element
    // // without it, execCommand('paste') won't work in Firefox
    // // reference: https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Interact_with_the_clipboard#Browser-specific_considerations_2
    // $input.setAttribute('contenteditable', true)
    // $input.id = 'clipboard_textarea'
    // Note: 2018-09-01, Firefox 61.0.2: Only able to paste clipboard into textarea for one time.
    // Switching to contenteditable div works fine
    const $input = document.createElement('div');
    $input.setAttribute('contenteditable', 'true');
    $input.id = 'clipboard_textarea';
    setStyle($input, {
        position: 'aboslute',
        top: '-9999px',
        left: '-9999px'
    });
    (document.body || document.documentElement).appendChild($input);
    return $input;
}
function getTextArea() {
    const $el = document.getElementById('clipboard_textarea');
    if ($el)
        return $el;
    return createTextarea();
}
function withInput(fn) {
    const $input = getTextArea();
    let ret;
    try {
        ret = fn($input);
    }
    catch (e) {
        console.error(e);
    }
    finally {
        $input.innerHTML = '';
    }
    return ret;
}
const api = {
    set: (text) => {
        withInput($input => {
            $input.innerText = text;
            $input.focus();
            document.execCommand('selectAll', false, null);
            document.execCommand('copy');
        });
    },
    get: () => {
        return withInput($input => {
            $input.blur();
            $input.focus();
            const res = document.execCommand('paste');
            if (res) {
                return $input.innerText;
            }
            return 'no luck';
        });
    }
};
exports["default"] = api;


/***/ }),

/***/ 43232:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STATE_STORAGE_KEY = exports.CS_IPC_TIMEOUT = exports.SCREENSHOT_DELAY = exports.UNTITLED_ID = exports.LAST_DESKTOP_SCREENSHOT_FILE_NAME = exports.LAST_SCREENSHOT_FILE_NAME = exports.TEST_CASE_STATUS = exports.CONTENT_SCRIPT_STATUS = exports.PLAYER_MODE = exports.PLAYER_STATUS = exports.RECORDER_STATUS = exports.INSPECTOR_STATUS = exports.APP_STATUS = void 0;
const mk = (list) => list.reduce((prev, key) => {
    prev[key] = key;
    return prev;
}, {});
exports.APP_STATUS = mk([
    'NORMAL',
    'INSPECTOR',
    'RECORDER',
    'PLAYER'
]);
exports.INSPECTOR_STATUS = mk([
    'PENDING',
    'INSPECTING',
    'STOPPED'
]);
exports.RECORDER_STATUS = mk([
    'PENDING',
    'RECORDING',
    'STOPPED'
]);
exports.PLAYER_STATUS = mk([
    'PLAYING',
    'PAUSED',
    'STOPPED'
]);
exports.PLAYER_MODE = mk([
    'TEST_CASE',
    'TEST_SUITE'
]);
exports.CONTENT_SCRIPT_STATUS = mk([
    'NORMAL',
    'RECORDING',
    'INSPECTING',
    'PLAYING'
]);
exports.TEST_CASE_STATUS = mk([
    'NORMAL',
    'SUCCESS',
    'ERROR',
    'ERROR_IN_SUB'
]);
exports.LAST_SCREENSHOT_FILE_NAME = '__lastscreenshot';
exports.LAST_DESKTOP_SCREENSHOT_FILE_NAME = '__last_desktop_screenshot';
exports.UNTITLED_ID = '__untitled__';
// Note: in Ubuntu, you have to take some delay after activating some tab, otherwise there are chances
// Chrome still think the panel is the window you want to take screenshot, and weird enough in Ubuntu,
// You can't take screenshot of tabs with 'chrome-extension://' schema, even if it's your own extension
exports.SCREENSHOT_DELAY = /Linux/i.test(self.navigator.userAgent) ? 200 : 0;
exports.CS_IPC_TIMEOUT = 3000;
exports.STATE_STORAGE_KEY = 'background_state';


/***/ }),

/***/ 36465:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Counter = void 0;
class Counter {
    constructor(options = {}) {
        this.n = 0;
        const { initial, getMax, onMax } = options;
        if (typeof getMax !== 'function')
            throw new Error(`'getMax' function is required`);
        if (typeof onMax !== 'function')
            throw new Error(`onMax callback is required`);
        this.initial = initial || 0;
        this.getMax = getMax;
        this.onMax = onMax;
        this.reset();
    }
    reset() {
        this.n = this.initial;
    }
    get() {
        return this.n;
    }
    getMaximum() {
        return this.getMax();
    }
    check() {
        const max = this.getMax();
        if (this.n + 1 > max) {
            this.onMax(this.n, max, this.initial);
            return false;
        }
        return true;
    }
    inc() {
        const max = this.getMax();
        if (this.n < max) {
            this.n += 1;
            return true;
        }
        else {
            this.onMax(this.n, max, this.initial);
            return false;
        }
    }
}
exports.Counter = Counter;


/***/ }),

/***/ 88325:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersistentCounter = void 0;
const counter_1 = __webpack_require__(36465);
class PersistentCounter extends counter_1.Counter {
    constructor(options) {
        super(options);
        this.ready = false;
        this.read = options.read;
        this.write = options.write;
    }
    reset() {
        super.reset();
        this.ready = false;
        setTimeout(() => {
            this.read()
                .then(n => {
                this.ready = true;
                this.n = n;
            });
        }, 0);
    }
    inc() {
        if (!this.ready) {
            throw new Error('counter not ready yet');
        }
        const result = super.inc();
        this.write(this.n);
        return result;
    }
}
exports.PersistentCounter = PersistentCounter;


/***/ }),

/***/ 21063:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCVTypeForDesktop = exports.ComputerVisionType = void 0;
var ComputerVisionType;
(function (ComputerVisionType) {
    ComputerVisionType["Browser"] = "browser";
    ComputerVisionType["Desktop"] = "desktop";
    ComputerVisionType["DesktopScreenCapture"] = "desktop_screen_capture";
})(ComputerVisionType = exports.ComputerVisionType || (exports.ComputerVisionType = {}));
function isCVTypeForDesktop(type) {
    return type === ComputerVisionType.Desktop || type === ComputerVisionType.DesktopScreenCapture;
}
exports.isCVTypeForDesktop = isCVTypeForDesktop;


/***/ }),

/***/ 25343:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createIframe = exports.ipcForIframe = void 0;
const cs_postmessage_1 = __webpack_require__(5116);
const registry_1 = __webpack_require__(55290);
const consecutive_1 = __webpack_require__(18463);
const ts_utils_1 = __webpack_require__(55452);
const postMsg = cs_postmessage_1.postMessage;
exports.ipcForIframe = ({ targetWindow = window.top, timeout = 60000 } = {}) => {
    const registry = registry_1.createListenerRegistry();
    const listener = ({ cmd, args }) => registry.fire('call', { cmd, args });
    const removeOnMsg = cs_postmessage_1.onMessage(window, listener);
    return {
        ask: (cmd, args) => {
            return postMsg(targetWindow, window, { cmd, args }, '*', timeout);
        },
        onAsk: (fn) => {
            registry.add('call', ({ cmd, args }) => fn(cmd, args));
        },
        destroy: () => {
            removeOnMsg();
        }
    };
};
exports.createIframe = (options) => {
    const { url, width, height, onLoad, domReady, ipcTimeout = 60000 } = options;
    const $iframe = document.createElement('iframe');
    const pLoad = new Promise((resolve, reject) => {
        if (width)
            $iframe.width = '' + width;
        if (height)
            $iframe.height = '' + height;
        $iframe.addEventListener('load', () => {
            if (typeof onLoad === 'function') {
                try {
                    onLoad();
                }
                catch (e) { }
            }
            resolve();
        });
        $iframe.src = url;
        document.body.appendChild($iframe);
    });
    const waitDomReady = (domReady) => {
        return ts_utils_1.retry(() => {
            return consecutive_1.withConsecutive(domReady, () => {
                return postMsg($iframe.contentWindow, window, { cmd: 'DOM_READY', args: {} }, '*', 1000)
                    .then(() => true, () => false);
            })
                .then(() => undefined);
        }, {
            timeout: ipcTimeout,
            shouldRetry: (e) => true,
            retryInterval: 1000
        })();
    };
    const pReady = domReady ? pLoad.then(() => waitDomReady(domReady)) : pLoad;
    const removeOnMsg = cs_postmessage_1.onMessage(window, ({ cmd, args }) => {
        return wrappedOnAsk(cmd, args);
    });
    const wrappedOnAsk = (cmd, args) => {
        return registry.fire('call', { cmd, args });
    };
    const registry = registry_1.createListenerRegistry();
    return {
        $iframe,
        destroy: () => {
            if ($iframe)
                $iframe.remove();
            removeOnMsg();
        },
        ask: (cmd, args) => {
            return pReady.then(() => {
                return postMsg($iframe.contentWindow, window, { cmd, args }, '*', ipcTimeout);
            });
        },
        onAsk: (fn) => {
            registry.add('call', ({ cmd, args }) => fn(cmd, args));
        }
    };
};


/***/ }),

/***/ 22491:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.askPageWithFixedTab = exports.askPageWithTab = exports.openPageInTab = exports.askPageWithIframe = exports.openPageInIframe = void 0;
const ipc_iframe_1 = __webpack_require__(25343);
const web_extension_1 = __importDefault(__webpack_require__(61171));
const ipc_cache_1 = __webpack_require__(54105);
const tab_utils_1 = __webpack_require__(96836);
exports.openPageInIframe = ipc_iframe_1.createIframe;
exports.askPageWithIframe = (options) => {
    const iframeIpc = exports.openPageInIframe({
        url: options.url,
        width: options.width,
        height: options.height,
        ipcTimeout: options.ipcTimeout,
        domReady: options.domReady,
        onLoad: options.onLoad
    });
    return iframeIpc.ask(options.cmd, options.args)
        .then((data) => {
        setTimeout(() => iframeIpc.destroy());
        return data;
    });
};
exports.openPageInTab = (options) => {
    const isValidTab = (tabId) => {
        return web_extension_1.default.tabs.get(tabId)
            .then((tab) => {
            return !!tab;
        })
            .catch((e) => false);
    };
    const updateExistingTabToUrl = (tabId, url) => {
        return isValidTab(tabId)
            .then(isValid => {
            return isValid ? web_extension_1.default.tabs.update(tabId, { url }) : createNewTabWithUrl(url);
        });
    };
    const createNewTabWithUrl = (url) => {
        if (options.popup) {
            return web_extension_1.default.windows.create({
                type: 'popup',
                url: url,
                width: Math.round(options.width || screen.availWidth),
                height: Math.round(options.height || screen.availHeight),
                left: Math.round(options.left || 0),
                top: Math.round(options.top || 0),
            })
                .then((win) => win.tabs[0]);
        }
        return web_extension_1.default.tabs.create({ url });
    };
    const { url, tabId, domReady } = options;
    const pTab = options.tabId ? updateExistingTabToUrl(tabId, url) : createNewTabWithUrl(url);
    const pIpc = pTab.then(tab => {
        const ipcStore = ipc_cache_1.getIpcCache();
        const pGetTab = domReady ? ipcStore.domReadyGet(tab.id, 20 * 1000, domReady) : ipcStore.get(tab.id, 20 * 1000);
        return (options.focus ? tab_utils_1.activateTab(tab.id, true) : Promise.resolve())
            .then(() => pGetTab)
            .then(ipc => (Object.assign(Object.assign({}, ipc), { getTabId: () => tab.id, getTab: () => web_extension_1.default.tabs.get(tab.id), destroy: () => {
                ipc.destroy();
                if (!options.tabId && !options.keep) {
                    web_extension_1.default.tabs.remove(tab.id);
                }
            } })));
    });
    return {
        destroy: () => {
            pIpc.then(ipc => ipc.destroy());
        },
        ask: (...args) => {
            return pIpc.then(ipc => ipc.ask(...args));
        },
        onAsk: (...args) => {
            pIpc.then(ipc => ipc.onAsk(...args));
        },
        getTab: () => {
            return pIpc.then(ipc => ipc.getTab());
        },
        getTabId: () => {
            return pIpc.then(ipc => ipc.getTabId());
        }
    };
};
exports.askPageWithTab = (options) => {
    const tabAPI = exports.openPageInTab({
        url: options.url,
        tabId: options.tabId,
        ipcTimeout: options.ipcTimeout,
        domReady: options.domReady
    });
    return tabAPI.ask(options.cmd, options.args)
        .then((data) => {
        setTimeout(() => tabAPI.destroy(), 0);
        return data;
    });
};
exports.askPageWithFixedTab = (() => {
    let curTabId = undefined;
    return (options) => {
        const tabAPI = exports.openPageInTab({
            url: options.url,
            tabId: options.tabId || curTabId,
            keep: true,
            ipcTimeout: options.ipcTimeout,
            domReady: options.domReady
        });
        return tabAPI.getTabId()
            .then((tabId) => {
            curTabId = tabId;
            return tabAPI.ask(options.cmd, options.args)
                .then((data) => {
                setTimeout(() => tabAPI.destroy(), 0);
                return data;
            });
        });
    };
})();


/***/ }),

/***/ 41010:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.renderLog = exports.renderLogType = void 0;
exports.renderLogType = (log) => {
    switch (log.type) {
        case 'reflect':
            return '[info]';
        case 'error':
            return (log.options && log.options.ignored) ? '[error][ignored]' : '[error]';
        default:
            return `[${log.type}]`;
    }
};
exports.renderLog = (log, withTimestamp = false) => {
    const prefix = withTimestamp ? (log.createTime.toISOString() + ' - ') : '';
    return prefix + exports.renderLogType(log) + ' ' + log.text;
};


/***/ }),

/***/ 29319:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = {
    proxy: {
        notControllable: 'The proxy settings are controlled by other app(s) or extension(s). Please disable or uninstall the apps or extensions in conflict'
    },
    contentHidden: 'Content is hidden during replay'
};


/***/ }),

/***/ 55290:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createListenerRegistry = exports.Registry = void 0;
class Registry {
    constructor({ process, onZero, onOne }) {
        this.cache = {};
        this.process = process;
        this.onZero = onZero || (() => { });
        this.onOne = onOne || (() => { });
    }
    add(id, obj) {
        this.cache[id] = this.cache[id] || [];
        this.cache[id].push(obj);
        if (this.cache[id].length === 1) {
            try {
                this.onOne(id);
            }
            catch (e) {
                // tslint:disable-next-line
                console.error('in onOne, ' + e.message);
            }
        }
        return true;
    }
    remove(id, obj) {
        if (!this.cache[id]) {
            return false;
        }
        this.cache[id] = this.cache[id].filter((item) => item !== obj);
        if (this.cache[id].length === 0) {
            try {
                this.onZero(id);
            }
            catch (e) {
                // tslint:disable-next-line
                console.error('in onZero, ' + e.message);
            }
        }
        return true;
    }
    removeAllWithData(obj) {
        Object.keys(this.cache).forEach((id) => {
            for (let i = this.cache[id].length - 1; i >= 0; i--) {
                if (this.cache[id][i] === obj) {
                    this.remove(id, this.cache[id][i]);
                }
            }
        });
    }
    fire(id, data) {
        if (!this.cache[id]) {
            return false;
        }
        this.cache[id].forEach((item) => {
            try {
                this.process(item, data, id);
            }
            catch (e) {
                // tslint:disable-next-line
                console.error('in process, ' + e.message);
            }
        });
        return true;
    }
    has(id) {
        return this.cache[id] && this.cache[id].length > 0;
    }
    keys() {
        return Object.keys(this.cache).filter((key) => this.cache[key] && this.cache[key].length > 0);
    }
    destroy() {
        Object.keys(this.cache).forEach((id) => {
            try {
                this.onZero(id);
            }
            catch (e) {
                // tslint:disable-next-line
                console.error('in onZero, ' + e.message);
            }
        });
        this.cache = {};
    }
}
exports.Registry = Registry;
function createListenerRegistry() {
    return new Registry({
        process: (fn, data, id) => {
            fn(data);
        }
    });
}
exports.createListenerRegistry = createListenerRegistry;


/***/ }),

/***/ 96836:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAllTabs = exports.getAllTabsInWindow = exports.getAllWindows = exports.updateUrlForTab = exports.getCurrentTab = exports.getTab = exports.activateTab = exports.createTab = void 0;
const ts_utils_1 = __webpack_require__(55452);
const web_extension_1 = __importDefault(__webpack_require__(61171));
exports.createTab = (url) => {
    return web_extension_1.default.tabs.create({ url, active: true });
};
exports.activateTab = (tabId, focusWindow = false) => {
    return web_extension_1.default.tabs.get(tabId)
        .then((tab) => {
        const p = focusWindow ? web_extension_1.default.windows.update(tab.windowId, { focused: true })
            : Promise.resolve();
        return p.then(() => web_extension_1.default.tabs.update(tab.id, { active: true }))
            .then(() => tab);
    });
};
exports.getTab = (tabId) => {
    return web_extension_1.default.tabs.get(tabId);
};
exports.getCurrentTab = (winId) => {
    const pWin = winId ? web_extension_1.default.windows.get(winId) : web_extension_1.default.windows.getLastFocused();
    return pWin.then((win) => {
        return web_extension_1.default.tabs.query({ active: true, windowId: win.id })
            .then((tabs) => tabs[0]);
    });
};
function updateUrlForTab(tabId, url) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const tab = typeof tabId === "number" ? (yield web_extension_1.default.tabs.get(tabId)) : tabId;
        const tabUrl = new URL(tab.url);
        const newUrl = new URL(url);
        const isSamePath = tabUrl.origin + tabUrl.pathname === newUrl.origin + tabUrl.pathname;
        // Browsers won't reload the page if the new url is only different in hash
        const noReload = isSamePath && !!((_a = newUrl.hash) === null || _a === void 0 ? void 0 : _a.length);
        if (noReload) {
            yield web_extension_1.default.tabs.update(tab.id, { url: "about:blank" });
            yield ts_utils_1.delay(() => { }, 100);
        }
        yield web_extension_1.default.tabs.update(tab.id, { url });
        return yield exports.getTab(tab.id);
    });
}
exports.updateUrlForTab = updateUrlForTab;
function getAllWindows() {
    return web_extension_1.default.windows.getAll();
}
exports.getAllWindows = getAllWindows;
function getAllTabsInWindow(windowId) {
    return web_extension_1.default.windows.get(windowId, { populate: true }).then((win) => { var _a; return (_a = win === null || win === void 0 ? void 0 : win.tabs) !== null && _a !== void 0 ? _a : []; });
}
exports.getAllTabsInWindow = getAllTabsInWindow;
function getAllTabs() {
    return __awaiter(this, void 0, void 0, function* () {
        const wins = yield getAllWindows();
        const list = yield Promise.all(wins.map((win) => getAllTabsInWindow(win.id)));
        return [].concat(...list);
    });
}
exports.getAllTabs = getAllTabs;


/***/ }),

/***/ 74199:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.showContextMenu = exports.ContextMenu = exports.ContextMenuDisplayStatus = exports.MenuItemType = void 0;
const react_1 = __importDefault(__webpack_require__(67294));
const react_dom_1 = __importDefault(__webpack_require__(73935));
const prop_types_1 = __importDefault(__webpack_require__(45697));
const antd_1 = __webpack_require__(56318);
const react_click_outside_1 = __importDefault(__webpack_require__(48683));
const ts_utils_1 = __webpack_require__(55452);
var MenuItemType;
(function (MenuItemType) {
    MenuItemType["Divider"] = "divider";
    MenuItemType["Button"] = "button";
})(MenuItemType = exports.MenuItemType || (exports.MenuItemType = {}));
var ContextMenuDisplayStatus;
(function (ContextMenuDisplayStatus) {
    ContextMenuDisplayStatus[ContextMenuDisplayStatus["Hidden"] = 0] = "Hidden";
    ContextMenuDisplayStatus[ContextMenuDisplayStatus["Transparent"] = 1] = "Transparent";
    ContextMenuDisplayStatus[ContextMenuDisplayStatus["Visible"] = 2] = "Visible";
})(ContextMenuDisplayStatus = exports.ContextMenuDisplayStatus || (exports.ContextMenuDisplayStatus = {}));
class ContextMenu extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.$container = null;
        this.state = {
            isCollectingSize: false,
            status: ContextMenuDisplayStatus.Transparent,
            size: {
                width: 0,
                height: 0
            }
        };
        this.hide = () => {
            this.props.onHide();
        };
        this.onClick = (e) => {
            const found = this.findMenuItem(e.key);
            if (!found) {
                return;
            }
            switch (found.type) {
                case MenuItemType.Button: {
                    const { context, onClick } = found.data;
                    try {
                        onClick(e.domEvent, context);
                    }
                    catch (e) {
                        console.warn(e);
                    }
                    finally {
                        this.hide();
                    }
                    break;
                }
                case MenuItemType.Divider:
                default:
                    break;
            }
        };
    }
    findMenuItem(menuItemId) {
        return this.props.menuItems.find((item, i) => this.getId(item, i) === menuItemId);
    }
    getId(menuItem, index) {
        return menuItem.id + '_' + index;
    }
    getContextMenuStyle() {
        const { status } = this.state;
        const common = {
            position: 'fixed'
        };
        const byStatus = (() => {
            switch (status) {
                case ContextMenuDisplayStatus.Hidden:
                    return {
                        display: 'none'
                    };
                case ContextMenuDisplayStatus.Transparent: {
                    return {
                        top: 0,
                        left: 0,
                        visibility: 'hidden'
                    };
                }
                case ContextMenuDisplayStatus.Visible: {
                    const leftTopPoint = ts_utils_1.pointToFitRect({
                        bound: {
                            x: 0,
                            y: 0,
                            width: window.innerWidth,
                            height: window.innerHeight
                        },
                        size: this.state.size,
                        point: {
                            x: this.props.x,
                            y: this.props.y
                        }
                    });
                    return {
                        top: leftTopPoint.y + 'px',
                        left: leftTopPoint.x + 'px',
                    };
                }
            }
        })();
        return Object.assign(Object.assign({}, common), byStatus);
    }
    collectSize() {
        this.setState({
            isCollectingSize: true
        });
        setTimeout(() => {
            if (!this.$container) {
                return;
            }
            this.setState({
                isCollectingSize: false,
                status: ContextMenuDisplayStatus.Visible,
                size: {
                    width: this.$container.offsetWidth,
                    height: this.$container.offsetHeight
                }
            });
        }, 100);
    }
    componentDidMount() {
        if (!this.state.isCollectingSize && this.state.status === ContextMenuDisplayStatus.Transparent) {
            this.collectSize();
        }
    }
    render() {
        return (react_1.default.createElement("div", { ref: (ref) => { this.$container = ref; }, style: this.getContextMenuStyle(), className: "context-menu" },
            react_1.default.createElement(react_click_outside_1.default, { onClickOutside: this.hide },
                react_1.default.createElement(antd_1.Menu, { onClick: this.onClick, style: { width: this.props.width + 'px' }, mode: "vertical", selectable: false }, this.props.menuItems.map((item, i) => {
                    switch (item.type) {
                        case MenuItemType.Divider:
                            return react_1.default.createElement(antd_1.Menu.Divider, { key: this.getId(item, i) });
                        case MenuItemType.Button:
                            return (react_1.default.createElement(antd_1.Menu.Item, { key: this.getId(item, i), disabled: !!item.disabled }, item.data.content));
                        default:
                            return null;
                    }
                })))));
    }
}
exports.ContextMenu = ContextMenu;
ContextMenu.propTypes = {
    menuItems: prop_types_1.default.array.isRequired,
    onHide: prop_types_1.default.func.isRequired,
    width: prop_types_1.default.number
};
ContextMenu.defaultProps = {
    width: 230
};
function getContainer() {
    const id = '__kantu_context_menus__';
    const $el = document.getElementById(id);
    if ($el)
        return $el;
    const $new = document.createElement('div');
    $new.id = id;
    document.body.appendChild($new);
    return $new;
}
function showContextMenu(props) {
    const $box = document.createElement('div');
    getContainer().appendChild($box);
    // Delay 20ms is for firefox
    setTimeout(() => {
        react_dom_1.default.render(react_1.default.createElement(ContextMenu, Object.assign({}, props, { onHide: () => {
                setTimeout(() => {
                    $box.remove();
                });
                props.onHide();
            } })), $box);
    }, 20);
}
exports.showContextMenu = showContextMenu;


/***/ }),

/***/ 37744:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const react_1 = __importDefault(__webpack_require__(67294));
const antd_1 = __webpack_require__(56318);
const prop_types_1 = __importDefault(__webpack_require__(45697));
class EditInPlace extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.state = {
            isEditing: false,
            value: ''
        };
        this.edit = () => {
            this.setState({ isEditing: true });
            setTimeout(() => {
                const $input = this.$input && this.$input.refs && this.$input.refs.input;
                if ($input) {
                    $input.focus();
                    const selection = this.props.getSelection(this.state.value, $input);
                    $input.selectionStart = selection ? selection.start : 0;
                    $input.selectionEnd = selection ? selection.end : $input.value.length;
                }
            }, 100);
        };
        this.submit = () => {
            this.props.checkValue(this.state.value)
                .then(pass => {
                if (pass) {
                    this.setState({ isEditing: false });
                    this.props.onChange(this.state.value)
                        .catch(e => this.setState({ value: this.props.value }));
                }
            });
        };
        this.reset = () => {
            this.setState({
                isEditing: false,
                value: this.props.value
            });
        };
    }
    componentDidMount() {
        this.setState({
            value: this.props.value
        });
    }
    componentWillReceiveProps(nextProps) {
        if (nextProps.value !== this.props.value) {
            this.setState({ value: nextProps.value });
        }
    }
    render() {
        if (!this.state.isEditing) {
            return (react_1.default.createElement("span", null,
                this.props.value,
                react_1.default.createElement(antd_1.Icon, { type: "edit", style: { marginLeft: '10px', cursor: 'pointer' }, onClick: this.edit })));
        }
        else {
            return (react_1.default.createElement(antd_1.Input, { defaultValue: "", autosize: true, ref: ref => { this.$input = ref; }, value: this.state.value, onChange: e => this.setState({ value: e.target.value }), onBlur: this.reset, onKeyDown: (e) => {
                    if (e.keyCode === 13)
                        return this.submit();
                    if (e.keyCode === 27)
                        return this.reset();
                } }));
        }
    }
}
exports["default"] = EditInPlace;
EditInPlace.propTypes = {
    value: prop_types_1.default.string.isRequired,
    onChange: prop_types_1.default.func.isRequired,
    checkValue: prop_types_1.default.func.isRequired,
    getSelection: prop_types_1.default.func
};
EditInPlace.defaultProps = {
    getSelection: () => null
};


/***/ }),

/***/ 15372:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazyImage = exports.getIntersectionObserverManager = exports.IntersectionObserverManager = void 0;
const react_1 = __importDefault(__webpack_require__(67294));
const ts_utils_1 = __webpack_require__(55452);
const log_1 = __importDefault(__webpack_require__(77242));
class IntersectionObserverManager {
    constructor(params) {
        this.targets = [];
        log_1.default('Create observer', params);
        this.observer = new IntersectionObserver(this.handleObserve.bind(this), params);
    }
    observe(el, run) {
        this.targets.push({ el, run, done: false });
        this.observer.observe(el);
    }
    remove(el) {
        const index = this.targets.findIndex(target => target.el === el);
        if (index !== -1) {
            this.targets.splice(index, 1);
        }
    }
    handleObserve(entries) {
        entries.forEach(entry => {
            if (entry.intersectionRatio <= 0) {
                return;
            }
            const el = entry.target;
            const index = this.targets.findIndex(target => target.el === el);
            if (index === -1 || this.targets[index].done) {
                return;
            }
            this.targets[index].run();
            this.targets[index].done = true;
        });
    }
}
exports.IntersectionObserverManager = IntersectionObserverManager;
exports.getIntersectionObserverManager = ts_utils_1.singletonGetterByKey((key) => key, (key, params) => {
    return new IntersectionObserverManager(params);
});
class LazyImage extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.el = null;
        this.manager = null;
        this.state = {
            url: '',
            isLoading: false
        };
    }
    componentWillMount() {
        this.manager = exports.getIntersectionObserverManager(this.props.type, {
            root: this.props.root,
            rootMargin: '20px',
            threshold: 0.01
        });
    }
    componentWillUnmount() {
        if (this.el && this.manager) {
            this.manager.remove(this.el);
        }
    }
    startObserve(el) {
        if (!this.manager) {
            return;
        }
        this.manager.observe(el, () => {
            this.getUrl();
        });
    }
    getSizeString(size) {
        if (typeof size === 'number') {
            return size + 'px';
        }
        return size;
    }
    getImageStyle() {
        return Object.assign(Object.assign(Object.assign({}, (!this.props.width ? {} : { width: this.getSizeString(this.props.width) })), (!this.props.height ? {} : { height: this.getSizeString(this.props.height) })), { backgroundImage: `url(${this.state.url})`, backgroundSize: 'contain', backgroundRepeat: 'no-repeat', backgroundPosition: 'center center' });
    }
    getUrl() {
        this.setState({ isLoading: true });
        return this.props.getUrl()
            .then((realUrl) => {
            this.setState({
                url: realUrl,
                isLoading: false
            });
        });
    }
    render() {
        return (react_1.default.createElement("div", { className: "lazy-image", style: this.getImageStyle(), ref: (el) => {
                this.el = el;
                if (el) {
                    this.startObserve(el);
                }
            } }));
    }
}
exports.LazyImage = LazyImage;


/***/ }),

/***/ 79197:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prompt = exports.Prompt = void 0;
const react_1 = __importDefault(__webpack_require__(67294));
const react_dom_1 = __importDefault(__webpack_require__(73935));
const prop_types_1 = __importDefault(__webpack_require__(45697));
const antd_1 = __webpack_require__(56318);
class Prompt extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.state = {
            value: '',
            visible: true
        };
        this.onOk = () => {
            return this.props.onOk(this.state.value)
                .then(() => this.hide());
        };
        this.onCancel = () => {
            return this.props.onCancel()
                .then(() => this.hide());
        };
    }
    componentDidMount() {
        this.setState({ value: this.props.value });
        setTimeout(() => this.focus(), 100);
    }
    componentWillReceiveProps(newProps) {
        if (newProps.value !== this.props.value) {
            this.setState({ value: newProps.value });
            setTimeout(() => this.focus(), 100);
        }
    }
    focus() {
        const input = this.input;
        if (input && input.refs && input.refs.input) {
            const $input = input.refs.input;
            $input.focus();
            if (this.props.inputType === 'text') {
                $input.selectionStart = this.props.selectionStart !== undefined ? this.props.selectionStart : 0;
                $input.selectionEnd = this.props.selectionEnd !== undefined ? this.props.selectionEnd : $input.value.length;
            }
        }
    }
    hide() {
        this.setState({ visible: false });
    }
    render() {
        return (react_1.default.createElement(antd_1.Modal, { ref: ref => { this.modal = ref; }, visible: this.state.visible, align: 'left', title: this.props.title, width: this.props.width, closable: this.props.closable, maskClosable: this.props.closable, okText: this.props.okText, cancelText: this.props.cancelText, onOk: this.onOk, onCancel: this.onCancel },
            this.props.message && this.props.message.length ? (react_1.default.createElement("pre", { style: {
                    fontFamily: 'inherit',
                    marginBottom: '10px',
                    whiteSpace: 'pre-wrap'
                } }, this.props.message)) : null,
            this.props.noInput ? null : (react_1.default.createElement(antd_1.Input, { defaultValue: "", ref: ref => this.input = ref, type: this.props.inputType, autosize: false, placeholder: this.props.placeholder, value: this.state.value, onChange: e => this.setState({ value: e.target.value }), onKeyDown: e => {
                    if (e.keyCode === 13)
                        this.onOk();
                } }))));
    }
}
exports.Prompt = Prompt;
Prompt.propTypes = {
    onOk: prop_types_1.default.func.isRequired,
    onCancel: prop_types_1.default.func.isRequired,
    title: prop_types_1.default.string,
    width: prop_types_1.default.number,
    message: prop_types_1.default.string,
    value: prop_types_1.default.string,
    noInput: prop_types_1.default.bool,
    inputType: prop_types_1.default.string,
    selectionStart: prop_types_1.default.number,
    selectionEnd: prop_types_1.default.number,
    placeholder: prop_types_1.default.string,
    okText: prop_types_1.default.string,
    cancelText: prop_types_1.default.string,
    keepOpenOnError: prop_types_1.default.bool
};
Prompt.defaultProps = {
    width: 350,
    title: 'Please input',
    message: '',
    value: '',
    placeholder: '',
    selectionStart: 0,
    selectionEnd: 0,
    noInput: false,
    closable: true,
    inputType: 'text',
    okText: 'Confirm',
    cancelText: 'Cancel',
    keepOpenOnError: false
};
function prompt(props) {
    return new Promise((resolve, reject) => {
        const wrappedProps = Object.assign(Object.assign({}, props), { onOk: (str) => {
                const go = () => {
                    resolve(str);
                    destroy();
                    return Promise.resolve(true);
                };
                return new Promise(resolve => {
                    resolve(props.onOk ? props.onOk(str) : true);
                })
                    .then(go, (e) => {
                    if (props.keepOpenOnError) {
                        return Promise.reject(e);
                    }
                    reject(e);
                    return true;
                });
            }, onCancel: () => {
                const go = () => {
                    resolve(null);
                    destroy();
                    return Promise.resolve(true);
                };
                return new Promise(resolve => {
                    resolve(props.onCancel ? props.onCancel() : true);
                })
                    .then(go, (e) => {
                    if (props.keepOpenOnError) {
                        return Promise.reject(e);
                    }
                    reject(e);
                    return true;
                });
            } });
        const $root = document.createElement('div');
        const $el = document.createElement('div');
        const destroy = () => setTimeout(() => {
            $root.remove();
        }, 1000);
        document.body.appendChild($root);
        $root.appendChild($el);
        react_dom_1.default.render(react_1.default.createElement(Prompt, Object.assign({}, wrappedProps)), $el);
    });
}
exports.prompt = prompt;


/***/ }),

/***/ 67504:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectInput = void 0;
const react_1 = __importDefault(__webpack_require__(67294));
const react_dom_1 = __importDefault(__webpack_require__(73935));
const antd_1 = __webpack_require__(56318);
const uuid_1 = __webpack_require__(48422);
const ts_utils_1 = __webpack_require__(55452);
__webpack_require__(11264);
const utils_1 = __webpack_require__(63370);
class SelectInput extends react_1.default.Component {
    constructor(props) {
        super(props);
        this.state = {
            text: '',
            shouldShowOptions: false
        };
        this.getDropDownElementId = ts_utils_1.singletonGetter(() => 'dropdown_' + uuid_1.v1());
        this.onFocus = () => {
            if (this.props.disabled) {
                return;
            }
            this.setState({
                shouldShowOptions: true
            });
        };
        this.onBlur = () => {
            setTimeout(() => {
                this.setState({
                    shouldShowOptions: false
                });
            }, 100);
        };
        this.onToggle = () => {
            if (this.props.disabled) {
                return;
            }
            if (this.state.shouldShowOptions) {
                this.onBlur();
            }
            else {
                this.onFocus();
                this.focusOnTextInput();
            }
        };
        this.onKeyDown = (e) => {
            switch (e.keyCode) {
                case 13:
                case 27:
                    this.setState({ shouldShowOptions: false });
                    break;
            }
        };
        this.onTextChange = (e) => {
            const text = e.target.value;
            this.setState({
                text,
                shouldShowOptions: true
            });
            this.props.onChange(text);
        };
        this.onItemClick = (e, item, index) => {
            var _a;
            const text = (_a = this.props.stringifyOption(item)) !== null && _a !== void 0 ? _a : this.props.getId(item, index);
            this.setState({
                text,
                shouldShowOptions: false
            });
            this.focusOnTextInput();
            this.props.onChange(text);
        };
        this.container = react_1.default.createRef();
        this.input = react_1.default.createRef();
    }
    componentDidMount() {
        if (this.props.value) {
            this.setState({
                text: this.props.value
            });
        }
    }
    componentDidUpdate(prevProps) {
        var _a;
        if (this.props.value !== prevProps.value) {
            this.setState({
                text: (_a = this.props.value) !== null && _a !== void 0 ? _a : ''
            });
        }
    }
    focusOnTextInput() {
        if (!this.input.current) {
            return;
        }
        const $input = this.input.current.refs.input;
        $input.focus();
    }
    getDropDownContainer() {
        const id = 'drop_down_container';
        const existing = document.getElementById(id);
        if (existing) {
            return existing;
        }
        const el = document.createElement('div');
        el.id = id;
        document.body.appendChild(el);
        return el;
    }
    getDropDownMountPoint() {
        const id = this.getDropDownElementId();
        const existing = document.getElementById(id);
        if (existing) {
            return existing;
        }
        const el = document.createElement('div');
        el.id = id;
        el.className = "drop-down";
        this.getDropDownContainer().appendChild(el);
        return el;
    }
    renderOneOption(item, index, selected) {
        var _a;
        const { getId, stringifyOption } = this.props;
        const OptionItem = this.props.OptionItem;
        const id = getId(item, index);
        if (OptionItem) {
            return react_1.default.createElement(OptionItem, { value: item, key: id });
        }
        const text = (_a = stringifyOption === null || stringifyOption === void 0 ? void 0 : stringifyOption(item)) !== null && _a !== void 0 ? _a : id;
        return (react_1.default.createElement(PlainTextOption, { key: id, item: item, index: index, text: text, selected: selected, onItemClick: this.onItemClick }));
    }
    renderOptions() {
        if (!this.state.shouldShowOptions) {
            return null;
        }
        const el = this.container.current;
        if (!el) {
            return null;
        }
        const rect = el.getBoundingClientRect();
        const margin = 3;
        const style = {
            position: 'absolute',
            left: rect.left,
            top: rect.top + rect.height + margin
        };
        if (!this.props.dropdownAutoWidth) {
            style.width = rect.width;
        }
        const node = (react_1.default.createElement("div", { className: "option-list", style: style }, this.props.options.map((item, i) => {
            return this.renderOneOption(item, i, this.state.text === this.props.stringifyOption(item));
        })));
        return react_dom_1.default.createPortal(node, this.getDropDownMountPoint());
    }
    render() {
        return (react_1.default.createElement("div", { className: utils_1.cn('select-input', { opened: this.state.shouldShowOptions }), ref: this.container },
            react_1.default.createElement(antd_1.Input, { ref: this.input, disabled: this.props.disabled, placeholder: this.props.placeholder, value: this.state.text, onFocus: this.onFocus, onBlur: this.onBlur, onClick: this.onFocus, onChange: this.onTextChange, onKeyDown: this.onKeyDown }),
            react_1.default.createElement("span", { className: "arrow-icon ant-select-arrow", onClick: this.onToggle }),
            this.renderOptions()));
    }
}
exports.SelectInput = SelectInput;
SelectInput.defaultProps = {
    disabled: false,
    dropdownAutoWidth: false
};
class PlainTextOption extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.onClick = (e) => {
            this.props.onItemClick(e, this.props.item, this.props.index);
        };
    }
    render() {
        return (react_1.default.createElement("div", { className: utils_1.cn('plain-text-option', { selected: this.props.selected }), onMouseDown: this.onClick }, this.props.text));
    }
}


/***/ }),

/***/ 8107:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeNode = void 0;
const react_1 = __importDefault(__webpack_require__(67294));
const prop_types_1 = __importDefault(__webpack_require__(45697));
const utils_1 = __webpack_require__(63370);
const ts_utils_1 = __webpack_require__(55452);
const tree_file_1 = __webpack_require__(58335);
class TreeNode extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.state = {};
        this.onClick = (e) => {
            const { data, onClick, paths, foldOnClickTitle } = this.props;
            if (onClick) {
                onClick(data, paths, e);
            }
            if (foldOnClickTitle && data.type === tree_file_1.FileNodeType.Folder) {
                this.onToggle(e);
            }
        };
        this.onDoubleClick = (e) => {
            const { data, onDoubleClick, paths } = this.props;
            if (onDoubleClick) {
                onDoubleClick(data, paths, e);
            }
        };
        this.onContextMenu = (e) => {
            const { data, onContextMenu, paths } = this.props;
            if (onContextMenu) {
                onContextMenu(data, paths, e);
            }
        };
        this.onToggle = (e) => {
            e.stopPropagation();
            const { data, onToggle, paths } = this.props;
            if (onToggle) {
                onToggle(data, paths, e);
            }
        };
    }
    render() {
        const { decorate = (x) => x } = this.props;
        return decorate(react_1.default.createElement("div", { id: ts_utils_1.normalizeHtmlId(this.props.data.id), className: utils_1.cn('tree-node', this.props.commonClass, this.props.data.className) },
            react_1.default.createElement("div", { className: "tree-node-content", onClick: this.onClick, onDoubleClick: this.onDoubleClick, onContextMenu: this.onContextMenu },
                react_1.default.createElement("div", { className: "tree-node-icon-wrapper", onClick: this.onToggle }, this.renderIcon()),
                react_1.default.createElement("div", { className: "tree-node-item-wrapper" }, this.renderItem()),
                this.renderItemExtra()),
            react_1.default.createElement("div", { className: "tree-node-children" }, this.renderSubnodes())));
    }
    renderIcon() {
        const { renderIcon, data, paths } = this.props;
        if (typeof renderIcon === 'function') {
            return renderIcon(data, paths);
        }
        else {
            return this.defaultRenderIcon(data);
        }
    }
    renderItem() {
        const { renderItem, data, paths } = this.props;
        if (typeof renderItem === 'function') {
            return renderItem(data, paths);
        }
        else {
            return this.defaultRenderItem(data);
        }
    }
    renderItemExtra() {
        const { renderItemExtra, data, paths } = this.props;
        if (typeof renderItemExtra === 'function') {
            return renderItemExtra(data, paths);
        }
        else {
            return null;
        }
    }
    defaultRenderIcon(data) {
        return (react_1.default.createElement("div", { className: utils_1.cn('node-icon') }, !data.folded ? 'O' : 'C'));
    }
    defaultRenderItem(data) {
        return data.text || `node at level ${data.level}`;
    }
    renderSubnodes() {
        const { data, paths, subnodeComponent = () => TreeNode } = this.props;
        const props = ts_utils_1.without(['data', 'paths'], this.props);
        if (data.type !== tree_file_1.FileNodeType.Folder || data.folded) {
            return null;
        }
        return (data.children || []).map((subnode, i) => {
            const SubNode = subnodeComponent(subnode, [...paths, i]);
            return (react_1.default.createElement(SubNode, Object.assign({ key: i }, props, { data: subnode, paths: [...paths, i] })));
        });
    }
}
exports.TreeNode = TreeNode;
TreeNode.propTypes = {
    data: prop_types_1.default.object.isRequired,
    renderItem: prop_types_1.default.func.isRequired,
    renderIcon: prop_types_1.default.func.isRequired,
    renderItemExtra: prop_types_1.default.func,
    decorate: prop_types_1.default.func,
    onClick: prop_types_1.default.func.isRequired,
    onDoubleClick: prop_types_1.default.func.isRequired,
    onContextMenu: prop_types_1.default.func.isRequired,
    onToggle: prop_types_1.default.func.isRequired,
    className: prop_types_1.default.string
};


/***/ }),

/***/ 58335:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileTree = exports.InternalFileTree = exports.FileNodeType = void 0;
const react_1 = __importDefault(__webpack_require__(67294));
const prop_types_1 = __importDefault(__webpack_require__(45697));
const react_dnd_1 = __webpack_require__(84785);
const antd_1 = __webpack_require__(56318);
const utils_1 = __webpack_require__(63370);
const tree_1 = __webpack_require__(8107);
const ts_utils_1 = __webpack_require__(55452);
const path_1 = __webpack_require__(84037);
__webpack_require__(83518);
var FileNodeType;
(function (FileNodeType) {
    FileNodeType["File"] = "file";
    FileNodeType["Folder"] = "folder";
})(FileNodeType = exports.FileNodeType || (exports.FileNodeType = {}));
class InternalFileTree extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.onToggle = (data, paths) => {
            if (data.type !== FileNodeType.Folder) {
                return;
            }
            this.props.onToggle(data, paths);
        };
        this.subnodeComponent = (() => {
            const { DndFileNode, DndFolderNode } = dndComponentsFactory({
                move: (sourceId, targetId, isDirectory) => {
                    this.props.onMove(sourceId, targetId, isDirectory);
                }
            });
            return (data, paths) => {
                switch (data.type) {
                    case FileNodeType.File:
                        return DndFileNode;
                    case FileNodeType.Folder:
                        return DndFolderNode;
                }
            };
        })();
        this.renderFileIcon = (data) => {
            switch (data.type) {
                case FileNodeType.File:
                    return (react_1.default.createElement("img", { src: "./img/code.svg", className: "file-node-icon file-icon" }));
                case FileNodeType.Folder:
                    if (!data.folded) {
                        return (react_1.default.createElement("img", { src: "./img/folder_expanded.svg", className: "file-node-icon folder-icon expanded" }));
                    }
                    else {
                        return (react_1.default.createElement("img", { src: "./img/folder.svg", className: "file-node-icon folder-icon" }));
                    }
            }
        };
        this.renderFileItem = (data, paths) => {
            return (react_1.default.createElement("div", { className: "file-node-title" },
                react_1.default.createElement("span", null, data.name)));
        };
        this.renderFileItemExtra = (data, paths) => {
            return (react_1.default.createElement(antd_1.Icon, { type: "bars", className: "more-button", onClick: (e) => this.props.onContextMenu(data, paths, e) }));
        };
    }
    shouldComponentUpdate(nextProps) {
        return !ts_utils_1.isForestEqual((a, b) => {
            const result = a.entryPath === b.entryPath &&
                a.folded === b.folded &&
                a.type === b.type &&
                a.className === b.className;
            return result;
        }, this.props.nodes, nextProps.nodes);
    }
    render() {
        const { nodes } = this.props;
        const { connectDropTarget, highlighted } = this.props;
        return connectDropTarget(react_1.default.createElement("div", { className: utils_1.cn('file-root', { 'drag-over': highlighted }) }, nodes.map((data, i) => {
            const Node = this.subnodeComponent(data, [i]);
            return (react_1.default.createElement(Node, { key: data.id, data: data, paths: [i], commonClass: "file-node", renderIcon: this.renderFileIcon, renderItem: this.renderFileItem, renderItemExtra: this.renderFileItemExtra, subnodeComponent: this.subnodeComponent, onClick: this.props.onClick, onDoubleClick: this.props.onDoubleClick, onContextMenu: this.props.onContextMenu, onToggle: this.onToggle, foldOnClickTitle: true }));
        })));
    }
}
exports.InternalFileTree = InternalFileTree;
InternalFileTree.propTypes = {
    nodes: prop_types_1.default.array.isRequired,
    onMove: prop_types_1.default.func.isRequired,
    onClick: prop_types_1.default.func.isRequired,
    onDoubleClick: prop_types_1.default.func.isRequired,
    onContextMenu: prop_types_1.default.func.isRequired
};
exports.FileTree = react_dnd_1.DropTarget([FileNodeType.Folder, FileNodeType.File], {
    drop(props, monitor, component) {
        const folderId = props.rootPath;
        const srcItem = monitor.getItem();
        props.onMove(srcItem.id, folderId, srcItem.isDirectory);
    },
    canDrop(props, monitor) {
        const folderId = props.rootPath;
        const { id: entryId } = monitor.getItem();
        if (folderId === entryId) {
            return false;
        }
        if (folderId === path_1.posix.dirname(entryId)) {
            return false;
        }
        return monitor.isOver({ shallow: true });
    }
}, (connect, monitor) => ({
    connectDropTarget: connect.dropTarget(),
    highlighted: monitor.isOver({ shallow: true }) && monitor.canDrop()
}))(InternalFileTree);
function dndComponentsFactory(opts) {
    const applyDragSource = (itemType) => (comp) => {
        return react_dnd_1.DragSource(itemType, {
            beginDrag: (props) => {
                const result = ({
                    id: props.data.id,
                    isDirectory: props.data.type === FileNodeType.Folder
                });
                return result;
            },
        }, (connect, monitor) => ({
            connectDragSource: connect.dragSource(),
            isDragging: monitor.isDragging()
        }))(comp);
    };
    const applyDropTarget = (itemType) => (comp) => {
        return react_dnd_1.DropTarget(itemType, {
            drop(props, monitor, component) {
                const folderId = props.data.id;
                const srcItem = monitor.getItem();
                opts.move(srcItem.id, folderId, srcItem.isDirectory);
            },
            canDrop(props, monitor) {
                const folderId = props.data.id;
                const { id: entryId } = monitor.getItem();
                if (folderId === entryId) {
                    return false;
                }
                if (folderId === path_1.posix.dirname(entryId)) {
                    return false;
                }
                return monitor.isOver({ shallow: true });
            }
        }, (connect, monitor) => ({
            connectDropTarget: connect.dropTarget(),
            highlighted: monitor.isOver({ shallow: true }) && monitor.canDrop()
        }))(comp);
    };
    const DndFileNode = applyDragSource(FileNodeType.File)(function InternalFileNode(props) {
        return (react_1.default.createElement(tree_1.TreeNode, Object.assign({}, props, { decorate: ts_utils_1.compose(props.connectDragSource, track) })));
    });
    const DndFolderNode = ts_utils_1.compose(applyDragSource(FileNodeType.Folder), applyDropTarget([FileNodeType.Folder, FileNodeType.File]))(function InternalFolderNode(props) {
        return (react_1.default.createElement(tree_1.TreeNode, Object.assign({}, props, { decorate: ts_utils_1.compose(props.connectDragSource, props.connectDropTarget, track), data: ts_utils_1.safeUpdateIn(['className'], (oldClassName = '') => utils_1.cn(oldClassName, { 'drag-over': props.highlighted }), props.data) })));
    });
    const track = (x) => {
        return x;
    };
    return { DndFolderNode, DndFileNode };
}


/***/ }),

/***/ 29102:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResourceNotLoaded = void 0;
const react_1 = __importDefault(__webpack_require__(67294));
const antd_1 = __webpack_require__(56318);
const state_1 = __webpack_require__(16112);
function ResourceNotLoaded(props) {
    return (react_1.default.createElement("div", { className: "list-not-loaded" },
        react_1.default.createElement("p", null,
            "Started by ",
            state_1.stringForRunBy(props.from),
            "."),
        react_1.default.createElement("p", null,
            props.name,
            " not loaded."),
        react_1.default.createElement(antd_1.Button, { type: "primary", onClick: props.showList }, "Load now")));
}
exports.ResourceNotLoaded = ResourceNotLoaded;


/***/ }),

/***/ 96812:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CsvList = void 0;
const react_1 = __importDefault(__webpack_require__(67294));
const antd_1 = __webpack_require__(56318);
const storage_1 = __webpack_require__(92687);
class CsvList extends react_1.default.PureComponent {
    render() {
        const columns = [
            {
                title: 'Name',
                dataIndex: 'name',
                key: 'name'
            },
            {
                title: 'Size',
                dataIndex: 'size',
                key: 'size',
                render: (d) => {
                    return storage_1.readableSize(d);
                }
            },
            {
                title: 'Last Modified',
                dataIndex: 'createTime',
                key: 'createTime',
                render: (d) => {
                    const pad = (n) => n >= 10 ? ('' + n) : ('0' + n);
                    return `${d.getFullYear()}/${pad(d.getMonth() + 1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
                }
            },
            {
                title: 'Action',
                key: 'ops',
                width: 100,
                render: (text, csv, index) => {
                    return (react_1.default.createElement("div", null,
                        react_1.default.createElement(antd_1.Button, { size: "small", shape: "circle", onClick: (ev) => {
                                this.props.viewCSV(csv);
                            } },
                            react_1.default.createElement(antd_1.Icon, { type: "eye-o" })),
                        react_1.default.createElement(antd_1.Button, { size: "small", type: "primary", shape: "circle", onClick: () => {
                                this.props.downloadCSV(csv);
                            } },
                            react_1.default.createElement(antd_1.Icon, { type: "download" })),
                        react_1.default.createElement(antd_1.Popconfirm, { title: "Sure to delete?", okText: "Delete", onConfirm: () => { this.props.removeCSV(csv); } },
                            react_1.default.createElement(antd_1.Button, { size: "small", type: "danger", shape: "circle" },
                                react_1.default.createElement(antd_1.Icon, { type: "close" })))));
                }
            }
        ];
        const tableConfig = {
            columns,
            dataSource: this.props.list,
            pagination: false,
            bordered: true,
            size: 'middle',
            rowKey: 'fullPath',
            onRowClick: () => {
                // Do nothing
            },
            rowClassName: () => {
                return '';
            }
        };
        return react_1.default.createElement(antd_1.Table, Object.assign({}, tableConfig));
    }
}
exports.CsvList = CsvList;


/***/ }),

/***/ 77596:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScreenshotList = void 0;
const react_1 = __importDefault(__webpack_require__(67294));
const lazy_image_1 = __webpack_require__(15372);
const storage_1 = __webpack_require__(16058);
class ScreenshotList extends react_1.default.PureComponent {
    render() {
        return (react_1.default.createElement("ul", { className: "screenshot-content" }, this.props.screenshots.map((ss, i) => (react_1.default.createElement("li", { key: ss.createTime + '_' + ss.createTime },
            react_1.default.createElement("span", { className: "timestamp" },
                ss.createTime && ss.createTime.toLocaleString(),
                " - ",
                react_1.default.createElement("span", { className: "filename" }, decodeURIComponent(ss.name))),
            react_1.default.createElement("a", { href: "#", onClick: e => {
                    e.preventDefault();
                    this.props.downloadScreenshot(ss.name, ss.fullPath);
                } },
                react_1.default.createElement(lazy_image_1.LazyImage, { type: 'screenshot', root: this.props.intersectRoot, width: 200, height: 200, defaultUrl: "", getUrl: () => {
                        return storage_1.getStorageManager().getScreenshotStorage().getLink(ss.fullPath);
                    } })))))));
    }
}
exports.ScreenshotList = ScreenshotList;


/***/ }),

/***/ 9543:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VisionList = void 0;
const react_1 = __importDefault(__webpack_require__(67294));
const antd_1 = __webpack_require__(56318);
const lazy_image_1 = __webpack_require__(15372);
const edit_in_place_1 = __importDefault(__webpack_require__(37744));
const storage_1 = __webpack_require__(16058);
class VisionList extends react_1.default.PureComponent {
    render() {
        if (!this.props.intersectRoot) {
            return null;
        }
        const columns = [
            {
                title: 'Image',
                dataIndex: 'fullPath',
                key: 'fullPath',
                width: 116,
                render: (fullPath) => {
                    return (react_1.default.createElement(lazy_image_1.LazyImage, { type: 'vision', root: this.props.intersectRoot, width: 100, height: 100, defaultUrl: "", getUrl: () => {
                            return storage_1.getStorageManager().getVisionStorage().getLink(fullPath);
                        } }));
                }
            },
            {
                title: 'Name',
                dataIndex: 'name',
                key: 'name',
                render: (name, vision) => {
                    return (react_1.default.createElement("div", { className: "vision-name-1", id: name },
                        react_1.default.createElement(edit_in_place_1.default, { value: vision.name, onChange: (name) => {
                                return Promise.resolve(this.props.renameVision(vision.name, name));
                            }, checkValue: (name) => {
                                return this.props.isNameValid(name);
                            }, getSelection: (name, $input) => {
                                const reg = /(?:_dpi_\d+)?\.png$/i;
                                const result = reg.exec(name);
                                if (!result) {
                                    return null;
                                }
                                const endIndex = result.index;
                                return {
                                    start: 0,
                                    end: endIndex
                                };
                            } })));
                }
            },
            {
                title: 'Action',
                key: 'ops',
                width: 100,
                render: (text, vision, index) => {
                    return (react_1.default.createElement("div", { className: "vision-actions" },
                        react_1.default.createElement(antd_1.Button, { size: "small", shape: "circle", onClick: (ev) => {
                                this.props.viewVision(vision.name);
                            } },
                            react_1.default.createElement(antd_1.Icon, { type: "eye-o" })),
                        react_1.default.createElement(antd_1.Dropdown, { overlay: react_1.default.createElement(antd_1.Menu, { onClick: ({ key }) => {
                                    switch (key) {
                                        case 'duplicate':
                                            return this.props.duplicateVision(vision.name);
                                        case 'name_to_target':
                                            return this.props.copyNameToTarget(vision.name);
                                        case 'delete':
                                            return this.props.deleteVision(vision.name);
                                    }
                                } },
                                react_1.default.createElement(antd_1.Menu.Item, { key: "duplicate" }, "Duplicate"),
                                react_1.default.createElement(antd_1.Menu.Item, { key: "name_to_target" }, "Add name to target box"),
                                react_1.default.createElement(antd_1.Menu.Divider, null),
                                react_1.default.createElement(antd_1.Menu.Item, { key: "delete" }, "Delete")) },
                            react_1.default.createElement(antd_1.Button, { size: "small", shape: "circle" },
                                react_1.default.createElement(antd_1.Icon, { type: "bars" })))));
                }
            }
        ];
        const search = (this.props.query || '').toLowerCase().trim();
        const matchedVisions = this.props.visions.filter(vision => {
            if (search.length === 0)
                return true;
            return vision.name.toLowerCase().indexOf(search) !== -1;
        });
        const tableConfig = {
            columns,
            dataSource: matchedVisions,
            pagination: false,
            bordered: true,
            size: 'middle',
            rowKey: (record) => {
                return record.fullPath + '__' + record.createTime.getTime();
            },
            onRowClick: () => {
                // Do nothing
            },
            rowClassName: () => {
                return '';
            }
        };
        return react_1.default.createElement(antd_1.Table, Object.assign({}, tableConfig));
    }
}
exports.VisionList = VisionList;


/***/ }),

/***/ 29754:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandItem = void 0;
const react_1 = __importDefault(__webpack_require__(67294));
const prop_types_1 = __importDefault(__webpack_require__(45697));
const react_dom_1 = __webpack_require__(73935);
const antd_1 = __webpack_require__(56318);
const ts_utils_1 = __webpack_require__(55452);
const react_dnd_1 = __webpack_require__(84785);
const command_1 = __webpack_require__(69396);
const utils_1 = __webpack_require__(63370);
var ItemTypes;
(function (ItemTypes) {
    ItemTypes["Command"] = "command";
})(ItemTypes || (ItemTypes = {}));
class InternalCommandItem extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.onClick = (e) => {
            this.props.onClick(e, this.props.command);
        };
        this.onContextMenu = (e) => {
            this.props.onContextMenu(e, this.props.command);
        };
    }
    render() {
        const { index, command, editable, isDragging, connectDropTarget, connectDragSource } = this.props;
        const decorate = ts_utils_1.compose(connectDragSource, connectDropTarget);
        const hasDescription = command.description && command.description.length > 0;
        return decorate(react_1.default.createElement("div", Object.assign({}, this.props.attributes, { style: this.props.style, className: utils_1.cn(this.props.className || '', { dragging: isDragging }), onClick: this.onClick, onContextMenu: this.onContextMenu }),
            react_1.default.createElement("div", { className: "row-col index-col" }, index),
            react_1.default.createElement("div", { className: "row-col command-col", title: command_1.commandText(command.cmd) },
                ts_utils_1.repeatStr(command.indent * 2, '\u00A0'),
                command_1.commandText(command.cmd)),
            react_1.default.createElement("div", { className: "row-col target-col", title: command.target, onMouseEnter: (e) => this.props.onMouseEnterTarget(e, command), onMouseLeave: (e) => this.props.onMouseLeaveTarget(e, command) }, command.target),
            react_1.default.createElement("div", { className: "row-col value-col", title: command.value }, command.value),
            react_1.default.createElement("div", { className: "row-col op-col" },
                hasDescription ? (react_1.default.createElement(antd_1.Tooltip, { title: command.description },
                    react_1.default.createElement(antd_1.Button, { disabled: !editable, type: "primary", shape: "circle", size: "small", onClick: (e) => {
                            this.props.onToggleComment(e, command);
                            e.stopPropagation();
                        } }, "//"))) : (react_1.default.createElement(antd_1.Button, { disabled: !editable, shape: "circle", size: "small", onClick: (e) => {
                        this.props.onToggleComment(e, command);
                        e.stopPropagation();
                    } }, "//")),
                react_1.default.createElement(antd_1.Button, { disabled: !editable, shape: "circle", size: "small", onClick: (e) => {
                        this.props.onDuplicate(e, command);
                        e.stopPropagation();
                    } },
                    react_1.default.createElement(antd_1.Icon, { type: "plus" })))));
    }
}
InternalCommandItem.propTypes = {
    style: prop_types_1.default.object,
    className: prop_types_1.default.string,
    attributes: prop_types_1.default.object,
    command: prop_types_1.default.object.isRequired,
    editable: prop_types_1.default.bool.isRequired,
    onClick: prop_types_1.default.func.isRequired,
    onContextMenu: prop_types_1.default.func.isRequired,
    onMouseEnterTarget: prop_types_1.default.func.isRequired,
    onMouseLeaveTarget: prop_types_1.default.func.isRequired,
    onToggleComment: prop_types_1.default.func.isRequired,
    onDuplicate: prop_types_1.default.func.isRequired,
    onMoveCommand: prop_types_1.default.func.isRequired,
    onDragStart: prop_types_1.default.func.isRequired,
    onDragEnd: prop_types_1.default.func.isRequired
};
InternalCommandItem.defaultProps = {
    style: {},
    attributes: {},
    className: ''
};
exports.CommandItem = ts_utils_1.compose(react_dnd_1.DragSource(ItemTypes.Command, {
    beginDrag: (props) => {
        return {
            index: props.command.realIndex
        };
    },
    isDragging: (props, monitor) => {
        return monitor.getItem().index === props.command.realIndex;
    }
}, (connect, monitor) => ({
    connectDragSource: connect.dragSource(),
    isDragging: monitor.isDragging()
})), react_dnd_1.DropTarget(ItemTypes.Command, {
    hover: (props, monitor, component) => {
        if (!component) {
            return;
        }
        const dragIndex = monitor.getItem().index;
        const hoverIndex = props.command.realIndex;
        if (dragIndex === hoverIndex) {
            return;
        }
        const hoverBoundingRect = react_dom_1.findDOMNode(component).getBoundingClientRect();
        const halfHeight = hoverBoundingRect.height / 2;
        const clientOffset = monitor.getClientOffset();
        if (!clientOffset) {
            return;
        }
        const yInElement = clientOffset.y - hoverBoundingRect.top;
        // Only perform the move when the mouse has crossed half of the items height
        // When dragging downwards, only move when the cursor is below 50%
        // When dragging upwards, only move when the cursor is above 50%
        // Dragging downwards
        if (dragIndex < hoverIndex && yInElement < halfHeight) {
            return;
        }
        // Dragging upwards
        if (dragIndex > hoverIndex && yInElement > halfHeight) {
            return;
        }
        props.onMoveCommand(dragIndex, hoverIndex);
        // Note: we're mutating the monitor item here!
        // Generally it's better to avoid mutations,
        // but we don't have id for command, so have to update index here
        monitor.getItem().index = hoverIndex;
    }
}, (connect) => ({
    connectDropTarget: connect.dropTarget()
})))(InternalCommandItem);


/***/ }),

/***/ 76572:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runInDesktopScreenshotEditor = exports.openDesktopScreenshotWindow = void 0;
const web_extension_1 = __importDefault(__webpack_require__(61171));
const tab_utils_1 = __webpack_require__(96836);
const open_page_1 = __webpack_require__(22491);
const DESKTOP_SCREENSHOT_PAGE_URL = web_extension_1.default.runtime.getURL('desktop_screenshot_editor.html');
exports.openDesktopScreenshotWindow = (() => {
    let lastTabId = 0;
    return (screenAvailableSize) => {
        return web_extension_1.default.tabs.get(lastTabId)
            .catch((e) => null)
            .then((tab) => {
            const api = open_page_1.openPageInTab({
                url: DESKTOP_SCREENSHOT_PAGE_URL,
                tabId: tab && tab.id,
                keep: true,
                popup: true,
                domReady: true,
                focus: true,
                width: screenAvailableSize.width / 2 + 50,
                height: screenAvailableSize.height / 2 + 100,
                left: screenAvailableSize.width / 4 - 25,
                top: screenAvailableSize.height / 4 - 50,
            });
            api.getTabId()
                .then((tabId) => {
                lastTabId = tabId;
                return tab_utils_1.activateTab(tabId);
            });
            return api;
        });
    };
})();
function runInDesktopScreenshotEditor(screenAvailableSize, req) {
    return exports.openDesktopScreenshotWindow(screenAvailableSize)
        .then(api => api.ask(req.type, req.data));
}
exports.runInDesktopScreenshotEditor = runInDesktopScreenshotEditor;


/***/ }),

/***/ 623:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.selectAreaOnDesktop = void 0;
const service_1 = __webpack_require__(76572);
const types_1 = __webpack_require__(34322);
const desktop_1 = __webpack_require__(1885);
const screen_capture_1 = __webpack_require__(83185);
const x_screen_capture_1 = __webpack_require__(74359);
const storage_1 = __importDefault(__webpack_require__(67585));
const tab_1 = __webpack_require__(65277);
function selectAreaOnDesktop(screenAvailableSize) {
    const captureDesktopViaNativeCVAPI = () => {
        return desktop_1.getNativeCVAPI().captureDesktop({ path: undefined })
            .then(hardDrivePath => {
            return service_1.runInDesktopScreenshotEditor(screenAvailableSize, {
                type: types_1.DesktopScreenshot.RequestType.Capture,
                data: {
                    image: {
                        source: types_1.DesktopScreenshot.ImageSource.CV,
                        path: hardDrivePath,
                        // width/height is not used for this event, so set it to 0
                        width: 0,
                        height: 0,
                    }
                }
            });
        });
    };
    const captureDesktopViaNativeScreenCapture = () => {
        return screen_capture_1.getNativeScreenCapture().captureDesktop().then(hardDrivePath => {
            return desktop_1.getNativeCVAPI().readFileAsDataURL(hardDrivePath, true);
        });
    };
    const shouldUseNativeScreenCapture = () => {
        return Promise.all([
            storage_1.default.get('config').then(config => config.useDesktopScreenCapture),
            x_screen_capture_1.getXScreenCapture().sanityCheck().catch(() => false)
        ])
            .then(([optedInNativeScreenCapture, hasInstalledNativeScreenCapture]) => {
            return optedInNativeScreenCapture && hasInstalledNativeScreenCapture;
        });
    };
    return shouldUseNativeScreenCapture().then(should => {
        const captureDesktop = should
            ? captureDesktopViaNativeScreenCapture
            : captureDesktopViaNativeCVAPI;
        return captureDesktop().then(dataUrl => {
            // If it's called on popup page, just use the function on window
            const handleCommand = window.handleCommand;
            if (typeof handleCommand === 'function') {
                return handleCommand('ADD_VISION_IMAGE', { dataUrl });
            }
            return tab_1.withPanelIpc()
                .then(panelIpc => {
                return panelIpc.ask('ADD_VISION_IMAGE', { dataUrl });
            });
        });
    });
}
exports.selectAreaOnDesktop = selectAreaOnDesktop;


/***/ }),

/***/ 13426:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.updateState = exports.getState = void 0;
const storage_1 = __importDefault(__webpack_require__(67585));
const C = __importStar(__webpack_require__(43232));
const defaultState = {
    status: C.APP_STATUS.NORMAL,
    tabIds: {
        lastActivated: [],
        lastInspect: null,
        lastRecord: null,
        toInspect: null,
        firstRecord: null,
        toRecord: null,
        lastPlay: null,
        firstPlay: null,
        toPlay: null,
        panel: null
    },
    pullback: false,
    // Note: heartBeatSecret = -1, means no heart beat available, and panel should not retry on heart beat lost
    heartBeatSecret: 0,
    // Note: disableHeartBeat = true, `checkHeartBeat` will stop working, it's useful for cases like close current tab
    disableHeartBeat: false,
    // Note: pendingPlayingTab = true, tells `getPlayTab` to wait until the current tab is closed and another tab is focused on
    pendingPlayingTab: false,
    xClickNeedCalibrationInfo: null,
    lastCsIpcSecret: null,
    closingAllWindows: false
};
function getState(optionalKey) {
    return storage_1.default.get(C.STATE_STORAGE_KEY).then(state => {
        const st = state || defaultState;
        if (typeof optionalKey === 'string') {
            return st[optionalKey];
        }
        return st;
    });
}
exports.getState = getState;
function updateState(updateFunc) {
    const fn = typeof updateFunc === 'function' ? updateFunc : (state) => (Object.assign(Object.assign({}, state), updateFunc));
    return getState().then((state) => {
        const result = fn(state);
        return storage_1.default.set(C.STATE_STORAGE_KEY, result).then(() => { });
    });
}
exports.updateState = updateState;


/***/ }),

/***/ 65277:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPlayTab = exports.withPanelIpc = exports.showPanelWindow = exports.getPanelTabIpc = exports.getInspectTabIpc = exports.getPlayTabIpc = exports.getRecordTabIpc = exports.genGetTabIpc = void 0;
const web_extension_1 = __importDefault(__webpack_require__(61171));
const ts_utils_1 = __webpack_require__(55452);
const ipc_cache_1 = __webpack_require__(54105);
const global_state_1 = __webpack_require__(13426);
const tab_utils_1 = __webpack_require__(96836);
const storage_1 = __importDefault(__webpack_require__(67585));
// Generate function to get ipc based on tabIdName and some error message
function genGetTabIpc(tabIdName, purpose) {
    return (timeout = 100, before = Infinity) => {
        return ts_utils_1.retry(() => __awaiter(this, void 0, void 0, function* () {
            const state = yield global_state_1.getState();
            const tabId = state.tabIds[tabIdName];
            if (!tabId) {
                return Promise.reject(new Error(`Error #150: No tab for ${purpose} yet`));
            }
            return web_extension_1.default.tabs.get(tabId);
        }), {
            timeout,
            retryInterval: 100,
            shouldRetry: () => true
        })()
            .then(tab => {
            if (!tab) {
                throw new Error(`Error #160: The ${purpose} tab seems to be closed`);
            }
            return ipc_cache_1.getIpcCache().get(tab.id, timeout, before)
                .catch(e => {
                throw new Error(`Error #170: No ipc available for the ${purpose} tab`);
            });
        });
    };
}
exports.genGetTabIpc = genGetTabIpc;
exports.getRecordTabIpc = genGetTabIpc('toRecord', 'recording');
exports.getPlayTabIpc = genGetTabIpc('toPlay', 'playing commands');
exports.getInspectTabIpc = genGetTabIpc('toInspect', 'inspect');
exports.getPanelTabIpc = genGetTabIpc('panel', 'dashboard');
function showPanelWindow({ params } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const state = yield global_state_1.getState();
        return tab_utils_1.activateTab(state.tabIds.panel, true)
            .then(() => false, () => {
            return storage_1.default.get('config')
                .then(config => {
                config = config || {};
                return (config.size || {})[config.showSidebar ? 'with_sidebar' : 'standard'];
            })
                .then((size) => __awaiter(this, void 0, void 0, function* () {
                size = size || {
                    width: 850,
                    height: 775
                };
                const urlQuery = Object.keys(params || {})
                    .map(key => {
                    return `${key}=${params[key]}`;
                })
                    .join('&');
                const base = web_extension_1.default.runtime.getURL('popup.html');
                const url = urlQuery.length > 0 ? `${base}?${urlQuery}` : base;
                yield global_state_1.updateState({ closingAllWindows: false });
                return web_extension_1.default.windows.create({
                    url,
                    type: 'popup',
                    width: size.width,
                    height: size.height
                })
                    .then((win) => {
                    if (!web_extension_1.default.isFirefox())
                        return;
                    // Refer to https://bugzilla.mozilla.org/show_bug.cgi?id=1425829
                    // Firefox New popup window appears blank until right-click
                    return ts_utils_1.delay(() => {
                        return web_extension_1.default.windows.update(win.id, {
                            width: size.width + 1,
                            height: size.height + 1
                        });
                    }, 1000);
                })
                    .then(() => ts_utils_1.delay(() => true, 2000));
            }));
        });
    });
}
exports.showPanelWindow = showPanelWindow;
function withPanelIpc(options) {
    return showPanelWindow(options)
        .then(() => exports.getPanelTabIpc(6 * 1000));
}
exports.withPanelIpc = withPanelIpc;
// Get the current tab for play, if url provided, it will be loaded in the tab
function getPlayTab(url) {
    return __awaiter(this, void 0, void 0, function* () {
        // Note: update error message to be more user friendly. But the original message is kept as comment
        // const theError  = new Error('Either a played tab or a url must be provided to start playing')
        const theError = new Error('Error #180: No connection to browser tab');
        const createOne = (url) => __awaiter(this, void 0, void 0, function* () {
            if (!url)
                throw theError;
            const tab = yield tab_utils_1.createTab(url);
            yield global_state_1.updateState(state => (Object.assign(Object.assign({}, state), { tabIds: Object.assign(Object.assign({}, state.tabIds), { lastPlay: state.tabIds.toPlay, toPlay: tab.id, firstPlay: tab.id }) })));
            return tab;
        });
        const runRealLogic = (state) => {
            if (!state.tabIds.toPlay && !url) {
                throw theError;
            }
            if (!state.tabIds.toPlay) {
                return createOne(url);
            }
            return tab_utils_1.getTab(state.tabIds.toPlay)
                .then((tab) => {
                if (!url) {
                    return tab;
                }
                // Note: must disable ipcCache manually here, so that further messages
                // won't be sent the old ipc
                ipc_cache_1.getIpcCache().disable(tab.id);
                const finalUrl = (() => {
                    try {
                        const u = new URL(url, tab.url);
                        return u.toString();
                    }
                    catch (e) {
                        return url;
                    }
                })();
                return tab_utils_1.updateUrlForTab(tab, finalUrl);
            }, () => createOne(url));
        };
        const state = yield global_state_1.getState();
        if (state.pendingPlayingTab) {
            yield ts_utils_1.until('pendingPlayingTab reset', () => {
                return {
                    pass: !state.pendingPlayingTab,
                    result: true
                };
            }, 100, 5000);
        }
        return runRealLogic(state);
    });
}
exports.getPlayTab = getPlayTab;


/***/ }),

/***/ 77204:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runCommandInPlayTab = void 0;
const global_state_1 = __webpack_require__(13426);
const web_extension_1 = __importDefault(__webpack_require__(61171));
const log_1 = __importDefault(__webpack_require__(77242));
const ipc_cs_1 = __importDefault(__webpack_require__(41471));
const C = __importStar(__webpack_require__(43232));
const ts_utils_1 = __webpack_require__(55452);
const timeout_counter_1 = __webpack_require__(82759);
const utils_1 = __webpack_require__(63370);
const tab_1 = __webpack_require__(65277);
// Note: There are several versions of runCommandXXX here. One by one, they have a better tolerence of error
// 1. runCommand:
//      Run a command, and wait until we can confirm that command is completed (e.g.  xxxAndWait)
//
// 2. runCommandWithRetry:
//      Enhance runCommand with retry mechanism, only retry when element is not found
//
// 3. runCommandWithClosureAndErrorProcess:
//      Include `args` in closure, and take care of `errorIgnore`
//
// 4. runWithHeartBeat:
//      Run a heart beat check along with `runCommandWithClosureAndErrorProcess`.
//      Heart beat check requires cs Ipc must be created before heart beat check starts.
//      With this, we can ensure the page is not closed or refreshed
//
// 5. runWithRetryOnLostHeartBeat:
//      Run `runWithHeartBeat` with retry mechanism. only retry when it's a 'lost heart beat' error
//      When closed/refresh is detected, it will try to send same command to that tab again.
function runCommandInPlayTab(command) {
    return __awaiter(this, void 0, void 0, function* () {
        timeout_counter_1.clearTimerForTimeoutStatus();
        // Note: `disableHeartBeat` is only set to true when current tab will
        // be closed ("reload tab" / "change url" excluded).
        // For exmaple `selectWindow tab=close`
        yield global_state_1.updateState({ disableHeartBeat: false });
        const shouldSkipCommandRun = yield preparePlayTab(command);
        if (shouldSkipCommandRun) {
            return {};
        }
        try {
            return yield runWithRetryOnLostHeartBeat(command);
        }
        catch (err) {
            const e = err;
            log_1.default.error('catched in runCommandInPlayTab', e.stack);
            if (e && e.message && (e.message.indexOf('lost heart beat when running command') !== -1 ||
                e.message.indexOf('Could not establish connection') !== -1)) {
                return yield runWithRetryOnLostHeartBeat(command);
            }
            return Promise.reject(e);
        }
    });
}
exports.runCommandInPlayTab = runCommandInPlayTab;
function updateHeartBeatSecret(options) {
    if (options === null || options === void 0 ? void 0 : options.disabled) {
        return global_state_1.updateState({ heartBeatSecret: -1 });
    }
    else {
        return global_state_1.updateState((state) => {
            const oldHeartBeatSecret = state.heartBeatSecret || 0;
            return (Object.assign(Object.assign({}, state), { heartBeatSecret: (Math.max(0, oldHeartBeatSecret) + 1) % 10000 }));
        });
    }
}
function callPlayTab(params) {
    var _a, _b, _c;
    const defaultTimeout = 100;
    // Default expired at is infinity, but to make it easy to pass it via ipc,
    // use the double of current timestamp
    const defaultNoLaterThan = Date.now() * 2;
    const defaultIpcCallTimeout = -1;
    const ipcTimeout = (_a = params.tabIpcTimeout) !== null && _a !== void 0 ? _a : defaultTimeout;
    const ipcNoLaterThan = (_b = params.tabIpcNoLaterThan) !== null && _b !== void 0 ? _b : defaultNoLaterThan;
    const ipcCallTimeout = (_c = params.ipcCallTimeout) !== null && _c !== void 0 ? _c : defaultIpcCallTimeout;
    return ipc_cs_1.default.ask('PANEL_CALL_PLAY_TAB', {
        ipcTimeout,
        ipcNoLaterThan,
        payload: {
            command: params.command,
            args: params.args,
        }
    }, ipcCallTimeout);
}
function checkHeartBeat(tabIpcTimeout, tabIpcExpiredAt) {
    return __awaiter(this, void 0, void 0, function* () {
        const disableHeartBeat = yield global_state_1.getState('disableHeartBeat');
        if (disableHeartBeat) {
            return { secret: "heart_beat_disabled" };
        }
        yield updateHeartBeatSecret();
        return callPlayTab({
            tabIpcTimeout,
            tabIpcNoLaterThan: tabIpcExpiredAt,
            command: 'HEART_BEAT',
            args: {}
        })
            .catch(e => {
            log_1.default.error('at least I catched it', e.message);
            throw new Error('heart beat error thrown');
        });
    });
}
function shouldWaitForDownloadAfterRun(command) {
    log_1.default('shouldWaitForDownloadAfterRun', command);
    return command.cmd === 'click';
}
function shoudWaitForCommand(command) {
    log_1.default('shoudWaitForCommand', command);
    return /andWait/i.test(command.cmd) || ['open', 'refresh'].indexOf(command.cmd) !== -1;
}
function getCommandTimeout(command) {
    const defaultTimeout = command.extra.timeoutElement * 1000;
    switch (command.cmd) {
        case 'waitForElementVisible':
        case 'waitForElementNotVisible':
        case 'waitForElementPresent':
        case 'waitForElementNotPresent': {
            const timeout = parseInt(command.value, 10);
            return !isNaN(timeout) ? timeout : defaultTimeout;
        }
        default:
            return defaultTimeout;
    }
}
// Note: -1 will disable ipc timeout for 'pause', and 'onDownload' command
function getIpcTimeout(command) {
    var _a;
    const pageLoadTimeout = (((_a = command === null || command === void 0 ? void 0 : command.extra) === null || _a === void 0 ? void 0 : _a.timeoutPageLoad) || 60) * 1000;
    switch (command.cmd) {
        case 'open':
        case 'clickAndWait':
        case 'selectAndWait':
            return pageLoadTimeout;
        case 'selectWindow': {
            const target = command.target;
            const isTabOpen = (target && target.toUpperCase()) === 'TAB=OPEN';
            return isTabOpen ? pageLoadTimeout : getCommandTimeout(command);
        }
        case 'pause':
        case 'onDownload':
        case 'captureEntirePageScreenshot':
            return -1;
        default:
            return getCommandTimeout(command);
    }
}
function getTimeoutPageLoad(command) {
    var _a;
    return (((_a = command === null || command === void 0 ? void 0 : command.extra) === null || _a === void 0 ? void 0 : _a.timeoutPageLoad) || 60) * 1000;
}
function withPageLoadCheck(command, timeoutPageLoad, promiseFunc) {
    const shouldWait = shoudWaitForCommand(command);
    if (!shouldWait) {
        return promiseFunc();
    }
    // Note: send timeout status to dashboard once "xxxWait" and "open" returns
    const clear = timeout_counter_1.startSendingTimeoutStatus(timeoutPageLoad);
    return Promise.race([
        promiseFunc()
            .then(data => { clear(); return data; }, e => { clear(); throw e; }),
        ts_utils_1.delay(() => {
            throw new Error(`Error #230: Page load ${timeoutPageLoad / 1000} seconds time out`);
        }, timeoutPageLoad)
    ]);
}
function waitForCommandToComplete(command, res) {
    var _a, _b;
    const timeoutPageLoad = getTimeoutPageLoad(command);
    const timeoutHeartbeat = (((_b = (_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.extra) === null || _b === void 0 ? void 0 : _b.timeoutElement) || 10) * 1000;
    const shouldWait = shoudWaitForCommand(command);
    if (!shouldWait) {
        return Promise.resolve();
    }
    return ts_utils_1.delay(() => { }, 2000)
        .then(() => {
        // Note: After refresh/redirect, ipc secret in content script changes,
        // use this fact to tell whether a page is loaded or not
        return ts_utils_1.retry(() => {
            return checkHeartBeat()
                .then((heartBeatResult) => __awaiter(this, void 0, void 0, function* () {
                const lastSecret = yield global_state_1.getState('lastCsIpcSecret');
                const heartBeatSecret = heartBeatResult.secret;
                if (lastSecret === heartBeatSecret) {
                    throw new Error('Error #220: Still same ipc secret');
                }
                return true;
            }));
        }, {
            shouldRetry: () => true,
            timeout: timeoutHeartbeat,
            retryInterval: 250
        })();
    })
        .catch(e => {
        const { cmd } = command;
        const isAndWait = /AndWait/.test(cmd);
        console.warn(e);
        if (isAndWait) {
            const instead = cmd.replace('AndWait', '');
            throw new Error(`Error #200: '${cmd}' failed. No page load event detected after ${timeoutHeartbeat / 1000} seconds. Try '${instead}' instead. Error details: ` + e.message);
        }
        else {
            throw new Error(`Error #210: '${cmd}' failed. No page load event detected after ${timeoutHeartbeat / 1000}s (!TIMEOUT_WAIT). Error details: ` + e.message);
        }
    })
        .then(() => __awaiter(this, void 0, void 0, function* () {
        yield callPlayTab({
            command: 'DOM_READY',
            args: {},
            ipcCallTimeout: timeoutPageLoad
        });
        yield callPlayTab({
            command: 'HACK_ALERT',
            args: {},
            ipcCallTimeout: C.CS_IPC_TIMEOUT
        });
    }));
}
function runCommand(command, retryInfo) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const state = yield global_state_1.getState();
        const ipcTimeout = getIpcTimeout(command);
        if (state.status !== C.APP_STATUS.PLAYER) {
            throw new Error("can't run command when it's not in player mode");
        }
        // Note: clear timer whenever we execute a new command, and it's not a retry
        if (retryInfo.retryCount === 0) {
            timeout_counter_1.clearTimerForTimeoutStatus();
        }
        // Note: each command keeps target page's status as PLAYING
        yield callPlayTab({
            command: 'SET_STATUS',
            args: {
                status: C.CONTENT_SCRIPT_STATUS.PLAYING
            }
        });
        yield callPlayTab({
            command: 'DOM_READY',
            args: {},
            ipcCallTimeout: ipcTimeout
        });
        const res = yield callPlayTab({
            command: 'RUN_COMMAND',
            args: {
                command: Object.assign(Object.assign({}, command), { extra: Object.assign(Object.assign({}, (command.extra || {})), { retryInfo }) })
            },
            ipcCallTimeout: ipcTimeout
        });
        yield withPageLoadCheck(command, getTimeoutPageLoad(command), () => waitForCommandToComplete(command, res));
        const secret = (_a = res.data) === null || _a === void 0 ? void 0 : _a.secret;
        if (secret) {
            yield global_state_1.updateState({ lastCsIpcSecret: secret });
        }
        return res.data;
    });
}
function isTimeoutError(msg) {
    return !!msg &&
        (msg.indexOf('timeout reached when looking for') !== -1 ||
            msg.indexOf('timeout reached when waiting for') !== -1 ||
            msg.indexOf('element is found but not visible yet') !== -1 ||
            msg.indexOf('IPC Promise has been destroyed') !== -1);
}
function runCommandWithRetry(command) {
    return __awaiter(this, void 0, void 0, function* () {
        // Note: add timerSecret to ensure it won't clear timer that is not created by this function call
        const timerSecret = Math.random();
        yield global_state_1.updateState({ timerSecret });
        const commandTimeout = getCommandTimeout(command);
        const maxRetryOnIpcTimeout = 1;
        let retryCountOnIpcTimeout = 0;
        const fn = ts_utils_1.retry(runCommand, {
            timeout: commandTimeout,
            shouldRetry: (e) => {
                log_1.default('runCommandWithRetry - shouldRetry', e.message);
                // Note: for rare cases when guest page doesn't respond to RUN_COMMAND, it will timeout for `timeoutElement`
                // And we should retry RUN_COMMAND for only once in that case, and also show this as warning to users
                // related issue: #513
                if (/ipcPromise.*timeout/i.test(e.message)) {
                    if (retryCountOnIpcTimeout < maxRetryOnIpcTimeout) {
                        callPlayTab({
                            command: 'ADD_LOG',
                            args: {
                                warning: 'Warning #300: Web page connection issue. Retrying last command.'
                            }
                        });
                        retryCountOnIpcTimeout++;
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                return isTimeoutError(e.message);
            },
            onFirstFail: (e) => {
                const title = e && e.message && e.message.indexOf('element is found but not visible yet') !== -1
                    ? 'Tag waiting' // All use Tag Waiting for now  // 'Visible waiting'
                    : 'Tag waiting';
                timeout_counter_1.startSendingTimeoutStatus(commandTimeout, title);
            },
            onFinal: (err, data) => __awaiter(this, void 0, void 0, function* () {
                const state = yield global_state_1.getState();
                log_1.default('onFinal', err, data);
                if (state.timer && state.timerSecret === timerSecret) {
                    clearInterval(state.timer);
                }
            })
        });
        try {
            return yield fn(command);
        }
        catch (err) {
            const e = err;
            if (!isTimeoutError(e.message)) {
                return Promise.reject(e);
            }
            if (command.targetOptions && command.targetOptions.length) {
                return runCommand(command, { final: true });
            }
            return Promise.reject(e);
        }
    });
}
function runCommandWithClosureAndErrorProcess(command) {
    return runCommandWithRetry(command)
        .catch(e => {
        var _a;
        // Return default value for storeXXX commands
        if (['storeText', 'storeValue', 'storeChecked', 'storeAttribute'].indexOf(command.cmd) !== -1) {
            const value = command.value;
            const LOCATOR_NOT_FOUND = '#LNF';
            return {
                vars: {
                    [value]: LOCATOR_NOT_FOUND
                },
                log: {
                    error: e.message
                }
            };
        }
        // Note: if variable !ERRORIGNORE is set to true,
        // it will just log errors instead of a stop of whole macro
        if ((_a = command.extra) === null || _a === void 0 ? void 0 : _a.errorIgnore) {
            return {
                log: {
                    error: e.message
                }
            };
        }
        throw e;
    });
}
function runWithHeartBeat(command) {
    const isTabOpenForSelectWindow = command.cmd === 'selectWindow' &&
        /^\s*tab=open\s*$/i.test(command.target);
    const neverResolvePromise = new Promise(() => { });
    const [infiniteCheckHeartBeat, stopInfiniteCheck] = (() => {
        const startTime = new Date().getTime();
        let stop = false;
        const check = () => {
            log_1.default('starting heart beat');
            // Note: do not check heart beat when
            // 1. it's a 'open' command, which is supposed to reconnect ipc
            // 2. it's going to download files, which will kind of reload page and reconnect ipc
            const pNoNeedForHearBeat = (() => {
                if (shoudWaitForCommand(command)) {
                    return Promise.resolve(true);
                }
                return ipc_cs_1.default.ask('PANEL_HAS_PENDING_DOWNLOAD', {});
            })();
            return pNoNeedForHearBeat.then(noNeedForHeartBeat => {
                if (noNeedForHeartBeat) {
                    updateHeartBeatSecret({ disabled: true });
                    return neverResolvePromise;
                }
                if (stop) {
                    return Promise.resolve();
                }
                return checkHeartBeat(100, startTime)
                    .then(() => ts_utils_1.delay(check, 1000), e => {
                    log_1.default.error('lost heart beart!!', e.stack);
                    throw new Error('lost heart beat when running command');
                });
            });
        };
        const stopIt = () => {
            log_1.default('stopping heart beat');
            stop = true;
        };
        return [check, stopIt];
    })();
    return Promise.race([
        runCommandWithClosureAndErrorProcess(command)
            .then(data => {
            stopInfiniteCheck();
            return data;
        })
            .catch(e => {
            stopInfiniteCheck();
            return Promise.reject(e);
        }),
        (isTabOpenForSelectWindow ? new Promise(() => { }) : infiniteCheckHeartBeat())
    ]);
}
function runWithRetryOnLostHeartBeat(command) {
    return __awaiter(this, void 0, void 0, function* () {
        const runWithHeartBeatRetry = ts_utils_1.retry(runWithHeartBeat, {
            timeout: getCommandTimeout(command),
            shouldRetry: (e) => {
                log_1.default('runWithHeartBeatRetry - shouldRetry', e.message);
                return !!e && !!e.message && e.message.indexOf('lost heart beat when running command') !== -1;
            },
            retryInterval: (retryCount, lastRetryInterval) => {
                return Math.max(1 * 1000, Math.min(5 * 1000, lastRetryInterval * 1.2));
            }
        });
        const result = yield runWithHeartBeatRetry(command);
        if (shouldWaitForDownloadAfterRun(command)) {
            // Note: wait for download to either be create or completed
            yield ipc_cs_1.default.ask('PANEL_WAIT_FOR_ANY_DOWNLOAD', {});
        }
        const state = yield global_state_1.getState();
        try {
            // Note: use bg to set pageUrl, so that we can be sure that this `pageUrl` is 100% correct
            const tab = yield web_extension_1.default.tabs.get(state.tabIds.toPlay);
            return Object.assign(Object.assign({}, result), { pageUrl: tab.url });
        }
        catch (e) {
            log_1.default.error('Error in fetching play tab url');
            return result;
        }
    });
}
function openNewUrlInPlayTab(command, startPageLoadCountDown) {
    const { cmd, target, value } = command;
    const [isOpenCommand, shouldSkipCommandRun, url] = (() => {
        if (cmd === 'open') {
            return [true, false, target];
        }
        if (cmd === 'selectWindow' && target && target.toLowerCase().trim() === 'tab=open') {
            return [true, true, value];
        }
        return [false, false, null];
    })();
    if (!isOpenCommand) {
        throw new Error('Error #101: UI.Vision RPA is not connected to a browser tab');
    }
    startPageLoadCountDown();
    return tab_1.getPlayTab(url)
        .then((tab) => ({ tab, shouldSkipCommandRun, hasOpenedUrl: true }));
}
function preparePlayTabIPC(command, tab, startCountDown, stopCountDown) {
    return ipc_cs_1.default.ask('PANEL_CS_IPC_READY', {
        tabId: tab.id,
        timeout: 100,
    })
        .then(() => {
        return { tab, hasOpenedUrl: false };
    }, () => {
        return openNewUrlInPlayTab(command, startCountDown);
    })
        .then(({ tab, hasOpenedUrl, shouldSkipCommandRun }) => {
        return callPlayTab({
            command: 'HEART_BEAT',
            args: '',
            tabIpcTimeout: getTimeoutPageLoad(command)
        })
            .then(() => {
            stopCountDown();
            return { tab, hasOpenedUrl, shouldSkipCommandRun };
        });
    });
}
function ensurePlayTabIPC(command, tab, startCountDown, stopCountDown) {
    // Note: in case the playing tab exists but not has a broken page, and is not reachable by tabs.sendMessage
    // We should try to run open command again if any
    return utils_1.withTimeout(getTimeoutPageLoad(command), () => __awaiter(this, void 0, void 0, function* () {
        try {
            return yield preparePlayTabIPC(command, tab, startCountDown, stopCountDown);
        }
        catch (err) {
            const e = err;
            if (!/Could not establish connection/.test(e.message)) {
                return Promise.reject(e);
            }
            const newTabResult = yield openNewUrlInPlayTab(command, startCountDown);
            return yield preparePlayTabIPC(command, newTabResult.tab, startCountDown, stopCountDown);
        }
    }))
        .catch(e => {
        if (/withTimeout/.test(e.message)) {
            throw new Error(`UI.Vision RPA fails to open this url`);
        }
        throw e;
    });
}
function createCountDown(timeout) {
    let stopPageLoadCountDown = () => { };
    const startPageLoadCountDown = () => {
        stopPageLoadCountDown();
        stopPageLoadCountDown = timeout_counter_1.startSendingTimeoutStatus(timeout);
    };
    return [startPageLoadCountDown, stopPageLoadCountDown];
}
function preparePlayTab(command) {
    const [startPageLoadCountDown, stopPageLoadCountDown] = createCountDown(getTimeoutPageLoad(command));
    return tab_1.getPlayTab()
        // Note: catch any error, and make it run 'getPlayTab(args.url)' instead
        .catch((e) => ({ id: -1 }))
        .then((tab) => {
        log_1.default('after first getPlayTab', tab);
        // On Firefox, it does get ipc from "about:blank", but somehow the connection is not good
        // it's always reconnecting. so instead of trying to run command on "about:blank",
        // redirect it to meaningful url
        const unresponsiblePages = ['about:blank', 'about:config'];
        if (unresponsiblePages.indexOf(tab.url) !== -1) {
            return openNewUrlInPlayTab(command, startPageLoadCountDown)
                .then(() => true);
        }
        return ensurePlayTabIPC(command, tab, startPageLoadCountDown, stopPageLoadCountDown)
            .then(({ tab, hasOpenedUrl, shouldSkipCommandRun }) => {
            // const p = args.shouldNotActivateTab ? Promise.resolve() : activateTab(tab.id, true)
            const p = Promise.resolve();
            // Note: wait for tab to confirm it has loaded
            return p
                .then(() => ipc_cs_1.default.ask('PANEL_CS_IPC_READY', {
                tabId: tab.id,
                timeout: 6000 * 10,
            }))
                .then(() => __awaiter(this, void 0, void 0, function* () {
                if (hasOpenedUrl) {
                    yield callPlayTab({
                        command: 'MARK_NO_COMMANDS_YET',
                        args: {},
                        ipcCallTimeout: C.CS_IPC_TIMEOUT
                    });
                }
                yield callPlayTab({
                    command: 'SET_STATUS',
                    args: { status: C.CONTENT_SCRIPT_STATUS.PLAYING },
                    ipcCallTimeout: C.CS_IPC_TIMEOUT
                });
            }))
                .then(() => shouldSkipCommandRun);
        });
    });
}


/***/ }),

/***/ 82759:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.onTimeoutStatus = exports.clearTimerForTimeoutStatus = exports.startSendingTimeoutStatus = void 0;
const registry_1 = __webpack_require__(55290);
const registry = registry_1.createListenerRegistry();
const keyTimeoutStatus = 'TIMEOUT_STATUS';
let timer;
function startSendingTimeoutStatus(timeout, type = 'wait', interval = 1000) {
    if (timer) {
        clearInterval(timer);
    }
    let past = 0;
    timer = setInterval(() => {
        past += interval;
        registry.fire(keyTimeoutStatus, {
            type,
            past,
            total: timeout
        });
        if (past >= timeout) {
            clearInterval(timer);
        }
    }, interval);
    return () => {
        clearInterval(timer);
    };
}
exports.startSendingTimeoutStatus = startSendingTimeoutStatus;
function clearTimerForTimeoutStatus() {
    clearInterval(timer);
}
exports.clearTimerForTimeoutStatus = clearTimerForTimeoutStatus;
function onTimeoutStatus(callback) {
    registry.add(keyTimeoutStatus, callback);
}
exports.onTimeoutStatus = onTimeoutStatus;


/***/ }),

/***/ 78328:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isNoDisplay = exports.isPlaying = exports.getShouldLoadResources = exports.getStatus = exports.getIndexToInsertRecorded = exports.isMacroFolderNodeListEmpty = exports.getMacroFolderNodeList = exports.getMacroFileNodeList = exports.getFilteredMacroFileNodeData = exports.getMacroFileNodeData = exports.getMacrosExtra = exports.getMacroFolderStructure = exports.getEditor = exports.entryNodeToFileNodeData = exports.editorCommandCount = exports.editorSelectedCommandIndex = exports.editorSelectedCommand = exports.findMacroFolderWithCaseInsensitiveRelativePath = exports.findMacroNodeWithCaseInsensitiveRelativePath = exports.findMacroNodeWithCaseInsensitiveFullPath = exports.findMacroNodeWithCaseInsensitiveField = exports.hasUnsavedMacro = exports.getShouldSaveAlternativeLocators = exports.getConfig = exports.isFocusOnSidebar = exports.isFocusOnCommandTable = exports.getErrorCommandIndices = exports.getWarningCommandIndices = exports.getDoneCommandIndices = exports.getBreakpointsByMacroId = exports.getBreakpoints = exports.getCurrentMacroId = exports.getTestSuitesWithAllInfo = void 0;
const reselect_1 = __webpack_require__(22222);
const constant_1 = __webpack_require__(43232);
const macro_extra_data_1 = __webpack_require__(24577);
const tree_file_1 = __webpack_require__(58335);
const ts_utils_1 = __webpack_require__(55452);
const state_1 = __webpack_require__(16112);
exports.getTestSuitesWithAllInfo = reselect_1.createSelector([
    (state) => state.editor.testSuites,
    (state) => state.editor.testSuitesExtra
], (testSuites, testSuitesExtra) => {
    const getKey = (ts) => ts.id;
    return testSuites.map(ts => {
        const key = getKey(ts);
        const extra = testSuitesExtra[key || ''];
        return Object.assign(Object.assign({}, ts), (extra || {}));
    });
});
exports.getCurrentMacroId = reselect_1.createSelector([
    (state) => state.editor.editing.meta.src
], (src) => {
    return src ? src.id : constant_1.UNTITLED_ID;
});
exports.getBreakpoints = reselect_1.createSelector([
    (state) => state.editor.macrosExtra,
    exports.getCurrentMacroId
], (macrosExtra, macroId) => {
    const extra = macrosExtra[macroId] || {};
    return extra.breakpointIndices || [];
});
function getBreakpointsByMacroId(state, macroId) {
    const macrosExtra = state.editor.macrosExtra;
    const extra = macrosExtra[macroId] || {};
    return extra.breakpointIndices || [];
}
exports.getBreakpointsByMacroId = getBreakpointsByMacroId;
exports.getDoneCommandIndices = reselect_1.createSelector([
    (state) => state.editor.macrosExtra,
    exports.getCurrentMacroId
], (macrosExtra, macroId) => {
    const extra = macrosExtra[macroId] || {};
    return extra.doneCommandIndices || [];
});
exports.getWarningCommandIndices = reselect_1.createSelector([
    (state) => state.editor.macrosExtra,
    exports.getCurrentMacroId
], (macrosExtra, macroId) => {
    const extra = macrosExtra[macroId] || {};
    return extra.warningCommandIndices || [];
});
exports.getErrorCommandIndices = reselect_1.createSelector([
    (state) => state.editor.macrosExtra,
    exports.getCurrentMacroId
], (macrosExtra, macroId) => {
    const extra = macrosExtra[macroId] || {};
    return extra.errorCommandIndices || [];
});
exports.isFocusOnCommandTable = reselect_1.createSelector([(state) => state], (state) => state.ui.focusArea === state_1.FocusArea.CommandTable);
exports.isFocusOnSidebar = reselect_1.createSelector([(state) => state], (state) => state.ui.focusArea === state_1.FocusArea.Sidebar);
exports.getConfig = reselect_1.createSelector([(state) => state.config], ts_utils_1.id);
exports.getShouldSaveAlternativeLocators = reselect_1.createSelector([exports.getConfig], (config) => !!config.saveAlternativeLocators);
function hasUnsavedMacro(state) {
    const { editor } = state;
    const { editing, editingSource, activeTab } = editor;
    if (!editing.meta.src)
        return true;
    switch (activeTab) {
        case 'table_view': {
            const { hasUnsaved } = editing.meta || {};
            return hasUnsaved;
        }
        case 'source_view': {
            return editingSource.original !== editingSource.current;
        }
        default:
            throw new Error('Unknown activeTab');
    }
}
exports.hasUnsavedMacro = hasUnsavedMacro;
function findMacroNodeWithCaseInsensitiveField(state, field, value, isDirectory = false) {
    const nodes = isDirectory ? exports.getMacroFolderNodeList(state) : exports.getMacroFileNodeList(state);
    const transform = (path) => path.toLowerCase().replace(/\\/g, '/').replace(/\.json$/i, '');
    const toMatch = transform(value);
    return nodes.find(node => {
        if (isDirectory !== node.isDirectory) {
            return false;
        }
        return transform(node.fullPath) === toMatch || transform(node[field]) === toMatch;
    });
}
exports.findMacroNodeWithCaseInsensitiveField = findMacroNodeWithCaseInsensitiveField;
function findMacroNodeWithCaseInsensitiveFullPath(state, fullPath) {
    return findMacroNodeWithCaseInsensitiveField(state, 'fullPath', fullPath);
}
exports.findMacroNodeWithCaseInsensitiveFullPath = findMacroNodeWithCaseInsensitiveFullPath;
function findMacroNodeWithCaseInsensitiveRelativePath(state, relativePath) {
    return findMacroNodeWithCaseInsensitiveField(state, 'relativePath', relativePath);
}
exports.findMacroNodeWithCaseInsensitiveRelativePath = findMacroNodeWithCaseInsensitiveRelativePath;
function findMacroFolderWithCaseInsensitiveRelativePath(state, relativePath) {
    return findMacroNodeWithCaseInsensitiveField(state, 'relativePath', relativePath, true);
}
exports.findMacroFolderWithCaseInsensitiveRelativePath = findMacroFolderWithCaseInsensitiveRelativePath;
function editorSelectedCommand(state) {
    const { meta, commands } = state.editor.editing;
    if (!meta || meta.selectedIndex === -1)
        return null;
    return commands[meta.selectedIndex] || null;
}
exports.editorSelectedCommand = editorSelectedCommand;
function editorSelectedCommandIndex(state) {
    const { meta } = state.editor.editing;
    return meta ? meta.selectedIndex : null;
}
exports.editorSelectedCommandIndex = editorSelectedCommandIndex;
function editorCommandCount(state) {
    const { commands } = state.editor.editing;
    return commands.length;
}
exports.editorCommandCount = editorCommandCount;
function entryNodeToFileNodeData(entryNode, getClassName, getFolded) {
    return ts_utils_1.treeMap((entryData, paths) => {
        return {
            id: entryData.fullPath,
            type: entryData.isFile ? tree_file_1.FileNodeType.File : tree_file_1.FileNodeType.Folder,
            level: paths.length,
            selected: false,
            name: entryData.name,
            entryPath: entryData.fullPath,
            folded: getFolded(entryData),
            className: getClassName(entryData)
        };
    }, entryNode);
}
exports.entryNodeToFileNodeData = entryNodeToFileNodeData;
exports.getEditor = (state) => state.editor;
exports.getMacroFolderStructure = reselect_1.createSelector([exports.getEditor], (editor) => {
    return editor.macroFolderStructure;
});
exports.getMacrosExtra = reselect_1.createSelector([exports.getEditor], (editor) => {
    return editor.macrosExtra;
});
exports.getMacroFileNodeData = reselect_1.createSelector([
    exports.getMacroFolderStructure,
    exports.getMacrosExtra,
    exports.getCurrentMacroId,
    exports.isFocusOnSidebar,
], (macroFolderStructure, macrosExtra, macroId, sidebarFocused) => {
    const getClassName = (data) => {
        const klasses = [];
        const id = data.fullPath;
        const status = macrosExtra[id] && macrosExtra[id].status;
        klasses.push((() => {
            switch (status) {
                case macro_extra_data_1.MacroResultStatus.Success:
                    return 'success';
                case macro_extra_data_1.MacroResultStatus.Error:
                    return 'error';
                case macro_extra_data_1.MacroResultStatus.ErrorInSub:
                    return 'error-in-sub';
                default:
                    return 'normal';
            }
        })());
        if (macroId === id) {
            klasses.push('selected');
        }
        if (!sidebarFocused) {
            klasses.push('blur');
        }
        return klasses.join(' ');
    };
    const getFolded = (data) => {
        const id = data.fullPath;
        const folded = macrosExtra[id] && macrosExtra[id].folded || false;
        return folded;
    };
    return macroFolderStructure.map((node) => {
        return entryNodeToFileNodeData(node, getClassName, getFolded);
    });
});
exports.getFilteredMacroFileNodeData = reselect_1.createSelector([
    exports.getMacroFileNodeData,
    (state) => state.macroQuery
], (macroFileNodeData, searchText) => {
    const trimSearchText = searchText.trim().toLowerCase();
    const filteredFileNodeData = (() => {
        if (trimSearchText.length === 0) {
            return macroFileNodeData;
        }
        return macroFileNodeData.map((node) => {
            const filteredNode = ts_utils_1.treeFilter((data) => data.name.toLowerCase().indexOf(trimSearchText) !== -1, node);
            if (!filteredNode) {
                return null;
            }
            return ts_utils_1.treeMap((data) => (Object.assign(Object.assign({}, data), { folded: false })), filteredNode);
        })
            .filter(node => node);
    })();
    return filteredFileNodeData;
});
exports.getMacroFileNodeList = reselect_1.createSelector([exports.getMacroFolderStructure], (macroFolderStructure) => {
    const findAllMacros = (root) => {
        const result = [];
        ts_utils_1.traverseTree((node) => {
            if (node.isFile) {
                result.push(node);
            }
            return ts_utils_1.TraverseTreeResult.Normal;
        }, root);
        return result;
    };
    return ts_utils_1.flatten(macroFolderStructure.map(findAllMacros));
});
exports.getMacroFolderNodeList = reselect_1.createSelector([exports.getMacroFolderStructure], (macroFolderStructure) => {
    const findAllFolders = (root) => {
        const result = [];
        ts_utils_1.traverseTree((node) => {
            if (node.isDirectory) {
                result.push(node);
            }
            return ts_utils_1.TraverseTreeResult.Normal;
        }, root);
        return result;
    };
    return ts_utils_1.flatten(macroFolderStructure.map(findAllFolders));
});
exports.isMacroFolderNodeListEmpty = reselect_1.createSelector([exports.getMacroFolderNodeList], (entries) => {
    return entries.length === 0;
});
exports.getIndexToInsertRecorded = reselect_1.createSelector([
    (state) => state.editor.editing.meta.indexToInsertRecorded
], ts_utils_1.id);
exports.getStatus = reselect_1.createSelector([(state) => state.status], ts_utils_1.id);
exports.getShouldLoadResources = reselect_1.createSelector([(state) => state.from], (from) => from === state_1.RunBy.Manual);
exports.isPlaying = reselect_1.createSelector([exports.getStatus, ts_utils_1.id], (appStatus, state) => {
    return appStatus === constant_1.APP_STATUS.PLAYER && state.player.status === constant_1.PLAYER_STATUS.PLAYING;
});
exports.isNoDisplay = reselect_1.createSelector([exports.isPlaying, ts_utils_1.id], (isPlaying, state) => {
    return isPlaying && state.noDisplayInPlay;
});


/***/ }),

/***/ 16112:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initialState = exports.newTestCaseEditing = exports.FocusArea = exports.stringForRunBy = exports.RunBy = void 0;
const C = __importStar(__webpack_require__(43232));
var RunBy;
(function (RunBy) {
    RunBy["Html"] = "html";
    RunBy["Bookmark"] = "bookmark";
    RunBy["Manual"] = "manual";
})(RunBy = exports.RunBy || (exports.RunBy = {}));
function stringForRunBy(type) {
    switch (type) {
        case RunBy.Bookmark:
            return 'bookmark';
        case RunBy.Html:
            return 'command line';
        case RunBy.Manual:
            return 'manual';
    }
}
exports.stringForRunBy = stringForRunBy;
var FocusArea;
(function (FocusArea) {
    FocusArea["Unknown"] = "unknown";
    FocusArea["Sidebar"] = "sidebar";
    FocusArea["CommandTable"] = "command_table";
    FocusArea["CodeSource"] = "code_source";
})(FocusArea = exports.FocusArea || (exports.FocusArea = {}));
exports.newTestCaseEditing = {
    commands: [],
    meta: {
        src: null,
        hasUnsaved: true,
        selectedIndex: -1
    }
};
// * editor
//    * testCases:          all test cases stored in indexedDB
//    * editing:            the current test cases being edited
//    * clipbard            for copy / cut / paste
//
// * player                 the state for player
//    * nextCommandIndex    the current command beging executed
//    * currentLoop         the current round
//    * loops               how many rounds to run totally
exports.initialState = {
    status: C.APP_STATUS.NORMAL,
    recorderStatus: C.RECORDER_STATUS.STOPPED,
    inspectorStatus: C.INSPECTOR_STATUS.STOPPED,
    isLoadingMacros: false,
    from: RunBy.Manual,
    noDisplayInPlay: false,
    editor: {
        testSuites: [],
        testCases: [],
        currentMacro: null,
        // macrosExtra is used to store:
        // * status
        // * breakpoints
        // * doneCommandIndices
        // * errorCommandIndices
        // * warningCommandIndices
        macrosExtra: {},
        // `macroFolderStructure` just holds folder and path info,
        // while macro content is still in `testCases`.
        // Similar case for `testSuitesFolderStructure`
        macroFolderStructure: [],
        testSuitesExtra: {},
        testSuitesFolderStructure: [],
        editing: Object.assign({}, exports.newTestCaseEditing),
        editingSource: {
            // Saved version
            original: null,
            // Version before editing
            pure: null,
            // Version keeping track of any editing
            current: null,
            error: null
        },
        clipboard: {
            commands: []
        },
        activeTab: 'table_view',
        isDraggingCommand: false
    },
    player: {
        mode: C.PLAYER_MODE.TEST_CASE,
        status: C.PLAYER_STATUS.STOPPED,
        stopReason: null,
        currentLoop: 0,
        loops: 0,
        nextCommandIndex: null,
        playInterval: 0,
        timeoutStatus: {
            type: null,
            total: null,
            past: null
        }
    },
    recorder: {
        skipOpen: false
    },
    variables: [],
    logs: [],
    screenshots: [],
    csvs: [],
    visions: [],
    config: {},
    proxy: null,
    ui: {
        focusArea: FocusArea.Unknown
    },
    macroQuery: ''
};


/***/ }),

/***/ 94826:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getScreenshotInSearchArea = exports.saveDataUrlToLastDesktopScreenshot = exports.saveDataUrlToLastScreenshot = exports.saveDataUrlToScreenshot = exports.searchVision = void 0;
const utils_1 = __webpack_require__(63370);
const cv_utils_1 = __webpack_require__(21063);
const tab_utils_1 = __webpack_require__(96836);
const storage_1 = __webpack_require__(16058);
const xdesktop_1 = __webpack_require__(91255);
const desktop_1 = __webpack_require__(1885);
const types_1 = __webpack_require__(34322);
const capture_screenshot_1 = __webpack_require__(89145);
const C = __importStar(__webpack_require__(43232));
const global_state_1 = __webpack_require__(13426);
const tab_1 = __webpack_require__(65277);
function searchVision(args) {
    const { visionFileName, minSimilarity, searchArea = 'full', storedImageRect, command, cvScope, devicePixelRatio, captureScreenshotService } = args;
    const commandExtra = command.extra || {};
    const requireGreenPinkBoxes = !!commandExtra.relativeVisual;
    const enableGreenPinkBoxes = typeof commandExtra.relativeVisual === 'boolean' ? commandExtra.relativeVisual : /_relative\.png$/i.test(visionFileName);
    const patternDpi = utils_1.dpiFromFileName(visionFileName) || 96;
    const pageDpi = utils_1.getPageDpi();
    const pStorageMan = Promise.resolve(storage_1.getStorageManager());
    const getPatternImage = (fileName) => {
        return pStorageMan.then(storageMan => {
            const visionStorage = storageMan.getVisionStorage();
            return visionStorage.exists(fileName)
                .then(existed => {
                if (!existed)
                    throw new Error(`Error #121: ${command.cmd}: No input image found for file name '${fileName}'`);
                return visionStorage.read(fileName, 'DataURL');
            });
        });
    };
    if (minSimilarity < 0.1 || minSimilarity > 1.0) {
        throw new Error('confidence should be between 0.1 and 1.0');
    }
    const isFullScreenshot = (searchArea !== 'rect' && !/\.png/i.test(searchArea)) || !storedImageRect;
    // Note: storedImageRect is supposed to be also returned by this API call
    // thus it is scaled down by (1 / window.devicePixelRatio),
    // we should recover coordiates to screen pixels
    const searchAreaRect = isFullScreenshot ? undefined : {
        x: window.devicePixelRatio * storedImageRect.x,
        y: window.devicePixelRatio * storedImageRect.y,
        width: window.devicePixelRatio * storedImageRect.width,
        height: window.devicePixelRatio * storedImageRect.height
    };
    const pRegions = (() => {
        switch (cvScope) {
            case 'desktop': {
                return xdesktop_1.getXDesktop().sanityCheck()
                    .then(() => getPatternImage(visionFileName))
                    .then(dataUrl => desktop_1.getNativeCVAPI().getImageFromDataUrl(dataUrl, patternDpi))
                    .then(imageObj => {
                    return desktop_1.getNativeCVAPI().searchDesktopWithGuard({
                        pattern: imageObj,
                        options: {
                            minSimilarity,
                            enableGreenPinkBoxes,
                            requireGreenPinkBoxes,
                            searchArea: searchAreaRect,
                            enableHighDpi: true,
                            allowSizeVariation: true,
                            saveCaptureOnDisk: true,
                            limitSearchArea: !isFullScreenshot
                        }
                    })
                        .then(result => {
                        return desktop_1.getNativeCVAPI().readFileAsDataURL(result.capturePath, true)
                            .then(dataUrl => {
                            return saveDataUrlToLastDesktopScreenshot(dataUrl)
                                // Note: convert coordinates to CSS pixels
                                .then(() => desktop_1.convertImageSearchResultIfAllCoordiatesBasedOnTopLeftScreen(result, 1 / window.devicePixelRatio, searchAreaRect));
                        });
                    });
                });
            }
            case 'browser':
            default:
                return xdesktop_1.getXDesktop().sanityCheck()
                    .then(() => Promise.all([
                    // DPI is bound to window.devicePixelRatio, here scale both pattern image and screenshot image to the page DPI
                    // so if it's a retina device, the image sizes here are 2x of the css size
                    getPatternImage(visionFileName).then(dataUrl => capture_screenshot_1.scaleDataURI(dataUrl, pageDpi / patternDpi)),
                    getScreenshotInSearchArea({ searchArea, storedImageRect, devicePixelRatio, captureScreenshotService, dpiScale: 1 })
                ]))
                    .then(([patternImageUrl, targetImageInfo]) => __awaiter(this, void 0, void 0, function* () {
                    const targetImageUrl = targetImageInfo.dataUrl;
                    const pageOffset = targetImageInfo.offset;
                    const viewportOffset = targetImageInfo.viewportOffset;
                    const patternImage = yield desktop_1.getNativeCVAPI().getImageFromDataUrl(patternImageUrl, patternDpi);
                    const screenshotImage = yield desktop_1.getNativeCVAPI().getImageFromDataUrl(targetImageUrl, patternDpi);
                    const searchResult = yield desktop_1.getNativeCVAPI().searchImageWithGuard({
                        image: screenshotImage,
                        pattern: patternImage,
                        options: {
                            minSimilarity,
                            enableGreenPinkBoxes,
                            requireGreenPinkBoxes,
                            searchArea: searchAreaRect,
                            enableHighDpi: true,
                            allowSizeVariation: true,
                            saveCaptureOnDisk: true,
                            limitSearchArea: !isFullScreenshot
                        }
                    });
                    // Resize all cooridinates from screen based to css based
                    return desktop_1.convertImageSearchResultForPage(searchResult, 1 / window.devicePixelRatio, pageOffset, viewportOffset);
                    // return searchImage({
                    //   targetImageUrl,
                    //   minSimilarity,
                    //   enableGreenPinkBoxes,
                    //   requireGreenPinkBoxes,
                    //   patternImageUrl: patternImageUrl as string,
                    //   allowSizeVariation: true,
                    //   scaleDownRatio: dpiScale * window.devicePixelRatio,
                    //   pageOffsetX: pageOffset.x || 0,
                    //   pageOffsetY: pageOffset.y || 0,
                    //   viewportOffsetX: viewportOffset.x || 0,
                    //   viewportOffsetY: viewportOffset.y || 0
                    // })
                    // .then(regions => regions.map(matched => ({ matched, reference: null })))
                }));
        }
    })();
    return pRegions.then(regions => {
        return {
            regions,
            imageInfo: {
                source: types_1.DesktopScreenshot.ImageSource.Storage,
                path: utils_1.ensureExtName('.png', cv_utils_1.isCVTypeForDesktop(cvScope) ? C.LAST_DESKTOP_SCREENSHOT_FILE_NAME : C.LAST_SCREENSHOT_FILE_NAME)
            }
        };
    });
}
exports.searchVision = searchVision;
function saveDataUrlToScreenshot(fileName, dataUrl) {
    return storage_1.getStorageManager()
        .getScreenshotStorage()
        .overwrite(utils_1.ensureExtName('.png', fileName), utils_1.dataURItoBlob(dataUrl));
    // TODO:
    // getPanelTabIpc()
    // .then(panelIpc => {
    //   return panelIpc.ask('RESTORE_SCREENSHOTS')
    // })
}
exports.saveDataUrlToScreenshot = saveDataUrlToScreenshot;
function saveDataUrlToLastScreenshot(dataUrl) {
    return saveDataUrlToScreenshot(C.LAST_SCREENSHOT_FILE_NAME, dataUrl);
}
exports.saveDataUrlToLastScreenshot = saveDataUrlToLastScreenshot;
function saveDataUrlToLastDesktopScreenshot(dataUrl) {
    return saveDataUrlToScreenshot(C.LAST_DESKTOP_SCREENSHOT_FILE_NAME, dataUrl);
}
exports.saveDataUrlToLastDesktopScreenshot = saveDataUrlToLastDesktopScreenshot;
function getScreenshotInSearchArea({ searchArea, storedImageRect, dpiScale, devicePixelRatio, captureScreenshotService }) {
    // Take png searh area as rect, it should have set `storedImageRect` in advance
    if (/\.png/.test(searchArea)) {
        searchArea = 'rect';
    }
    const capture = (ipc, tabId) => {
        switch (searchArea) {
            case 'viewport':
                return Promise.all([
                    ipc.ask('SCREENSHOT_PAGE_INFO', {}, C.CS_IPC_TIMEOUT),
                    captureScreenshotService.captureScreen(tabId, devicePixelRatio)
                ])
                    .then(([pageInfo, dataUrl]) => {
                    saveDataUrlToLastScreenshot(dataUrl);
                    return {
                        offset: {
                            x: pageInfo.originalX,
                            y: pageInfo.originalY
                        },
                        viewportOffset: {
                            x: 0,
                            y: 0
                        },
                        dataUrl
                    };
                });
            case 'full': {
                return Promise.all([
                    ipc.ask('SCREENSHOT_PAGE_INFO', {}, C.CS_IPC_TIMEOUT),
                    captureScreenshotService.captureFullScreen(tabId, {
                        startCapture: () => {
                            return ipc.ask('START_CAPTURE_FULL_SCREENSHOT', {}, C.CS_IPC_TIMEOUT);
                        },
                        endCapture: (pageInfo) => {
                            return ipc.ask('END_CAPTURE_FULL_SCREENSHOT', { pageInfo }, C.CS_IPC_TIMEOUT);
                        },
                        scrollPage: (offset) => {
                            return ipc.ask('SCROLL_PAGE', { offset }, C.CS_IPC_TIMEOUT);
                        }
                    })
                ])
                    .then(([pageInfo, dataUrl]) => {
                    saveDataUrlToLastScreenshot(dataUrl);
                    return {
                        dataUrl,
                        offset: {
                            x: 0,
                            y: 0
                        },
                        viewportOffset: {
                            x: -1 * pageInfo.originalX,
                            y: -1 * pageInfo.originalY
                        }
                    };
                });
            }
            case 'rect': {
                // Note: in this mode, `storedImageRect` is viewport based coordinates
                if (!storedImageRect) {
                    throw new Error('rect mode: !storedImageRect should not be empty');
                }
                return ipc.ask('SCREENSHOT_PAGE_INFO')
                    .then((pageInfo) => {
                    return captureScreenshotService.captureScreenInSelectionSimple(tabId, {
                        rect: storedImageRect,
                        devicePixelRatio: pageInfo.devicePixelRatio
                    })
                        .then((dataUrl) => {
                        saveDataUrlToLastScreenshot(dataUrl);
                        return ({
                            dataUrl,
                            offset: {
                                x: storedImageRect.x + pageInfo.originalX,
                                y: storedImageRect.y + pageInfo.originalY
                            },
                            viewportOffset: {
                                x: storedImageRect.x,
                                y: storedImageRect.y
                            }
                        });
                    });
                });
            }
            default: {
                if (/^element:/i.test(searchArea)) {
                    // Note: in this mode, `storedImageRect` is document based coordinates
                    if (!storedImageRect) {
                        throw new Error('!storedImageRect should not be empty');
                    }
                    const fileName = utils_1.ensureExtName('.png', C.LAST_SCREENSHOT_FILE_NAME);
                    return Promise.all([
                        ipc.ask('SCREENSHOT_PAGE_INFO', {}, C.CS_IPC_TIMEOUT),
                        storage_1.getStorageManager()
                            .getScreenshotStorage()
                            .read(fileName, 'DataURL')
                    ])
                        .then(([pageInfo, dataUrl]) => {
                        return {
                            dataUrl,
                            offset: {
                                x: storedImageRect.x,
                                y: storedImageRect.y
                            },
                            viewportOffset: {
                                x: storedImageRect.x - pageInfo.originalX,
                                y: storedImageRect.y - pageInfo.originalY
                            }
                        };
                    });
                }
                throw new Error(`Unsupported searchArea '${searchArea}'`);
            }
        }
    };
    return Promise.all([tab_1.getPlayTabIpc(), global_state_1.getState()])
        .then(([ipc, state]) => {
        const toPlayTabId = state.tabIds.toPlay;
        return tab_utils_1.activateTab(toPlayTabId, true)
            .then(() => utils_1.delay(() => { }, C.SCREENSHOT_DELAY))
            .then(() => capture(ipc, toPlayTabId))
            .then(obj => {
            return capture_screenshot_1.scaleDataURI(obj.dataUrl, dpiScale)
                .then(dataUrl => ({
                dataUrl,
                offset: obj.offset,
                viewportOffset: obj.viewportOffset
            }));
        });
    });
}
exports.getScreenshotInSearchArea = getScreenshotInSearchArea;


/***/ }),

/***/ 97551:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkLicense = exports.convertToLicenseInfo = exports.isNetworkError = void 0;
const axios_1 = __importDefault(__webpack_require__(9669));
const config_1 = __importDefault(__webpack_require__(62275));
const ts_utils_1 = __webpack_require__(55452);
function isNetworkError(error) {
    return error.message === 'Network Error';
}
exports.isNetworkError = isNetworkError;
function convertToLicenseInfo(result, licenseKey) {
    switch (result.status) {
        case 'key_not_found':
            return { licenseKey, status: 'key_not_found' };
        case 'off':
            return { licenseKey, status: 'off', type: result.product };
        case 'on':
            return {
                licenseKey,
                status: 'on',
                type: result.product,
                name: result.data1a,
                upgradeUrl: result.data1b,
                maxOcrCalls: parseInt(result.data2b)
            };
    }
}
exports.convertToLicenseInfo = convertToLicenseInfo;
function checkLicense(params) {
    const url = ts_utils_1.urlWithQueries(config_1.default.license.api.url, {
        version: params.version,
        licensekey: params.licenseKey
    });
    return axios_1.default.get(url).then(res => {
        const result = res.data;
        return convertToLicenseInfo(result, params.licenseKey);
    })
        .catch((e) => {
        if (e.response) {
            throw new Error(e.response.data);
        }
        return Promise.reject(e);
    });
}
exports.checkLicense = checkLicense;


/***/ }),

/***/ 26997:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.backup = void 0;
const file_saver_1 = __importDefault(__webpack_require__(18187));
const jszip_1 = __importDefault(__webpack_require__(55733));
const utils_1 = __webpack_require__(63370);
const convert_utils_1 = __webpack_require__(61169);
const convert_suite_utils_1 = __webpack_require__(36832);
const storage_1 = __webpack_require__(16058);
const path_1 = __webpack_require__(84037);
const common_1 = __webpack_require__(50554);
function backup(options) {
    const { backup, macroNodes, testSuites, screenshots, csvs, visions } = options;
    const zip = new jszip_1.default();
    const ps = [];
    const getFolder = (relativePath, zipRoot) => {
        if (relativePath === '.') {
            return zipRoot;
        }
        const dirs = relativePath.split(path_1.posix.sep);
        return dirs.reduce((prev, dir) => {
            return prev.folder(dir);
        }, zipRoot);
    };
    if (backup.testCase && macroNodes && macroNodes.length) {
        const rootFolder = zip.folder(common_1.ZipFolders.Macros);
        macroNodes.forEach(node => {
            const dirPath = path_1.posix.dirname(node.relativePath);
            const fileName = path_1.posix.basename(node.relativePath);
            const folder = getFolder(dirPath, rootFolder);
            ps.push(storage_1.getStorageManager().getMacroStorage().read(node.fullPath, 'Text')
                .then((data) => {
                const macro = data;
                folder.file(fileName, convert_utils_1.toJSONString({
                    name: macro.name,
                    commands: macro.data.commands
                }, {
                    ignoreTargetOptions: !!options.ignoreMacroTargetOptions
                }));
            }));
        });
    }
    if (backup.testSuite && testSuites && testSuites.length) {
        const folder = zip.folder(common_1.ZipFolders.TestSuites);
        const genName = utils_1.nameFactory();
        testSuites.forEach(ts => {
            const name = genName(ts.name);
            folder.file(`${name}.json`, convert_suite_utils_1.stringifyTestSuite(ts));
        });
    }
    if (backup.screenshot && screenshots && screenshots.length) {
        const folder = zip.folder(common_1.ZipFolders.Screenshots);
        const ssStorage = storage_1.getStorageManager().getScreenshotStorage();
        screenshots.forEach(ss => {
            ps.push(ssStorage.read(ss.fullPath, 'ArrayBuffer')
                .then(buffer => {
                folder.file(ss.name, buffer, { binary: true });
            }));
        });
    }
    if (backup.vision && visions && visions.length) {
        const folder = zip.folder(common_1.ZipFolders.Visions);
        const visionStorage = storage_1.getStorageManager().getVisionStorage();
        visions.forEach(vision => {
            ps.push(visionStorage.read(vision.fullPath, 'ArrayBuffer')
                .then(buffer => {
                folder.file(vision.name, buffer, { binary: true });
            }));
        });
    }
    if (backup.csv && csvs && csvs.length) {
        const folder = zip.folder(common_1.ZipFolders.Csvs);
        const csvStorage = storage_1.getStorageManager().getCSVStorage();
        csvs.forEach(csv => {
            ps.push(csvStorage.read(csv.fullPath, 'Text')
                .then(text => folder.file(csv.name, text)));
        });
    }
    return Promise.all(ps)
        .then(() => {
        zip.generateAsync({ type: 'blob' })
            .then(function (blob) {
            file_saver_1.default.saveAs(blob, 'uivision_backup.zip');
        });
    });
}
exports.backup = backup;


/***/ }),

/***/ 50554:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZipFolders = void 0;
var ZipFolders;
(function (ZipFolders) {
    ZipFolders["Macros"] = "macros";
    ZipFolders["TestSuites"] = "testsuites";
    ZipFolders["Screenshots"] = "screenshots";
    ZipFolders["Csvs"] = "datasources";
    ZipFolders["Visions"] = "images";
})(ZipFolders = exports.ZipFolders || (exports.ZipFolders = {}));


/***/ }),

/***/ 58238:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getStorageAndPath = exports.sortZipObjects = exports.sortZipObjectsInline = exports.restoreBackup = void 0;
const jszip_1 = __importDefault(__webpack_require__(55733));
const storage_1 = __webpack_require__(16058);
const ts_utils_1 = __webpack_require__(55452);
const convert_utils_1 = __webpack_require__(61169);
const common_1 = __webpack_require__(50554);
function restoreBackup(options) {
    const storageManager = storage_1.getStorageManager(options.storage);
    return jszip_1.default.loadAsync(options.file)
        .then(zip => {
        // 0. sort entries by folder/file, name
        // 1. Find all folders that is in valid root, create them one by one if not exists
        // 2. Find all files, write into storage
        const fileZipObjects = [];
        const folderZipObjects = [];
        zip.forEach((_, obj) => {
            if (obj.dir) {
                folderZipObjects.push(obj);
            }
            else {
                fileZipObjects.push(obj);
            }
        });
        sortZipObjectsInline(fileZipObjects);
        sortZipObjectsInline(folderZipObjects);
        const createAllFolders = () => {
            return ts_utils_1.flow(...folderZipObjects.map(obj => {
                const res = getStorageAndPath({
                    manager: storageManager,
                    path: obj.name
                });
                if (!res || res.relativePath === '.' || res.relativePath === '') {
                    return () => Promise.resolve();
                }
                return () => {
                    return res.storage.directoryExists(res.relativePath)
                        .then(exists => {
                        if (exists) {
                            return;
                        }
                        return res.storage.createDirectory(res.relativePath)
                            .then(() => { });
                    });
                };
            }));
        };
        const createAllFiles = () => {
            return ts_utils_1.flow(...fileZipObjects.map(obj => {
                const res = getStorageAndPath({
                    manager: storageManager,
                    path: obj.name
                });
                if (!res) {
                    return () => Promise.resolve();
                }
                switch (res.target) {
                    case storage_1.StorageTarget.Macro: {
                        return () => {
                            return obj.async('text')
                                .then(text => {
                                return res.storage.write(res.relativePath, convert_utils_1.fromJSONString(text));
                            })
                                .then(() => res.target);
                        };
                    }
                    case storage_1.StorageTarget.Screenshot:
                    case storage_1.StorageTarget.Vision:
                    case storage_1.StorageTarget.CSV: {
                        return () => {
                            return obj.async('blob')
                                .then(blob => {
                                return res.storage.write(res.relativePath, blob);
                            })
                                .then(() => res.target);
                        };
                    }
                    default: {
                        return () => Promise.resolve();
                    }
                }
            }))
                .then(results => {
                return {
                    count: {
                        macro: results.filter((x) => x === storage_1.StorageTarget.Macro).length,
                        testSuite: results.filter((x) => x === storage_1.StorageTarget.TestSuite).length,
                        screenshot: results.filter((x) => x === storage_1.StorageTarget.Screenshot).length,
                        vision: results.filter((x) => x === storage_1.StorageTarget.Vision).length,
                        csv: results.filter((x) => x === storage_1.StorageTarget.CSV).length
                    }
                };
            });
        };
        return createAllFolders().then(createAllFiles);
    });
}
exports.restoreBackup = restoreBackup;
function sortZipObjectsInline(list) {
    list.sort((a, b) => {
        if (a.name < b.name) {
            return -1;
        }
        if (a.name > b.name) {
            return 1;
        }
        return 0;
    });
}
exports.sortZipObjectsInline = sortZipObjectsInline;
function sortZipObjects(list) {
    const result = [...list];
    sortZipObjectsInline(result);
    return result;
}
exports.sortZipObjects = sortZipObjects;
function getStorageAndPath(options) {
    const DELIM = '/';
    const parts = options.path.split(DELIM).filter(part => part !== '.');
    const subPath = parts.slice(1).join(DELIM);
    const isDir = parts[parts.length - 1] === '';
    const [storage, target] = (() => {
        switch (parts[0]) {
            case common_1.ZipFolders.Macros:
                return [options.manager.getMacroStorage(), storage_1.StorageTarget.Macro];
            case common_1.ZipFolders.TestSuites:
                return [options.manager.getTestSuiteStorage(), storage_1.StorageTarget.TestSuite];
            case common_1.ZipFolders.Csvs:
                return [options.manager.getCSVStorage(), storage_1.StorageTarget.CSV];
            case common_1.ZipFolders.Screenshots:
                return [options.manager.getScreenshotStorage(), storage_1.StorageTarget.Screenshot];
            case common_1.ZipFolders.Visions:
                return [options.manager.getVisionStorage(), storage_1.StorageTarget.Vision];
            default:
                return [null, null];
        }
    })();
    if (!storage) {
        return null;
    }
    return {
        storage: storage,
        target: target,
        dir: isDir,
        relativePath: subPath
    };
}
exports.getStorageAndPath = getStorageAndPath;


/***/ }),

/***/ 38801:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyValueData = exports.parseKey = void 0;
const storage_1 = __importDefault(__webpack_require__(67585));
const ts_utils_1 = __webpack_require__(55452);
function parseKey(key) {
    return key.split('::').filter(s => s.length > 0);
}
exports.parseKey = parseKey;
class KeyValueData {
    constructor() {
        this.withOneLock = ts_utils_1.concurrent(1)((run) => {
            return new Promise((resolve, reject) => {
                try {
                    Promise.resolve(run()).then(resolve, reject);
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    }
    get(key) {
        const [mainKey, subKeys] = this.getMainKeyAndSubKeys(key);
        return storage_1.default.get(mainKey)
            .then((data = {}) => {
            const result = ts_utils_1.getIn(subKeys, data);
            return result;
        });
    }
    set(key, value) {
        return this.withOneLock(() => {
            const [mainKey, subKeys] = this.getMainKeyAndSubKeys(key);
            return storage_1.default.get(mainKey)
                .then((data = {}) => {
                const updated = ts_utils_1.safeSetIn(subKeys, value, data);
                return storage_1.default.set(mainKey, updated)
                    .then(() => ts_utils_1.getIn(subKeys, updated));
            });
        });
    }
    update(key, updater) {
        return this.withOneLock(() => {
            const [mainKey, subKeys] = this.getMainKeyAndSubKeys(key);
            return storage_1.default.get(mainKey)
                .then((data = {}) => {
                const updated = ts_utils_1.safeUpdateIn(subKeys, updater, data);
                return storage_1.default.set(mainKey, updated)
                    .then(() => ts_utils_1.getIn(subKeys, updated));
            });
        });
    }
    getMainKeyAndSubKeys(key) {
        const keys = parseKey(key);
        const mainKey = keys[0];
        const subKeys = keys.slice(1);
        return [mainKey, subKeys];
    }
}
exports.KeyValueData = KeyValueData;


/***/ }),

/***/ 24577:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMacroExtraKeyValueData = exports.MacroExtraKeyValueData = exports.MacroResultStatus = void 0;
const common_1 = __webpack_require__(38801);
const ts_utils_1 = __webpack_require__(55452);
var MacroResultStatus;
(function (MacroResultStatus) {
    MacroResultStatus["Normal"] = "NORMAL";
    MacroResultStatus["Success"] = "SUCCESS";
    MacroResultStatus["Error"] = "ERROR";
    MacroResultStatus["ErrorInSub"] = "ERROR_IN_SUB";
})(MacroResultStatus = exports.MacroResultStatus || (exports.MacroResultStatus = {}));
class MacroExtraKeyValueData extends common_1.KeyValueData {
    getAll() {
        return super.get("");
    }
    getMainKeyAndSubKeys(key) {
        const [mainKey, subKeys] = super.getMainKeyAndSubKeys(key);
        return [
            MacroExtraKeyValueData.STORAGE_KEY,
            [mainKey].concat(subKeys).filter(x => x && x.length)
        ];
    }
}
exports.MacroExtraKeyValueData = MacroExtraKeyValueData;
MacroExtraKeyValueData.STORAGE_KEY = 'macro_extra';
exports.getMacroExtraKeyValueData = ts_utils_1.singletonGetter(() => new MacroExtraKeyValueData());


/***/ }),

/***/ 38411:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMigrationKeyValueData = exports.MigrationKeyValueData = void 0;
const common_1 = __webpack_require__(38801);
const ts_utils_1 = __webpack_require__(55452);
class MigrationKeyValueData extends common_1.KeyValueData {
    getAll() {
        return super.get("");
    }
    getMainKeyAndSubKeys(key) {
        const [mainKey, subKeys] = super.getMainKeyAndSubKeys(key);
        return [
            MigrationKeyValueData.STORAGE_KEY,
            [mainKey].concat(subKeys).filter(x => x && x.length)
        ];
    }
}
exports.MigrationKeyValueData = MigrationKeyValueData;
MigrationKeyValueData.STORAGE_KEY = 'migration_records';
exports.getMigrationKeyValueData = ts_utils_1.singletonGetter(() => new MigrationKeyValueData());


/***/ }),

/***/ 19878:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMiscData = exports.MiscData = exports.MiscKey = void 0;
const common_1 = __webpack_require__(38801);
const ts_utils_1 = __webpack_require__(55452);
var MiscKey;
(function (MiscKey) {
    MiscKey["BrowserModeLastMacroId"] = "browser_mode_last_macro_id";
    MiscKey["XFileModeLastMacroId"] = "xfile_mode_last_macro_id";
})(MiscKey = exports.MiscKey || (exports.MiscKey = {}));
class MiscData extends common_1.KeyValueData {
    getMainKeyAndSubKeys(key) {
        const [mainKey, subKeys] = super.getMainKeyAndSubKeys(key);
        return [
            MiscData.STORAGE_KEY,
            [mainKey].concat(subKeys).filter(x => x && x.length)
        ];
    }
}
exports.MiscData = MiscData;
MiscData.STORAGE_KEY = 'misc_data';
exports.getMiscData = ts_utils_1.singletonGetter(() => new MiscData());


/***/ }),

/***/ 34945:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTestSuiteExtraKeyValueData = exports.TestSuiteExtraKeyValueData = void 0;
const common_1 = __webpack_require__(38801);
const ts_utils_1 = __webpack_require__(55452);
class TestSuiteExtraKeyValueData extends common_1.KeyValueData {
    getAll() {
        return super.get("");
    }
    getMainKeyAndSubKeys(key) {
        const [mainKey, subKeys] = super.getMainKeyAndSubKeys(key);
        return [
            TestSuiteExtraKeyValueData.STORAGE_KEY,
            [mainKey].concat(subKeys).filter(x => x && x.length)
        ];
    }
}
exports.TestSuiteExtraKeyValueData = TestSuiteExtraKeyValueData;
TestSuiteExtraKeyValueData.STORAGE_KEY = 'test_suite_extra';
exports.getTestSuiteExtraKeyValueData = ts_utils_1.singletonGetter(() => new TestSuiteExtraKeyValueData());


/***/ }),

/***/ 53678:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLicenseService = void 0;
const web_extension_1 = __importDefault(__webpack_require__(61171));
const storage_1 = __importDefault(__webpack_require__(67585));
const ts_utils_1 = __webpack_require__(55452);
const service_1 = __webpack_require__(53468);
const actions_1 = __webpack_require__(97876);
exports.getLicenseService = ts_utils_1.singletonGetter(() => {
    return new service_1.LicenseService({
        getVersion: () => {
            return Promise.resolve(web_extension_1.default.runtime.getManifest().version);
        },
        getLegacyXModuleStatus: () => {
            return window['store'].getState().config.xmodulesStatus;
        },
        setLegacyXModuleStatus: (status) => {
            return Promise.resolve(window['store'].dispatch(actions_1.updateConfig({ xmodulesStatus: status })));
        },
        save: (license) => {
            return storage_1.default.set(service_1.LicenseService.StorageKey, license).then(() => { });
        },
        read: () => {
            return storage_1.default.get(service_1.LicenseService.StorageKey).then(license => license !== null && license !== void 0 ? license : null);
        }
    });
});


/***/ }),

/***/ 53468:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LicenseService = void 0;
const types_1 = __webpack_require__(10714);
const HttpAPI = __importStar(__webpack_require__(97551));
const config_1 = __importDefault(__webpack_require__(62275));
class LicenseService {
    constructor(params) {
        this.params = params;
        this.license = null;
        this.getLatestInfo();
    }
    get legacyXModuleStatus() {
        return this.params.getLegacyXModuleStatus();
    }
    checkLicense(licenseKey) {
        return this.params.getVersion().then(version => {
            return HttpAPI.checkLicense({
                licenseKey,
                version
            });
        })
            .then(license => {
            // Only persist valid license
            if (license.status === 'key_not_found') {
                return license;
            }
            this.license = license;
            return Promise.all([
                this.params.save(license),
                this.params.setLegacyXModuleStatus('checked_by_remote')
            ])
                .then(() => license);
        });
    }
    recheckLicenseIfPossible() {
        var _a;
        if (this.legacyXModuleStatus !== 'checked_by_remote' || !this.license) {
            return Promise.resolve(false);
        }
        return this.checkLicense((_a = this.license) === null || _a === void 0 ? void 0 : _a.licenseKey).then(() => true);
    }
    getLatestInfo() {
        return Promise.all([
            this.params.read()
        ])
            .then(tuple => {
            this.license = tuple[0];
            return tuple[0];
        });
    }
    canPerform(feature) {
        var _a;
        if (this.legacyXModuleStatus !== 'checked_by_remote') {
            return true;
        }
        const licenseType = (_a = this.license.type) !== null && _a !== void 0 ? _a : types_1.LicenseType.Personal;
        switch (licenseType) {
            case types_1.LicenseType.Enterprise:
            case types_1.LicenseType.Personal:
            case types_1.LicenseType.Pro:
                return true;
            case types_1.LicenseType.Player:
                return feature === types_1.Feature.Replay;
        }
    }
    isProLicense() {
        var _a;
        switch (this.legacyXModuleStatus) {
            case 'pro':
                return true;
            case 'checked_by_remote':
                return ((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) === 'on' &&
                    (this.license.type === types_1.LicenseType.Pro || this.license.type === types_1.LicenseType.Enterprise);
            default:
                return false;
        }
    }
    isPersonalLicense() {
        var _a;
        switch (this.legacyXModuleStatus) {
            case 'free':
                return true;
            case 'checked_by_remote':
                return ((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) === 'on' &&
                    this.license.type === types_1.LicenseType.Personal;
            default:
                return false;
        }
    }
    isPlayerLicense() {
        var _a;
        switch (this.legacyXModuleStatus) {
            case 'checked_by_remote':
                return ((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) === 'on' &&
                    this.license.type === types_1.LicenseType.Player;
            default:
                return false;
        }
    }
    hasNoLicense() {
        switch (this.legacyXModuleStatus) {
            case 'unregistered':
                return true;
            case 'checked_by_remote':
                return !this.license || this.license.status !== 'on';
            default:
                return false;
        }
    }
    isLicenseExpired() {
        var _a;
        return this.legacyXModuleStatus === 'checked_by_remote' && ((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) === 'off';
    }
    getEditionName() {
        var _a;
        if (this.legacyXModuleStatus === 'checked_by_remote' && ((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) === 'on') {
            return this.license.name;
        }
        switch (this.legacyXModuleStatus) {
            case 'free':
                return 'Personal Edition';
            case 'pro':
                return 'PRO Edition';
            case 'unregistered':
            case 'checked_by_remote':
            default:
                return 'Free Edition';
        }
    }
    getUpgradeUrl() {
        var _a;
        if (this.legacyXModuleStatus === 'checked_by_remote' && ((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) === 'on') {
            return this.license.upgradeUrl;
        }
        switch (this.legacyXModuleStatus) {
            case 'free':
                return config_1.default.xmodulesLimit.free.upgradeUrl;
            case 'pro':
                return config_1.default.xmodulesLimit.pro.upgradeUrl;
            case 'unregistered':
            case 'checked_by_remote':
            default:
                return config_1.default.xmodulesLimit.unregistered.upgradeUrl;
        }
    }
    getMaxOcrCalls() {
        var _a;
        if (this.legacyXModuleStatus === 'checked_by_remote' && ((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) === 'on') {
            return this.license.maxOcrCalls;
        }
        switch (this.legacyXModuleStatus) {
            case 'free':
                return config_1.default.xmodulesLimit.free.ocrCommandCount;
            case 'pro':
                return config_1.default.xmodulesLimit.pro.ocrCommandCount;
            case 'checked_by_remote':
            case 'unregistered':
            default:
                return config_1.default.xmodulesLimit.unregistered.ocrCommandCount;
        }
    }
    getMaxXCommandCalls() {
        const status = this.convertToLegacyStatus();
        switch (status) {
            case 'free':
                return config_1.default.xmodulesLimit.free.xCommandCount;
            case 'pro':
                return config_1.default.xmodulesLimit.pro.xCommandCount;
            case 'unregistered':
            default:
                return config_1.default.xmodulesLimit.unregistered.xCommandCount;
        }
    }
    getMaxProxyCalls() {
        const status = this.convertToLegacyStatus();
        switch (status) {
            case 'free':
                return config_1.default.xmodulesLimit.free.proxyExecCount;
            case 'pro':
                return config_1.default.xmodulesLimit.pro.proxyExecCount;
            case 'unregistered':
            default:
                return config_1.default.xmodulesLimit.unregistered.proxyExecCount;
        }
    }
    getMaxXFileMacros() {
        const status = this.convertToLegacyStatus();
        switch (status) {
            case 'free':
                return config_1.default.xmodulesLimit.free.xFileMacroCount;
            case 'pro':
                return config_1.default.xmodulesLimit.pro.xFileMacroCount;
            case 'unregistered':
            default:
                return config_1.default.xmodulesLimit.unregistered.xFileMacroCount;
        }
    }
    convertToLegacyStatus() {
        var _a;
        if (this.legacyXModuleStatus && this.legacyXModuleStatus !== 'checked_by_remote') {
            return this.legacyXModuleStatus;
        }
        if (((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) !== 'on') {
            return 'unregistered';
        }
        switch (this.license.type) {
            case types_1.LicenseType.Player:
            case types_1.LicenseType.Enterprise:
            case types_1.LicenseType.Pro:
                return 'pro';
            case types_1.LicenseType.Personal:
                return 'free';
        }
    }
}
exports.LicenseService = LicenseService;
LicenseService.StorageKey = 'a9t9';


/***/ }),

/***/ 10714:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Feature = exports.LicenseType = void 0;
var LicenseType;
(function (LicenseType) {
    LicenseType["Enterprise"] = "ui-ee";
    LicenseType["Personal"] = "ui-personal";
    LicenseType["Player"] = "ui-player";
    LicenseType["Pro"] = "ui-pro";
})(LicenseType = exports.LicenseType || (exports.LicenseType = {}));
var Feature;
(function (Feature) {
    Feature[Feature["Replay"] = 0] = "Replay";
    Feature[Feature["Record"] = 1] = "Record";
    Feature[Feature["Edit"] = 2] = "Edit";
})(Feature = exports.Feature || (exports.Feature = {}));


/***/ }),

/***/ 30399:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLogService = exports.LogService = void 0;
const filesystem_1 = __webpack_require__(65065);
const xfile_1 = __webpack_require__(1577);
const path_1 = __importDefault(__webpack_require__(84037));
const log_1 = __importDefault(__webpack_require__(77242));
const ts_utils_1 = __webpack_require__(55452);
const storage_1 = __webpack_require__(16058);
class LogService {
    constructor(params = {}) {
        this.pDirReady = Promise.resolve(false);
        this.logsDir = '';
        this.fileName = 'log.txt';
        this.waitForStorageManager = () => Promise.resolve(storage_1.getStorageManager());
        this.check();
        this.updateLogFileName();
        if (params.waitForStorageManager) {
            this.waitForStorageManager = params.waitForStorageManager;
        }
    }
    updateLogFileName() {
        const now = new Date();
        const dateStr = `${now.getFullYear()}${ts_utils_1.pad2digits(now.getMonth() + 1)}${ts_utils_1.pad2digits(now.getDate())}`;
        const timeStr = [now.getHours(), now.getMinutes(), now.getSeconds()].map(n => ts_utils_1.pad2digits(n)).join('');
        this.fileName = `log-${dateStr}-${timeStr}.txt`;
    }
    check() {
        this.pDirReady = xfile_1.getXFile().sanityCheck(true).then(isSane => {
            if (!isSane) {
                return false;
            }
            const { rootDir } = xfile_1.getXFile().getCachedConfig();
            if (!rootDir) {
                return false;
            }
            this.logsDir = path_1.default.join(rootDir, 'logs');
            return filesystem_1.getNativeFileSystemAPI().ensureDir({
                path: this.logsDir
            });
        });
        return this.pDirReady;
    }
    log(str) {
        return this.waitForStorageManager()
            .then(storageManager => {
            if (!storageManager.isXFileMode()) {
                return false;
            }
            return xfile_1.getXFile().sanityCheck(true)
                .then(() => this.pDirReady)
                .then((ready) => {
                if (!ready) {
                    return false;
                }
                return filesystem_1.getNativeFileSystemAPI().appendAllText({
                    path: path_1.default.join(this.logsDir, this.fileName),
                    content: ensureLineBreak(str)
                });
            }, (e) => {
                log_1.default.warn('Failed to log: ', e.message);
                return false;
            });
        });
    }
    logWithTime(str) {
        return this.log(`${new Date().toISOString()} - ${str}`);
    }
    logTo(filePath, str) {
        return this.waitForStorageManager()
            .then(storageManager => {
            if (!storageManager.isXFileMode()) {
                return false;
            }
            return xfile_1.getXFile().sanityCheck(true)
                .then((ready) => {
                if (!ready) {
                    return false;
                }
                const dirPath = path_1.default.dirname(filePath);
                return filesystem_1.getNativeFileSystemAPI().ensureDir({ path: dirPath })
                    .then((dirReady) => {
                    if (!dirReady) {
                        return false;
                    }
                    return filesystem_1.getNativeFileSystemAPI().appendAllText({
                        path: filePath,
                        content: ensureLineBreak(str)
                    });
                });
            }, (e) => {
                log_1.default.warn('Failed to log: ', e.message);
                return false;
            });
        });
    }
}
exports.LogService = LogService;
exports.getLogService = ts_utils_1.singletonGetter(() => new LogService());
function ensureLineBreak(str) {
    if (str.length === 0) {
        return str;
    }
    if (str.charAt(str.length - 1) !== '\n') {
        return str + '\n';
    }
    return str;
}


/***/ }),

/***/ 32723:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MigrationService = void 0;
const semver_1 = __importDefault(__webpack_require__(36625));
const types_1 = __webpack_require__(36402);
const ts_utils_1 = __webpack_require__(55452);
class MigrationService {
    constructor(options) {
        this.storage = options.storage;
        this.jobs = options.jobs;
    }
    isMigrated(type) {
        return this.storage.get(type)
            .then((record) => !!record);
    }
    getRecords() {
        return this.storage.getAll();
    }
    runType(type) {
        return this.isMigrated(type)
            .then((migrated) => {
            if (migrated) {
                return types_1.MigrationResult.AlreadyMigrated;
            }
            const job = this.findJob(type);
            if (!job) {
                return types_1.MigrationResult.JobUnknown;
            }
            return job.shouldMigrate()
                .then((pass) => {
                if (!pass) {
                    return types_1.MigrationResult.NotQualified;
                }
                return job.migrate()
                    .then(() => types_1.MigrationResult.Success);
            });
        })
            .catch((e) => {
            console.error(e);
            return types_1.MigrationResult.Error;
        })
            .then((result) => {
            if (result !== types_1.MigrationResult.Success) {
                return Promise.resolve(result);
            }
            return this.storage.set(type, {
                result,
                id: ts_utils_1.uid(),
                runAt: new Date().getTime(),
                jobType: type
            })
                .then(() => result);
        });
    }
    runAll(previousVersion, currentVersion) {
        const validJobs = this.jobs.filter((job) => {
            return semver_1.default.satisfies(previousVersion, job.previousVersionRange());
        });
        return ts_utils_1.flow(...validJobs.map((job) => {
            const type = job.getType();
            return () => {
                return this.runType(type)
                    .then((result) => ({ type, result }));
            };
        }))
            .then((list) => {
            const result = list.reduce((prev, cur) => {
                prev[cur.type] = cur.result;
                return prev;
            }, {});
            return result;
        });
    }
    findJob(type) {
        return this.jobs.find((item) => item.getType() === type);
    }
}
exports.MigrationService = MigrationService;


/***/ }),

/***/ 93298:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getKantuMigrationService = exports.KantuMigrationService = void 0;
const common_1 = __webpack_require__(32723);
const migration_data_1 = __webpack_require__(38411);
const _2019_04_01_macro_suite_storage_1 = __webpack_require__(93915);
const ts_utils_1 = __webpack_require__(55452);
class KantuMigrationService extends common_1.MigrationService {
    constructor() {
        super({
            storage: {
                get(type) {
                    return migration_data_1.getMigrationKeyValueData().get(type);
                },
                set(type, data) {
                    return migration_data_1.getMigrationKeyValueData().set(type, data)
                        .then(() => true);
                },
                getAll() {
                    return migration_data_1.getMigrationKeyValueData().getAll()
                        .then((dict) => {
                        return Object.keys(dict).map((key) => dict[key]);
                    });
                }
            },
            jobs: [
                _2019_04_01_macro_suite_storage_1.getMigrateMacroTestSuiteToBrowserFileSystem()
            ]
        });
    }
}
exports.KantuMigrationService = KantuMigrationService;
exports.getKantuMigrationService = ts_utils_1.singletonGetter(() => {
    return new KantuMigrationService();
});


/***/ }),

/***/ 93915:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMigrateMacroTestSuiteToBrowserFileSystem = exports.MigrateMacroTestSuiteToBrowserFileSystem = void 0;
const types_1 = __webpack_require__(36402);
const indexeddb_storage_1 = __webpack_require__(90925);
const storage_1 = __webpack_require__(16058);
const macro_extra_data_1 = __webpack_require__(24577);
const filesystem_1 = __importDefault(__webpack_require__(90942));
const backup_1 = __webpack_require__(26997);
const ts_utils_1 = __webpack_require__(55452);
class MigrateMacroTestSuiteToBrowserFileSystem {
    constructor() {
        this.oldMacros = [];
    }
    getMeta() {
        return {
            createdAt: new Date('2019-04-01').getTime(),
            goal: [
                `Migrate macros and test suites from indexedDB storage to Browser File System storage`,
                `In order to prepare for an easy support for deep folder structure`,
                `Note: the old indexedDB storage WILL NOT be cleared, just in case any user loses his data during migration`,
                `The real clean up could be done in future releases, in the form of another migration job`
            ].join('. ')
        };
    }
    getType() {
        return types_1.MigrationJobType.MigrateMacroTestSuiteToBrowserFileSystem;
    }
    previousVersionRange() {
        return '<=4.0.1';
    }
    shouldMigrate() {
        const oldMacroStorage = this.getOldMacroStorage();
        const oldTestSuiteStorage = this.getOldTestSuiteStorage();
        return Promise.all([
            oldMacroStorage.list().then((list) => list.length),
            oldTestSuiteStorage.list().then((list) => list.length)
        ])
            .then(([macroCount, testSuiteCount]) => {
            return macroCount > 0 || testSuiteCount > 0;
        });
    }
    migrate() {
        const migrateMacros = () => {
            return this.getOldMacroStorage().readAll()
                .then((fileObjs) => {
                console.log('this.getOldMacroStorage().readAll()', fileObjs);
                this.oldMacros = fileObjs.map((obj) => obj.content);
                return filesystem_1.default.ensureDirectory('/macros')
                    .then(() => this.getNewMacroStorage().bulkWrite(fileObjs));
            })
                .then(() => true);
        };
        const migrateTestSuites = () => {
            return this.getOldTestSuiteStorage().readAll()
                .then((fileObjs) => {
                console.log('this.getOldTestSuiteStorage().readAll()', fileObjs);
                return filesystem_1.default.ensureDirectory('/testsuites')
                    .then(() => this.getNewTestSuiteStorage().bulkWrite(fileObjs));
            })
                .then(() => true);
        };
        const migrateMacroExtra = () => {
            return macro_extra_data_1.getMacroExtraKeyValueData().getAll()
                .then((allMacroExtra) => {
                this.oldMacros.forEach(macro => {
                    const newId = this.getNewMacroStorage().filePath(macro.name);
                    const oldId = macro.id;
                    if (allMacroExtra[oldId]) {
                        allMacroExtra[newId] = allMacroExtra[oldId];
                    }
                });
                return macro_extra_data_1.getMacroExtraKeyValueData().set('', allMacroExtra);
            });
        };
        return migrateMacros()
            .then(() => migrateTestSuites())
            .then(() => migrateMacroExtra())
            .then(() => true);
    }
    remedy() {
        // Download the old macros and test suites in zip
        const readOldMacros = () => {
            return this.getOldMacroStorage().readAll()
                .then((fileObjs) => {
                this.oldMacros = fileObjs.map((obj) => obj.content);
                return this.oldMacros;
            });
        };
        const readOldTestSuites = () => {
            return this.getOldTestSuiteStorage().readAll()
                .then((fileObjs) => {
                return fileObjs.map((obj) => obj.content);
            });
        };
        return readOldMacros()
            .then(macros => {
            return readOldTestSuites()
                .then(testSuites => {
                return backup_1.backup({
                    backup: {
                        testCase: true,
                        testSuite: true
                    },
                    macroNodes: macros,
                    testSuites: testSuites
                });
            });
        });
    }
    getOldMacroStorage() {
        return indexeddb_storage_1.getIndexeddbFlatStorage({
            table: 'testCases'
        });
    }
    getOldTestSuiteStorage() {
        return indexeddb_storage_1.getIndexeddbFlatStorage({
            table: 'testSuites'
        });
    }
    getNewMacroStorage() {
        return this.getStorageManager().getStorageForTarget(storage_1.StorageTarget.Macro, storage_1.StorageStrategyType.Browser);
    }
    getNewTestSuiteStorage() {
        return this.getStorageManager().getStorageForTarget(storage_1.StorageTarget.TestSuite, storage_1.StorageStrategyType.Browser);
    }
    getStorageManager() {
        return new storage_1.StorageManager(storage_1.StorageStrategyType.Browser, {
            getMacros: () => this.oldMacros,
            getMaxMacroCount: () => Promise.resolve(Infinity)
        });
    }
}
exports.MigrateMacroTestSuiteToBrowserFileSystem = MigrateMacroTestSuiteToBrowserFileSystem;
exports.getMigrateMacroTestSuiteToBrowserFileSystem = ts_utils_1.singletonGetter(() => {
    return new MigrateMacroTestSuiteToBrowserFileSystem();
});


/***/ }),

/***/ 36402:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MigrationResult = exports.MigrationJobType = void 0;
var MigrationJobType;
(function (MigrationJobType) {
    MigrationJobType["MigrateMacroTestSuiteToBrowserFileSystem"] = "20190401_macro_test_suite_to_browser_fs";
})(MigrationJobType = exports.MigrationJobType || (exports.MigrationJobType = {}));
var MigrationResult;
(function (MigrationResult) {
    MigrationResult[MigrationResult["AlreadyMigrated"] = 0] = "AlreadyMigrated";
    MigrationResult[MigrationResult["NotQualified"] = 1] = "NotQualified";
    MigrationResult[MigrationResult["Success"] = 2] = "Success";
    MigrationResult[MigrationResult["Error"] = 3] = "Error";
    MigrationResult[MigrationResult["JobUnknown"] = 4] = "JobUnknown";
})(MigrationResult = exports.MigrationResult || (exports.MigrationResult = {}));


/***/ }),

/***/ 29159:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOcrCommandCounter = void 0;
const storage_1 = __importDefault(__webpack_require__(67585));
const persistent_counter_1 = __webpack_require__(88325);
const ts_utils_1 = __webpack_require__(55452);
const log_1 = __importDefault(__webpack_require__(77242));
const STORAGE_KEY = 'OCR_CONVERSIONS_PER_DAY';
const today = () => {
    const d = new Date();
    return {
        year: d.getFullYear(),
        month: d.getMonth() + 1,
        date: d.getDate()
    };
};
const isSameDay = (a, b) => {
    return a.year === b.year &&
        a.month === b.month &&
        a.date === b.date;
};
exports.getOcrCommandCounter = ts_utils_1.singletonGetter((options) => {
    const read = () => {
        log_1.default('getOcrCommandCounter - read');
        return storage_1.default.get(STORAGE_KEY)
            .then((val) => {
            if (!val)
                return options.initial;
            if (!isSameDay(today(), val.day))
                return options.initial;
            return val.count;
        });
    };
    const write = (n) => {
        log_1.default('getOcrCommandCounter - write', n);
        return storage_1.default.set(STORAGE_KEY, {
            day: today(),
            count: n
        })
            .then(() => { });
    };
    return new persistent_counter_1.PersistentCounter(Object.assign(Object.assign({}, options), { read,
        write }));
});


/***/ }),

/***/ 94901:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOcrEndpointPicker = exports.randomIndex = exports.OcrEndpointPicker = exports.getOcrServerKeyValueData = exports.OcrServerKeyValueData = void 0;
const common_1 = __webpack_require__(38801);
const ts_utils_1 = __webpack_require__(55452);
const config_1 = __importDefault(__webpack_require__(62275));
class OcrServerKeyValueData extends common_1.KeyValueData {
    getAll() {
        return super.get("").then(data => data || {});
    }
    getMainKeyAndSubKeys(key) {
        const [mainKey, subKeys] = super.getMainKeyAndSubKeys(key);
        return [
            OcrServerKeyValueData.STORAGE_KEY,
            [mainKey].concat(subKeys).filter(x => x && x.length)
        ];
    }
}
exports.OcrServerKeyValueData = OcrServerKeyValueData;
OcrServerKeyValueData.STORAGE_KEY = 'ocr_server_data';
exports.getOcrServerKeyValueData = ts_utils_1.singletonGetter(() => new OcrServerKeyValueData());
class OcrEndpointPicker {
    constructor(options) {
        this.servers = options.servers;
        this.resetTime = options.resetTime;
        this.lastId = null;
    }
    all() {
        return Promise.resolve(this.servers);
    }
    isAllDown() {
        return this.validServers()
            .then(({ servers }) => {
            return servers.length === 0;
        });
    }
    randomPick() {
        return this.validServers()
            .then(({ servers, serverInfos }) => {
            return servers[randomIndex(servers.length)];
        });
    }
    bestPick() {
        return this.validServers()
            .then(({ servers, serverInfos }) => {
            const getTime = (server) => {
                return serverInfos[server.id] ? serverInfos[server.id].lastTotalMilliseconds : 0;
            };
            return servers.reduce((prev, server) => {
                if (!prev)
                    return server;
                // Note: These two lines are used to avoid using the same endpoint on two consecutive runs
                // That's not what we want at this comment, so comment it out
                //
                // if (prev.id === this.lastId)    return server
                // if (server.id === this.lastId)  return prev
                const timeA = getTime(prev);
                const timeB = getTime(server);
                switch (Math.sign(timeA - timeB)) {
                    case 0: return Math.random() > 0.5 ? prev : server;
                    case 1: return server;
                    case -1:
                    default: return prev;
                }
            });
        });
    }
    reset() {
        // Note: reset server sanity to null when all servers are down,
        // so that it will check all servers again on next request
        return ts_utils_1.flow(...this.servers.map(server => {
            return () => exports.getOcrServerKeyValueData().set(server.id, null);
        }))
            .then(() => { });
    }
    use(id) {
        const found = this.servers.find(item => item.id === id);
        if (!found)
            throw new Error(`No server found with id '${id}'`);
        this.lastId = id;
    }
    report(id, sanityInfo) {
        return exports.getOcrServerKeyValueData().set(id, sanityInfo)
            .then(() => true);
    }
    validServers() {
        return exports.getOcrServerKeyValueData().getAll()
            .then(serverInfos => {
            const now = new Date().getTime();
            const servers = this.servers.filter(server => {
                const info = serverInfos[server.id];
                if (!info)
                    return true;
                if (now - info.lastResponseTimestamp > this.resetTime)
                    return true;
                if (info.lastError)
                    return false;
                return info.lastTotalMilliseconds <= config_1.default.ocr.apiHealthyResponseTime;
            });
            if (servers.length === 0) {
                throw new Error('All OCR servers are down');
            }
            return {
                servers,
                serverInfos
            };
        });
    }
}
exports.OcrEndpointPicker = OcrEndpointPicker;
function randomIndex(count) {
    return Math.round(Math.random() * count);
}
exports.randomIndex = randomIndex;
exports.getOcrEndpointPicker = ts_utils_1.singletonGetter(() => {
    return new OcrEndpointPicker({
        servers: config_1.default.ocr.apiList,
        resetTime: config_1.default.ocr.resetTime
    });
});


/***/ }),

/***/ 99489:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidOCRLanguage = exports.languages = void 0;
const __languages = {
    ara: {
        "lang": "ara",
        "name": "Arabic",
        "short": "AR"
    },
    chs: {
        "lang": "chs",
        "name": "ChineseSimplified",
        "short": "简"
    },
    cht: {
        "lang": "cht",
        "name": "ChineseTraditional",
        "short": "繁"
    },
    ce: {
        "lang": "ce",
        "name": "Czech",
        "short": "CS"
    },
    dan: {
        "lang": "dan",
        "name": "Danish",
        "short": "DA"
    },
    dut: {
        "lang": "dut",
        "name": "Dutch",
        "short": "NL"
    },
    eng: {
        "lang": "eng",
        "name": "English",
        "short": "EN"
    },
    fin: {
        "lang": "fin",
        "name": "Finnish",
        "short": "FI"
    },
    fre: {
        "lang": "fre",
        "name": "French",
        "short": "FR"
    },
    ger: {
        "lang": "ger",
        "name": "German",
        "short": "DE"
    },
    gre: {
        "lang": "gre",
        "name": "Greek",
        "short": "EL"
    },
    hun: {
        "lang": "hun",
        "name": "Hungarian",
        "short": "HU"
    },
    ita: {
        "lang": "ita",
        "name": "Italian",
        "short": "IT"
    },
    jpn: {
        "lang": "jpn",
        "name": "Japanese",
        "short": "JP"
    },
    kor: {
        "lang": "kor",
        "name": "Korean",
        "short": "KO"
    },
    nor: {
        "lang": "nor",
        "name": "Norwegian",
        "short": "NN"
    },
    pol: {
        "lang": "pol",
        "name": "Polish",
        "short": "PL"
    },
    por: {
        "lang": "por",
        "name": "Portuguese",
        "short": "PT"
    },
    rus: {
        "lang": "rus",
        "name": "Russian",
        "short": "RU"
    },
    spa: {
        "lang": "spa",
        "name": "Spanish",
        "short": "ES"
    },
    swe: {
        "lang": "swe",
        "name": "Swedish",
        "short": "SV"
    },
    tur: {
        "lang": "tur",
        "name": "Turkish",
        "short": "TR"
    }
};
exports.languages = __languages;
function isValidOCRLanguage(lang) {
    return typeof lang === 'string' && !!__languages[lang.toLowerCase()];
}
exports.isValidOCRLanguage = isValidOCRLanguage;


/***/ }),

/***/ 61364:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMacroCallStack = exports.getMacroCallStack = exports.MacroCallStack = exports.CallStack = void 0;
const types_1 = __webpack_require__(77697);
const stack_1 = __webpack_require__(11038);
const macro_1 = __webpack_require__(72767);
const ts_utils_1 = __webpack_require__(55452);
const registry_1 = __webpack_require__(55290);
class CallStack extends stack_1.Stack {
    constructor(options) {
        super();
        this.opts = options;
        this.registry = registry_1.createListenerRegistry();
    }
    on(eventName, listener) {
        this.registry.add(eventName, listener);
        return () => this.registry.remove(eventName, listener);
    }
    off() {
        this.registry.destroy();
    }
    call(resource, runningStatus) {
        if (!this.isEmpty()) {
            this.updatePeek((element) => {
                return {
                    id: element.id,
                    resource: element.resource,
                    runningStatus: Object.assign(Object.assign({}, this.opts.updateRunningStatusForCaller(element.runningStatus, element.resource)), { status: macro_1.MacroStatus.Calling })
                };
            });
        }
        this.push({
            resource,
            id: ts_utils_1.uid(),
            runningStatus: runningStatus || this.opts.getInitialRunningStatus(resource)
        });
        this.registry.fire(types_1.CallStackEvent.BeforeRun, this.callStackSnapshot());
        return this.runPeek();
    }
    runPeek(isResume = false) {
        return this.opts.prepareContext(this.peek(), this.getFrameStatus(this.peek(), isResume))
            .then(() => {
            const item = this.peek();
            return this.opts.run(item, this.getFrameStatus(item, isResume))
                .then(() => {
                const snapshot = this.callStackSnapshot();
                const latestFrameId = this.opts.getLatestFrameIdFromSnapshot(snapshot);
                // FIXME: There is a kind of design error here. This callback after runPeek could be run twice
                // for a single macro.
                //
                // For exmaple, Run A => A calls B => B returns to A => A continues
                // 1) Run A: runPeek is called for A for first time
                // 2) A calls B: runPeek is called for B for first time
                // 3) B returns to A: The call to runPeek below is run, so runPeek is called for A for second time
                //
                // As a temporary fix, I have to check if snapshot's last element is the same as the one being run
                if (latestFrameId !== item.id) {
                    return;
                }
                this.registry.fire(types_1.CallStackEvent.AfterReturn, snapshot);
                this.pop();
                if (this.isEmpty()) {
                    return;
                }
                this.updatePeekAfterResume();
                this.registry.fire(types_1.CallStackEvent.BeforeResume, this.callStackSnapshot());
                return this.runPeek(true);
            });
        });
    }
    updatePeek(updater) {
        this.guardNotEmpty();
        const index = this.getCount() - 1;
        this.list[index] = updater(this.list[index]);
    }
    getFrameStatus(element, isResume) {
        return {
            isResume,
            isBottom: this.getCount() === 1,
            frameId: element.id
        };
    }
    updatePeekAfterResume() {
        this.updatePeek((element) => {
            return element;
        });
    }
    callStackSnapshot() {
        return this.list.map((item) => item.resource);
    }
}
exports.CallStack = CallStack;
class MacroCallStack extends CallStack {
    isAtBottom() {
        return this.getCount() === 1;
    }
    callStackSnapshot() {
        return this.list.map((item) => ({
            id: item.resource.id,
            name: item.resource.name,
            frameId: item.id
        }));
    }
    updatePeekAfterResume() {
        this.updatePeek((element) => {
            const curIndex = element.runningStatus.nextIndex;
            const nextIndex = curIndex + 1;
            const commandResults = [...element.runningStatus.commandResults];
            commandResults[curIndex] = macro_1.CommandRunningStatus.Success;
            return {
                id: element.id,
                resource: element.resource,
                runningStatus: {
                    nextIndex,
                    commandResults,
                    status: macro_1.MacroStatus.Running,
                    playerState: Object.assign(Object.assign({}, element.runningStatus.playerState), { nextIndex, doneIndices: [
                            ...element.runningStatus.playerState.doneIndices,
                            curIndex
                        ] }),
                    interpreterState: element.runningStatus.interpreterState
                }
            };
        });
    }
}
exports.MacroCallStack = MacroCallStack;
exports.getMacroCallStack = ts_utils_1.singletonGetter((callStackOptions) => {
    if (!callStackOptions) {
        throw new Error('macro call stack options is required');
    }
    return new MacroCallStack(callStackOptions);
});
function createMacroCallStack(options) {
    return exports.getMacroCallStack({
        getInitialRunningStatus: (macro) => ({
            nextIndex: 0,
            status: macro_1.MacroStatus.Running,
            commandResults: [],
            playerState: {},
            interpreterState: {}
        }),
        getLatestFrameIdFromSnapshot: (snapshot) => {
            const last = snapshot[snapshot.length - 1];
            return last ? last.frameId : null;
        },
        updateRunningStatusForCaller: (runningStatus, macro) => {
            return options.getCurrentMacroRunningStatus();
        },
        prepareContext: (resourceAndStatus, frameStatus) => {
            const macro = resourceAndStatus.resource;
            const status = resourceAndStatus.runningStatus;
            return ts_utils_1.withPromise(() => options.updateSelectedMacro(macro, status, frameStatus))
                .then(() => ts_utils_1.withPromise(() => options.restorePlayerState(macro, status, frameStatus)));
        },
        run: (resourceAndStatus, frameStatus) => {
            // Steps
            // * Update selected macro
            // * Restore commandResults
            // * Restore tcPlayer state
            // * Start to play
            const macro = resourceAndStatus.resource;
            const status = resourceAndStatus.runningStatus;
            return ts_utils_1.withPromise(() => options.playMacro(macro, status, frameStatus));
        }
    });
}
exports.createMacroCallStack = createMacroCallStack;


/***/ }),

/***/ 11038:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stack = exports.StackError = void 0;
class StackError extends Error {
}
exports.StackError = StackError;
class Stack {
    constructor(list) {
        this.list = [];
        if (list && list.length) {
            this.list = list;
        }
    }
    clear() {
        this.list = [];
    }
    toArray() {
        return [...this.list];
    }
    getCount() {
        return this.list.length;
    }
    isEmpty() {
        return this.getCount() === 0;
    }
    contains(item) {
        return !!this.list.find((el) => el === item);
    }
    push(item) {
        this.list.push(item);
    }
    peek() {
        this.guardNotEmpty();
        return this.list[this.getCount() - 1];
    }
    bottom() {
        this.guardNotEmpty();
        return this.list[0];
    }
    pop() {
        this.guardNotEmpty();
        return this.list.pop();
    }
    guardNotEmpty() {
        if (this.isEmpty()) {
            throw new StackError('empty stack');
        }
    }
}
exports.Stack = Stack;


/***/ }),

/***/ 77697:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallStackEvent = void 0;
var CallStackEvent;
(function (CallStackEvent) {
    CallStackEvent["BeforeRun"] = "before_run";
    CallStackEvent["BeforeResume"] = "before_resume";
    CallStackEvent["AfterReturn"] = "after_return";
})(CallStackEvent = exports.CallStackEvent || (exports.CallStackEvent = {}));


/***/ }),

/***/ 72767:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDoneErrorIndices = exports.getCommandResults = exports.MacroStatus = exports.CommandRunningStatus = void 0;
var CommandRunningStatus;
(function (CommandRunningStatus) {
    CommandRunningStatus[CommandRunningStatus["Pending"] = 0] = "Pending";
    CommandRunningStatus[CommandRunningStatus["Success"] = 1] = "Success";
    CommandRunningStatus[CommandRunningStatus["Failure"] = 2] = "Failure";
    CommandRunningStatus[CommandRunningStatus["Warning"] = 3] = "Warning";
})(CommandRunningStatus = exports.CommandRunningStatus || (exports.CommandRunningStatus = {}));
var MacroStatus;
(function (MacroStatus) {
    MacroStatus[MacroStatus["Idle"] = 0] = "Idle";
    MacroStatus[MacroStatus["Running"] = 1] = "Running";
    MacroStatus[MacroStatus["Calling"] = 2] = "Calling";
    MacroStatus[MacroStatus["Finished"] = 3] = "Finished";
    MacroStatus[MacroStatus["Error"] = 4] = "Error";
})(MacroStatus = exports.MacroStatus || (exports.MacroStatus = {}));
function getCommandResults(data) {
    const { doneIndices, errorIndices, warningIndices, count } = data;
    const result = [];
    for (let i = 0; i < count; i++) {
        if (doneIndices.indexOf(i) !== -1) {
            result.push(CommandRunningStatus.Success);
        }
        else if (errorIndices.indexOf(i) !== -1) {
            result.push(CommandRunningStatus.Failure);
        }
        else if (warningIndices.indexOf(i) !== -1) {
            result.push(CommandRunningStatus.Warning);
        }
        else {
            result.push(CommandRunningStatus.Pending);
        }
    }
    return result;
}
exports.getCommandResults = getCommandResults;
function getDoneErrorIndices(commandResults) {
    const doneIndices = [];
    const errorIndices = [];
    const warningIndices = [];
    commandResults.forEach((r, i) => {
        switch (r) {
            case CommandRunningStatus.Failure:
                return errorIndices.push(i);
            case CommandRunningStatus.Warning:
                return warningIndices.push(i);
            case CommandRunningStatus.Success:
                return doneIndices.push(i);
        }
    });
    return {
        doneIndices,
        errorIndices,
        warningIndices,
        count: commandResults.length
    };
}
exports.getDoneErrorIndices = getDoneErrorIndices;


/***/ }),

/***/ 99372:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Countdown = void 0;
class Countdown {
    constructor(callback) {
        this.startTime = null;
        this.timeout = null;
        this.timer = null;
        this.callback = callback;
    }
    restart(newTimeout, force = false) {
        clearTimeout(this.timer);
        if (force || this.timeout === null || !this.startTime) {
            this.timeout = newTimeout;
            this.startTime = new Date();
            if (newTimeout !== 0) {
                this.timer = setTimeout(() => this.runCallback(), this.timeout);
            }
        }
        else {
            const past = new Date().getTime() - this.startTime.getTime();
            const rest = newTimeout - past;
            this.timeout = newTimeout;
            if (newTimeout !== 0) {
                if (rest < 0) {
                    return this.callback();
                }
                else {
                    this.timer = setTimeout(() => this.runCallback(), rest);
                }
            }
        }
    }
    pause() {
        clearTimeout(this.timer);
        if (!this.startTime || !this.timeout) {
            return;
        }
        const past = new Date().getTime() - this.startTime.getTime();
        const rest = this.timeout - past;
        this.timeout = rest;
    }
    resume() {
        if (!this.timeout) {
            return;
        }
        this.startTime = new Date();
        this.timer = setTimeout(() => this.runCallback(), this.timeout);
    }
    stop() {
        clearTimeout(this.timer);
        this.clearState();
    }
    output() {
        // return nothing
    }
    clearState() {
        this.timer = null;
        this.timeout = null;
        this.startTime = null;
    }
    runCallback() {
        try {
            this.callback();
        }
        catch (e) {
            console.error(e);
        }
        finally {
            this.clearState();
        }
    }
}
exports.Countdown = Countdown;


/***/ }),

/***/ 95324:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMacroMonitor = exports.MacroMonitor = exports.MacroParamsProviderType = void 0;
const types_1 = __webpack_require__(75391);
const monitor_1 = __webpack_require__(80849);
const timer_1 = __webpack_require__(62722);
const countdown_1 = __webpack_require__(99372);
const ts_utils_1 = __webpack_require__(55452);
var MacroParamsProviderType;
(function (MacroParamsProviderType) {
    MacroParamsProviderType[MacroParamsProviderType["Constructor"] = 0] = "Constructor";
    MacroParamsProviderType[MacroParamsProviderType["Restart"] = 1] = "Restart";
})(MacroParamsProviderType = exports.MacroParamsProviderType || (exports.MacroParamsProviderType = {}));
class MacroMonitor extends monitor_1.Monitor {
    constructor(paramsProvider) {
        super({
            [types_1.MacroInspector.Timer]: (id) => {
                return new timer_1.Timer();
            },
            [types_1.MacroInspector.LoopTimer]: (id) => {
                return new timer_1.Timer();
            },
            [types_1.MacroInspector.Countdown]: (id) => {
                const args = paramsProvider(MacroParamsProviderType.Constructor, types_1.MacroInspector.Countdown, id, false);
                const callback = args[0];
                return new countdown_1.Countdown(callback);
            }
        }, (name, id, notBatch) => {
            return paramsProvider(MacroParamsProviderType.Restart, name, id, notBatch);
        });
    }
}
exports.MacroMonitor = MacroMonitor;
exports.getMacroMonitor = ts_utils_1.singletonGetter((paramsProvider) => {
    return new MacroMonitor(paramsProvider);
});


/***/ }),

/***/ 80849:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Monitor = void 0;
const ts_utils_1 = __webpack_require__(55452);
class Monitor {
    constructor(inspectorConstructors, paramsProvider) {
        this.inspectorConstructors = {};
        this.targets = {};
        this.paramsProvider = paramsProvider;
        this.inspectorConstructors = inspectorConstructors;
    }
    addTarget(id, autoStart = true) {
        this.targets[id] = ts_utils_1.objMap((factory, key) => {
            const inspector = factory(id);
            if (autoStart) {
                inspector.restart(...this.paramsProvider(key));
            }
            return inspector;
        }, this.inspectorConstructors);
    }
    removeTarget(id) {
        if (!this.targets[id]) {
            return;
        }
        ts_utils_1.objMap((inspector) => {
            inspector.stop();
        }, this.targets[id]);
        delete this.targets[id];
    }
    clear() {
        Object.keys(this.targets).map((id) => {
            this.removeTarget(id);
        });
    }
    restart() {
        this.traverseAllInspectors((inspector, key, id) => {
            inspector.restart(...this.paramsProvider(key, id));
        });
    }
    pause() {
        this.traverseAllInspectors((inspector) => {
            inspector.pause();
        });
    }
    resume() {
        this.traverseAllInspectors((inspector) => {
            inspector.resume();
        });
    }
    stop() {
        this.traverseAllInspectors((inspector) => {
            inspector.stop();
        });
    }
    restartInspector(id, inspectorName) {
        this.getInspector(id, inspectorName).restart(...this.paramsProvider(inspectorName, id, true));
    }
    pauseInspector(id, inspectorName) {
        this.getInspector(id, inspectorName).pause();
    }
    resumeInspector(id, inspectorName) {
        this.getInspector(id, inspectorName).resume();
    }
    stopInspector(id, inspectorName) {
        this.getInspector(id, inspectorName).stop();
    }
    getDataFromInspector(id, inspectorName) {
        return this.getInspector(id, inspectorName).output();
    }
    traverseAllInspectors(fn) {
        ts_utils_1.objMap((inspectors, id) => {
            ts_utils_1.objMap((inspector, key) => {
                try {
                    fn(inspector, key, id);
                }
                catch (e) {
                    console.error(e);
                }
            }, inspectors);
        }, this.targets);
    }
    getInspector(id, inspectorName) {
        const inspectors = this.targets[id];
        if (!inspectors) {
            throw new Error(`Can't find monitor target with id '${id}'`);
        }
        const inspector = inspectors[inspectorName];
        if (!inspector) {
            throw new Error(`Can't find inspector with name '${inspectorName}' for target id '${id}'`);
        }
        return inspector;
    }
}
exports.Monitor = Monitor;


/***/ }),

/***/ 62722:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Timer = void 0;
class Timer {
    constructor() {
        this.startTime = new Date();
        this.acc = 0;
    }
    restart() {
        this.startTime = new Date();
        this.acc = 0;
    }
    pause() {
        const now = new Date();
        this.acc += now.getTime() - this.startTime.getTime();
    }
    resume() {
        this.startTime = new Date();
    }
    stop() {
        // do nothing
    }
    output() {
        return this.elapsed();
    }
    elapsed() {
        return this.acc + (new Date().getTime() - this.startTime.getTime());
    }
    elapsedInSeconds() {
        const diff = this.elapsed();
        return (diff / 1000).toFixed(2) + 's';
    }
}
exports.Timer = Timer;


/***/ }),

/***/ 75391:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MacroInspector = void 0;
var MacroInspector;
(function (MacroInspector) {
    MacroInspector["Timer"] = "timer";
    MacroInspector["LoopTimer"] = "loop_timer";
    MacroInspector["Countdown"] = "countdown";
})(MacroInspector = exports.MacroInspector || (exports.MacroInspector = {}));


/***/ }),

/***/ 21560:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseProxyManager = void 0;
const registry_1 = __webpack_require__(55290);
class BaseProxyManager {
    constructor() {
        this.proxy = null;
        this.registry = registry_1.createListenerRegistry();
    }
    getProxy() {
        return Promise.resolve(this.proxy);
    }
    getAuth(host, port) {
        if (!this.proxy || !this.proxy.username) {
            return null;
        }
        // port could be number, so must convert it to string before compare
        if (this.proxy.host === host && this.proxy.port === '' + port) {
            return {
                username: this.proxy.username,
                password: this.proxy.password
            };
        }
        return null;
    }
    onChange(listener) {
        this.registry.add('change', listener);
        return () => { this.registry.remove('change', listener); };
    }
}
exports.BaseProxyManager = BaseProxyManager;


/***/ }),

/***/ 22078:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProxyHttpAuth = void 0;
const web_extension_1 = __importDefault(__webpack_require__(61171));
class ProxyHttpAuth {
    constructor(params) {
        this.unbindListener = () => { };
        this.bound = false;
        this.getAuth = params.getAuth;
    }
    bind() {
        if (this.bound) {
            return;
        }
        this.bound = true;
        const listener = this.onAuthRequired.bind(this);
        web_extension_1.default.webRequest.onAuthRequired.addListener(listener, { urls: ['<all_urls>'] }, ['blocking']);
        this.unbindListener = () => web_extension_1.default.webRequest.onAuthRequired.removeListener(listener);
    }
    unbind() {
        if (!this.bound) {
            return;
        }
        this.unbindListener();
        this.bound = false;
    }
    onAuthRequired(details) {
        if (!details.isProxy) {
            return {};
        }
        const auth = this.getAuth(details.challenger.host, '' + details.challenger.port);
        return auth ? { authCredentials: auth } : {};
    }
}
exports.ProxyHttpAuth = ProxyHttpAuth;


/***/ }),

/***/ 51829:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseProxyUrl = exports.setProxy = exports.getProxyManager = void 0;
const types_1 = __webpack_require__(41559);
const listener_api_proxy_1 = __webpack_require__(4465);
const settings_api_proxy_1 = __webpack_require__(60131);
const pac_api_proxy_1 = __webpack_require__(60446);
const http_auth_1 = __webpack_require__(22078);
const messages_1 = __importDefault(__webpack_require__(29319));
const allAvailableProxyManagers = [
    new listener_api_proxy_1.ProxyManagerViaListenerAPI(),
    new pac_api_proxy_1.ProxyManagerViaPacAPI(),
    new settings_api_proxy_1.ProxyManagerViaSettingsAPI()
];
const proxyHttpAuth = new http_auth_1.ProxyHttpAuth({
    getAuth: (host, port) => {
        return getProxyManager().getAuth(host, port);
    }
});
function getProxyManager() {
    for (let i = 0, len = allAvailableProxyManagers.length; i < len; i++) {
        if (allAvailableProxyManagers[i].isSupported()) {
            return allAvailableProxyManagers[i];
        }
    }
    throw new Error('Unable to use proxy');
}
exports.getProxyManager = getProxyManager;
function setProxy(proxy) {
    return new Promise((resolve, reject) => {
        const proxyManager = getProxyManager();
        // Default to not incognito mode
        proxyManager.isControllable(false)
            .then((controllable) => {
            if (!controllable) {
                throw new Error(messages_1.default.proxy.notControllable);
            }
            proxyHttpAuth.bind();
            if (!proxy) {
                return proxyManager.reset();
            }
            return proxyManager.setProxy(proxy);
        })
            .then(resolve, reject);
    });
}
exports.setProxy = setProxy;
function parseProxyUrl(proxyUrl, usernameAndPassword) {
    const url = new URL(proxyUrl);
    // URL has problem parsing non-standard url like socks4://0.0.0.0
    // hostname will be empty string, so we have to replace protocol with http
    const httpUrl = new URL(proxyUrl.replace(/\s*socks[45]/i, 'http'));
    const host = httpUrl.hostname;
    const type = (() => {
        switch (url.protocol) {
            case 'http:':
                return types_1.ProxyScheme.Http;
            case 'https:':
                return types_1.ProxyScheme.Https;
            case 'socks4:':
                return types_1.ProxyScheme.Socks4;
            case 'socks5:':
                return types_1.ProxyScheme.Socks5;
            default:
                throw new Error('Invalid proxy protocol');
        }
    })();
    const port = (() => {
        if (httpUrl.port) {
            return httpUrl.port;
        }
        switch (type) {
            case types_1.ProxyScheme.Http:
                return '80';
            case types_1.ProxyScheme.Https:
                return '443';
            case types_1.ProxyScheme.Socks4:
            case types_1.ProxyScheme.Socks5:
                return '1080';
        }
    })();
    if (!host || !host.length) {
        throw new Error('No host found in proxy');
    }
    if (!port || isNaN(parseInt(port, 10))) {
        throw new Error('No valid port found in proxy');
    }
    const { username, password } = (() => {
        if (!usernameAndPassword || !usernameAndPassword.length) {
            return {};
        }
        const index = usernameAndPassword.indexOf(',');
        if (index === -1) {
            return { username: usernameAndPassword };
        }
        return {
            username: usernameAndPassword.substr(0, index),
            password: usernameAndPassword.substr(index + 1)
        };
    })();
    return {
        type,
        host,
        port,
        username,
        password
    };
}
exports.parseProxyUrl = parseProxyUrl;


/***/ }),

/***/ 4465:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProxyManagerViaListenerAPI = exports.convertToFirefoxProxyInfo = void 0;
const types_1 = __webpack_require__(41559);
const base_1 = __webpack_require__(21560);
function convertToFirefoxProxyInfo(proxy) {
    return Object.assign(Object.assign({}, proxy), { type: (proxy.type === types_1.ProxyScheme.Socks5 ? types_1.FirefoxProxyType.Socks5 : proxy.type) });
}
exports.convertToFirefoxProxyInfo = convertToFirefoxProxyInfo;
class ProxyManagerViaListenerAPI extends base_1.BaseProxyManager {
    constructor() {
        super();
        this.unbind = () => { };
        this.isBound = false;
    }
    isSupported() {
        return typeof browser !== 'undefined' && browser.proxy && browser.proxy.onRequest;
    }
    isControllable(incognito) {
        return Promise.resolve(true);
    }
    setProxy(proxy) {
        this.bind();
        this.proxy = proxy;
        this.notifyProxyChange();
        return Promise.resolve();
    }
    reset() {
        this.proxy = null;
        this.notifyProxyChange();
        return Promise.resolve();
    }
    notifyProxyChange() {
        setTimeout(() => {
            this.registry.fire('change', this.proxy);
        }, 10);
    }
    bind() {
        if (this.isBound) {
            return;
        }
        this.isBound = true;
        const listener = this.onProxyRequest.bind(this);
        browser.proxy.onRequest.addListener(listener, { urls: ['<all_urls>'] });
        this.unbind = () => browser.proxy.onRequest.removeListener(listener);
    }
    onProxyRequest(requestInfo) {
        return this.proxy ? convertToFirefoxProxyInfo(this.proxy) : { type: types_1.FirefoxProxyType.Direct };
    }
}
exports.ProxyManagerViaListenerAPI = ProxyManagerViaListenerAPI;


/***/ }),

/***/ 60446:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProxyManagerViaPacAPI = void 0;
const base_1 = __webpack_require__(21560);
const listener_api_proxy_1 = __webpack_require__(4465);
const ipc_cs_1 = __importDefault(__webpack_require__(41471));
const log_1 = __importDefault(__webpack_require__(77242));
const ts_utils_1 = __webpack_require__(55452);
class ProxyManagerViaPacAPI extends base_1.BaseProxyManager {
    constructor() {
        super();
        this.unbind = () => { };
        this.isBound = false;
    }
    isSupported() {
        return typeof browser !== 'undefined' && browser.proxy && browser.proxy.register;
    }
    isControllable() {
        return Promise.resolve(true);
    }
    setProxy(proxy) {
        this.bind();
        this.proxy = proxy;
        this.notifyProxyChange();
        // Not sure if 1s delay could be omitted. Just keep it here in case legacy pac api
        // takes time before proxy takes effect
        return browser.runtime.sendMessage({
            cmd: 'SET_PROXY',
            data: proxy ? listener_api_proxy_1.convertToFirefoxProxyInfo(proxy) : null
        }, { toProxyScript: true })
            .then(() => ts_utils_1.delay(() => { }, 1000));
    }
    reset() {
        this.proxy = null;
        this.notifyProxyChange();
        return ipc_cs_1.default.ask('PANEL_SET_PROXY_FOR_PAC', { proxy: null })
            .then(() => ts_utils_1.delay(() => { }, 1000));
    }
    getAuth(host, port) {
        if (!this.proxy || !this.proxy.username) {
            return null;
        }
        if (this.proxy.host === host && this.proxy.port === port) {
            return {
                username: this.proxy.username,
                password: this.proxy.password
            };
        }
        return null;
    }
    notifyProxyChange() {
        setTimeout(() => {
            this.registry.fire('change', this.proxy);
        }, 10);
    }
    bind() {
        if (this.isBound) {
            return;
        }
        this.isBound = true;
        const pacListener = (data) => {
            if (data.type === 'PROXY_LOG') {
                log_1.default('PROXY_LOG', data);
            }
        };
        browser.proxy.register('firefox_pac.js');
        browser.runtime.onMessage.addListener(pacListener);
        this.unbind = () => {
            browser.proxy.unregister();
            browser.runtime.onMessage.removeListener(pacListener);
        };
    }
}
exports.ProxyManagerViaPacAPI = ProxyManagerViaPacAPI;


/***/ }),

/***/ 60131:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProxyManagerViaSettingsAPI = void 0;
const base_1 = __webpack_require__(21560);
class ProxyManagerViaSettingsAPI extends base_1.BaseProxyManager {
    constructor() {
        super();
        this.isBound = false;
    }
    isSupported() {
        return typeof chrome !== 'undefined' && chrome.proxy && chrome.proxy.settings && chrome.proxy.settings.onChange;
    }
    isControllable(incognito) {
        return new Promise((resolve, reject) => {
            chrome.proxy.settings.get({ incognito: !!incognito }, (details) => {
                if (chrome.runtime.lastError) {
                    return reject(chrome.runtime.lastError);
                }
                const { levelOfControl } = details;
                const inControl = ['controllable_by_this_extension', 'controlled_by_this_extension'].indexOf(levelOfControl) !== -1;
                resolve(inControl);
            });
        });
    }
    setProxy(proxy) {
        this.bindProxyChange();
        this.proxy = proxy;
        return new Promise((resolve, reject) => {
            chrome.proxy.settings.set({
                value: {
                    mode: 'fixed_servers',
                    rules: {
                        singleProxy: {
                            scheme: proxy.type,
                            host: proxy.host,
                            port: parseInt(proxy.port, 10)
                        }
                    }
                }
            }, () => {
                if (chrome.runtime.lastError) {
                    return reject(chrome.runtime.lastError);
                }
                resolve();
            });
        });
    }
    reset() {
        return new Promise((resolve, reject) => {
            chrome.proxy.settings.set({
                value: {
                    mode: 'direct'
                }
            }, () => {
                if (chrome.runtime.lastError) {
                    return reject(chrome.runtime.lastError);
                }
                resolve();
            });
        });
    }
    bindProxyChange() {
        if (this.isBound) {
            return;
        }
        this.isBound = true;
        chrome.proxy.settings.onChange.addListener((details) => {
            const proxyData = this.fromChromeDetails(details);
            // Proxy data returned by fromChromeDetails doesn't contain username/password
            // so must avoid it overwrites the one with auth info
            this.setLocalProxyIfIsNew(proxyData);
            this.registry.fire('change', proxyData);
        });
    }
    fetchProxyFromSettings() {
        return new Promise((resolve, reject) => {
            chrome.proxy.settings.get({ incognito: false }, (details) => {
                if (chrome.runtime.lastError) {
                    return reject(chrome.runtime.lastError);
                }
                const proxyData = this.fromChromeDetails(details);
                this.setLocalProxyIfIsNew(proxyData);
                this.registry.fire('change', proxyData);
                resolve();
            });
        });
    }
    fromChromeDetails(details) {
        if (details.value.mode !== 'fixed_servers' || !details.value.rules || !details.value.rules.singleProxy) {
            return null;
        }
        const singleProxy = details.value.rules.singleProxy;
        return {
            host: singleProxy.host,
            port: '' + singleProxy.port,
            type: singleProxy.scheme
        };
    }
    setLocalProxyIfIsNew(proxyData) {
        var _a, _b;
        if ((proxyData === null || proxyData === void 0 ? void 0 : proxyData.host) !== ((_a = this.proxy) === null || _a === void 0 ? void 0 : _a.host) ||
            (proxyData === null || proxyData === void 0 ? void 0 : proxyData.port) !== ((_b = this.proxy) === null || _b === void 0 ? void 0 : _b.port)) {
            this.proxy = proxyData;
        }
    }
}
exports.ProxyManagerViaSettingsAPI = ProxyManagerViaSettingsAPI;


/***/ }),

/***/ 41559:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FirefoxProxyType = exports.ProxyScheme = void 0;
var ProxyScheme;
(function (ProxyScheme) {
    ProxyScheme["Http"] = "http";
    ProxyScheme["Https"] = "https";
    ProxyScheme["Socks4"] = "socks4";
    ProxyScheme["Socks5"] = "socks5";
})(ProxyScheme = exports.ProxyScheme || (exports.ProxyScheme = {}));
var FirefoxProxyType;
(function (FirefoxProxyType) {
    FirefoxProxyType["Direct"] = "direct";
    FirefoxProxyType["Http"] = "http";
    FirefoxProxyType["Https"] = "https";
    FirefoxProxyType["Socks4"] = "socks4";
    FirefoxProxyType["Socks5"] = "socks";
})(FirefoxProxyType = exports.FirefoxProxyType || (exports.FirefoxProxyType = {}));


/***/ }),

/***/ 83185:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/// <reference types="chrome"/>
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNativeScreenCapture = exports.NativeScreenCapture = void 0;
const ts_utils_1 = __webpack_require__(55452);
var CommandName;
(function (CommandName) {
    CommandName["GetVersion"] = "getVersion";
    CommandName["GetDPI"] = "getDPI";
    CommandName["SetDirectory"] = "setDirectory";
    CommandName["SaveScreenshot"] = "saveScreenshot";
})(CommandName || (CommandName = {}));
class NativeScreenCapture {
    reconnect() {
        return Promise.resolve(this);
    }
    getVersion() {
        return this.sendMessage(CommandName.GetVersion);
    }
    getDpi() {
        return this.sendMessage(CommandName.GetDPI);
    }
    captureDesktop() {
        return this.sendMessage(CommandName.SaveScreenshot);
    }
    changeDirectory(dir) {
        return this.sendMessage(CommandName.SaveScreenshot, { current: dir });
    }
    sendMessage(command, extra = {}) {
        return new Promise((resolve, reject) => {
            chrome.runtime.sendNativeMessage(NativeScreenCapture.HostName, Object.assign(Object.assign({}, extra), { command }), (response) => {
                if (response && response.result) {
                    resolve(response[NativeScreenCapture.FieldNameMapping[command]]);
                }
                else {
                    let error = response && response.error;
                    error = error || 'Unknown error';
                    reject(new Error(error));
                }
            });
        });
    }
}
exports.NativeScreenCapture = NativeScreenCapture;
NativeScreenCapture.HostName = 'com.github.teamdocs.kcmd';
NativeScreenCapture.FieldNameMapping = {
    [CommandName.GetVersion]: 'version',
    [CommandName.GetDPI]: 'dpi',
    [CommandName.SetDirectory]: 'directory',
    [CommandName.SaveScreenshot]: 'file',
};
exports.getNativeScreenCapture = ts_utils_1.singletonGetter(() => new NativeScreenCapture());


/***/ }),

/***/ 27734:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertSideCommand = exports.convertSideMacro = exports.importSideProject = void 0;
const ts_utils_1 = __webpack_require__(55452);
const storage_1 = __webpack_require__(16058);
const log_1 = __importDefault(__webpack_require__(77242));
const utils_1 = __webpack_require__(63370);
function importSideProject(project) {
    const folderName = utils_1.sanitizeFileName(project.name);
    const macroStorage = storage_1.getStorageManager().getMacroStorage();
    const path = macroStorage.getPathLib();
    return ts_utils_1.uniqueName(folderName, {
        check: (name) => {
            return macroStorage.directoryExists(name)
                .then(result => !result);
        }
    })
        .then(finalFolderName => {
        return macroStorage.createDirectory(finalFolderName)
            .then(() => {
            return Promise.all(project.tests.map(sideMacro => {
                sideMacro.name = utils_1.sanitizeFileName(sideMacro.name);
                const filePath = path.join(finalFolderName, sideMacro.name + '.json');
                const macro = convertSideMacro(sideMacro, project.url);
                return macroStorage.write(filePath, {
                    name: macro.name,
                    data: {
                        commands: macro.commands
                    }
                })
                    .then(() => true, (e) => {
                    log_1.default(e);
                    return e.message;
                });
            }))
                .then(list => {
                return {
                    successCount: list.filter((x) => x && typeof x === 'boolean').length,
                    errorCount: list.filter((x) => typeof x === 'string').length,
                    errors: list.filter((x) => typeof x === 'string'),
                    ignoreCount: 0
                };
            });
        })
            .then(macrosResult => {
            return {
                projectName: project.name,
                folderName: finalFolderName,
                macros: macrosResult,
                suites: {
                    successCount: 0,
                    ignoreCount: project.suites.length,
                    errorCount: 0,
                    errors: []
                }
            };
        });
    });
}
exports.importSideProject = importSideProject;
function convertSideMacro(macro, baseUrl) {
    return {
        name: macro.name,
        commands: ts_utils_1.flatten(macro.commands.map(command => convertSideCommand(command, baseUrl)))
    };
}
exports.convertSideMacro = convertSideMacro;
function convertSideCommand(command, baseUrl) {
    if (command.command === 'open') {
        return [{
                cmd: 'open',
                target: resolveUrl(baseUrl, command.target),
                value: ''
            }];
    }
    if (isSameNameSupported(command.command)) {
        return [Object.assign({ cmd: command.command, target: command.target, value: command.value }, (command.targets ? { targetOptions: command.targets.map(item => item[0]) } : {}))];
    }
    const res = convertSideCommandMapping(command);
    if (res.length > 0) {
        return res;
    }
    return [{
            cmd: 'comment',
            target: `${command.command} // ${command.target}`,
            value: command.value
        }];
}
exports.convertSideCommand = convertSideCommand;
function isSameNameSupported(name) {
    switch (name) {
        case 'open':
        case 'select':
        case 'type':
        case 'pause':
        case 'addSelection':
        case 'answerOnNextPrompt':
        case 'assertAlert':
        case 'assertChecked':
        case 'assertConfirmation':
        case 'assertEditable':
        case 'assertElementPresent':
        case 'assertElementNotPresent':
        case 'assertNotEditable':
        case 'assertNotChecked':
        case 'assertPrompt':
        case 'assertTitle':
        case 'assertText':
        case 'assertValue':
        case 'check':
        case 'click':
        case 'clickAt':
        case 'do':
        case 'dragAndDropToObject':
        case 'echo':
        case 'editContent':
        case 'else':
        case 'elseIf':
        case 'end':
        case 'executeAsyncScript':
        case 'executeScript':
        case 'forEach':
        case 'mouseOver':
        case 'repeatIf':
        case 'removeSelection':
        case 'run':
        case 'select':
        case 'selectFrame':
        case 'sendKeys':
        case 'setWindowSize':
        case 'store':
        case 'storeAttribute':
        case 'storeText':
        case 'storeTitle':
        case 'storeValue':
        case 'storeXpathCount':
        case 'times':
        case 'uncheck':
        case 'verifyChecked':
        case 'verifyText':
        case 'verifyTitle':
        case 'verifyValue':
        case 'verifyEditable':
        case 'verifyElementPresent':
        case 'verifyElementNotPresent':
        case 'verifyNotChecked':
        case 'verifyNotEditable':
        case 'waitForElementVisible':
        case 'waitForElementNotVisible':
        case 'waitForElementPresent':
        case 'waitForElementNotPresent':
            return true;
        default:
            return false;
    }
}
function convertSideCommandMapping(command) {
    const withTimeoutWaitChanged = (value, command) => {
        return [{
                cmd: 'store',
                target: '${!TIMEOUT_WAIT}',
                value: '__LAST_TIMEOUT_WAIT__'
            }, {
                cmd: 'store',
                target: (parseFloat(value) / 1000).toFixed(3),
                value: '!TIMEOUT_WAIT'
            },
            command,
            {
                cmd: 'store',
                target: '${__LAST_TIMEOUT_WAIT__}',
                value: '!TIMEOUT_WAIT'
            }];
    };
    switch (command.command) {
        case 'runScript': {
            return [{
                    cmd: 'executeScript',
                    target: command.target,
                    value: ''
                }];
        }
        case 'if': {
            return [{
                    cmd: 'if_v2',
                    target: command.target,
                    value: command.value
                }];
        }
        case 'while': {
            return [{
                    cmd: 'while_v2',
                    target: command.target,
                    value: command.value
                }];
        }
        default:
            return [];
    }
}
function resolveUrl(baseUrl, url) {
    if (/^https?:\/\//.test(url)) {
        return url;
    }
    if (url.charAt(0) === '/') {
        const u = new URL(baseUrl);
        return u.origin + url;
    }
    return baseUrl + url;
}


/***/ }),

/***/ 90925:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIndexeddbFlatStorage = exports.IndexeddbFlatStorage = void 0;
const storage_1 = __webpack_require__(92687);
const db_1 = __importDefault(__webpack_require__(7281));
const utils_1 = __webpack_require__(63370);
const ts_utils_1 = __webpack_require__(55452);
class IndexeddbFlatStorage extends storage_1.FlatStorage {
    constructor(options) {
        super();
        this.displayedCount = 0;
        this.totalCount = 0;
        const tableName = options.table;
        if (!db_1.default.tables.find(t => t.name === tableName)) {
            throw new Error(`Unknown indexeddb table name '${tableName}'`);
        }
        this.table = db_1.default.table(options.table);
    }
    getDisplayCount() {
        return this.displayedCount;
    }
    getTotalCount() {
        return this.totalCount;
    }
    __list() {
        // Note: must wrap dexie's "Promise", as it's dexie's own thenable Promise
        return Promise.resolve(this.table.toArray())
            .then((xs) => {
            const convert = (x) => ({
                dir: '',
                fileName: (x.name),
                lastModified: new Date(),
                size: 'unknown'
            });
            this.totalCount = xs.length;
            this.displayedCount = xs.length;
            return xs.map(convert);
        });
    }
    exists(fileName) {
        return Promise.resolve(this.table
            .where('name')
            .equals(fileName)
            .toArray())
            .then((xs) => {
            return xs.length > 0;
        });
    }
    read(fileName, type) {
        if (type !== 'Text') {
            throw new Error(`ReadFileType '${type}' is not supported in indexeddb storage`);
        }
        return this.findByName(fileName);
    }
    readAll(readFileType = 'Text', onErrorFiles) {
        return Promise.resolve(this.table.toArray())
            .then(items => {
            return items.map(item => ({
                fileName: item.name,
                content: item
            }));
        });
    }
    __write(fileName, content) {
        return this.findByName(fileName)
            .catch(() => null)
            .then((item) => {
            if (item) {
                const data = this.normalize(Object.assign(Object.assign({}, item), content));
                delete data.id;
                return this.table.update(item.id, data);
            }
            else {
                const data = this.normalize(Object.assign({ id: utils_1.uid() }, content));
                return this.table.add(data);
            }
        })
            .then(() => { });
    }
    __overwrite(fileName, content) {
        return this.write(fileName, content);
    }
    __clear() {
        return Promise.resolve(this.table.clear());
    }
    __remove(fileName) {
        return this.findByName(fileName)
            .then(item => {
            return this.table.delete(item.id);
        });
    }
    __rename(fileName, newName) {
        return this.findByName(fileName)
            .then((item) => {
            return this.table.update(item.id, { name: newName });
        })
            .then(() => { });
    }
    __copy(fileName, newName) {
        return this.findByName(fileName)
            .then((item) => {
            delete item.id;
            item.name = newName;
            return this.__write(newName, item);
        });
    }
    ensureDir() {
        return Promise.resolve();
    }
    findByName(name) {
        return Promise.resolve(this.table
            .where('name')
            .equals(name)
            .first())
            .then((item) => {
            if (!item)
                throw new Error(`indexeddb storage: Item with name '${name}' is not found`);
            return item;
        });
    }
    normalize(data) {
        return data;
    }
    dataToString(data) {
        return JSON.stringify(data);
    }
}
exports.IndexeddbFlatStorage = IndexeddbFlatStorage;
exports.getIndexeddbFlatStorage = ts_utils_1.singletonGetterByKey((opts) => {
    return opts.table;
}, (opts) => {
    return new IndexeddbFlatStorage(opts);
});


/***/ }),

/***/ 74359:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getXScreenCapture = exports.XScreenCapture = void 0;
const common_1 = __webpack_require__(75346);
const ts_utils_1 = __webpack_require__(55452);
const screen_capture_1 = __webpack_require__(83185);
class XScreenCapture extends common_1.XModule {
    getName() {
        return common_1.XModuleTypes.XScreenCapture;
    }
    getAPI() {
        return screen_capture_1.getNativeScreenCapture();
    }
    initConfig() {
        return this.getConfig();
    }
    sanityCheck() {
        return Promise.all([
            this.getConfig(),
            this.getAPI().getVersion()
                .catch(e => {
                throw new Error('Error #301: Screen Capture XModule is not installed yet');
            })
        ])
            .then(() => true);
    }
    checkUpdate() {
        return Promise.reject(new Error('checkUpdate is not implemented yet'));
    }
    checkUpdateLink(modVersion, extVersion) {
        return `https://ui.vision/x/idehelp?help=xscreencapture_updatecheck&xversion=${modVersion}&kantuversion=${extVersion}`;
    }
    downloadLink() {
        return 'https://ui.vision/x/idehelp?help=xscreencapture_download';
    }
    infoLink() {
        return 'https://ui.vision/x/idehelp?help=xscreencapture';
    }
}
exports.XScreenCapture = XScreenCapture;
exports.getXScreenCapture = ts_utils_1.singletonGetter(() => {
    return new XScreenCapture();
});


/***/ }),

/***/ 35073:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getXUserIO = exports.XUserIO = void 0;
const common_1 = __webpack_require__(75346);
const xy_1 = __webpack_require__(18677);
const ts_utils_1 = __webpack_require__(55452);
class XUserIO extends common_1.XModule {
    getName() {
        return common_1.XModuleTypes.XUserIO;
    }
    getAPI() {
        return xy_1.getNativeXYAPI();
    }
    initConfig() {
        return this.getConfig();
    }
    sanityCheck() {
        return Promise.all([
            this.getConfig(),
            this.getAPI().getVersion()
                .then(() => this.getAPI(), () => this.getAPI().reconnect())
                .catch(e => {
                throw new Error('Error #301: RealUser Simulation XModule is not installed yet');
            })
        ])
            .then(() => true);
    }
    checkUpdate() {
        return Promise.reject(new Error('checkUpdate is not implemented yet'));
    }
    checkUpdateLink(modVersion, extVersion) {
        return `https://ui.vision/x/idehelp?help=xclick_updatecheck&xversion=${modVersion}&kantuversion=${extVersion}`;
    }
    downloadLink() {
        return 'https://ui.vision/x/idehelp?help=xclick_download';
    }
    infoLink() {
        return 'https://ui.vision/x/idehelp?help=xclick';
    }
}
exports.XUserIO = XUserIO;
exports.getXUserIO = ts_utils_1.singletonGetter(() => {
    return new XUserIO();
});


/***/ }),

/***/ 91255:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getXDesktop = exports.XDesktop = void 0;
const common_1 = __webpack_require__(75346);
const desktop_1 = __webpack_require__(1885);
const ts_utils_1 = __webpack_require__(55452);
class XDesktop extends common_1.XModule {
    getName() {
        return common_1.XModuleTypes.XDesktop;
    }
    getAPI() {
        return desktop_1.getNativeCVAPI();
    }
    initConfig() {
        return this.getConfig();
    }
    sanityCheck() {
        return Promise.all([
            this.getConfig(),
            this.getAPI().getVersion()
                .then(() => this.getAPI(), () => this.getAPI().reconnect())
                .catch(e => {
                throw new Error('Error #301: Visual Desktop Automation XModule is not installed yet');
            })
        ])
            .then(() => true);
    }
    checkUpdate() {
        return Promise.reject(new Error('checkUpdate is not implemented yet'));
    }
    checkUpdateLink(modVersion, extVersion) {
        return `https://ui.vision/x/idehelp?help=xdesktop_updatecheck&xversion=${modVersion}&kantuversion=${extVersion}`;
    }
    downloadLink() {
        return 'https://ui.vision/x/idehelp?help=xdesktop_download';
    }
    infoLink() {
        return 'https://ui.vision/x/idehelp?help=xdesktop';
    }
}
exports.XDesktop = XDesktop;
exports.getXDesktop = ts_utils_1.singletonGetter(() => {
    return new XDesktop();
});


/***/ }),

/***/ 47790:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodTypeInvocationNames = exports.MethodTypeFriendlyNames = void 0;
exports.MethodTypeFriendlyNames = [
    "GetVersion",
    "SendMouseEvent",
    "SendMouseWheelEvent",
    "SendText",
    "GetActiveBrowserOuterRect",
    "FindRectangle",
    "GetScreenBackingScaleFactor"
];
exports.MethodTypeInvocationNames = [
    "get_version",
    "send_mouse_event",
    "send_mouse_wheel_event",
    "send_text",
    "get_active_browser_outer_rect",
    "find_rectangle",
    "get_screen_backing_scale_factor"
];


/***/ }),

/***/ 18677:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNativeXYAPI = exports.MouseEventType = exports.MouseButton = void 0;
const constants_1 = __webpack_require__(47790);
const ts_utils_1 = __webpack_require__(55452);
const kantu_xy_host_1 = __webpack_require__(41512);
const resize_window_1 = __webpack_require__(79210);
const log_1 = __importDefault(__webpack_require__(77242));
var MouseButton;
(function (MouseButton) {
    MouseButton[MouseButton["Left"] = 0] = "Left";
    MouseButton[MouseButton["Right"] = 1] = "Right";
    MouseButton[MouseButton["Middle"] = 2] = "Middle";
})(MouseButton = exports.MouseButton || (exports.MouseButton = {}));
var MouseEventType;
(function (MouseEventType) {
    MouseEventType[MouseEventType["Move"] = 0] = "Move";
    MouseEventType[MouseEventType["Down"] = 1] = "Down";
    MouseEventType[MouseEventType["Up"] = 2] = "Up";
    MouseEventType[MouseEventType["Click"] = 3] = "Click";
    MouseEventType[MouseEventType["DoubleClick"] = 4] = "DoubleClick";
    MouseEventType[MouseEventType["CtrlClick"] = 5] = "CtrlClick";
    MouseEventType[MouseEventType["ShiftClick"] = 6] = "ShiftClick";
    MouseEventType[MouseEventType["TripleClick"] = 7] = "TripleClick";
})(MouseEventType = exports.MouseEventType || (exports.MouseEventType = {}));
exports.getNativeXYAPI = ts_utils_1.singletonGetter(() => {
    const nativeHost = new kantu_xy_host_1.KantuXYHost();
    let pReady = nativeHost.connectAsync().catch(e => {
        log_1.default.warn('pReady - error', e);
        throw e;
    });
    const api = constants_1.MethodTypeInvocationNames.reduce((prev, method) => {
        const camel = ts_utils_1.snakeToCamel(method);
        prev[camel] = (() => {
            const fn = (params) => pReady.then(() => {
                return nativeHost.invokeAsync(method, params)
                    .catch(e => {
                    // Note: Looks like for now whenever there is an error, you have to reconnect native host
                    // otherwise, all commands return "Disconnected" afterwards
                    const typeSafeAPI = api;
                    typeSafeAPI.reconnect().catch(() => { });
                    throw e;
                });
            });
            return fn;
        })();
        return prev;
    }, {
        reconnect: () => {
            nativeHost.disconnect();
            pReady = nativeHost.connectAsync();
            return pReady.then(() => api);
        },
        // Note: This factor equals to ScreenMouseCoornidate / CssMouseCoordinate
        getScalingFactor: () => {
            const typeSafeAPI = api;
            return typeSafeAPI.getScreenBackingScaleFactor()
                .then(screenBackingFactor => window.devicePixelRatio / screenBackingFactor);
        },
        sendViewportMouseEvent: (event, options) => {
            const typeSafeAPI = api;
            return Promise.all([
                options.getViewportRectInScreen(),
                resize_window_1.getFocusedWindowSize(),
                typeSafeAPI.getScalingFactor()
            ])
                .then(tuple => {
                const viewportRect = tuple[0];
                const winSize = tuple[1];
                const scalingFactor = tuple[2];
                const offsetX = viewportRect.x;
                const offsetY = viewportRect.y;
                return typeSafeAPI.sendMouseEvent({
                    type: event.type,
                    button: event.button,
                    x: event.x * scalingFactor + offsetX * scalingFactor,
                    y: event.y * scalingFactor + offsetY * scalingFactor
                });
            })
                .catch(e => {
                console.error(e);
                return false;
            });
        }
    });
    return api;
});


/***/ }),

/***/ 41512:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KantuXYHost = void 0;
const native_host_1 = __webpack_require__(35705);
class KantuXYHost extends native_host_1.NativeMessagingHost {
    constructor() {
        super(KantuXYHost.HOST_NAME);
    }
}
exports.KantuXYHost = KantuXYHost;
KantuXYHost.HOST_NAME = "com.a9t9.kantu.xy";


/***/ }),

/***/ 69386:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 31616:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 69862:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 40964:
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	(() => {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/runtimeId */
/******/ 	(() => {
/******/ 		__webpack_require__.j = 42;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			42: 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkui_vision_web_extension"] = self["webpackChunkui_vision_web_extension"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, [736,105,263,423], () => (__webpack_require__(55579)))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;