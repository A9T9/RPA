/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		8: 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push([1086,1,0]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ 100:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ getElementByXPath; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ isLocator; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ command_runner_getElementByLocator; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* binding */ command_runner_run; });

// UNUSED EXPORTS: assertLocator, getElementByLocatorWithTargetOptions, getFrameByLocator

// EXTERNAL MODULE: ./node_modules/dom-element-is-natively-editable/index.js
var dom_element_is_natively_editable = __webpack_require__(149);

// EXTERNAL MODULE: ./node_modules/kd-glob-to-regexp/index.js
var kd_glob_to_regexp = __webpack_require__(192);
var kd_glob_to_regexp_default = /*#__PURE__*/__webpack_require__.n(kd_glob_to_regexp);

// EXTERNAL MODULE: ./src/common/utils.js
var utils = __webpack_require__(4);

// EXTERNAL MODULE: ./src/common/dom_utils.ts
var dom_utils = __webpack_require__(22);

// EXTERNAL MODULE: ./src/common/ts_utils.ts
var ts_utils = __webpack_require__(12);

// EXTERNAL MODULE: ./src/common/ipc/cs_postmessage.js
var cs_postmessage = __webpack_require__(63);

// EXTERNAL MODULE: ./src/common/web_extension.js
var web_extension = __webpack_require__(10);
var web_extension_default = /*#__PURE__*/__webpack_require__.n(web_extension);

// EXTERNAL MODULE: ./src/common/log.ts
var log = __webpack_require__(11);
var log_default = /*#__PURE__*/__webpack_require__.n(log);

// EXTERNAL MODULE: ./src/common/drag_mock/index.js
var drag_mock = __webpack_require__(360);
var drag_mock_default = /*#__PURE__*/__webpack_require__.n(drag_mock);

// CONCATENATED MODULE: ./src/common/lib/keysim.js
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



var CTRL = 1 << 0;
var META = 1 << 1;
var ALT = 1 << 2;
var SHIFT = 1 << 3;

// Key Events
var KeyEvents = {
  DOWN: 1 << 0,
  PRESS: 1 << 1,
  UP: 1 << 2,
  INPUT: 1 << 3
};
KeyEvents.ALL = KeyEvents.DOWN | KeyEvents.PRESS | KeyEvents.UP | KeyEvents.INPUT;

/**
 * Represents a keystroke, or a single key code with a set of active modifiers.
 *
 * @class Keystroke
 */
var Keystroke =
/**
 * @param {number} modifiers A bitmask formed by CTRL, META, ALT, and SHIFT.
 * @param {number} keyCode
 */
function Keystroke(modifiers, keyCode) {
  _classCallCheck(this, Keystroke);

  this.modifiers = modifiers;
  this.ctrlKey = !!(modifiers & CTRL);
  this.metaKey = !!(modifiers & META);
  this.altKey = !!(modifiers & ALT);
  this.shiftKey = !!(modifiers & SHIFT);
  this.keyCode = keyCode;
}

/**
 * Gets the bitmask value for the "control" modifier.
 *
 * @type {number}
 */


/**
 * Gets the bitmask value for the "meta" modifier.
 *
 * @return {number}
 */


/**
 * Gets the bitmask value for the "alt" modifier.
 *
 * @return {number}
 */


/**
 * Gets the bitmask value for the "shift" modifier.
 *
 * @return {number}
 */
;

/**
 * Simulates a keyboard with a particular key-to-character and key-to-action
 * mapping. Use `US_ENGLISH` to get a pre-configured keyboard.
 */
Keystroke.CTRL = CTRL;
Keystroke.META = META;
Keystroke.ALT = ALT;
Keystroke.SHIFT = SHIFT;
var keysim_Keyboard = function () {
  /**
   * @param {Object.<number, Keystroke>} charCodeKeyCodeMap
   * @param {Object.<string, number>} actionKeyCodeMap
   */
  function Keyboard(charCodeKeyCodeMap, actionKeyCodeMap) {
    _classCallCheck(this, Keyboard);

    this._charCodeKeyCodeMap = charCodeKeyCodeMap;
    this._actionKeyCodeMap = actionKeyCodeMap;
  }

  /**
   * Determines the character code generated by pressing the given keystroke.
   *
   * @param {Keystroke} keystroke
   * @return {?number}
   */


  _createClass(Keyboard, [{
    key: 'charCodeForKeystroke',
    value: function charCodeForKeystroke(keystroke) {
      var map = this._charCodeKeyCodeMap;
      for (var charCode in map) {
        if (Object.prototype.hasOwnProperty.call(map, charCode)) {
          var keystrokeForCharCode = map[charCode];
          if (keystroke.keyCode === keystrokeForCharCode.keyCode && keystroke.modifiers === keystrokeForCharCode.modifiers) {
            return parseInt(charCode, 10);
          }
        }
      }
      return null;
    }

    /**
     * Creates an event ready for dispatching onto the given target.
     *
     * @param {string} type One of "keydown", "keypress", "keyup", "textInput" or "input".
     * @param {Keystroke} keystroke
     * @param {HTMLElement} target
     * @return {Event}
     */

  }, {
    key: 'createEventFromKeystroke',
    value: function createEventFromKeystroke(type, keystroke, target) {
      var document = target.ownerDocument;
      var window = document.defaultView;
      var Event = window.Event;

      var event = void 0;

      try {
        event = new Event(type);
      } catch (e) {
        event = document.createEvent('UIEvents');
      }

      event.initEvent(type, true, true);

      switch (type) {
        case 'textInput':
          event.data = String.fromCharCode(this.charCodeForKeystroke(keystroke));
          break;

        case 'keydown':
        case 'keypress':
        case 'keyup':
          event.shiftKey = keystroke.shiftKey;
          event.altKey = keystroke.altKey;
          event.metaKey = keystroke.metaKey;
          event.ctrlKey = keystroke.ctrlKey;
          event.keyCode = type === 'keypress' ? this.charCodeForKeystroke(keystroke) : keystroke.keyCode;
          event.charCode = type === 'keypress' ? event.keyCode : 0;
          event.which = event.keyCode;
          break;
      }

      return event;
    }

    /**
     * Fires the correct sequence of events on the given target as if the given
     * action was undertaken by a human.
     *
     * @param {string} action e.g. "alt+shift+left" or "backspace"
     * @param {HTMLElement} target
     */

  }, {
    key: 'dispatchEventsForAction',
    value: function dispatchEventsForAction(action, target) {
      var keystroke = this.keystrokeForAction(action);
      this.dispatchEventsForKeystroke(keystroke, target);
    }

    /**
     * Fires the correct sequence of events on the given target as if the given
     * input had been typed by a human.
     *
     * @param {string} input
     * @param {HTMLElement} target
     */

  }, {
    key: 'dispatchEventsForInput',
    value: function dispatchEventsForInput(input, target) {
      var currentModifierState = 0;
      for (var i = 0, length = input.length; i < length; i++) {
        var keystroke = this.keystrokeForCharCode(input.charCodeAt(i));
        if (!keystroke) continue;

        this.dispatchModifierStateTransition(target, currentModifierState, keystroke.modifiers);
        this.dispatchEventsForKeystroke(keystroke, target, false);
        currentModifierState = keystroke.modifiers;
      }
      this.dispatchModifierStateTransition(target, currentModifierState, 0);
    }

    /**
     * Fires the correct sequence of events on the given target as if the given
     * keystroke was performed by a human. When simulating, for example, typing
     * the letter "A" (assuming a U.S. English keyboard) then the sequence will
     * look like this:
     *
     *   keydown   keyCode=16 (SHIFT) charCode=0      shiftKey=true
     *   keydown   keyCode=65 (A)     charCode=0      shiftKey=true
     *   keypress  keyCode=65 (A)     charCode=65 (A) shiftKey=true
     *   textInput data=A
     *   input
     *   keyup     keyCode=65 (A)     charCode=0      shiftKey=true
     *   keyup     keyCode=16 (SHIFT) charCode=0      shiftKey=false
     *
     * If the keystroke would not cause a character to be input, such as when
     * pressing alt+shift+left, the sequence looks like this:
     *
     *   keydown   keyCode=16 (SHIFT) charCode=0 altKey=false shiftKey=true
     *   keydown   keyCode=18 (ALT)   charCode=0 altKey=true  shiftKey=true
     *   keydown   keyCode=37 (LEFT)  charCode=0 altKey=true  shiftKey=true
     *   keyup     keyCode=37 (LEFT)  charCode=0 altKey=true  shiftKey=true
     *   keyup     keyCode=18 (ALT)   charCode=0 altKey=false shiftKey=true
     *   keyup     keyCode=16 (SHIFT) charCode=0 altKey=false shiftKey=false
     *
     * To disable handling of modifier keys, call with `transitionModifers` set
     * to false. Doing so will omit the keydown and keyup events associated with
     * shift, ctrl, alt, and meta keys surrounding the actual keystroke.
     *
     * @param {Keystroke} keystroke
     * @param {HTMLElement} target
     * @param {boolean=} transitionModifiers
     * @param {number} events
     */

  }, {
    key: 'dispatchEventsForKeystroke',
    value: function dispatchEventsForKeystroke(keystroke, target) {
      var transitionModifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var events = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : KeyEvents.ALL;

      if (!keystroke) return;

      if (transitionModifiers) {
        this.dispatchModifierStateTransition(target, 0, keystroke.modifiers, events);
      }

      var keydownEvent = void 0;
      if (events & KeyEvents.DOWN) {
        keydownEvent = this.createEventFromKeystroke('keydown', keystroke, target);
      }

      if (keydownEvent && target.dispatchEvent(keydownEvent) && this.targetCanReceiveTextInput(target)) {
        var keypressEvent = void 0;
        if (events & KeyEvents.PRESS) {
          keypressEvent = this.createEventFromKeystroke('keypress', keystroke, target);
        }
        if (keypressEvent && keypressEvent.charCode && target.dispatchEvent(keypressEvent)) {
          if (events & KeyEvents.INPUT) {
            var textinputEvent = this.createEventFromKeystroke('textInput', keystroke, target);
            target.dispatchEvent(textinputEvent);

            var inputEvent = this.createEventFromKeystroke('input', keystroke, target);
            target.dispatchEvent(inputEvent);
          }
        }
      }

      if (events & KeyEvents.UP) {
        var keyupEvent = this.createEventFromKeystroke('keyup', keystroke, target);
        target.dispatchEvent(keyupEvent);
      }

      if (transitionModifiers) {
        this.dispatchModifierStateTransition(target, keystroke.modifiers, 0);
      }
    }

    /**
     * Transitions from one modifier state to another by dispatching key events.
     *
     * @param {EventTarget} target
     * @param {number} fromModifierState
     * @param {number} toModifierState
     * @param {number} events
     * @private
     */

  }, {
    key: 'dispatchModifierStateTransition',
    value: function dispatchModifierStateTransition(target, fromModifierState, toModifierState) {
      var events = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : KeyEvents.ALL;

      var currentModifierState = fromModifierState;
      var didHaveMeta = (fromModifierState & META) === META;
      var willHaveMeta = (toModifierState & META) === META;
      var didHaveCtrl = (fromModifierState & CTRL) === CTRL;
      var willHaveCtrl = (toModifierState & CTRL) === CTRL;
      var didHaveShift = (fromModifierState & SHIFT) === SHIFT;
      var willHaveShift = (toModifierState & SHIFT) === SHIFT;
      var didHaveAlt = (fromModifierState & ALT) === ALT;
      var willHaveAlt = (toModifierState & ALT) === ALT;

      var includeKeyUp = events & KeyEvents.UP;
      var includeKeyDown = events & KeyEvents.DOWN;

      if (includeKeyUp && didHaveMeta === true && willHaveMeta === false) {
        // Release the meta key.
        currentModifierState &= ~META;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.META), target));
      }

      if (includeKeyUp && didHaveCtrl === true && willHaveCtrl === false) {
        // Release the ctrl key.
        currentModifierState &= ~CTRL;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.CTRL), target));
      }

      if (includeKeyUp && didHaveShift === true && willHaveShift === false) {
        // Release the shift key.
        currentModifierState &= ~SHIFT;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.SHIFT), target));
      }

      if (includeKeyUp && didHaveAlt === true && willHaveAlt === false) {
        // Release the alt key.
        currentModifierState &= ~ALT;
        target.dispatchEvent(this.createEventFromKeystroke('keyup', new Keystroke(currentModifierState, this._actionKeyCodeMap.ALT), target));
      }

      if (includeKeyDown && didHaveMeta === false && willHaveMeta === true) {
        // Press the meta key.
        currentModifierState |= META;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.META), target));
      }

      if (includeKeyDown && didHaveCtrl === false && willHaveCtrl === true) {
        // Press the ctrl key.
        currentModifierState |= CTRL;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.CTRL), target));
      }

      if (includeKeyDown && didHaveShift === false && willHaveShift === true) {
        // Press the shift key.
        currentModifierState |= SHIFT;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.SHIFT), target));
      }

      if (includeKeyDown && didHaveAlt === false && willHaveAlt === true) {
        // Press the alt key.
        currentModifierState |= ALT;
        target.dispatchEvent(this.createEventFromKeystroke('keydown', new Keystroke(currentModifierState, this._actionKeyCodeMap.ALT), target));
      }

      if (currentModifierState !== toModifierState) {
        throw new Error('internal error, expected modifier state: ' + toModifierState + (', got: ' + currentModifierState));
      }
    }

    /**
     * Returns the keystroke associated with the given action.
     *
     * @param {string} action
     * @return {?Keystroke}
     */

  }, {
    key: 'keystrokeForAction',
    value: function keystrokeForAction(action) {
      var keyCode = null;
      var modifiers = 0;

      // Note: when it comes to a single character as '+',
      // should not take it as a key combiniation (no action.split)
      var parts = action.length === 1 ? [action] : action.split('+');
      var lastPart = parts.pop();

      parts.forEach(function (part) {
        switch (part.toUpperCase()) {
          case 'CTRL':
            modifiers |= CTRL;
            break;
          case 'META':
            modifiers |= META;
            break;
          case 'ALT':
            modifiers |= ALT;
            break;
          case 'SHIFT':
            modifiers |= SHIFT;
            break;
          default:
            console.error('parts', parts);
            throw new Error('in "' + action + '", invalid modifier: ' + part);
        }
      });

      if (lastPart.toUpperCase() in this._actionKeyCodeMap) {
        keyCode = this._actionKeyCodeMap[lastPart.toUpperCase()];
      } else if (lastPart.length === 1) {
        var lastPartKeystroke = this.keystrokeForCharCode(lastPart.charCodeAt(0));
        if (!lastPartKeystroke) return null;

        modifiers |= lastPartKeystroke.modifiers;
        keyCode = lastPartKeystroke.keyCode;
      } else {
        throw new Error('in "' + action + '", invalid action: ' + lastPart);
      }

      return new Keystroke(modifiers, keyCode);
    }

    /**
     * Gets the keystroke used to generate the given character code.
     *
     * @param {number} charCode
     * @return {?Keystroke}
     */

  }, {
    key: 'keystrokeForCharCode',
    value: function keystrokeForCharCode(charCode) {
      return this._charCodeKeyCodeMap[charCode] || null;
    }

    /**
     * @param {EventTarget} target
     * @private
     */

  }, {
    key: 'targetCanReceiveTextInput',
    value: function targetCanReceiveTextInput(target) {
      if (!target) {
        return false;
      }

      return Object(dom_element_is_natively_editable["a" /* default */])(target);
    }
  }]);

  return Keyboard;
}();

var US_ENGLISH_CHARCODE_KEYCODE_MAP = {
  32: new Keystroke(0, 32), // <space>
  33: new Keystroke(SHIFT, 49), // !
  34: new Keystroke(SHIFT, 222), // "
  35: new Keystroke(SHIFT, 51), // #
  36: new Keystroke(SHIFT, 52), // $
  37: new Keystroke(SHIFT, 53), // %
  38: new Keystroke(SHIFT, 55), // &
  39: new Keystroke(0, 222), // '
  40: new Keystroke(SHIFT, 57), // (
  41: new Keystroke(SHIFT, 48), // )
  42: new Keystroke(SHIFT, 56), // *
  43: new Keystroke(SHIFT, 187), // +
  44: new Keystroke(0, 188), // ,
  45: new Keystroke(0, 189), // -
  46: new Keystroke(0, 190), // .
  47: new Keystroke(0, 191), // /
  48: new Keystroke(0, 48), // 0
  49: new Keystroke(0, 49), // 1
  50: new Keystroke(0, 50), // 2
  51: new Keystroke(0, 51), // 3
  52: new Keystroke(0, 52), // 4
  53: new Keystroke(0, 53), // 5
  54: new Keystroke(0, 54), // 6
  55: new Keystroke(0, 55), // 7
  56: new Keystroke(0, 56), // 8
  57: new Keystroke(0, 57), // 9
  58: new Keystroke(SHIFT, 186), // :
  59: new Keystroke(0, 186), // ;
  60: new Keystroke(SHIFT, 188), // <
  61: new Keystroke(0, 187), // =
  62: new Keystroke(SHIFT, 190), // >
  63: new Keystroke(SHIFT, 191), // ?
  64: new Keystroke(SHIFT, 50), // @
  65: new Keystroke(SHIFT, 65), // A
  66: new Keystroke(SHIFT, 66), // B
  67: new Keystroke(SHIFT, 67), // C
  68: new Keystroke(SHIFT, 68), // D
  69: new Keystroke(SHIFT, 69), // E
  70: new Keystroke(SHIFT, 70), // F
  71: new Keystroke(SHIFT, 71), // G
  72: new Keystroke(SHIFT, 72), // H
  73: new Keystroke(SHIFT, 73), // I
  74: new Keystroke(SHIFT, 74), // J
  75: new Keystroke(SHIFT, 75), // K
  76: new Keystroke(SHIFT, 76), // L
  77: new Keystroke(SHIFT, 77), // M
  78: new Keystroke(SHIFT, 78), // N
  79: new Keystroke(SHIFT, 79), // O
  80: new Keystroke(SHIFT, 80), // P
  81: new Keystroke(SHIFT, 81), // Q
  82: new Keystroke(SHIFT, 82), // R
  83: new Keystroke(SHIFT, 83), // S
  84: new Keystroke(SHIFT, 84), // T
  85: new Keystroke(SHIFT, 85), // U
  86: new Keystroke(SHIFT, 86), // V
  87: new Keystroke(SHIFT, 87), // W
  88: new Keystroke(SHIFT, 88), // X
  89: new Keystroke(SHIFT, 89), // Y
  90: new Keystroke(SHIFT, 90), // Z
  91: new Keystroke(0, 219), // [
  92: new Keystroke(0, 220), // \
  93: new Keystroke(0, 221), // ]
  94: new Keystroke(SHIFT, 54), // ^
  95: new Keystroke(SHIFT, 189), // _
  96: new Keystroke(0, 192), // `
  97: new Keystroke(0, 65), // a
  98: new Keystroke(0, 66), // b
  99: new Keystroke(0, 67), // c
  100: new Keystroke(0, 68), // d
  101: new Keystroke(0, 69), // e
  102: new Keystroke(0, 70), // f
  103: new Keystroke(0, 71), // g
  104: new Keystroke(0, 72), // h
  105: new Keystroke(0, 73), // i
  106: new Keystroke(0, 74), // j
  107: new Keystroke(0, 75), // k
  108: new Keystroke(0, 76), // l
  109: new Keystroke(0, 77), // m
  110: new Keystroke(0, 78), // n
  111: new Keystroke(0, 79), // o
  112: new Keystroke(0, 80), // p
  113: new Keystroke(0, 81), // q
  114: new Keystroke(0, 82), // r
  115: new Keystroke(0, 83), // s
  116: new Keystroke(0, 84), // t
  117: new Keystroke(0, 85), // u
  118: new Keystroke(0, 86), // v
  119: new Keystroke(0, 87), // w
  120: new Keystroke(0, 88), // x
  121: new Keystroke(0, 89), // y
  122: new Keystroke(0, 90), // z
  123: new Keystroke(SHIFT, 219), // {
  124: new Keystroke(SHIFT, 220), // |
  125: new Keystroke(SHIFT, 221), // }
  126: new Keystroke(SHIFT, 192) // ~
};

var US_ENGLISH_ACTION_KEYCODE_MAP = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPSLOCK: 20,
  ESCAPE: 27,
  PAGEUP: 33,
  PAGEDOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  INSERT: 45,
  DELETE: 46,
  META: 91,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123
};

/**
 * Gets a keyboard instance configured as a U.S. English keyboard would be.
 *
 * @return {Keyboard}
 */
keysim_Keyboard.US_ENGLISH = new keysim_Keyboard(US_ENGLISH_CHARCODE_KEYCODE_MAP, US_ENGLISH_ACTION_KEYCODE_MAP);
// CONCATENATED MODULE: ./src/common/send_keys.js




var keyboard = keysim_Keyboard.US_ENGLISH;

var findParentByTag = function findParentByTag(el, tag) {
  var p = el;

  // eslint-disable-next-line no-cond-assign
  while (p = p.parentNode) {
    if (p.tagName === tag.toUpperCase()) {
      return p;
    }
  }

  return null;
};

var send_keys_splitStringToChars = function splitStringToChars(str) {
  var specialKeys = ['KEY_LEFT', 'KEY_UP', 'KEY_RIGHT', 'KEY_DOWN', 'KEY_PGUP', 'KEY_PAGE_UP', 'KEY_PGDN', 'KEY_PAGE_DOWN', 'KEY_BKSP', 'KEY_BACKSPACE', 'KEY_DEL', 'KEY_DELETE', 'KEY_ENTER', 'KEY_TAB'];
  var reg = new RegExp('\\$\\{(' + specialKeys.join('|') + ')\\}');
  var parts = Object(utils["splitKeep"])(reg, str);

  return parts.reduce(function (prev, cur) {
    if (reg.test(cur)) {
      prev.push(cur);
    } else {
      prev = prev.concat(cur.split(''));
    }

    return prev;
  }, []);
};

var getKeyStrokeAction = function getKeyStrokeAction(str) {
  var reg = /^\$\{([^}]+)\}$/;
  var match = void 0;

  // eslint-disable-next-line no-cond-assign
  if (match = str.match(reg)) {
    switch (match[1]) {
      case 'KEY_LEFT':
        return 'LEFT';

      case 'KEY_UP':
        return 'UP';

      case 'KEY_RIGHT':
        return 'RIGHT';

      case 'KEY_DOWN':
        return 'DOWN';

      case 'KEY_PGUP':
      case 'KEY_PAGE_UP':
        return 'PAGEUP';

      case 'KEY_PGDN':
      case 'KEY_PAGE_DOWN':
        return 'PAGEDOWN';

      case 'KEY_BKSP':
      case 'KEY_BACKSPACE':
        return 'BACKSPACE';

      case 'KEY_DEL':
      case 'KEY_DELETE':
        return 'DELETE';

      case 'KEY_ENTER':
        return 'ENTER';

      case 'KEY_TAB':
        return 'TAB';
    }
  }

  return str;
};

var isEditable = function isEditable(el) {
  if (el.getAttribute('readonly') !== null) return false;
  var tag = el.tagName.toUpperCase();
  var type = (el.type || '').toLowerCase();
  var editableTypes = ['text', 'search', 'tel', 'url', 'email', 'password', 'number'];

  if (tag === 'TEXTAREA') return true;
  if (tag === 'INPUT' && editableTypes.indexOf(type) !== -1) return true;

  return false;
};

var maybeEditText = function maybeEditText(target, c) {
  if (!isEditable(target)) return;
  if (c.length === 1) {
    if (!isNil(target.selectionStart)) {
      var lastStart = target.selectionStart;
      target.value = target.value.substring(0, target.selectionStart) + c + target.value.substring(target.selectionEnd);

      setSelection(target, lastStart + 1);
    } else {
      target.value = target.value + c;
    }
  } else {
    switch (c) {
      case 'ENTER':
        target.value = target.value + '\n';
        setSelection(target, target.value.length);
        break;
      case 'TAB':
        target.value = target.value + '\t';
        setSelection(target, target.value.length);
        break;
      case 'LEFT':
        setSelection(target, target.selectionStart - 1);
        break;
      case 'RIGHT':
        setSelection(target, target.selectionEnd + 1);
        break;
      case 'BACKSPACE':
        {
          var pos = target.selectionStart;
          target.value = target.value.substring(0, target.selectionStart - 1) + target.value.substring(target.selectionEnd);
          setSelection(target, pos - 1);
          break;
        }
      case 'DELETE':
        {
          var _pos = target.selectionEnd;
          target.value = target.value.substring(0, target.selectionStart) + target.value.substring(target.selectionEnd + 1);
          setSelection(target, _pos);
          break;
        }
    }
  }
};

var maybeSubmitForm = function maybeSubmitForm(target, key) {
  if (key !== 'ENTER') return;
  if (!isEditable(target)) return;

  var form = findParentByTag(target, 'FORM');
  if (!form) return;

  form.submit();
};

var isNil = function isNil(val) {
  return val === null || val === undefined;
};

var setSelection = function setSelection($el, start, end) {
  // Note: Inputs like number and email, doesn't support selectionEnd
  // for safety, make sure those values are not null or undefined (infers that it's available)
  if (!isNil($el.selectionStart)) {
    $el.selectionStart = start;
  }

  if (!isNil($el.selectionEnd)) {
    $el.selectionEnd = end !== undefined ? end : start;
  }
};

var replaceActionKey = function () {
  var mapping = {
    0: null, // the NULL character
    8: 'BACKSPACE',
    9: 'TAB',
    10: 'ENTER', // \n  new line
    11: null, // \v  vertical tab
    12: null, // \f  form feed
    13: null // \r  carriage return
  };

  return function (c) {
    // Note: it means it's already key stroke action
    if (c.length > 1) return c;
    return mapping[c.charCodeAt(0)] || c;
  };
}();

function sendKeys(target, str, noSpecialKeys) {
  var rawChars = noSpecialKeys ? str.split('') : send_keys_splitStringToChars(str);
  var chars = rawChars.map(replaceActionKey).filter(function (x) {
    return x && x.length;
  });

  target.focus();
  if (target.value) {
    setSelection(target, target.value.length);
  }

  chars.forEach(function (c) {
    var action = getKeyStrokeAction(c);

    maybeEditText(target, action);
    // Note: This line will take care of KEYDOWN KEYPRESS KEYUP and TEXTINPUT
    keyboard.dispatchEventsForAction(action, target);

    if (!noSpecialKeys) {
      maybeSubmitForm(target, action);
    }
  });
}
// EXTERNAL MODULE: ./src/common/encrypt.js
var encrypt = __webpack_require__(136);

// EXTERNAL MODULE: ./src/common/constant.ts
var constant = __webpack_require__(17);

// EXTERNAL MODULE: ./src/config/index.ts
var config = __webpack_require__(34);
var config_default = /*#__PURE__*/__webpack_require__.n(config);

// CONCATENATED MODULE: ./src/common/command_runner.js
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }















var HIGHLIGHT_TIMEOUT = 500;

var command_runner_globMatch = function globMatch(pattern, text, opts) {
  var reg = kd_glob_to_regexp_default()(pattern, opts || {});
  var res = reg.test(text);
  return res;
};

var getElementsByXPath = function getElementsByXPath(xpath) {
  var snapshot = document.evaluate(xpath, document.body, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
  var list = [];

  for (var i = 0, len = snapshot.snapshotLength; i < len; i++) {
    list.push(snapshot.snapshotItem(i));
  }

  return list;
};

var getElementByXPath = function getElementByXPath(xpath) {
  return getElementsByXPath(xpath)[0];
};

// reference: https://github.com/timoxley/offset
var viewportOffset = function viewportOffset(el) {
  var box = el.getBoundingClientRect();

  // Note: simply use bouddingClientRect since elementFromPoint uses
  // the same top/left relative to the current viewport/window instead of whole document
  return {
    top: box.top,
    left: box.left
  };
};

var command_runner_getIframeViewportOffset = function getIframeViewportOffset() {
  if (window === window.top) {
    return Promise.resolve({ x: 0, y: 0 });
  }

  return Object(cs_postmessage["postMessage"])(window.parent, window, {
    action: 'SOURCE_VIEWPORT_OFFSET',
    data: {}
  });
};

var command_runner_untilInjected = function untilInjected() {
  var api = {
    eval: function _eval(code) {
      log_default()('sending INJECT_RUN_EVAL');
      return Object(cs_postmessage["postMessage"])(window, window, { cmd: 'INJECT_RUN_EVAL', args: { code: code } }, '*', 5000).then(function (data) {
        log_default()('eval result', data);
        return data.result;
      });
    }
  };
  var injected = !!document.body.getAttribute('data-injected');
  if (injected) return Promise.resolve(api);

  Object(utils["insertScript"])(web_extension_default.a.extension.getURL('inject.js'));

  return Object(utils["retry"])(function () {
    log_default()('sending INJECT_READY');
    return Object(cs_postmessage["postMessage"])(window, window, { cmd: 'INJECT_READY' }, '*', 500);
  }, {
    shouldRetry: function shouldRetry() {
      return true;
    },
    timeout: 5000,
    retryInterval: 0
  })().then(function () {
    return api;
  }).catch(function (e) {
    log_default()(e.stack);
    throw new Error('fail to inject');
  });
};

var isElementFromPoint = function isElementFromPoint(str) {
  return (/^#elementfrompoint/i.test(str.trim())
  );
};

var viewportCoordinateByElementFromPoint = function viewportCoordinateByElementFromPoint(str) {
  var reg = /^#elementfrompoint\s*\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/i;
  var m = str.trim().match(reg);

  if (!m) {
    throw new Error('Invalid \'#elementfrompoint\' expression');
  }

  var viewportX = parseFloat(m[1]);
  var viewportY = parseFloat(m[2]);

  if (viewportX <= 0 || viewportY <= 0) {
    throw new Error('\'#elementfrompoint\' only accepts positive numbers');
  }

  return [viewportX, viewportY];
};

var elementByElementFromPoint = function elementByElementFromPoint(str) {
  var _viewportCoordinateBy = viewportCoordinateByElementFromPoint(str),
      _viewportCoordinateBy2 = _slicedToArray(_viewportCoordinateBy, 2),
      x = _viewportCoordinateBy2[0],
      y = _viewportCoordinateBy2[1];

  var el = document.elementFromPoint(x, y);
  return el;
};

var command_runner_focusIfEditable = function focusIfEditable($el) {
  if (Object(dom_element_is_natively_editable["a" /* default */])($el) && typeof $el.focus === 'function') {
    $el.focus();
  }
};

var assertLocator = function assertLocator(str) {
  var i = str.indexOf('=');

  // xpath
  if (/^\//.test(str)) return true;
  // efp
  if (/^#elementfrompoint/i.test(str)) return true;
  // Above is all locators that doesn't require '='
  if (i === -1) throw new Error('invalid locator, ' + str);

  var method = str.substr(0, i);
  var value = str.substr(i + 1);

  if (!value || !value.length) throw new Error('invalid locator, ' + str);

  switch (method && method.toLowerCase()) {
    case 'id':
    case 'name':
    case 'identifier':
    case 'link':
    case 'linktext':
    case 'partiallinktext':
    case 'css':
    case 'xpath':
      return true;

    default:
      throw new Error('invalid locator, ' + str);
  }
};

var isLocator = function isLocator(str) {
  try {
    assertLocator(str);
    return true;
  } catch (e) {
    return false;
  }
};

// Note: parse the locator and return the element found accordingly
var command_runner_getElementByLocator = function getElementByLocator(str, shouldWaitForVisible) {
  var i = str.indexOf('=');
  var el = void 0;

  if (/^\//.test(str)) {
    el = getElementByXPath(str);
  } else if (/^#elementfrompoint/i.test(str.trim())) {
    el = elementByElementFromPoint(str);
    log_default()('elementfrompoint', el);
  } else if (i === -1) {
    throw new Error('getElementByLocator: invalid locator, ' + str);
  } else {
    var method = str.substr(0, i);
    var value = str.substr(i + 1);
    var lowerMethod = method && method.toLowerCase();

    switch (lowerMethod) {
      case 'id':
        el = document.getElementById(value);
        break;

      case 'name':
        el = document.getElementsByName(value)[0];
        break;

      case 'identifier':
        el = document.getElementById(value) || document.getElementsByName(value)[0];
        break;

      case 'link-notused':
        {
          var links = [].slice.call(document.getElementsByTagName('a'));
          // Note: there are cases such as 'link=exact:xxx'
          var realVal = value.replace(/^exact:/, '');
          // Note: position support. eg. link=Download@POS=3
          var match = realVal.match(/^(.+)@POS=(\d+)$/i);
          var index = 0;

          if (match) {
            realVal = match[1];
            index = parseInt(match[2]) - 1;
          }

          // Note: use textContent instead of innerText to avoid influence from text-transform
          var candidates = links.filter(function (a) {
            return command_runner_globMatch(realVal, Object(dom_utils["domText"])(a));
          });
          el = candidates[index];
          break;
        }

      case 'link':
      case 'linktext':
      case 'partiallinktext':
        {
          var _links = [].slice.call(document.getElementsByTagName('a'));
          // Note: position support. eg. link=Download@POS=3
          var _match = value.match(/^(.+)@POS=(\d+)$/i);
          var _realVal = value;
          var _index = 0;

          if (_match) {
            _realVal = _match[1];
            _index = parseInt(_match[2]) - 1;
          }

          var pattern = lowerMethod === 'partiallinktext' ? '*' + _realVal + '*' : _realVal;
          var _candidates = _links.filter(function (link) {
            return command_runner_globMatch(pattern, Object(dom_utils["domText"])(link), { flags: 'im' });
          });

          el = _candidates[_index];
          break;
        }

      case 'css':
        el = document.querySelector(value);
        break;

      case 'xpath':
        el = getElementByXPath(value);
        break;

      default:
        throw new Error('getElementByLocator: unsupported locator method, ' + method);
    }
  }

  if (!el) {
    throw new Error('getElementByLocator: fail to find element based on the locator, ' + str);
  }

  if (shouldWaitForVisible && !Object(dom_utils["isVisible"])(el)) {
    throw new Error('getElementByLocator: element is found but not visible yet');
  }

  return el;
};

// We now save targetOptions in command, if main target can't be found (extra?.retryInfo.final === true),
// it should try all targetOptions just for once
var getElementByLocatorWithTargetOptions = function getElementByLocatorWithTargetOptions(locator, shouldWaitForVisible, command, csIpc) {
  var _ref = command || {},
      extra = _ref.extra,
      targetOptions = _ref.targetOptions;

  if (extra && extra.retryInfo && extra.retryInfo.final && targetOptions && targetOptions.length) {
    for (var i = 0, len = targetOptions.length; i < len; i++) {
      var target = targetOptions[i];

      try {
        var el = command_runner_getElementByLocator(target, shouldWaitForVisible);

        csIpc.ask('CS_ADD_LOG', {
          warning: 'Element found with secondary locator "' + target + '". To use it by default, update the target field to use it as primary locator.'
        });

        return el;
      } catch (e) {
        if (i === len - 1) {
          throw e;
        }
      }
    }
  }

  return command_runner_getElementByLocator(locator, shouldWaitForVisible);
};

var command_runner_getFrameByLocator = function getFrameByLocator(str, helpers) {
  var i = str.indexOf('=');

  // Note: try to parse format of 'index=0' and 'relative=top/parent'
  if (i !== -1) {
    var method = str.substr(0, i);
    var value = str.substr(i + 1);

    switch (method) {
      case 'index':
        {
          var index = parseInt(value, 10);
          var frames = window.frames;
          var frame = frames[index];

          if (!frame) {
            throw new Error('Frame index out of range (index ' + value + ' in ' + frames.length + ' frames');
          }

          return { frame: frame };
        }

      case 'relative':
        {
          if (value === 'top') {
            return { frame: window.top };
          }

          if (value === 'parent') {
            return { frame: window.parent };
          }

          throw new Error('Unsupported relative type, ' + value);
        }
    }
  }

  // Note: consider it as name, if no '=' found and it has no xpath pattern
  if (i === -1 && !/^\/.*/.test(str)) {
    str = 'name=' + str;
  }

  var frameDom = command_runner_getElementByLocator(str);

  if (!frameDom || !frameDom.contentWindow) {
    throw new Error('The element found based on ' + str + ' is NOT a frame/iframe');
  }

  // Note: for those iframe/frame that don't have src, they won't load content_script.js
  // so we have to inject the script by ourselves
  if (!frameDom.getAttribute('src')) {
    var file = web_extension_default.a.extension.getURL('content_script.js');
    var doc = frameDom.contentDocument;
    var s = doc.constructor.prototype.createElement.call(doc, 'script');

    s.setAttribute('type', 'text/javascript');
    s.setAttribute('src', file);

    doc.documentElement.appendChild(s);
    s.parentNode.removeChild(s);

    helpers.hackAlertConfirmPrompt(doc);
  }

  // Note: can't return the contentWindow directly, because Promise 'resolve' will
  // try to test its '.then' method, which will cause a cross origin violation
  // so, we wrap it in an object
  return { frame: frameDom.contentWindow };
};

var command_runner_run = function run(command, csIpc, helpers) {
  var cmd = command.cmd,
      target = command.target,
      value = command.value,
      extra = command.extra;

  var wrap = function wrap(fn, genOptions) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var options = genOptions.apply(undefined, args);

      return new Promise(function (resolve, reject) {
        try {
          resolve(fn.apply(undefined, args));
        } catch (e) {
          reject(new Error(options.errorMsg(e.message)));
        }
      });
    };
  };
  var wrapWithPromiseAndErrorMessageTransform = Object(ts_utils["partial"])(function (getLocator, fn) {
    return wrap(fn, function () {
      var locator = getLocator.apply(undefined, arguments);

      return {
        errorMsg: function errorMsg(msg) {
          if (/element is found but not visible yet/.test(msg)) {
            return 'element is found but not visible yet for \'' + locator + '\' (use !WaitForVisible = false to disable waiting for visible)';
          }

          return 'timeout reached when looking for element \'' + locator + '\'';
        }
      };
    });
  });
  var wrapWithLogForEfp = Object(ts_utils["partial"])(function (getLocator, fn) {
    return function () {
      var el = fn.apply(undefined, arguments);
      var locator = getLocator.apply(undefined, arguments);

      if (isElementFromPoint(locator)) {
        var elXpath = 'unkown';

        try {
          elXpath = helpers.xpath(el);
        } catch (e) {}

        var msg = locator + ' => xpath "' + elXpath + '"';

        csIpc.ask('CS_ADD_LOG', { info: msg });
      }

      return el;
    };
  });
  var wrapWithSearchForInput = function wrapWithSearchForInput(fn) {
    return function () {
      var el = fn.apply(undefined, arguments);

      if (!el || el.tagName === 'INPUT') {
        return el;
      }

      var label = Object(dom_utils["getAncestor"])(el, function (node) {
        return node.tagName === 'LABEL';
      });

      if (!label) {
        return el;
      }

      var input = label.querySelector('input');

      return input || el;
    };
  };
  var getElementByLocatorWithLogForEfp = wrapWithLogForEfp(getElementByLocatorWithTargetOptions, function (locator) {
    return locator;
  });
  var __getFrameByLocator = wrap(command_runner_getFrameByLocator, function (locator) {
    return {
      errorMsg: function errorMsg(msg) {
        return 'timeout reached when looking for frame \'' + locator + '\'';
      }
    };
  });
  var __getElementByLocator = Object(ts_utils["compose"])(wrapWithPromiseAndErrorMessageTransform(function (locator) {
    return locator;
  }), wrapWithLogForEfp(function (locator) {
    return locator;
  }))(getElementByLocatorWithTargetOptions);

  var __getInputElementByLocator = Object(ts_utils["compose"])(wrapWithPromiseAndErrorMessageTransform(function (locator) {
    return locator;
  }), wrapWithLogForEfp(function (locator) {
    return locator;
  }), wrapWithSearchForInput)(getElementByLocatorWithTargetOptions);

  var __expectNoElementByLocator = function __expectNoElementByLocator(locator, shouldWaitForVisible) {
    return __getElementByLocator(locator, shouldWaitForVisible).then(function () {
      if (shouldWaitForVisible) {
        throw new Error('timeout reached when waiting for element \'' + locator + '\' to be not present');
      } else {
        throw new Error('timeout reached when waiting for element \'' + locator + '\' to be not visible');
      }
    }, function () {
      return true;
    });
  };

  switch (cmd) {
    case 'open':
      if (window.noCommandsYet) {
        return true;
      }

      return Object(utils["until"])('document.body', function () {
        return {
          pass: !!document.body,
          result: document.body
        };
      }).then(function (body) {
        setTimeout(function () {
          csIpc.ask('CS_LOAD_URL', { url: command.target }).then(function () {
            return true;
          });
        });
        return true;
      });

    case 'refresh':
      setTimeout(function () {
        return window.location.reload();
      }, 0);
      return true;

    case 'mouseOver':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function (el) {
          try {
            if (extra.playScrollElementsIntoView) el.scrollIntoView({ block: 'center' });
            if (extra.playHighlightElements) helpers.highlightDom(el, HIGHLIGHT_TIMEOUT);
          } catch (e) {
            log_default.a.error('error in scroll and highlight', e.message);
          }

          el.dispatchEvent(new MouseEvent('mouseover', { bubbles: true }));
          return true;
        });
      }

    // Note: 'locate' command is only for internal use
    case 'locate':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function (el) {
          try {
            if (extra.playScrollElementsIntoView) el.scrollIntoView({ block: 'center' });
            if (extra.playHighlightElements) helpers.highlightDom(el, HIGHLIGHT_TIMEOUT);
          } catch (e) {
            log_default.a.error('error in scroll and highlight', e.message);
          }

          var vpOffset = viewportOffset(el);

          return command_runner_getIframeViewportOffset().then(function (windowOffset) {
            return {
              rect: {
                x: vpOffset.left + windowOffset.x,
                y: vpOffset.top + windowOffset.y,
                width: el.offsetWidth,
                height: el.offsetHeight
              }
            };
          });
        });
      }

    case 'dragAndDropToObject':
      {
        return Promise.all([__getElementByLocator(target, false, command, csIpc), __getElementByLocator(value)]).then(function (_ref2) {
          var _ref3 = _slicedToArray(_ref2, 2),
              $src = _ref3[0],
              $tgt = _ref3[1];

          drag_mock_default.a.triggerDragEvent($src, $tgt);
          return true;
        });
      }

    case 'waitForElementVisible':
    case 'waitForVisible':
      {
        return __getElementByLocator(target, true, command, csIpc).then(function () {
          return true;
        });
      }

    case 'waitForElementNotVisible':
      {
        return __expectNoElementByLocator(target, true).then(function () {
          return true;
        });
      }

    case 'waitForElementPresent':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function () {
          return true;
        });
      }

    case 'waitForElementNotPresent':
      {
        return __expectNoElementByLocator(target, false).then(function () {
          return true;
        });
      }

    case 'clickAt':
      {
        var isEfp = isElementFromPoint(target);
        var pTarget = function () {
          if (!isEfp) return Promise.resolve(target);
          return command_runner_getIframeViewportOffset().then(function (iframeOffset) {
            log_default()('iframeOffset', iframeOffset);

            var _viewportCoordinateBy3 = viewportCoordinateByElementFromPoint(target),
                _viewportCoordinateBy4 = _slicedToArray(_viewportCoordinateBy3, 2),
                x = _viewportCoordinateBy4[0],
                y = _viewportCoordinateBy4[1];

            return '#elementfrompoint (' + (x - iframeOffset.x) + ', ' + (y - iframeOffset.y) + ')';
          });
        }();

        return pTarget.then(function (target) {
          return __getElementByLocator(target, extra.waitForVisible, command, csIpc).then(function (el) {
            if (!/^\d+\s*,\s*\d+$/.test(value) && !isElementFromPoint(target)) {
              throw new Error('invalid offset for clickAt: ' + value);
            }

            var scrollAndHighlight = function scrollAndHighlight() {
              try {
                if (extra.playScrollElementsIntoView) el.scrollIntoView({ block: 'center' });
                if (extra.playHighlightElements) helpers.highlightDom(el, HIGHLIGHT_TIMEOUT);
              } catch (e) {
                log_default.a.error('error in scroll and highlight');
              }
            };

            var _ref4 = function () {
              if (isEfp) {
                return viewportCoordinateByElementFromPoint(target);
              } else {
                var _value$split$map = value.split(',').map(function (str) {
                  return parseInt(str.trim(), 10);
                }),
                    _value$split$map2 = _slicedToArray(_value$split$map, 2),
                    x = _value$split$map2[0],
                    y = _value$split$map2[1];

                var _viewportOffset = viewportOffset(el),
                    top = _viewportOffset.top,
                    left = _viewportOffset.left;

                return [left + x, top + y];
              }
            }(),
                _ref5 = _slicedToArray(_ref4, 2),
                origClientX = _ref5[0],
                origClientY = _ref5[1];

            var lastScrollX = window.scrollX;
            var lastScrollY = window.scrollY;

            if (!isEfp) scrollAndHighlight();

            var clientX = origClientX + (lastScrollX - window.scrollX);
            var clientY = origClientY + (lastScrollY - window.scrollY);

            log_default()('clickAt clientX/clientY', clientX, clientY);['mousedown', 'mouseup', 'click'].forEach(function (eventType) {
              el.dispatchEvent(new MouseEvent(eventType, {
                view: window,
                bubbles: true,
                cancelable: true,
                clientX: clientX,
                clientY: clientY
              }));
            });

            // Note: delay scroll and highlight for efp,
            // otherwise that scroll could mess up the whole coodirnate calculation
            if (isEfp) scrollAndHighlight();

            command_runner_focusIfEditable(el);
            return true;
          });
        });
      }

    case 'click':
    case 'clickAndWait':
      {
        return __getElementByLocator(target, extra.waitForVisible, command, csIpc).then(function (el) {
          try {
            if (extra.playScrollElementsIntoView) el.scrollIntoView({ block: 'center' });
            if (extra.playHighlightElements) helpers.highlightDom(el, HIGHLIGHT_TIMEOUT);
          } catch (e) {
            log_default.a.error('error in scroll and highlight');
          }

          ;['mousedown', 'mouseup', 'click'].forEach(function (eventType) {
            if (eventType === 'click' && typeof el.click === 'function') {
              return el.click();
            }

            el.dispatchEvent(new MouseEvent(eventType, {
              view: window,
              bubbles: true,
              cancelable: true
            }));
          });

          command_runner_focusIfEditable(el);
          return true;
        });
      }

    case 'check':
    case 'uncheck':
      {
        return __getInputElementByLocator(target, extra.waitForVisible, command, csIpc).then(function (el) {
          el.checked = cmd === 'check';
          el.dispatchEvent(new Event('change', {
            target: el,
            bubbles: true
          }));
          return true;
        });
      }

    case 'addSelection':
    case 'removeSelection':
    case 'select':
    case 'selectAndWait':
      {
        return __getElementByLocator(target, extra.waitForVisible, command, csIpc).then(function (el) {
          var options = [].slice.call(el.getElementsByTagName('option'));
          var i = value.indexOf('=');
          var optionType = value.substring(0, i);
          var optionValue = value.substring(i + 1);

          var option = function () {
            switch (optionType) {
              case 'label':
                return options.find(function (op) {
                  return command_runner_globMatch(optionValue, Object(dom_utils["domText"])(op).trim());
                });

              case 'index':
                return options.find(function (_, index) {
                  return index === parseInt(optionValue);
                });

              case 'id':
                return options.find(function (op, index) {
                  return op.id === optionValue;
                });

              case 'value':
                return options.find(function (op) {
                  return op.value === optionValue;
                });

              default:
                throw new Error('Option type "' + optionType + '" not supported');
            }
          }();

          if (!option) {
            throw new Error('cannot find option with \'' + value + '\'');
          }

          if (extra.playScrollElementsIntoView) el.scrollIntoView({ block: 'center' });
          if (extra.playHighlightElements) helpers.highlightDom(el, HIGHLIGHT_TIMEOUT);

          switch (cmd) {
            case 'addSelection':
              option.selected = true;
              break;

            case 'removeSelection':
              option.selected = false;
              break;

            default:
              el.value = option.value;
              break;
          }

          el.dispatchEvent(new Event('change', {
            target: el,
            bubbles: true
          }));
          return true;
        });
      }

    case 'type':
      {
        return __getElementByLocator(target, extra.waitForVisible, command, csIpc).then(function (el) {
          var tag = el.tagName.toLowerCase();

          if (tag !== 'input' && tag !== 'textarea') {
            throw new Error('run command: element found is neither input nor textarea');
          }

          if (extra.playScrollElementsIntoView) el.scrollIntoView({ block: 'center' });
          if (extra.playHighlightElements) helpers.highlightDom(el, HIGHLIGHT_TIMEOUT);

          // Note: need the help of chrome.debugger to set file path to file input
          if (el.type && el.type.toLowerCase() === 'file') {
            if (web_extension_default.a.isFirefox()) {
              throw new Error('Setting file path fo file inputs is not supported by Firefox extension api yet');
            }

            return csIpc.ask('CS_SET_FILE_INPUT_FILES', {
              files: value.split(';'),
              selector: Object(dom_utils["cssSelector"])(el)
            });
          }

          command_runner_focusIfEditable(el);

          return Object(encrypt["a" /* decryptIfNeeded */])(value, el).then(function (realValue) {
            el.value = '';

            if (realValue.length <= config_default.a.commandRunner.sendKeysMaxCharCount) {
              sendKeys(el, realValue, true);
            }

            el.value = realValue;
            el.dispatchEvent(new Event('change', {
              target: el,
              bubbles: true
            }));
            return true;
          });
        }).catch(function (e) {
          if (/This input element accepts a filename/i.test(e.message)) {
            throw new Error('Sorry, upload can not be automated Chrome (API limitation).');
          }

          throw e;
        });
      }

    case 'editContent':
      {
        return __getElementByLocator(target, extra.waitForVisible, command, csIpc).then(function (el) {
          if (el.contentEditable !== 'true') {
            throw new Error('Target is not contenteditable');
          }

          if (extra.playScrollElementsIntoView) el.scrollIntoView({ block: 'center' });
          if (extra.playHighlightElements) helpers.highlightDom(el, HIGHLIGHT_TIMEOUT);

          el.focus();
          el.innerHTML = value;
          el.blur();

          return true;
        });
      }

    case 'selectFrame':
      {
        return __getFrameByLocator(target, helpers).then(function (frameWindow) {
          if (!frameWindow) {
            throw new Error('Invalid frame/iframe');
          }

          return frameWindow;
        });
      }

    case 'verifyText':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function (el) {
          var text = Object(dom_utils["domText"])(el);

          if (!command_runner_globMatch(value, text)) {
            return {
              log: {
                error: 'text not matched, \n\texpected: "' + value + '", \n\tactual: "' + text + '"'
              }
            };
          }

          return true;
        });
      }

    case 'verifyTitle':
      {
        if (!command_runner_globMatch(target, document.title)) {
          return {
            log: {
              error: 'title not matched, \n\texpected: "' + target + '", \n\tactual: "' + document.title + '"'
            }
          };
        }

        return true;
      }

    case 'verifyElementPresent':
      {
        var _ref6 = extra || {},
            timeoutElement = _ref6.timeoutElement,
            retryInfo = _ref6.retryInfo;

        return __getElementByLocator(target, false, command, csIpc).then(function () {
          return true;
        }, function (e) {
          var shotsLeft = timeoutElement * 1000 / retryInfo.retryInterval - retryInfo.retryCount;
          var isLastChance = shotsLeft <= 1;

          if (isLastChance) {
            return {
              log: {
                error: '\'' + target + '\' element not present'
              }
            };
          }

          throw e;
        });
      }

    case 'verifyElementNotPresent':
      {
        var _ref7 = extra || {},
            _timeoutElement = _ref7.timeoutElement,
            _retryInfo = _ref7.retryInfo;

        return __expectNoElementByLocator(target).then(function () {
          return true;
        }, function (e) {
          var shotsLeft = _timeoutElement * 1000 / _retryInfo.retryInterval - _retryInfo.retryCount;
          var isLastChance = shotsLeft <= 1;

          if (isLastChance) {
            return {
              log: {
                error: '\'' + target + '\' element is still present'
              }
            };
          }

          throw e;
        });
      }

    case 'verifyEditable':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function (el) {
          var editable = Object(dom_utils["isEditable"])(el);

          if (!editable) {
            return {
              log: {
                error: '\'' + target + '\' is not editable'
              }
            };
          }

          return true;
        });
      }

    case 'verifyNotEditable':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function (el) {
          var editable = Object(dom_utils["isEditable"])(el);

          if (editable) {
            return {
              log: {
                error: '\'' + target + '\' is editable'
              }
            };
          }

          return true;
        });
      }

    case 'verifyChecked':
      {
        return __getInputElementByLocator(target, false, command, csIpc).then(function (el) {
          var checked = !!el.checked;

          if (!checked) {
            return {
              log: {
                error: '\'' + target + '\' is not checked'
              }
            };
          }

          return true;
        });
      }
    case 'verifyNotChecked':
      {
        return __getInputElementByLocator(target, false, command, csIpc).then(function (el) {
          var checked = !!el.checked;

          if (checked) {
            return {
              log: {
                error: '\'' + target + '\' is checked'
              }
            };
          }

          return true;
        });
      }

    case 'verifyAttribute':
      {
        var index = target.lastIndexOf('@');

        if (index === -1) {
          throw new Error('invalid target for verifyAttribute - ' + target);
        }

        var locator = target.substr(0, index);
        var attrName = target.substr(index + 1);

        return __getElementByLocator(locator, false, command, csIpc).then(function (el) {
          var attr = el.getAttribute(attrName);

          if (!command_runner_globMatch(value, attr)) {
            return {
              log: {
                error: 'attribute not matched, \n\texpected: "' + value + '", \n\tactual: "' + attr + '"'
              }
            };
          }

          return true;
        });
      }

    case 'verifyError':
      {
        if (extra.lastCommandOk) {
          return {
            log: {
              error: target
            }
          };
        }

        return true;
      }

    case 'assertText':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function (el) {
          var text = Object(dom_utils["domText"])(el);

          if (!command_runner_globMatch(value, text)) {
            throw new Error('text not matched, \n\texpected: "' + value + '", \n\tactual: "' + text + '"');
          }

          return true;
        });
      }

    case 'assertTitle':
      {
        if (!command_runner_globMatch(target, document.title)) {
          throw new Error('title not matched, \n\texpected: "' + target + '", \n\tactual: "' + document.title + '"');
        }

        return true;
      }

    case 'assertElementPresent':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function () {
          return true;
        });
      }

    case 'assertElementNotPresent':
      {
        return __expectNoElementByLocator(target);
      }

    case 'assertChecked':
      {
        return __getInputElementByLocator(target, false, command, csIpc).then(function (el) {
          var checked = !!el.checked;

          if (!checked) {
            throw new Error('\'' + target + '\' is not checked');
          }

          return true;
        });
      }

    case 'assertNotChecked':
      {
        return __getInputElementByLocator(target, false, command, csIpc).then(function (el) {
          var checked = !!el.checked;

          if (checked) {
            throw new Error('\'' + target + '\' is checked');
          }

          return true;
        });
      }

    case 'assertEditable':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function (el) {
          var editable = Object(dom_utils["isEditable"])(el);

          if (!editable) {
            throw new Error('\'' + target + '\' is not editable');
          }

          return true;
        });
      }

    case 'assertNotEditable':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function (el) {
          var editable = Object(dom_utils["isEditable"])(el);

          if (editable) {
            throw new Error('\'' + target + '\' is editable');
          }

          return true;
        });
      }

    case 'assertAttribute':
      {
        var _index2 = target.lastIndexOf('@');

        if (_index2 === -1) {
          throw new Error('invalid target for assertAttribute - ' + target);
        }

        var _locator = target.substr(0, _index2);
        var _attrName = target.substr(_index2 + 1);

        return __getElementByLocator(_locator, false, command, csIpc).then(function (el) {
          var attr = el.getAttribute(_attrName);

          if (!command_runner_globMatch(value, attr)) {
            throw new Error('attribute not matched, \n\texpected: "' + value + '", \n\tactual: "' + attr + '"');
          }

          return true;
        });
      }

    case 'assertError':
      {
        if (extra.lastCommandOk) {
          throw new Error(target);
        }

        return true;
      }

    case 'assertAlert':
      {
        var msg = document.body.getAttribute('data-alert');

        if (!msg) {
          throw new Error('no alert found!');
        }

        if (!command_runner_globMatch(target, msg)) {
          throw new Error('unmatched alert msg, \n\texpected: "' + target + '", \n\tactual: "' + msg + '"');
        }

        document.body.setAttribute('data-alert', '');
        return true;
      }

    case 'assertConfirmation':
      {
        var _msg = document.body.getAttribute('data-confirm');

        if (!_msg) {
          throw new Error('no confirm found!');
        }

        if (!command_runner_globMatch(target, _msg)) {
          throw new Error('unmatched confirm msg, \n\texpected: "' + target + '", \n\tactual: "' + _msg + '"');
        }

        document.body.setAttribute('data-confirm', '');
        return true;
      }

    case 'assertPrompt':
      {
        var _msg2 = document.body.getAttribute('data-prompt');

        if (!_msg2) {
          throw new Error('no prompt found!');
        }

        if (!command_runner_globMatch(target, _msg2)) {
          throw new Error('unmatched prompt msg, \n\texpected: "' + target + '", \n\tactual: "' + _msg2 + '"');
        }

        document.body.setAttribute('data-prompt', '');
        return true;
      }

    case 'answerOnNextPrompt':
      {
        document.body.setAttribute('data-prompt-answer', target);
        return true;
      }

    case 'waitForPageToLoad':
      return true;

    case 'storeXpathCount':
      {
        var i = target.indexOf('=');
        var method = target.substr(0, i);
        var xpathStr = target.substr(i + 1);
        var lowerMethod = method && method.toLowerCase();

        if (lowerMethod !== 'xpath') {
          throw new Error('storeXpathCount: target should start with "xpath="');
        }

        return {
          vars: _defineProperty({}, value, getElementsByXPath(xpathStr).length)
        };
      }

    case 'storeTitle':
      {
        return {
          vars: _defineProperty({}, value, document.title)
        };
      }

    case 'storeText':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function (el) {
          return {
            vars: _defineProperty({}, value, Object(dom_utils["domText"])(el))
          };
        });
      }

    case 'storeAttribute':
      {
        var _index3 = target.lastIndexOf('@');

        if (_index3 === -1) {
          throw new Error('invalid target for storeAttribute - ' + target);
        }

        var _locator2 = target.substr(0, _index3);
        var _attrName2 = target.substr(_index3 + 1);

        return __getElementByLocator(_locator2, false, command, csIpc).then(function (el) {
          var attr = el.getAttribute(_attrName2);

          if (!attr) {
            throw new Error('missing attribute \'' + _attrName2 + '\'');
          }

          return {
            vars: _defineProperty({}, value, attr)
          };
        });
      }

    case 'storeEval':
      {
        return command_runner_untilInjected().then(function (api) {
          return api.eval(target).then(function (result) {
            return {
              vars: _defineProperty({}, value, result)
            };
          }).catch(function (e) {
            throw new Error('Error in runEval code: ' + e.message);
          });
        });
      }

    case 'storeValue':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function (el) {
          var text = el.value || '';

          return {
            vars: _defineProperty({}, value, text)
          };
        });
      }

    case 'storeChecked':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function (el) {
          var checked = !!el.checked;

          return {
            vars: _defineProperty({}, value, checked)
          };
        });
      }

    case 'verifyValue':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function (el) {
          var text = el.value;

          if (!command_runner_globMatch(value, text)) {
            return {
              log: {
                error: 'value not matched, \n\texpected: "' + value + '", \n\tactual: "' + text + '"'
              }
            };
          }

          return true;
        });
      }

    case 'assertValue':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function (el) {
          var text = el.value;

          if (!command_runner_globMatch(value, text)) {
            throw new Error('value not matched, \n\texpected: "' + value + '", \n\tactual: "' + text + '"');
          }

          return true;
        });
      }

    case 'executeScript':
    case 'executeAsyncScript':
      {
        return command_runner_untilInjected().then(function (api) {
          var code = 'Promise.resolve((function () { ' + target + ' })());';

          return api.eval(code).then(function (result) {
            if (value && value.length) {
              return {
                vars: _defineProperty({}, value, result)
              };
            }

            return true;
          }).catch(function (e) {
            throw new Error('Error in ' + cmd + ' code: ' + e.message);
          });
        });
      }

    case 'sendKeys':
      {
        return __getElementByLocator(target, false, command, csIpc).then(function (el) {
          command_runner_focusIfEditable(el);
          sendKeys(el, value);
          return true;
        });
      }

    case 'selectWindow':
      {
        var p = function () {
          switch (target && target.toUpperCase()) {
            case 'TAB=CLOSEALLOTHER':
              return csIpc.ask('CS_CLOSE_OTHER_TABS', {});

            case 'TAB=CLOSE':
              return csIpc.ask('CS_CLOSE_CURRENT_TAB', {});

            default:
              return csIpc.ask('CS_SELECT_WINDOW', { target: target, value: value });
          }
        }();

        // Note: let `selectWindow` pass through cs and back to background,
        // to keep the flow more consistent with the other commands
        return p.then(function () {
          return true;
        });
      }

    case 'sourceSearch':
    case 'sourceExtract':
      {
        if (!target) {
          throw new Error('Must provide text / regular expression to search for');
        }

        if (!value) {
          throw new Error('Must specify a variable to save the result');
        }

        var getMatchAndCaptureIndex = function getMatchAndCaptureIndex(str) {
          var nonZeroIndex = function nonZeroIndex(n) {
            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            if (n === undefined) return 0;
            return Math.max(0, parseInt(n, 10) + offset);
          };
          var m = /@\s*(\d+)(?:\s*,\s*(\d+))?\s*$/.exec(str);

          if (!m) {
            return {
              rest: str,
              matchIndex: 0,
              captureIndex: 0
            };
          }

          return {
            rest: str.substring(0, m.index),
            matchIndex: nonZeroIndex(m[1], -1),
            captureIndex: nonZeroIndex(m[2])
          };
        };

        // Note: get matchIndex captureIndex first, no matter it's for regexp or simple text

        var _getMatchAndCaptureIn = getMatchAndCaptureIndex(target),
            rest = _getMatchAndCaptureIn.rest,
            matchIndex = _getMatchAndCaptureIn.matchIndex,
            captureIndex = _getMatchAndCaptureIn.captureIndex;

        if (cmd === 'sourceSearch' && rest !== target) {
          throw new Error('The @ parameter is only supported in sourceExtract');
        }

        var regexp = function () {
          if (!/^regex(=|:)/i.test(rest)) {
            return null;
          }

          var raw = rest.replace(/^regex(=|:)/i, '');
          var reg = /^\/(.*)\/([gimsuy]+)?$/;

          if (!reg.test(raw)) {
            return Object(utils["toRegExp"])(raw.replace(/^\/|\/g?$/g, ''), { needEncode: false, flag: 'g' });
          }

          var match = raw.match(reg);

          if (!match || !match.length) {
            return null;
          }

          var _match2 = _slicedToArray(match, 3),
              _ = _match2[0],
              regexpText = _match2[1],
              flags = _match2[2];

          var flagText = ts_utils["uniqueStrings"].apply(undefined, ['g'].concat(_toConsumableArray(flags.split('')))).join('');

          return Object(utils["toRegExp"])(regexpText, { needEncode: false, flag: flagText });
        }();
        var regexpForText = function () {
          if (regexp) return null;
          var raw = rest.replace(/^text(=|:)/i, '');

          if (cmd === 'sourceExtract' && !/\*/.test(raw)) {
            throw new Error('Missing * or REGEX in sourceExtract. Extracting a plain text doesn\'t make much sense');
          }

          // flag 's': Allows . to match newline characters. (Added in ES2018, not yet supported in Firefox).
          // reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Advanced_searching_with_flags_2
          var flags = RegExp.prototype.hasOwnProperty('dotAll') ? 'gs' : 'g';
          return kd_glob_to_regexp_default()(raw, { flags: flags, capture: true, nonGreedy: true });
        }();
        var matches = function () {
          var html = document.documentElement.outerHTML;
          var reg = regexp || regexpForText;
          var result = [];
          var m = void 0;

          // eslint-disable-next-line no-cond-assign
          while (m = reg.exec(html)) {
            result.push(m);

            // Note: save some energy, if it's already enough to get what users want
            if (cmd === 'sourceExtract' && result.length >= matchIndex + 1) {
              break;
            }
          }

          return result;
        }();

        log_default()('matches', matches, regexp, regexpForText);

        if (cmd === 'sourceSearch') {
          return {
            vars: _defineProperty({}, value, matches.length)
          };
        }

        if (cmd === 'sourceExtract') {
          var guard = function guard(str) {
            return str !== undefined ? str : '#nomatchfound';
          };

          return {
            vars: _defineProperty({}, value, guard((matches[matchIndex] || [])[captureIndex]))
          };
        }

        throw new Error('Impossible to reach here');
      }

    case 'visionLimitSearchArea':
    case 'storeImage':
      {
        var _run = function _run(locator, fileName) {
          return __getElementByLocator(locator).then(function (el) {
            if (!fileName || !fileName.length) {
              throw new Error('storeImage: \'value\' is required as image name');
            }

            var clientRect = el.getBoundingClientRect();
            var pSourceOffset = function () {
              if (window.top === window) {
                return Promise.resolve({ x: 0, y: 0 });
              }

              // Note: it's too complicated to take screenshot of element deep in iframe stack
              // if you have to scroll each level of iframe to get the full image of it.
              el.scrollIntoView();

              return Object(cs_postmessage["postMessage"])(window.parent, window, {
                action: 'SOURCE_PAGE_OFFSET',
                data: {}
              });
            }();

            return pSourceOffset.then(function (sourceOffset) {
              var rect = {
                x: sourceOffset.x + clientRect.x + Object(dom_utils["scrollLeft"])(document),
                y: sourceOffset.y + clientRect.y + Object(dom_utils["scrollTop"])(document),
                width: clientRect.width,
                height: clientRect.height
              };

              return csIpc.ask('CS_STORE_SCREENSHOT_IN_SELECTION', {
                rect: rect,
                fileName: Object(utils["ensureExtName"])('.png', fileName),
                devicePixelRatio: window.devicePixelRatio
              }).then(function () {
                return {
                  vars: {
                    '!storedImageRect': rect
                  }
                };
              });
            });
          });
        };

        var _locator3 = void 0,
            fileName = void 0;

        if (cmd === 'storeImage') {
          _locator3 = target;
          fileName = value;
        } else if (cmd === 'visionLimitSearchArea') {
          _locator3 = target.trim().replace(/^element:/i, '').trim();
          fileName = constant["LAST_SCREENSHOT_FILE_NAME"];
        }

        return _run(_locator3, fileName);
      }

    case 'captureScreenshot':
      {
        if (!target || !target.length) {
          throw new Error('captureScreenshot: \'target\' is required as file name');
        }

        return csIpc.ask('CS_CAPTURE_SCREENSHOT', { fileName: Object(utils["ensureExtName"])('.png', target) }).then(function (_ref8) {
          var fileName = _ref8.fileName,
              url = _ref8.url;
          return {
            screenshot: {
              url: url,
              name: fileName
            }
          };
        });
      }

    case 'captureEntirePageScreenshot':
      {
        if (!target || !target.length) {
          throw new Error('captureEntirePageScreenshot: \'target\' is required as file name');
        }

        return csIpc.ask('CS_CAPTURE_FULL_SCREENSHOT', { fileName: Object(utils["ensureExtName"])('.png', target) }).then(function (_ref9) {
          var fileName = _ref9.fileName,
              url = _ref9.url;
          return {
            screenshot: {
              url: url,
              name: fileName
            }
          };
        });
      }

    case 'onDownload':
      {
        return csIpc.ask('CS_ON_DOWNLOAD', {
          fileName: target,
          wait: (value || '').trim() === 'true',
          timeout: extra.timeoutDownload * 1000,
          timeoutForStart: extra.timeoutDownloadStart * 1000
        });
      }

    case 'deleteAllCookies':
      {
        return csIpc.ask('CS_DELETE_ALL_COOKIES', {
          url: window.location.origin
        }).then(function () {
          return true;
        });
      }

    case 'if':
    case 'while':
    case 'gotoIf':
      {
        try {
          return {
            // eslint-disable-next-line no-eval
            condition: window.eval(target)
          };
        } catch (e) {
          throw new Error('Error in runEval condition of ' + cmd + ': ' + e.message);
        }
      }

    default:
      throw new Error('Command ' + cmd + ' not supported yet');
  }
};

/***/ }),

/***/ 1003:
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(1004);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(133)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 1004:
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(132)(undefined);
// imports


// module
exports.push([module.i, ".header{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;overflow:hidden;padding:0 20px;width:100%;height:44px;border-bottom:2px solid #ccc;background-color:#f9f9f9}.header .status{float:right;line-height:42px;font-size:14px}.header .status h1{margin:0;font-size:20px;line-height:44px}.header .select-case{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;line-height:44px;font-size:13px}.header .select-case .test-case-name{margin-right:15px;line-height:35px;max-width:100px;overflow:hidden;display:inline-block;white-space:nowrap;text-overflow:ellipsis}.header .select-case .test-case-name.unsaved{color:orange}.header .select-case .test-case-name.unsaved:after{content:\"*\";margin-left:3px}.header .actions{margin-top:6px}.header .actions .ant-btn-group>.ant-btn-group{float:none}.header .actions .play-actions{margin:0 10px}.ant-dropdown-menu{max-height:300px;overflow-y:auto}.ant-dropdown-menu .editing{color:blue!important}.settings-modal .ant-tabs-nav .ant-tabs-tab{margin-right:12px;padding:8px 6px}.settings-modal .ant-checkbox-wrapper+.ant-checkbox-wrapper{margin-left:0}.settings-modal .tip{margin-left:15px;color:#aaa}.settings-modal .xmodule-item{margin-bottom:25px;padding:15px;border:2px solid #333;font-size:14px;-webkit-box-shadow:rgba(0,0,0,.5) 0 2px 5px 0;box-shadow:0 2px 5px 0 rgba(0,0,0,.5)}.settings-modal .xmodule-item label{margin-right:15px;width:100px;font-size:14px}.settings-modal .xmodule-item .xmodule-title{margin-bottom:10px;font-size:14px}.settings-modal .xmodule-item .xmodule-title>*{margin-right:20px}.settings-modal .xmodule-item .xmodule-title>:last-child{margin-right:0}.settings-modal .xmodule-item .xmodule-status{display:-webkit-box;display:-ms-flexbox;display:flex;margin-bottom:20px}.settings-modal .xmodule-item .xmodule-status .status-box>*{margin-right:15px}.settings-modal .xmodule-item .xmodule-status .status-box>:last-child{margin-right:0}.settings-modal .xmodule-item .xmodule-settings h3{margin-bottom:10px;font-size:14px;font-weight:700}.settings-modal .xmodule-item .xmodule-settings .xmodule-settings-item .settings-detail{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;margin-bottom:10px}.settings-modal .xmodule-item .xmodule-settings .xmodule-settings-item .settings-detail .settings-detail-content{-webkit-box-flex:1;-ms-flex:1;flex:1}.settings-modal .xmodule-item .xmodule-settings .check-result{margin-top:5px;color:red;font-size:13px}.settings-modal .backup-pane{padding:0 20px}.settings-modal .backup-pane h4{font-size:16px;margin-bottom:10px}.settings-modal .backup-pane .row{margin-bottom:10px}.settings-modal .backup-pane p,.settings-modal .backup-pane ul li{margin-bottom:5px}.settings-modal .api-pane{padding:0 20px 20px}.settings-modal .api-pane p{margin:20px 0}.settings-modal .selenium-pane{padding:0 20px 20px}.settings-modal .selenium-pane h4{font-size:16px;margin-bottom:10px}.settings-modal .selenium-pane .import-row{margin-top:20px;margin-bottom:20px}.settings-modal .selenium-pane .import-row button{margin-right:20px}.settings-modal .security-pane{padding:0 20px 20px}.settings-modal .security-pane h4{font-size:16px;margin-bottom:10px}.settings-modal .security-pane p{margin-bottom:10px}.settings-modal .security-pane label{margin-right:10px}.settings-modal .security-pane .ant-radio-wrapper{display:block;height:30px;line-height:30px}.settings-modal .security-pane .input-line{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-bottom:10px}.settings-modal .security-pane .input-line .input-label{width:120px}.settings-modal .security-pane .input-line .ant-checkbox-wrapper{margin-left:15px}.settings-modal .security-pane .input-line a{margin-left:20px}.settings-modal .ocr-pane{padding:0 20px 20px}.settings-modal .ocr-pane p{margin-bottom:10px}.settings-modal .ocr-pane .row{margin-bottom:20px}.settings-modal .ocr-pane .radio-block .ant-radio-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;line-height:30px}.settings-modal .ocr-pane .radio-block .ant-radio-wrapper.need-pro{color:gray}.settings-modal .ocr-pane .radio-block .ant-radio-wrapper .ant-radio{margin-top:8px}.settings-modal .ocr-pane .radio-block .ant-radio-wrapper .offline-label{display:inline-block;width:80px}.settings-modal .ocr-pane .label-text{margin-right:15px}.settings-modal .vision-pane{padding:0 20px 20px}.settings-modal .vision-pane .row,.settings-modal .vision-pane p{margin-bottom:10px}.settings-modal .vision-pane .ant-radio-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;line-height:30px}.settings-modal .vision-pane .ant-radio-wrapper .ant-radio{margin-top:8px}.settings-modal .vision-pane .ant-form-item label{width:280px;color:rgba(0,0,0,.65)}.settings-modal .xmodules-pane{padding:0 0 20px}.settings-modal .register-pane .register-note{width:80%}.settings-modal .register-pane .register-note .actions{margin-top:15px}.settings-modal .register-pane .register-note.inactive,.settings-modal .register-pane .register-note.inactive a{color:#aaa}.settings-modal .register-pane .register-form{margin-top:25px}.settings-modal .register-pane .register-form label{display:block;margin-bottom:10px;font-weight:700}.settings-modal .register-pane .register-form .register-row{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.settings-modal .register-pane .register-form .register-row input{margin-right:15px;width:40%}.settings-modal .register-pane .register-status{margin-top:25px}.settings-modal .register-pane .register-status a{margin-left:15px}", ""]);

// exports


/***/ }),

/***/ 1005:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = __webpack_require__(84);
const HttpAPI = __importStar(__webpack_require__(523));
const config_1 = __importDefault(__webpack_require__(34));
class LicenseService {
    constructor(params) {
        this.params = params;
        this.license = null;
        this.getLatestInfo();
    }
    get legacyXModuleStatus() {
        return this.params.getLegacyXModuleStatus();
    }
    checkLicense(licenseKey) {
        return this.params.getVersion().then(version => {
            return HttpAPI.checkLicense({
                licenseKey,
                version
            });
        })
            .then(license => {
            // Only persist valid license
            if (license.status === 'key_not_found') {
                return license;
            }
            this.license = license;
            return Promise.all([
                this.params.save(license),
                this.params.setLegacyXModuleStatus('checked_by_remote')
            ])
                .then(() => license);
        });
    }
    recheckLicenseIfPossible() {
        var _a;
        if (this.legacyXModuleStatus !== 'checked_by_remote' || !this.license) {
            return Promise.resolve(false);
        }
        return this.checkLicense((_a = this.license) === null || _a === void 0 ? void 0 : _a.licenseKey).then(() => true);
    }
    getLatestInfo() {
        return Promise.all([
            this.params.read()
        ])
            .then(tuple => {
            this.license = tuple[0];
            return tuple[0];
        });
    }
    canPerform(feature) {
        var _a;
        if (this.legacyXModuleStatus !== 'checked_by_remote') {
            return true;
        }
        const licenseType = (_a = this.license.type) !== null && _a !== void 0 ? _a : types_1.LicenseType.Personal;
        switch (licenseType) {
            case types_1.LicenseType.Enterprise:
            case types_1.LicenseType.Personal:
            case types_1.LicenseType.Pro:
                return true;
            case types_1.LicenseType.Player:
                return feature === types_1.Feature.Replay;
        }
    }
    isProLicense() {
        var _a;
        switch (this.legacyXModuleStatus) {
            case 'pro':
                return true;
            case 'checked_by_remote':
                return ((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) === 'on' &&
                    (this.license.type === types_1.LicenseType.Pro || this.license.type === types_1.LicenseType.Enterprise);
            default:
                return false;
        }
    }
    isPersonalLicense() {
        var _a;
        switch (this.legacyXModuleStatus) {
            case 'free':
                return true;
            case 'checked_by_remote':
                return ((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) === 'on' &&
                    this.license.type === types_1.LicenseType.Personal;
            default:
                return false;
        }
    }
    isPlayerLicense() {
        var _a;
        switch (this.legacyXModuleStatus) {
            case 'checked_by_remote':
                return ((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) === 'on' &&
                    this.license.type === types_1.LicenseType.Player;
            default:
                return false;
        }
    }
    hasNoLicense() {
        switch (this.legacyXModuleStatus) {
            case 'unregistered':
                return true;
            case 'checked_by_remote':
                return !this.license || this.license.status !== 'on';
            default:
                return false;
        }
    }
    isLicenseExpired() {
        var _a;
        return this.legacyXModuleStatus === 'checked_by_remote' && ((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) === 'off';
    }
    getEditionName() {
        var _a;
        if (this.legacyXModuleStatus === 'checked_by_remote' && ((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) === 'on') {
            return this.license.name;
        }
        switch (this.legacyXModuleStatus) {
            case 'free':
                return 'Personal Edition';
            case 'pro':
                return 'PRO Edition';
            case 'unregistered':
            case 'checked_by_remote':
            default:
                return 'Free Edition';
        }
    }
    getUpgradeUrl() {
        var _a;
        if (this.legacyXModuleStatus === 'checked_by_remote' && ((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) === 'on') {
            return this.license.upgradeUrl;
        }
        switch (this.legacyXModuleStatus) {
            case 'free':
                return config_1.default.xmodulesLimit.free.upgradeUrl;
            case 'pro':
                return config_1.default.xmodulesLimit.pro.upgradeUrl;
            case 'unregistered':
            case 'checked_by_remote':
            default:
                return config_1.default.xmodulesLimit.unregistered.upgradeUrl;
        }
    }
    getMaxOcrCalls() {
        var _a;
        if (this.legacyXModuleStatus === 'checked_by_remote' && ((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) === 'on') {
            return this.license.maxOcrCalls;
        }
        switch (this.legacyXModuleStatus) {
            case 'free':
                return config_1.default.xmodulesLimit.free.ocrCommandCount;
            case 'pro':
                return config_1.default.xmodulesLimit.pro.ocrCommandCount;
            case 'checked_by_remote':
            case 'unregistered':
            default:
                return config_1.default.xmodulesLimit.unregistered.ocrCommandCount;
        }
    }
    getMaxXCommandCalls() {
        const status = this.convertToLegacyStatus();
        switch (status) {
            case 'free':
                return config_1.default.xmodulesLimit.free.xCommandCount;
            case 'pro':
                return config_1.default.xmodulesLimit.pro.xCommandCount;
            case 'unregistered':
            default:
                return config_1.default.xmodulesLimit.unregistered.xCommandCount;
        }
    }
    getMaxProxyCalls() {
        const status = this.convertToLegacyStatus();
        switch (status) {
            case 'free':
                return config_1.default.xmodulesLimit.free.proxyExecCount;
            case 'pro':
                return config_1.default.xmodulesLimit.pro.proxyExecCount;
            case 'unregistered':
            default:
                return config_1.default.xmodulesLimit.unregistered.proxyExecCount;
        }
    }
    getMaxXFileMacros() {
        const status = this.convertToLegacyStatus();
        switch (status) {
            case 'free':
                return config_1.default.xmodulesLimit.free.xFileMacroCount;
            case 'pro':
                return config_1.default.xmodulesLimit.pro.xFileMacroCount;
            case 'unregistered':
            default:
                return config_1.default.xmodulesLimit.unregistered.xFileMacroCount;
        }
    }
    convertToLegacyStatus() {
        var _a;
        if (this.legacyXModuleStatus && this.legacyXModuleStatus !== 'checked_by_remote') {
            return this.legacyXModuleStatus;
        }
        if (((_a = this.license) === null || _a === void 0 ? void 0 : _a.status) !== 'on') {
            return 'unregistered';
        }
        switch (this.license.type) {
            case types_1.LicenseType.Player:
            case types_1.LicenseType.Enterprise:
            case types_1.LicenseType.Pro:
                return 'pro';
            case types_1.LicenseType.Personal:
                return 'free';
        }
    }
}
exports.LicenseService = LicenseService;
LicenseService.StorageKey = 'a9t9';


/***/ }),

/***/ 1023:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MethodTypeFriendlyNames = [
    "GetVersion",
    "SendMouseEvent",
    "SendMouseWheelEvent",
    "SendText",
    "GetActiveBrowserOuterRect",
    "FindRectangle",
    "GetScreenBackingScaleFactor"
];
exports.MethodTypeInvocationNames = [
    "get_version",
    "send_mouse_event",
    "send_mouse_wheel_event",
    "send_text",
    "get_active_browser_outer_rect",
    "find_rectangle",
    "get_screen_backing_scale_factor"
];


/***/ }),

/***/ 1024:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const native_host_1 = __webpack_require__(97);
class KantuXYHost extends native_host_1.NativeMessagingHost {
    constructor() {
        super(KantuXYHost.HOST_NAME);
    }
}
exports.KantuXYHost = KantuXYHost;
KantuXYHost.HOST_NAME = "com.a9t9.kantu.xy";


/***/ }),

/***/ 1029:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const counter_1 = __webpack_require__(404);
class PersistentCounter extends counter_1.Counter {
    constructor(options) {
        super(options);
        this.ready = false;
        this.read = options.read;
        this.write = options.write;
    }
    reset() {
        super.reset();
        this.ready = false;
        setTimeout(() => {
            this.read()
                .then(n => {
                this.ready = true;
                this.n = n;
            });
        }, 0);
    }
    inc() {
        if (!this.ready) {
            throw new Error('counter not ready yet');
        }
        const result = super.inc();
        this.write(this.n);
        return result;
    }
}
exports.PersistentCounter = PersistentCounter;


/***/ }),

/***/ 1030:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ts_utils_1 = __webpack_require__(12);
class Monitor {
    constructor(inspectorConstructors, paramsProvider) {
        this.inspectorConstructors = {};
        this.targets = {};
        this.paramsProvider = paramsProvider;
        this.inspectorConstructors = inspectorConstructors;
    }
    addTarget(id, autoStart = true) {
        this.targets[id] = ts_utils_1.objMap((factory, key) => {
            const inspector = factory(id);
            if (autoStart) {
                inspector.restart(...this.paramsProvider(key));
            }
            return inspector;
        }, this.inspectorConstructors);
    }
    removeTarget(id) {
        if (!this.targets[id]) {
            return;
        }
        ts_utils_1.objMap((inspector) => {
            inspector.stop();
        }, this.targets[id]);
        delete this.targets[id];
    }
    clear() {
        Object.keys(this.targets).map((id) => {
            this.removeTarget(id);
        });
    }
    restart() {
        this.traverseAllInspectors((inspector, key, id) => {
            inspector.restart(...this.paramsProvider(key, id));
        });
    }
    pause() {
        this.traverseAllInspectors((inspector) => {
            inspector.pause();
        });
    }
    resume() {
        this.traverseAllInspectors((inspector) => {
            inspector.resume();
        });
    }
    stop() {
        this.traverseAllInspectors((inspector) => {
            inspector.stop();
        });
    }
    restartInspector(id, inspectorName) {
        this.getInspector(id, inspectorName).restart(...this.paramsProvider(inspectorName, id, true));
    }
    pauseInspector(id, inspectorName) {
        this.getInspector(id, inspectorName).pause();
    }
    resumeInspector(id, inspectorName) {
        this.getInspector(id, inspectorName).resume();
    }
    stopInspector(id, inspectorName) {
        this.getInspector(id, inspectorName).stop();
    }
    getDataFromInspector(id, inspectorName) {
        return this.getInspector(id, inspectorName).output();
    }
    traverseAllInspectors(fn) {
        ts_utils_1.objMap((inspectors, id) => {
            ts_utils_1.objMap((inspector, key) => {
                try {
                    fn(inspector, key, id);
                }
                catch (e) {
                    console.error(e);
                }
            }, inspectors);
        }, this.targets);
    }
    getInspector(id, inspectorName) {
        const inspectors = this.targets[id];
        if (!inspectors) {
            throw new Error(`Can't find monitor target with id '${id}'`);
        }
        const inspector = inspectors[inspectorName];
        if (!inspector) {
            throw new Error(`Can't find inspector with name '${inspectorName}' for target id '${id}'`);
        }
        return inspector;
    }
}
exports.Monitor = Monitor;


/***/ }),

/***/ 1031:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Timer {
    constructor() {
        this.startTime = new Date();
        this.acc = 0;
    }
    restart() {
        this.startTime = new Date();
        this.acc = 0;
    }
    pause() {
        const now = new Date();
        this.acc += now.getTime() - this.startTime.getTime();
    }
    resume() {
        this.startTime = new Date();
    }
    stop() {
        // do nothing
    }
    output() {
        return this.elapsed();
    }
    elapsed() {
        return this.acc + (new Date().getTime() - this.startTime.getTime());
    }
    elapsedInSeconds() {
        const diff = this.elapsed();
        return (diff / 1000).toFixed(2) + 's';
    }
}
exports.Timer = Timer;


/***/ }),

/***/ 1032:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Countdown {
    constructor(callback) {
        this.startTime = null;
        this.timeout = null;
        this.timer = null;
        this.callback = callback;
    }
    restart(newTimeout, force = false) {
        clearTimeout(this.timer);
        if (force || this.timeout === null || !this.startTime) {
            this.timeout = newTimeout;
            this.startTime = new Date();
            if (newTimeout !== 0) {
                this.timer = setTimeout(() => this.runCallback(), this.timeout);
            }
        }
        else {
            const past = new Date().getTime() - this.startTime.getTime();
            const rest = newTimeout - past;
            this.timeout = newTimeout;
            if (newTimeout !== 0) {
                if (rest < 0) {
                    return this.callback();
                }
                else {
                    this.timer = setTimeout(() => this.runCallback(), rest);
                }
            }
        }
    }
    pause() {
        clearTimeout(this.timer);
        if (!this.startTime || !this.timeout) {
            return;
        }
        const past = new Date().getTime() - this.startTime.getTime();
        const rest = this.timeout - past;
        this.timeout = rest;
    }
    resume() {
        if (!this.timeout) {
            return;
        }
        this.startTime = new Date();
        this.timer = setTimeout(() => this.runCallback(), this.timeout);
    }
    stop() {
        clearTimeout(this.timer);
        this.clearState();
    }
    output() {
        // return nothing
    }
    clearState() {
        this.timer = null;
        this.timeout = null;
        this.startTime = null;
    }
    runCallback() {
        try {
            this.callback();
        }
        catch (e) {
            console.error(e);
        }
        finally {
            this.clearState();
        }
    }
}
exports.Countdown = Countdown;


/***/ }),

/***/ 1033:
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(1034);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(133)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 1034:
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(132)(undefined);
// imports


// module
exports.push([module.i, ".sidebar{position:relative;-webkit-box-flex:1;-ms-flex:1;flex:1;min-width:260px;height:100%;border-right:2px solid #ccc}.sidebar .sidebar-inner{position:absolute;top:0;bottom:80px;right:0;left:0;overflow-y:auto}.sidebar .sidebar-inner.no-tab{padding-top:8px;overflow-x:hidden}.sidebar .no-data{margin-top:20px;text-align:center;font-size:14px;color:#aaa}.sidebar .sidebar-macros .untitled{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:5px 10px;font-size:14px}.sidebar .sidebar-macros .untitled.selected{background:#fdffd1}.sidebar .sidebar-macros .untitled .icon-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-right:5px;width:20px}.sidebar .sidebar-macros .untitled .icon-wrapper .file-icon{display:block;height:16px}.sidebar .test-case-actions,.sidebar .test-suite-actions{padding:0 10px 10px}.sidebar .test-case-actions button,.sidebar .test-suite-actions button{margin-right:10px}.sidebar .test-case-actions{display:-webkit-box;display:-ms-flexbox;display:flex;padding-bottom:0}.sidebar .sidebar-test-suites .test-suite-item{padding:0 0 10px;margin-bottom:5px}.sidebar .sidebar-test-suites .test-suite-item.playing{background:#fdffd1}.sidebar .sidebar-test-suites .test-suite-item.fold{margin-bottom:0;padding-bottom:0}.sidebar .sidebar-test-suites .test-suite-item.fold .test-suite-cases,.sidebar .sidebar-test-suites .test-suite-item.fold .test-suite-more-actions{display:none}.sidebar .sidebar-test-suites .test-suite-item .test-suite-row{padding:5px 10px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer}.sidebar .sidebar-test-suites .test-suite-item .test-suite-row .test-suite-title{-webkit-box-flex:1;-ms-flex:1;flex:1;margin-left:10px}.sidebar .sidebar-test-suites .test-suite-item .test-suite-row .more-button{display:none}.sidebar .sidebar-test-suites .test-suite-item .test-suite-row:hover .more-button{display:block}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases{padding:3px 5px}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases li{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:3px 5px 3px 20px;margin-bottom:5px}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases li.done-tc{background-color:#d1ffd8}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases li.done-tc.blur{background-color:rgba(209,255,216,.6)}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases li.error-tc{background-color:#f7c1c1}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases li.error-tc.blur{background-color:hsla(0,77%,86%,.6)}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases li.current-tc{background-color:#d5d6f9}.sidebar .sidebar-test-suites .test-suite-item .test-suite-cases li.current-tc.blur{background-color:rgba(213,214,249,.6)}.sidebar .sidebar-test-suites .test-suite-item .test-suite-more-actions{padding-left:27px}.sidebar .sidebar-storage-mode{position:absolute;bottom:0;left:0;right:0;height:80px;padding:0 10px 15px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end}.sidebar .sidebar-storage-mode .storage-mode-header{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-bottom:5px;font-size:12px}.sidebar .sidebar-storage-mode .storage-mode-header h3{font-size:14px}.sidebar .ant-tabs{min-height:100%}.sidebar .ant-tabs-bar{border-bottom:2px solid #ccc}.sidebar .ant-tabs-nav-container-scrolling{padding-left:0;padding-right:0}.sidebar .ant-tabs-tab-next.ant-tabs-tab-arrow-show,.sidebar .ant-tabs-tab-prev.ant-tabs-tab-arrow-show{display:none}.sidebar .ant-tabs-nav{height:44px}.sidebar .ant-tabs-nav .ant-tabs-tab{margin-right:0;line-height:27px}.sidebar .ant-tabs-nav-scroll{text-align:center}.sidebar .resize-handler{position:absolute;right:-2px;top:0;bottom:0;width:2px;background:#ccc;cursor:col-resize}.sidebar .resize-handler.focused,.sidebar .resize-handler:hover{right:-4px;width:6px;background:#aaa}.sidebar.with-xmodules-note .sidebar-inner{bottom:160px}.sidebar.with-xmodules-note .sidebar-storage-mode{height:160px}.sidebar.with-xmodules-note .note-for-macros{margin-bottom:20px;padding:10px 10px 0;border-top:1px solid #333;font-size:12px}.with-sidebar .sidebar{display:block}.context-menu{z-index:10}.context-menu .ant-menu{border:\"1px solid #ccc\";border-radius:4px;-webkit-box-shadow:0 1px 6px rgba(0,0,0,.2);box-shadow:0 1px 6px rgba(0,0,0,.2)}.context-menu .ant-menu .ant-menu-item{height:36px;line-height:36px}.context-menu .ant-menu .ant-menu-item:hover{background:#ecf6fd}.xfile-not-installed-modal.left-bottom{position:absolute;top:auto!important;bottom:100px;left:100px}.xfile-not-installed-modal p{margin-bottom:20px;font-size:16px;font-weight:700}.macros-dropdown{width:auto!important}", ""]);

// exports


/***/ }),

/***/ 1036:
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(1037);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(133)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 1037:
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(132)(undefined);
// imports


// module
exports.push([module.i, ".dashboard{-webkit-box-orient:vertical;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-ms-flex:1;flex:1;margin:15px 15px 0}.dashboard,.dashboard .flex-row{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-direction:normal}.dashboard .flex-row{-webkit-box-orient:horizontal;-ms-flex-direction:row;flex-direction:row}.dashboard .form-group{margin-bottom:15px}.dashboard .toolbox{display:-webkit-box;display:-ms-flexbox;display:flex}.dashboard .toolbox .record-ops{-webkit-box-flex:1;-ms-flex:1;flex:1;text-align:right}.dashboard .toolbox .play-ops{margin-left:15px}.dashboard .ant-table-pagination{display:none}.dashboard .ant-table-header{overflow:hidden!important;margin-bottom:0!important;padding-bottom:0!important}.dashboard .ant-table-header .ant-table-thead>tr>th{padding:13px 8px}.dashboard .ant-table-body .ant-table-thead>tr>th{padding:10px 8px}.dashboard .ant-table-tbody>tr>td{padding:8px}.dashboard tr.selected-command>td{background-color:#fdffd1!important}.dashboard tr.error-command>td{background-color:#f7c1c1!important}.dashboard tr.running-command>td{background-color:#d5d6f9!important}.dashboard tr.done-command>td{background-color:#d1ffd8!important}.dashboard .ant-btn-group>.ant-btn-group{float:none}.dashboard .ant-form-item{margin-bottom:8px}.dashboard .editor-wrapper{-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:2;-ms-flex:2;flex:2}.dashboard .editor-wrapper,.dashboard .editor-wrapper .tabs-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal}.dashboard .editor-wrapper .tabs-wrapper{position:relative;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-ms-flex:1;flex:1}.dashboard .editor-wrapper .tabs-wrapper .vision-type{position:absolute;right:0;top:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer}.dashboard .editor-wrapper .tabs-wrapper .vision-type img{display:block;margin-right:10px;width:20px;height:20px}.dashboard .editor-wrapper .tabs-wrapper .vision-type span{text-decoration:underline;color:#108ee9;font-size:16px}.dashboard .commands-view{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:2;-ms-flex:2;flex:2}.dashboard .commands-view .ant-tabs-bar{margin-bottom:0}.dashboard .commands-view .ant-tabs-content{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-ms-flex:1;flex:1;padding:10px;border:1px solid #d9d9d9;border-width:0 1px 1px}.dashboard .commands-view .ant-tabs-content .ant-tabs-tabpane{-webkit-box-flex:1;-ms-flex:1;flex:1;-ms-flex-negative:unset!important;flex-shrink:unset!important;position:relative}.dashboard .commands-view .ant-tabs-content .table-wrapper{position:absolute;top:0;bottom:165px;left:0;right:0;overflow-y:auto}.dashboard .commands-view .ant-tabs-content .fields-wrapper{position:absolute;left:0;right:0;bottom:0;height:155px}.dashboard .commands-view .ant-tabs-content .fields-wrapper .ant-form-item-label{text-align:left}.dashboard .commands-view .ant-tabs-content .fields-wrapper .target-row .flex-row{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.dashboard .commands-view .ant-tabs-content .fields-wrapper .target-row .select-input{-webkit-box-flex:1;-ms-flex:1;flex:1}.dashboard .commands-view .ant-tabs-content .fields-wrapper .target-row .select-input input{width:100%}.dashboard .commands-view .ant-tabs-content .fields-wrapper .target-row .textarea-wrapper{position:relative;-webkit-box-flex:1;-ms-flex:1;flex:1;max-width:60%;margin-right:10px}.dashboard .commands-view .ant-tabs-content .fields-wrapper .target-row .textarea-wrapper .open-full-editor{position:absolute;bottom:5px;right:15px;cursor:pointer}.dashboard .commands-view .ant-tabs-content .fields-wrapper .target-row .textarea-wrapper .open-full-editor:hover{color:#108ee9}.dashboard .commands-view .ant-tabs-content .fields-wrapper .target-row button{margin-left:10px}.dashboard .commands-view .ant-tabs-content .react-codemirror2{position:relative}.dashboard .commands-view .ant-tabs-content .react-codemirror2.has-error{height:calc(100% - 70px)}.dashboard .commands-view .ant-tabs-content .react-codemirror2.no-error{height:calc(100% - 0px)}.dashboard .commands-view .ant-tabs-content .react-codemirror2 .CodeMirror{position:absolute;top:0;bottom:0;left:0;right:0;height:auto;font-size:13px}.dashboard .commands-view .ant-tabs-content .ant-spin-container,.dashboard .commands-view .ant-tabs-content .ant-spin-nested-loading,.dashboard .commands-view .ant-tabs-content .ant-table,.dashboard .commands-view .ant-tabs-content .ant-table-content,.dashboard .commands-view .ant-tabs-content .ant-table-scroll,.dashboard .commands-view .ant-tabs-content .ant-table-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-ms-flex:1;flex:1}.dashboard .commands-view .ant-tabs-content .ant-table-scroll{overflow-y:auto}.dashboard .commands-view.target-as-textarea .ant-tabs-content .table-wrapper{bottom:179px}.dashboard .commands-view.target-as-textarea .ant-tabs-content .fields-wrapper{height:169px}.dashboard .commands-view.target-as-textarea .ant-tabs-content .fields-wrapper textarea{resize:none}.dashboard .commands-view .command-row{position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding-left:5px;border-bottom:1px solid #e9e9e9;line-height:35px;font-size:13px}.dashboard .commands-view .command-row:hover{background:#ecf6fd}.dashboard .commands-view .command-row.dragging{opacity:0}.dashboard .commands-view .command-row.footer-row,.dashboard .commands-view .command-row.header-row{background-color:#f7f7f7;font-weight:700}.dashboard .commands-view .command-row.footer-row{display:block;text-align:center;cursor:pointer}.dashboard .commands-view .command-row.breakpoint-command:before{content:\"\";position:absolute;top:50%;left:0;-webkit-transform:translateY(-50%);transform:translateY(-50%);width:0;height:0;border:8px solid transparent;border-left-color:green}.dashboard .commands-view .command-row.error-command{background-color:#f7c1c1;color:red}.dashboard .commands-view .command-row.error-command.blur{background-color:hsla(0,77%,86%,.6)}.dashboard .commands-view .command-row.warning-command{background-color:hsla(33,87%,79%,.7);color:orange}.dashboard .commands-view .command-row.warning-command.blur{background-color:hsla(33,87%,79%,.3)}.dashboard .commands-view .command-row.running-command{background-color:#d5d6f9}.dashboard .commands-view .command-row.running-command.blur{background-color:rgba(213,214,249,.6)}.dashboard .commands-view .command-row.done-command{background-color:#d1ffd8}.dashboard .commands-view .command-row.done-command.blur{background-color:rgba(209,255,216,.6)}.dashboard .commands-view .command-row.selected-command{background-color:#fdffd1}.dashboard .commands-view .command-row.selected-command.blur{background-color:rgba(253,255,209,.6)}.dashboard .commands-view .command-row.comment-command{background-color:transparent;color:#ccc;font-style:italic}.dashboard .commands-view .command-row.comment-command.selected-command{background-color:#fdffd1}.dashboard .commands-view .command-row.comment-command.selected-command.blur{background-color:rgba(253,255,209,.6)}.dashboard .commands-view .command-row .row-col{padding:0 8px}.dashboard .commands-view .command-row .row-col.index-col{padding:0;width:25px;text-align:center}.dashboard .commands-view .command-row .row-col.command-col{min-width:130px}.dashboard .commands-view .command-row .row-col.command-col,.dashboard .commands-view .command-row .row-col.target-col,.dashboard .commands-view .command-row .row-col.value-col{-webkit-box-flex:1;-ms-flex:1;flex:1;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.dashboard .commands-view .command-row .row-col.op-col{width:80px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.dashboard .table-footer{position:absolute;left:0;right:0;top:0;bottom:0;line-height:32px;text-align:center;font-weight:700;background:#f7f7f7;cursor:pointer}.dashboard .table-footer:hover{background:#e0e0e0}.dashboard .logs-screenshots{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;position:relative;margin-top:15px}.dashboard .logs-screenshots.fold{height:32px!important;overflow:hidden}.dashboard .logs-screenshots.fold .ant-tabs-content{display:none}.dashboard .logs-screenshots .resize-handler{position:absolute;top:-10px;left:0;width:100%;height:6px;background:transparent;cursor:row-resize}.dashboard .logs-screenshots .resize-handler.focused,.dashboard .logs-screenshots .resize-handler:hover{height:6px;background:#ccc}.dashboard .logs-screenshots .ant-tabs.ant-tabs-card>.ant-tabs-bar .ant-tabs-tab{padding:5px 12px 4px}.dashboard .logs-screenshots .ant-tabs{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-ms-flex:1;flex:1}.dashboard .logs-screenshots .ant-tabs-bar{margin-bottom:0}.dashboard .logs-screenshots .ant-tabs-content{-webkit-box-flex:1;-ms-flex:1;flex:1;overflow-y:auto;min-height:70px;border:1px solid #d9d9d9;border-width:0 1px 1px}.dashboard .logs-screenshots .ls-toolbox{position:absolute;right:0;top:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.dashboard .logs-screenshots .ls-toolbox>*{margin-right:5px}.dashboard .logs-screenshots .ls-toolbox>:last-child{margin-right:0}.dashboard .logs-screenshots .log-content,.dashboard .logs-screenshots .screenshot-content{padding:10px 0}.dashboard .logs-screenshots .screenshot-content li{padding:0 20px 20px}.dashboard .logs-screenshots .screenshot-content li .timestamp{display:block;margin-bottom:10px;font-size:14px}.dashboard .logs-screenshots .screenshot-content li .filename{font-weight:700}.dashboard .logs-screenshots .log-content{list-style:none;margin:0;padding:0 10px;height:calc(100% - 38px);overflow-y:auto}.dashboard .logs-screenshots .log-content li{padding:5px 0;font-size:12px;border-bottom:1px solid #f3f3f3}.dashboard .logs-screenshots .log-content li:after{content:\"\";display:table;clear:both}.dashboard .logs-screenshots .log-content li a.info{color:#108ee9!important}.dashboard .logs-screenshots .log-content li.error{color:red;font-weight:700}.dashboard .logs-screenshots .log-content li.error a{color:red;text-decoration:underline}.dashboard .logs-screenshots .log-content li.warning{color:orange}.dashboard .logs-screenshots .log-content li .log-type{float:left;margin-right:10px}.dashboard .logs-screenshots .log-content li .log-detail{white-space:pre-wrap}.dashboard .logs-screenshots .csv-content{padding:10px}.dashboard .logs-screenshots .csv-content button{margin-right:5px}.dashboard .logs-screenshots .variable-content{padding:10px}.dashboard .logs-screenshots .variable-content .variable-options{margin-bottom:10px}.dashboard .logs-screenshots .variable-content .ant-checkbox-wrapper{margin-left:0!important;margin-right:10px}.dashboard .logs-screenshots .variable-content .read-only{color:#ccc}.dashboard .logs-screenshots .vision-content{padding:10px}.dashboard .logs-screenshots .vision-content .vision-top-actions{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-bottom:15px}.dashboard .logs-screenshots .vision-content .vision-top-actions .main-actions{-webkit-box-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;margin-right:15px}.dashboard .logs-screenshots .vision-content .vision-top-actions .main-actions .main-actions-left{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.dashboard .logs-screenshots .vision-content .vision-top-actions .main-actions .main-actions-left>*{margin-right:15px}.dashboard .logs-screenshots .vision-content .vision-top-actions .main-actions .main-actions-left>:last-child{margin-right:0}.dashboard .logs-screenshots .vision-content .vision-top-actions .main-actions .load-image-button{padding:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.dashboard .logs-screenshots .vision-content .vision-top-actions .main-actions .load-image-button label{padding:0 15px;cursor:pointer}.dashboard .logs-screenshots .vision-content .vision-top-actions .more-info{font-size:14px}.dashboard .logs-screenshots .vision-content .vision-image{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center;overflow:hidden;width:100px;height:100px;border:1px solid #ccc}.dashboard .logs-screenshots .vision-content .vision-image img{max-height:100px}.dashboard .logs-screenshots .vision-content .vision-name{font-size:14px;word-break:break-all}.dashboard .logs-screenshots .vision-content .vision-actions{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.dashboard .logs-screenshots .vision-content .vision-actions button{margin-right:5px}.dashboard .logs-screenshots .vision-content .vision-actions button:last-child{margin-right:0}.dashboard .online-help{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;margin-top:15px;padding:0 10px;height:25px;line-height:25px;font-size:14px;text-align:right}.dashboard #context_menu{z-index:10}.dashboard #context_menu .ant-menu{border:\"1px solid #ccc\";border-radius:4px;-webkit-box-shadow:0 1px 6px rgba(0,0,0,.2);box-shadow:0 1px 6px rgba(0,0,0,.2)}.dashboard #context_menu .ant-menu .ant-menu-item{height:36px;line-height:36px}.dashboard #context_menu .ant-menu .ant-menu-item:hover{background:#ecf6fd}.dashboard #context_menu .ant-menu .ant-menu-item .shortcut{float:right;color:#999}.dashboard .target-full-editor .mask{position:fixed;z-index:100;top:0;bottom:0;left:0;right:0;background:#000;opacity:.4}.dashboard .target-full-editor .react-codemirror2{position:fixed;z-index:100;top:40px;bottom:40px;left:40px;right:40px}.dashboard .target-full-editor .react-codemirror2 .CodeMirror{height:100%}.dashboard .target-full-editor .close-button{position:fixed;z-index:101;top:25px;right:25px}.source-error{color:red;white-space:pre-wrap;font-size:12px}.ant-dropdown .ant-dropdown-menu{max-height:none}@media (max-width:768px){.duplicate-modal,.play-loop-modal,.rename-modal,.save-modal{width:400px!important;margin:0 auto}}", ""]);

// exports


/***/ }),

/***/ 105:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(153);
const ts_utils_1 = __webpack_require__(12);
var MacroResultStatus;
(function (MacroResultStatus) {
    MacroResultStatus["Normal"] = "NORMAL";
    MacroResultStatus["Success"] = "SUCCESS";
    MacroResultStatus["Error"] = "ERROR";
    MacroResultStatus["ErrorInSub"] = "ERROR_IN_SUB";
})(MacroResultStatus = exports.MacroResultStatus || (exports.MacroResultStatus = {}));
class MacroExtraKeyValueData extends common_1.KeyValueData {
    getAll() {
        return super.get("");
    }
    getMainKeyAndSubKeys(key) {
        const [mainKey, subKeys] = super.getMainKeyAndSubKeys(key);
        return [
            MacroExtraKeyValueData.STORAGE_KEY,
            [mainKey].concat(subKeys).filter(x => x && x.length)
        ];
    }
}
exports.MacroExtraKeyValueData = MacroExtraKeyValueData;
MacroExtraKeyValueData.STORAGE_KEY = 'macro_extra';
exports.getMacroExtraKeyValueData = ts_utils_1.singletonGetter(() => new MacroExtraKeyValueData());


/***/ }),

/***/ 1059:
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(1060);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(133)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 106:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const superagent_1 = __importDefault(__webpack_require__(385));
const types_1 = __webpack_require__(112);
const utils_1 = __webpack_require__(4);
const ts_utils_1 = __webpack_require__(12);
function runOCR(options) {
    const scaleStr = (options.scale + '').toLowerCase();
    const scale = ['true', 'false'].indexOf(scaleStr) !== -1 ? scaleStr : 'true';
    const engine = [1, 2].indexOf(options.engine || 0) !== -1 ? options.engine : 1;
    const singleRun = () => {
        return options.getApiUrlAndApiKey()
            .then(server => {
            const { url, key } = server;
            const f = new FormData();
            f.append('apikey', key);
            f.append('language', options.language);
            f.append('scale', scale);
            f.append('OCREngine', '' + engine);
            f.append('isOverlayRequired', '' + options.isOverlayRequired);
            if (options.isTable !== undefined) {
                f.append('isTable', '' + options.isTable);
            }
            if (typeof options.image === 'string') {
                f.append('file', utils_1.dataURItoBlob(options.image), 'unknown.png');
            }
            else {
                f.append('file', options.image.blob, options.image.name);
            }
            const startTime = new Date().getTime();
            if (options.willSendRequest) {
                options.willSendRequest({ server, startTime });
            }
            return utils_1.withTimeout(options.singleApiTimeout, () => {
                return superagent_1.default.post(url)
                    .send(f);
            })
                .then((res) => {
                if (options.didGetResponse) {
                    return options.didGetResponse({
                        server,
                        startTime,
                        endTime: new Date().getTime(),
                        response: res.body,
                        error: null
                    })
                        .then(() => res, () => res);
                }
                return res;
            }, (e) => {
                const err = getApiError(e);
                if (options.didGetResponse) {
                    return options.didGetResponse({
                        server,
                        startTime,
                        endTime: new Date().getTime(),
                        response: null,
                        error: err
                    })
                        .then(() => { throw err; }, () => { throw err; });
                }
                throw e;
            })
                .then(onApiReturn, onApiError)
                .catch(e => {
                if (/timeout/i.test(e.message)) {
                    throw new Error(`OCR request timeout ${(options.singleApiTimeout / 1000).toFixed(1)}s`);
                }
                else {
                    throw e;
                }
            });
        });
    };
    const run = ts_utils_1.retry(singleRun, {
        // We don't want timeout mechanism from retry, so just make it big enough
        timeout: options.singleApiTimeout * 10,
        retryInterval: 0,
        shouldRetry: options.shouldRetry || (() => false)
    });
    return utils_1.withTimeout(options.totalTimeout, run)
        .catch(e => {
        if (/timeout/i.test(e.message)) {
            throw new Error('OCR timeout');
        }
        else {
            throw e;
        }
    });
}
exports.runOCR = runOCR;
function getApiError(e) {
    if (e.response && typeof e.response.body === 'string') {
        return new Error(e.response.body);
    }
    return e;
}
function onApiError(e) {
    console.error(e);
    throw getApiError(e);
}
function onApiReturn(res) {
    guardOCRResponse(res.body);
    return res.body;
}
function guardOCRResponse(data) {
    switch (data.OCRExitCode) {
        case types_1.OCRExitCode.AllParsed:
            return;
        case types_1.OCRExitCode.PartiallyParsed:
            throw new Error([
                'Parsed Partially (Only few pages out of all the pages parsed successfully)',
                data.ErrorMessage || '',
                data.ErrorDetails || '',
            ]
                .filter(s => s.length > 0)
                .join('; '));
        case types_1.OCRExitCode.Failed:
            throw new Error([
                'OCR engine fails to parse an image',
                data.ErrorMessage || '',
                data.ErrorDetails || '',
            ]
                .filter(s => s.length > 0)
                .join('; '));
        case types_1.OCRExitCode.Fatal:
            throw new Error([
                'Fatal error occurs during parsing',
                data.ErrorMessage || '',
                data.ErrorDetails || '',
            ]
                .filter(s => s.length > 0)
                .join('; '));
    }
}
exports.guardOCRResponse = guardOCRResponse;
function wordIteratorFromParseResults(parseResults) {
    let pageIndex = 0;
    let lineIndex = 0;
    let wordIndex = 0;
    const next = () => {
        const page = parseResults[pageIndex];
        const currentLines = page ? page.TextOverlay.Lines : [];
        const line = page ? page.TextOverlay.Lines[lineIndex] : null;
        const currentWords = line ? line.Words : [];
        const word = line ? line.Words[wordIndex] : null;
        if (!word) {
            return {
                done: true,
                value: null
            };
        }
        const value = {
            word,
            position: {
                pageIndex,
                lineIndex,
                wordIndex
            }
        };
        [pageIndex, lineIndex, wordIndex] = (() => {
            let nextWordIndex = wordIndex + 1;
            let nextLineIndex = lineIndex;
            let nextPageIndex = pageIndex;
            if (nextWordIndex >= currentWords.length) {
                nextWordIndex = 0;
                nextLineIndex += 1;
            }
            if (nextLineIndex >= currentLines.length) {
                nextLineIndex = 0;
                nextPageIndex += 1;
            }
            if (nextPageIndex >= parseResults.length) {
                return [-1, -1, -1];
            }
            return [nextPageIndex, nextLineIndex, nextWordIndex];
        })();
        return {
            value,
            done: false
        };
    };
    return { next };
}
exports.wordIteratorFromParseResults = wordIteratorFromParseResults;
function iterateThroughParseResults(parseResults, fn) {
    const iterator = wordIteratorFromParseResults(parseResults);
    while (true) {
        const { done, value } = iterator.next();
        if (done)
            break;
        const shouldContinue = fn(value);
        if (!shouldContinue)
            break;
    }
}
exports.iterateThroughParseResults = iterateThroughParseResults;
function searchTextInOCRResponse(data) {
    const { text, index, parsedResults, exhaust } = data;
    const isExactMatch = /^\[.*\]$/.test(text);
    const realText = isExactMatch ? text.slice(1, -1) : text;
    const words = realText.split(/\s+/g).map(s => s.trim()).filter(s => s.length > 0);
    if (index < 0 || Math.round(index) !== index) {
        throw new Error('index must be positive integer');
    }
    let found = [];
    let wordIndex = 0;
    let matchIndex = 0;
    iterateThroughParseResults(parsedResults, (wordWithPos) => {
        const matchType = (() => {
            if (isExactMatch)
                return WordMatchType.Full;
            if (words.length === 1)
                return WordMatchType.AnyPart;
            if (wordIndex === 0)
                return WordMatchType.Postfix;
            if (wordIndex === words.length - 1)
                return WordMatchType.Prefix;
            return WordMatchType.Full;
        })();
        if (!hasWordMatch(words[wordIndex], wordWithPos.word.WordText, matchType)) {
            found[matchIndex] = [];
            wordIndex = 0;
            return true;
        }
        found[matchIndex] = found[matchIndex] || [];
        found[matchIndex].push(wordWithPos);
        wordIndex += 1;
        // Whether it's the last word
        if (wordIndex >= words.length) {
            matchIndex += 1;
            wordIndex = 0;
            const shouldContinue = exhaust || matchIndex <= index;
            return shouldContinue;
        }
        return true;
    });
    const all = found.filter(pWords => pWords.length === words.length)
        .map(pWords => ({
        words: pWords,
        // Note: similarity is useless in current implementation
        similarity: 1
    }));
    const hit = all[index] || null;
    return {
        hit,
        all,
        exhaust
    };
}
exports.searchTextInOCRResponse = searchTextInOCRResponse;
function isWordEqual(a, b) {
    if (!a || !b)
        return false;
    return a.trim().toLowerCase() === b.trim().toLowerCase();
}
exports.isWordEqual = isWordEqual;
var WordMatchType;
(function (WordMatchType) {
    WordMatchType[WordMatchType["Full"] = 0] = "Full";
    WordMatchType[WordMatchType["Prefix"] = 1] = "Prefix";
    WordMatchType[WordMatchType["Postfix"] = 2] = "Postfix";
    WordMatchType[WordMatchType["AnyPart"] = 3] = "AnyPart";
})(WordMatchType = exports.WordMatchType || (exports.WordMatchType = {}));
function hasWordMatch(pattern, target, matchType) {
    if (!pattern || !target)
        return false;
    const lowerPattern = pattern.trim().toLowerCase();
    const lowerTarget = target.trim().toLowerCase();
    switch (matchType) {
        case WordMatchType.Full: {
            return lowerPattern === lowerTarget;
        }
        case WordMatchType.Prefix: {
            return lowerTarget.indexOf(lowerPattern) === 0;
        }
        case WordMatchType.Postfix: {
            const index = lowerTarget.indexOf(lowerPattern);
            return index !== -1 && index === lowerTarget.length - lowerPattern.length;
        }
        case WordMatchType.AnyPart: {
            return lowerTarget.indexOf(lowerPattern) !== -1;
        }
    }
}
exports.hasWordMatch = hasWordMatch;
function isWordPositionEqual(a, b) {
    return a.pageIndex === b.pageIndex &&
        a.lineIndex === b.lineIndex &&
        a.wordIndex === b.wordIndex;
}
exports.isWordPositionEqual = isWordPositionEqual;
function allWordsWithPosition(parseResults, excludePositions) {
    const result = [];
    const isAtKnownPosition = (wordWithPos) => {
        return excludePositions.reduce((prev, pos) => {
            if (prev)
                return true;
            return isWordPositionEqual(pos, wordWithPos.position);
        }, false);
    };
    iterateThroughParseResults(parseResults, (wordWithPos) => {
        if (!isAtKnownPosition(wordWithPos)) {
            result.push(wordWithPos);
        }
        return true;
    });
    return result;
}
exports.allWordsWithPosition = allWordsWithPosition;
function ocrMatchRect(match) {
    const rectsByLine = match.words.reduce((prev, cur) => {
        const key = `${cur.position.pageIndex}_${cur.position.lineIndex}`;
        if (!prev[key]) {
            prev[key] = {
                x: cur.word.Left,
                y: cur.word.Top,
                width: cur.word.Width,
                height: cur.word.Height
            };
        }
        else {
            prev[key] = Object.assign(Object.assign({}, prev[key]), { width: Math.max(prev[key].width, cur.word.Left + cur.word.Width - prev[key].x), height: Math.max(prev[key].height, cur.word.Top + cur.word.Height - prev[key].y) });
        }
        return prev;
    }, {});
    const widestRect = Object.keys(rectsByLine).reduce((prev, key) => {
        return prev.width < rectsByLine[key].width ? rectsByLine[key] : prev;
    }, { x: 0, y: 0, width: 0, height: 0 });
    return widestRect;
}
exports.ocrMatchRect = ocrMatchRect;
function ocrMatchCenter(match) {
    const rect = ocrMatchRect(match);
    return {
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2
    };
}
exports.ocrMatchCenter = ocrMatchCenter;
function scaleOcrParseResultWord(word, scale) {
    return Object.assign(Object.assign({}, word), { Width: scale * word.Width, Height: scale * word.Height, Left: scale * word.Left, Top: scale * word.Top });
}
exports.scaleOcrParseResultWord = scaleOcrParseResultWord;
function scaleOcrResponseCoordinates(res, scale) {
    const data = ts_utils_1.safeUpdateIn(['ParsedResults', '[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], (word) => scaleOcrParseResultWord(word, scale), res);
    return data;
}
exports.scaleOcrResponseCoordinates = scaleOcrResponseCoordinates;
function scaleOcrTextSearchMatch(match, scale) {
    const data = ts_utils_1.safeUpdateIn(['words', '[]', 'word'], (word) => scaleOcrParseResultWord(word, scale), match);
    return data;
}
exports.scaleOcrTextSearchMatch = scaleOcrTextSearchMatch;


/***/ }),

/***/ 1060:
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(132)(undefined);
// imports


// module
exports.push([module.i, ".select-input{position:relative}.select-input input{padding-right:24px}.select-input .arrow-icon{position:absolute;top:50%;right:8px;-webkit-transform:scale(.75) rotate(0deg);transform:scale(.75) rotate(0deg);color:rgba(0,0,0,.43);-webkit-transition:-webkit-transform .2s ease;transition:-webkit-transform .2s ease;transition:transform .2s ease;transition:transform .2s ease,-webkit-transform .2s ease;pointer-events:none;cursor:pointer}.select-input.opened .arrow-icon{-webkit-transform:scale(.75) rotate(180deg);transform:scale(.75) rotate(180deg)}.drop-down .option-list{position:absolute;z-index:1000;border-radius:4px;font-size:12px;background:#fff;-webkit-box-shadow:0 1px 6px rgba(0,0,0,.2);box-shadow:0 1px 6px rgba(0,0,0,.2)}.drop-down .option-list .plain-text-option{padding:7px 8px;cursor:pointer}.drop-down .option-list .plain-text-option.selected{background-color:#f7f7f7;font-weight:600}.drop-down .option-list .plain-text-option:hover{background-color:#ecf6fd}", ""]);

// exports


/***/ }),

/***/ 1062:
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(1063);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(133)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 1063:
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(132)(undefined);
// imports


// module
exports.push([module.i, "body{margin:0;padding:0;font-size:16px}*{-webkit-box-sizing:border-box;box-sizing:border-box}.app{position:absolute;top:0;bottom:0;left:0;right:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.app.no-display .status{margin-bottom:20px;font-size:14px}.app.no-display .content{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.app.with-alert .backup-alert{display:block}.app .app-inner{-webkit-box-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.app .backup-alert{display:none;padding:5px 0;text-align:center;font-size:14px;background:#fdfdc2}.app .backup-alert .backup-actions{margin-left:20px}.app .backup-alert .backup-actions button{margin-right:10px}.app .content{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:3;-ms-flex:3;flex:3;min-width:520px;background:#fff;overflow-y:auto}.app .hidden-during-replay{-webkit-box-orient:horizontal;-ms-flex-direction:row;flex-direction:row;padding-top:15px;font-size:14px;color:#999}.app .hidden-during-replay,.app .list-not-loaded{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-direction:normal;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.app .list-not-loaded{-webkit-box-orient:vertical;-ms-flex-direction:column;flex-direction:column}.app .list-not-loaded button{margin-top:20px}", ""]);

// exports


/***/ }),

/***/ 107:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var idb_filesystem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(170);
/* harmony import */ var idb_filesystem_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(idb_filesystem_js__WEBPACK_IMPORTED_MODULE_0__);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();



var fs = function () {
  var requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;

  if (!requestFileSystem) {
    throw new Error('requestFileSystem not supported');
  }

  var dumbSize = 1024 * 1024;
  var maxSize = 5 * 1024 * 1024;
  var getFS = function getFS(size) {
    size = size || maxSize;

    return new Promise(function (resolve, reject) {
      requestFileSystem(window.TEMPORARY, size, resolve, reject);
    });
  };

  var getDirectory = function getDirectory(dir, shouldCreate, fs) {
    var parts = (Array.isArray(dir) ? dir : dir.split('/')).filter(function (p) {
      return p && p.length;
    });
    var getDir = function getDir(parts, directoryEntry) {
      if (!parts || !parts.length) return Promise.resolve(directoryEntry);

      return new Promise(function (resolve, reject) {
        directoryEntry.getDirectory(parts[0], { create: !!shouldCreate }, function (dirEntry) {
          return resolve(dirEntry);
        }, function (e) {
          return reject(e);
        });
      }).then(function (entry) {
        return getDir(parts.slice(1), entry);
      });
    };

    var pFS = fs ? Promise.resolve(fs) : getFS(dumbSize);
    return pFS.then(function (fs) {
      return getDir(parts, fs.root);
    });
  };

  var ensureDirectory = function ensureDirectory(dir, fs) {
    return getDirectory(dir, true, fs);
  };

  var rmdir = function rmdir(dir, fs) {
    return getDirectory(dir, false, fs).then(function (directoryEntry) {
      return new Promise(function (resolve, reject) {
        directoryEntry.remove(resolve, reject);
      });
    });
  };

  var rmdirR = function rmdirR(dir, fs) {
    return getDirectory(dir, false, fs).then(function (directoryEntry) {
      return new Promise(function (resolve, reject) {
        return directoryEntry.removeRecursively(resolve, reject);
      });
    });
  };

  // @return a Promise of [FileSystemEntries]
  var list = function list() {
    var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';

    return getFS(dumbSize).then(function (fs) {
      return new Promise(function (resolve, reject) {
        getDirectory(dir).then(function (dirEntry) {
          var result = [];
          var dirReader = dirEntry.createReader();
          var read = function read() {
            dirReader.readEntries(function (entries) {
              if (entries.length === 0) {
                resolve(result.sort());
              } else {
                result = result.concat(Array.from(entries));
                read();
              }
            }, reject);
          };

          read();
        }).catch(reject);
      });
    }).catch(function (e) {
      console.warn('list', e.code, e.name, e.message);
      throw e;
    });
  };

  var fileLocator = function fileLocator(filePath, fs) {
    var parts = filePath.split('/');
    return getDirectory(parts.slice(0, -1), false, fs).then(function (directoryEntry) {
      return {
        directoryEntry: directoryEntry,
        fileName: parts.slice(-1)[0]
      };
    });
  };

  var readFile = function readFile(filePath, type) {
    if (['ArrayBuffer', 'BinaryString', 'DataURL', 'Text'].indexOf(type) === -1) {
      throw new Error('invalid readFile type, \'' + type + '\'');
    }

    return getFS().then(function (fs) {
      return fileLocator(filePath, fs).then(function (_ref) {
        var directoryEntry = _ref.directoryEntry,
            fileName = _ref.fileName;

        return new Promise(function (resolve, reject) {
          directoryEntry.getFile(fileName, {}, function (fileEntry) {
            fileEntry.file(function (file) {
              var reader = new FileReader();

              reader.onerror = reject;
              reader.onloadend = function () {
                resolve(this.result);
              };

              switch (type) {
                case 'ArrayBuffer':
                  return reader.readAsArrayBuffer(file);
                case 'BinaryString':
                  return reader.readAsBinaryString(file);
                case 'DataURL':
                  return reader.readAsDataURL(file);
                case 'Text':
                  return reader.readAsText(file);
                default:
                  throw new Error('unsupported data type, \'' + type);
              }
            }, reject);
          }, reject);
        });
      });
    }).catch(function (e) {
      console.warn('readFile', e.code, e.name, e.message);
      throw e;
    });
  };

  var writeFile = function writeFile(filePath, blob, size) {
    return getFS(size).then(function (fs) {
      return fileLocator(filePath, fs).then(function (_ref2) {
        var directoryEntry = _ref2.directoryEntry,
            fileName = _ref2.fileName;

        return new Promise(function (resolve, reject) {
          directoryEntry.getFile(fileName, { create: true }, function (fileEntry) {
            fileEntry.createWriter(function (fileWriter) {
              fileWriter.onwriteend = function () {
                return resolve(fileEntry.toURL());
              };
              fileWriter.onerror = reject;

              fileWriter.write(blob);
            });
          }, reject);
        });
      });
    }).catch(function (e) {
      console.warn(e.code, e.name, e.message);
      throw e;
    });
  };

  var removeFile = function removeFile(filePath) {
    return getFS().then(function (fs) {
      return fileLocator(filePath, fs).then(function (_ref3) {
        var directoryEntry = _ref3.directoryEntry,
            fileName = _ref3.fileName;

        return new Promise(function (resolve, reject) {
          directoryEntry.getFile(fileName, { create: true }, function (fileEntry) {
            fileEntry.remove(resolve, reject);
          }, reject);
        });
      });
    }).catch(function (e) {
      console.warn('removeFile', e.code, e.name, e.message);
      throw e;
    });
  };

  var moveFile = function moveFile(srcPath, targetPath) {
    return getFS().then(function (fs) {
      return Promise.all([fileLocator(srcPath, fs), fileLocator(targetPath, fs)]).then(function (tuple) {
        var srcDirEntry = tuple[0].directoryEntry;
        var srcFileName = tuple[0].fileName;
        var tgtDirEntry = tuple[1].directoryEntry;
        var tgtFileName = tuple[1].fileName;

        return new Promise(function (resolve, reject) {
          srcDirEntry.getFile(srcFileName, {}, function (fileEntry) {
            try {
              fileEntry.moveTo(tgtDirEntry, tgtFileName, resolve, reject);
            } catch (e) {
              // Note: For firefox, we use `idb.filesystem.js`, but it hasn't implemented `moveTo` method
              // so we have to mock it with read / write / remove
              readFile(srcPath, 'ArrayBuffer').then(function (arrayBuffer) {
                return writeFile(targetPath, new Blob([new Uint8Array(arrayBuffer)]));
              }).then(function () {
                return removeFile(srcPath);
              }).then(resolve, reject);
            }
          }, reject);
        });
      });
    });
  };

  var copyFile = function copyFile(srcPath, targetPath) {
    return getFS().then(function (fs) {
      return Promise.all([fileLocator(srcPath, fs), fileLocator(targetPath, fs)]).then(function (tuple) {
        var srcDirEntry = tuple[0].directoryEntry;
        var srcFileName = tuple[0].fileName;
        var tgtDirEntry = tuple[1].directoryEntry;
        var tgtFileName = tuple[1].fileName;

        return new Promise(function (resolve, reject) {
          srcDirEntry.getFile(srcFileName, {}, function (fileEntry) {
            try {
              fileEntry.copyTo(tgtDirEntry, tgtFileName, resolve, reject);
            } catch (e) {
              // Note: For firefox, we use `idb.filesystem.js`, but it hasn't implemented `copyTo` method
              // so we have to mock it with read / write
              readFile(srcPath, 'ArrayBuffer').then(function (arrayBuffer) {
                return writeFile(targetPath, new Blob([new Uint8Array(arrayBuffer)]));
              }).then(resolve, reject);
            }
          }, reject);
        });
      });
    }).catch(function (e) {
      console.warn('copyFile', e.code, e.name, e.message);
      throw e;
    });
  };

  var getMetadata = function getMetadata(filePath) {
    var isDirectory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    return getFS().then(function (fs) {
      if (filePath.getMetadata) {
        return new Promise(function (resolve, reject) {
          return filePath.getMetadata(resolve);
        });
      }

      return fileLocator(filePath, fs).then(function (_ref4) {
        var directoryEntry = _ref4.directoryEntry,
            fileName = _ref4.fileName;

        return new Promise(function (resolve, reject) {
          var args = [fileName, { create: false }, function (entry) {
            entry.getMetadata(resolve);
          }, reject];

          if (isDirectory) {
            directoryEntry.getDirectory.apply(directoryEntry, args);
          } else {
            directoryEntry.getFile.apply(directoryEntry, args);
          }
        });
      });
    }).catch(function (e) {
      console.warn('getMetadata', e.code, e.name, e.message);
      throw e;
    });
  };

  var existsStat = function existsStat(entryPath) {
    return getFS().then(function (fs) {
      return fileLocator(entryPath, fs).then(function (_ref5) {
        var directoryEntry = _ref5.directoryEntry,
            fileName = _ref5.fileName;

        var isSomeEntry = function isSomeEntry(getMethodName) {
          return new Promise(function (resolve) {
            directoryEntry[getMethodName](fileName, { create: false }, function (data) {
              resolve(true);
            }, function () {
              return resolve(false);
            });
          });
        };

        var pIsFile = isSomeEntry('getFile');
        var pIsDir = isSomeEntry('getDirectory');

        return Promise.all([pIsFile, pIsDir]).then(function (_ref6) {
          var _ref7 = _slicedToArray(_ref6, 2),
              isFile = _ref7[0],
              isDirectory = _ref7[1];

          return {
            isFile: isFile,
            isDirectory: isDirectory
          };
        });
      });
    }).catch(function (e) {
      // DOMException.NOT_FOUND_ERR === 8
      if (e && e.code === 8) {
        return {
          isFile: false,
          isDirectory: false
        };
      }

      console.warn('fs.exists', e.code, e.name, e.message);
      throw e;
    });
  };

  var exists = function exists(entryPath) {
    var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        type = _ref8.type;

    return existsStat(entryPath).then(function (stat) {
      switch (type) {
        case 'file':
          return stat.isFile;

        case 'directory':
          return stat.isDirectory;

        default:
          return stat.isFile || stat.isDirectory;
      }
    });
  };

  return {
    list: list,
    readFile: readFile,
    writeFile: writeFile,
    removeFile: removeFile,
    moveFile: moveFile,
    copyFile: copyFile,
    getDirectory: getDirectory,
    getMetadata: getMetadata,
    ensureDirectory: ensureDirectory,
    exists: exists,
    existsStat: existsStat,
    rmdir: rmdir,
    rmdirR: rmdirR
  };
}();

// For test only
window.fs = fs;

/* harmony default export */ __webpack_exports__["default"] = (fs);

/***/ }),

/***/ 1086:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/antd/lib/message/index.js
var message = __webpack_require__(15);
var message_default = /*#__PURE__*/__webpack_require__.n(message);

// EXTERNAL MODULE: ./node_modules/antd/lib/locale-provider/index.js
var locale_provider = __webpack_require__(621);
var locale_provider_default = /*#__PURE__*/__webpack_require__.n(locale_provider);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(0);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(18);
var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);

// EXTERNAL MODULE: ./node_modules/react-router-dom/es/index.js + 30 modules
var es = __webpack_require__(362);

// EXTERNAL MODULE: ./node_modules/antd/lib/locale-provider/en_US.js
var en_US = __webpack_require__(387);
var en_US_default = /*#__PURE__*/__webpack_require__.n(en_US);

// EXTERNAL MODULE: ./node_modules/react-dnd-html5-backend/dist/esm/index.js + 12 modules
var esm = __webpack_require__(655);

// EXTERNAL MODULE: ./node_modules/react-dnd/dist/esm/common/DndProvider.js
var DndProvider = __webpack_require__(553);

// EXTERNAL MODULE: ./node_modules/fuzzyset.js/index.js
var fuzzyset_js = __webpack_require__(627);
var fuzzyset_js_default = /*#__PURE__*/__webpack_require__.n(fuzzyset_js);

// EXTERNAL MODULE: ./node_modules/semver/semver.js
var semver = __webpack_require__(135);
var semver_default = /*#__PURE__*/__webpack_require__.n(semver);

// EXTERNAL MODULE: ./src/config/index.ts
var src_config = __webpack_require__(34);
var config_default = /*#__PURE__*/__webpack_require__.n(src_config);

// EXTERNAL MODULE: ./src/common/lib/path/index.js
var lib_path = __webpack_require__(27);

// EXTERNAL MODULE: ./src/common/lib/file_saver.js
var file_saver = __webpack_require__(70);
var file_saver_default = /*#__PURE__*/__webpack_require__.n(file_saver);

// EXTERNAL MODULE: ./node_modules/antd/lib/button/index.js
var lib_button = __webpack_require__(19);
var button_default = /*#__PURE__*/__webpack_require__.n(lib_button);

// EXTERNAL MODULE: ./node_modules/antd/lib/modal/index.js
var modal = __webpack_require__(56);
var modal_default = /*#__PURE__*/__webpack_require__.n(modal);

// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 18 modules
var react_redux_es = __webpack_require__(85);

// EXTERNAL MODULE: ./node_modules/redux/es/index.js + 15 modules
var redux_es = __webpack_require__(77);

// EXTERNAL MODULE: ./src/actions/index.js + 2 modules
var actions = __webpack_require__(16);

// EXTERNAL MODULE: ./src/common/constant.ts
var constant = __webpack_require__(17);

// EXTERNAL MODULE: ./src/common/ipc/ipc_cs.js
var ipc_cs = __webpack_require__(20);

// EXTERNAL MODULE: ./node_modules/antd/lib/icon/index.js
var icon = __webpack_require__(45);
var icon_default = /*#__PURE__*/__webpack_require__.n(icon);

// EXTERNAL MODULE: ./node_modules/antd/lib/dropdown/index.js
var dropdown = __webpack_require__(158);
var dropdown_default = /*#__PURE__*/__webpack_require__.n(dropdown);

// EXTERNAL MODULE: ./node_modules/antd/lib/menu/index.js
var menu = __webpack_require__(25);
var menu_default = /*#__PURE__*/__webpack_require__.n(menu);

// EXTERNAL MODULE: ./node_modules/antd/lib/tabs/index.js
var tabs = __webpack_require__(38);
var tabs_default = /*#__PURE__*/__webpack_require__.n(tabs);

// EXTERNAL MODULE: ./node_modules/antd/lib/input/index.js
var input = __webpack_require__(29);
var input_default = /*#__PURE__*/__webpack_require__.n(input);

// EXTERNAL MODULE: ./node_modules/antd/lib/checkbox/index.js
var lib_checkbox = __webpack_require__(39);
var checkbox_default = /*#__PURE__*/__webpack_require__.n(lib_checkbox);

// EXTERNAL MODULE: ./node_modules/antd/lib/select/index.js
var lib_select = __webpack_require__(37);
var select_default = /*#__PURE__*/__webpack_require__.n(lib_select);

// EXTERNAL MODULE: ./node_modules/antd/lib/radio/index.js
var lib_radio = __webpack_require__(35);
var radio_default = /*#__PURE__*/__webpack_require__.n(lib_radio);

// EXTERNAL MODULE: ./node_modules/antd/lib/form/index.js
var lib_form = __webpack_require__(31);
var form_default = /*#__PURE__*/__webpack_require__.n(lib_form);

// EXTERNAL MODULE: ./node_modules/antd/lib/row/index.js
var row = __webpack_require__(639);
var row_default = /*#__PURE__*/__webpack_require__.n(row);

// EXTERNAL MODULE: ./node_modules/antd/lib/col/index.js
var col = __webpack_require__(403);
var col_default = /*#__PURE__*/__webpack_require__.n(col);

// EXTERNAL MODULE: ./node_modules/copy-to-clipboard/index.js
var copy_to_clipboard = __webpack_require__(640);
var copy_to_clipboard_default = /*#__PURE__*/__webpack_require__.n(copy_to_clipboard);

// EXTERNAL MODULE: ./src/components/header.scss
var header = __webpack_require__(1003);

// EXTERNAL MODULE: ./src/common/player.js
var common_player = __webpack_require__(28);

// EXTERNAL MODULE: ./src/recomputed/index.ts
var recomputed = __webpack_require__(23);

// EXTERNAL MODULE: ./src/components/save_test_case.js
var save_test_case = __webpack_require__(99);

// EXTERNAL MODULE: ./src/actions/simple_actions.ts
var simple_actions = __webpack_require__(41);

// EXTERNAL MODULE: ./src/common/utils.js
var utils = __webpack_require__(4);

// EXTERNAL MODULE: ./src/services/xmodules/xfile.ts
var xfile = __webpack_require__(32);

// EXTERNAL MODULE: ./src/services/xmodules/x_user_io.ts
var x_user_io = __webpack_require__(88);

// EXTERNAL MODULE: ./src/services/xmodules/xdesktop.ts
var xdesktop = __webpack_require__(74);

// EXTERNAL MODULE: ./src/services/xmodules/x_screen_capture.ts
var x_screen_capture = __webpack_require__(75);

// EXTERNAL MODULE: ./src/services/xmodules/common.ts
var xmodules_common = __webpack_require__(90);

// EXTERNAL MODULE: ./src/services/storage/index.ts
var storage = __webpack_require__(13);

// EXTERNAL MODULE: ./src/common/web_extension.js
var web_extension = __webpack_require__(10);
var web_extension_default = /*#__PURE__*/__webpack_require__.n(web_extension);

// EXTERNAL MODULE: ./src/services/ocr/languages.ts
var languages = __webpack_require__(329);

// EXTERNAL MODULE: ./src/common/registry.ts
var registry = __webpack_require__(184);

// EXTERNAL MODULE: ./src/common/ts_utils.ts
var ts_utils = __webpack_require__(12);

// EXTERNAL MODULE: ./src/common/cv_utils.ts
var cv_utils = __webpack_require__(42);

// CONCATENATED MODULE: ./src/common/variables.js
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }







var standardKeyConstants = ['KEY_LEFT', 'KEY_UP', 'KEY_RIGHT', 'KEY_DOWN', 'KEY_PGUP', 'KEY_PAGE_UP', 'KEY_PGDN', 'KEY_PAGE_DOWN', 'KEY_BKSP', 'KEY_BACKSPACE', 'KEY_DEL', 'KEY_DELETE', 'KEY_ENTER', 'KEY_TAB', 'KEY_ESC', 'KEY_SPACE', 'KEY_HOME', 'KEY_END'];

var metaKeyConstants = ['KEY_CTRL', 'KEY_ALT', 'KEY_SHIFT', 'KEY_WIN', 'KEY_CMD', 'KEY_META'];

var fnKeyConstants = ['KEY_F1', 'KEY_F2', 'KEY_F3', 'KEY_F4', 'KEY_F5', 'KEY_F6', 'KEY_F7', 'KEY_F8', 'KEY_F9', 'KEY_F10', 'KEY_F11', 'KEY_F12', 'KEY_F13', 'KEY_F14', 'KEY_F15'];

var numericKeyConstants = ['KEY_Num0', 'KEY_Num1', 'KEY_Num2', 'KEY_Num3', 'KEY_Num4', 'KEY_Num5', 'KEY_Num6', 'KEY_Num7', 'KEY_Num8', 'KEY_Num9'];

var numberKeyConstants = ['KEY_0', 'KEY_1', 'KEY_2', 'KEY_3', 'KEY_4', 'KEY_5', 'KEY_6', 'KEY_7', 'KEY_8', 'KEY_9'];

var letterKeyConstants = ['KEY_A', 'KEY_B', 'KEY_C', 'KEY_D', 'KEY_E', 'KEY_F', 'KEY_G', 'KEY_H', 'KEY_I', 'KEY_J', 'KEY_K', 'KEY_L', 'KEY_M', 'KEY_N', 'KEY_O', 'KEY_P', 'KEY_Q', 'KEY_R', 'KEY_S', 'KEY_T', 'KEY_U', 'KEY_V', 'KEY_W', 'KEY_X', 'KEY_Y', 'KEY_Z'];

var keyConstants = [].concat(standardKeyConstants, metaKeyConstants, fnKeyConstants, numberKeyConstants, numericKeyConstants, letterKeyConstants).map(function (key) {
  return key.toUpperCase();
});

var variables_isValidKeyConstant = function isValidKeyConstant(pattern) {
  var str = pattern && pattern.toUpperCase();

  if (keyConstants.indexOf(str) !== -1) return true;
  if (/^KEY_\w+(\+KEY_\w+)*$/.test(str)) {
    var keys = str.split('+');
    return utils["and"].apply(undefined, _toConsumableArray(keys.map(function (s) {
      return keyConstants.indexOf(s) !== -1;
    })));
  }
  return false;
};

var DEFAULT_KEY = 'main';
var cache = {};

var variables_validateVariableName = function validateVariableName(name) {
  if (name.charAt(0) === '!') {
    name = name.substr(1);
  }

  try {
    Object(utils["validateStandardName"])(name);
  } catch (e) {
    throw new Error('Invalid variable name \'' + name + '\'. A variable name ' + e.message);
  }

  return true;
};

var regDollarV2 = /\$\{((!?\w+)((\.\w+|\[(\d+|\$\{!?\w+\})\])*))\}/gi;
var regStoredVars = /storedVars\[('|")((!?\w+)((\.\w+|\[(\d+|\$\{!?\w+\})\])*))\1\]/gi;

function substrToList(substr) {
  var regSubstr = /\.(\w+)|\[(\d+|\$\{!?\w+\})\]/gi;
  var normalizedStr = substr && substr.trim();

  if (!normalizedStr || normalizedStr.length === 0) {
    return [];
  }

  var result = [];
  var lastEndIndex = -1;
  var m = void 0;

  // eslint-disable-next-line no-cond-assign
  while (m = regSubstr.exec(substr)) {
    if (!m || m.index !== lastEndIndex + 1) {
      throw new Error('Invalid variable expression');
    }

    result.push(m[1] || m[2]);
    lastEndIndex = lastEndIndex + m[0].length;
  }

  if (lastEndIndex !== normalizedStr.length - 1) {
    throw new Error('Invalid variable expression ending');
  }

  return result;
}

function listToSubstr(list) {
  return list.map(function (str) {
    return (/^\d+$/.test(str) ? '[' + str + ']' : '.' + str
    );
  }).join('');
}

function varsFactory() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_KEY;
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var isBoolean = function isBoolean(val) {
    return ['TRUE', 'FALSE'].indexOf((val + '').toUpperCase()) !== -1;
  };
  var opts = _extends({
    isInvalidInternalVar: function isInvalidInternalVar(key) {
      return key.indexOf('!') === 0 && key !== '!TIMEOUT_PAGELOAD' && key !== '!TIMEOUT_WAIT' && key !== '!TIMEOUT_MACRO' && key !== '!TIMEOUT_DOWNLOAD' && key !== '!TIMEOUT_DOWNLOAD_START' && key !== '!REPLAYSPEED' && key !== '!LOOP' && key !== '!TESTSUITE_LOOP' && key !== '!URL' && key !== '!MACRONAME' && key !== '!RUNTIME' && key !== '!CSVLINE' && key !== '!CSVLINE' && key !== '!LASTCOMMANDOK' && key !== '!ERRORIGNORE' && key !== '!CSVREADLINENUMBER' && key !== '!CSVREADSTATUS' && key !== '!CSVREADMAXROW' && key !== '!CLIPBOARD' && key !== '!STATUSOK' && key !== '!WAITFORVISIBLE' && key !== '!IMAGEX' && key !== '!IMAGEY' && key !== '!IMAGEWIDTH' && key !== '!IMAGEHEIGHT' && key !== '!VISUALSEARCHAREA' && key !== '!STOREDIMAGERECT' && key !== '!STRINGESCAPE' && key !== '!CMD_VAR1' && key !== '!CMD_VAR2' && key !== '!CMD_VAR3' && key !== '!OCRLANGUAGE' && key !== '!OCRENGINE' && key !== '!OCRSCALE' && key !== '!OCRTABLEEXTRACTION' && key !== '!OCRX' && key !== '!OCRY' && key !== '!BROWSER' && key !== '!OS' && key !== '!TIMES' && key !== '!FOREACH' && key !== '!CVSCOPE' && key !== '!XRUN_EXITCODE' && key !== '!PROXY_EXEC_COUNT' && key !== '!GLOBAL_TESTSUITE_STOP_ON_ERROR' && key !== '!LAST_DOWNLOADED_FILE_NAME' && !/^!COL\d+$/i.test(key);
    },
    readonly: ['!LOOP', 'TESTSUITE_LOOP', '!URL', '!MACRONAME', '!RUNTIME', '!LASTCOMMANDOK', '!CSVREADSTATUS', '!CSVREADMAXROW', '!VISUALSEARCHAREA', '!BROWSER', '!OS', '!CVSCOPE', '!XRUN_EXITCODE', '!PROXY_EXEC_COUNT', '!TIMES', '!FOREACH', '!LAST_DOWNLOADED_FILE_NAME'].concat(_toConsumableArray(keyConstants)),
    typeCheck: {
      '!REPLAYSPEED': function REPLAYSPEED(val) {
        return ['SLOW', 'MEDIUM', 'FAST', 'NODISPLAY'].indexOf((val || '').toUpperCase()) !== -1;
      },
      '!TIMEOUT_PAGELOAD': function TIMEOUT_PAGELOAD(val) {
        return parseInt(val, 10) >= 0;
      },
      '!TIMEOUT_WAIT': function TIMEOUT_WAIT(val) {
        return parseInt(val, 10) >= 0;
      },
      '!TIMEOUT_MACRO': function TIMEOUT_MACRO(val) {
        return parseInt(val, 10) >= 0;
      },
      '!TIMEOUT_DOWNLOAD': function TIMEOUT_DOWNLOAD(val) {
        return parseInt(val, 10) >= 0;
      },
      '!TIMEOUT_DOWNLOAD_START': function TIMEOUT_DOWNLOAD_START(val) {
        return parseInt(val, 10) >= 0;
      },
      '!CSVREADLINENUMBER': function CSVREADLINENUMBER(val) {
        return parseInt(val, 10) >= 0;
      },
      '!OCRLANGUAGE': function OCRLANGUAGE(val) {
        return Object(languages["isValidOCRLanguage"])(val);
      },
      '!OCRENGINE': function OCRENGINE(val) {
        return [1, 2].indexOf(parseInt(val, 10)) !== -1;
      },
      '!OCRSCALE': isBoolean,
      '!OCRX': function OCRX(val) {
        return parseInt(val, 10) >= 0;
      },
      '!OCRY': function OCRY(val) {
        return parseInt(val, 10) >= 0;
      },
      '!ERRORIGNORE': isBoolean,
      '!STATUSOK': isBoolean,
      '!WAITFORVISIBLE': isBoolean,
      '!STRINGESCAPE': isBoolean,
      '!GLOBAL_TESTSUITE_STOP_ON_ERROR': isBoolean,
      '!CVSCOPE': function CVSCOPE(val) {
        return [cv_utils["ComputerVisionType"].Browser, cv_utils["ComputerVisionType"].Desktop, cv_utils["ComputerVisionType"].DesktopScreenCapture].indexOf(val) !== -1;
      }
    },
    normalize: function normalize(key, val) {
      var upperKey = key.toUpperCase();
      var acceptStringTrueFalse = function acceptStringTrueFalse(val) {
        if (val === 'true') return true;
        if (val === 'false') return false;
        return val;
      };
      var num = function num(s) {
        return parseFloat(s);
      };

      switch (upperKey) {
        case '!ERRORIGNORE':
        case '!STATUSOK':
        case '!WAITFORVISIBLE':
        case '!STRINGESCAPE':
        case '!GLOBAL_TESTSUITE_STOP_ON_ERROR':
        case '!OCRSCALE':
        case '!OCRTABLEEXTRACTION':
          return acceptStringTrueFalse(val);

        case '!TIMEOUT_PAGELOAD':
        case '!TIMEOUT_WAIT':
        case '!TIMEOUT_MACRO':
        case '!TIMEOUT_DOWNLOAD':
        case '!TIMEOUT_DOWNLOAD_START':
        case '!OCRENGINE':
          return num(val);

        default:
          return val;
      }
    }
  }, options);
  var vars = initial;

  var listeners = new registry["Registry"]({ process: function process(fn, data, eventName) {
      return fn(data);
    } });
  var fireOnChange = function fireOnChange() {
    return listeners.fire('change', { vars: _extends({}, vars) });
  };
  var self = {
    reset: function reset() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.keepGlobal) {
        var globals = Object.keys(vars).reduce(function (prev, key) {
          if (/^!?global/i.test(key) || /^!TESTSUITE_LOOP$/i.test(key)) {
            prev[key] = vars[key];
          }
          return prev;
        }, {});

        vars = globals;
      } else {
        vars = {};
      }

      fireOnChange();
    },
    render: function render(str, options) {
      var _ref = options && options.withHashNotation ? [regStoredVars, 3, 4] : [regDollarV2, 2, 3],
          _ref2 = _slicedToArray(_ref, 3),
          reg = _ref2[0],
          mainIndex = _ref2[1],
          subIndex = _ref2[2];

      var decorate = options && options.shouldStringify ? function (x) {
        return JSON.stringify(x);
      } : ts_utils["id"];

      return self.replaceAllVars({
        str: str,
        reg: reg,
        decorate: decorate,
        getVarName: function getVarName(args) {
          return args[mainIndex];
        },
        getSubstring: function getSubstring(args) {
          return args[subIndex];
        }
      });
    },
    replaceAllVars: function replaceAllVars(params) {
      var str = params.str,
          reg = params.reg,
          _params$getVarName = params.getVarName,
          getVarName = _params$getVarName === undefined ? function (args) {
        return args[1];
      } : _params$getVarName,
          _params$getSubstring = params.getSubstring,
          getSubstring = _params$getSubstring === undefined ? function (args) {
        return args[2];
      } : _params$getSubstring,
          _params$decorate = params.decorate,
          decorate = _params$decorate === undefined ? function (val) {
        return val;
      } : _params$decorate;


      return str.replace(reg, function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var variable = (getVarName(args) || '').toUpperCase();
        var subs = substrToList(getSubstring(args)).map(function (key) {
          return self.render(key);
        });

        // Note: keep as it is if it's a KEY_XXX variable, which should be handled by command runner
        if (variables_isValidKeyConstant(variable)) {
          return args[0];
        }

        var root = self.getVarForRender(variable);
        var rawValue = subs.reduce(function (prev, key, i) {
          if (prev === null || prev === undefined) {
            throw new Error('' + variable + listToSubstr(subs.slice(0, i)) + ' is ' + prev);
          }
          return prev[key];
        }, root);

        return decorate(rawValue, args);
      });
    },
    getVarForRender: function getVarForRender(key) {
      var upperKey = (key || '').toUpperCase();

      if (upperKey in vars) {
        return vars[upperKey];
      } else {
        if (/^!cmd_var(1|2|3)$/i.test(upperKey)) return 'NOT_SET';

        if (/^!/.test(upperKey)) {
          throw new Error('Internal variable "' + upperKey + '" not supported');
        } else {
          throw new Error('variable "' + upperKey + '" is not defined');
        }
      }
    },
    get: function get(field) {
      return vars[field.toUpperCase()];
    },
    set: function set(obj, isAdmin) {
      Object.keys(obj).forEach(function (key) {
        var trimmedKey = key.trim();
        if (trimmedKey.length === 0) return;

        variables_validateVariableName(trimmedKey);

        var targetKey = trimmedKey.toUpperCase();

        // Note: prevent variable with empty name
        if (targetKey.length === 0) return;

        // Note: special treatment for !CSVLINE
        if (/^!CSVLINE$/i.test(targetKey)) {
          var csvLine = self.get('!CSVLINE');

          if (csvLine === undefined) {
            csvLine = [];
          } else if (!Array.isArray(csvLine)) {
            csvLine = [csvLine];
          }

          csvLine.push(obj[key]);
          vars['!CSVLINE'] = csvLine;

          return;
        }

        if (!isAdmin && opts.readonly.indexOf(targetKey) !== -1) {
          throw new Error('Cannot write to readonly variable \'' + key + '\'');
        }

        if (opts.isInvalidInternalVar(targetKey)) {
          throw new Error('Not allowed to write to \'' + key + '\'');
        }

        if (opts.typeCheck[targetKey] && !opts.typeCheck[targetKey](obj[key])) {
          throw new Error('Value \'' + obj[key] + '\' is not supported for variable "' + targetKey + '"');
        }

        vars[targetKey] = opts.normalize(key, obj[key]);
      });

      fireOnChange();
    },
    clear: function clear(reg) {
      Object.keys(vars).forEach(function (key) {
        if (reg.test(key)) {
          delete vars[key];
        }
      });

      fireOnChange();
    },
    isReadOnly: function isReadOnly(variable) {
      var str = variable && variable.toUpperCase ? variable.toUpperCase() : '';
      return opts.readonly.indexOf(str) !== -1;
    },
    dump: function dump() {
      return _extends({}, vars);
    },
    onChange: function onChange(fn) {
      listeners.add('change', fn);
      return function () {
        return listeners.remove('change', fn);
      };
    }
  };

  cache[name] = self;
  return self;
}

var getVarsInstance = function getVarsInstance() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_KEY;

  return cache[name];
};

var createVarsFilter = function createVarsFilter(_ref3) {
  var _ref3$withUserDefined = _ref3.withUserDefined,
      withUserDefined = _ref3$withUserDefined === undefined ? true : _ref3$withUserDefined,
      withCommonInternal = _ref3.withCommonInternal,
      withAdvancedInternal = _ref3.withAdvancedInternal;

  var checkUserDefined = function checkUserDefined(name) {
    return !/^!/.test(name);
  };
  var checkCommonInternal = function checkCommonInternal(name) {
    var list = ['!url', '!clipboard', '!runtime', '!statusok', '!errorignore'].map(function (x) {
      return x.toUpperCase();
    });
    return list.indexOf(name.toUpperCase()) !== -1;
  };
  var checkAdvancedInternal = function checkAdvancedInternal(name) {
    return (/^!/.test(name) && !checkCommonInternal(name)
    );
  };
  var orCheck = function orCheck(fns) {
    return function () {
      for (var i = 0, len = fns.length; i < len; i++) {
        if (fns[i].apply(fns, arguments)) return true;
      }
      return false;
    };
  };
  var list = [withUserDefined ? checkUserDefined : null, withCommonInternal ? checkCommonInternal : null, withAdvancedInternal ? checkAdvancedInternal : null].filter(function (x) {
    return !!x;
  });

  return orCheck(list);
};
// CONCATENATED MODULE: ./src/common/interpreter.js
var interpreter_slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var interpreter_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



var normalizeLabelName = function normalizeLabelName(label) {
  return label.toUpperCase();
};

var interpreter_Interpreter = function () {
  function Interpreter() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Interpreter);

    this.state = Object(ts_utils["clone"])(Interpreter.DefaultState);

    if (opts.pre) {
      this.__customPre = opts.pre;
    }

    if (opts.run) {
      this.__customRun = opts.run;
    }

    if (opts.post) {
      this.__customPost = opts.post;
    }
  }

  _createClass(Interpreter, [{
    key: 'reset',
    value: function reset() {
      this.__setState({
        labels: {},
        tags: [],
        commands: []
      });
    }
  }, {
    key: 'preprocess',
    value: function preprocess(commands) {
      var _this = this;

      var nextState = { commands: commands, tags: [] };
      var halfTags = [];
      var errorAtIndex = function errorAtIndex(i, msg) {
        var e = new Error(msg);
        e.errorIndex = i;
        return e;
      };

      commands.forEach(function (c, i) {
        if (_this.__customPre && _this.__customPre(c, i)) return;

        var topHalfTag = halfTags[halfTags.length - 1];

        switch (c.cmd) {
          // Commands for if, while, do, times, forEach statements
          case 'if_v2':
          case 'if':
          case 'times':
          case 'forEach':
          case 'while_v2':
          case 'while':
          case 'do':
            {
              halfTags.push({
                type: c.cmd,
                start: { index: i, command: c }
              });

              break;
            }

          case 'repeatIf':
            {
              if (!topHalfTag || !/^do$/.test(topHalfTag.type)) {
                throw errorAtIndex(i, 'No matching do for this repeatIf (at command #' + (i + 1) + ')');
              }

              nextState.tags.push(interpreter_extends({}, topHalfTag, {
                end: { index: i, command: c }
              }));

              halfTags.pop();
              break;
            }

          case 'elseif':
          case 'else':
            {
              if (!topHalfTag || !/^if/.test(topHalfTag.type)) {
                throw errorAtIndex(i, 'No matching if for this ' + c.cmd + ' (at command #' + (i + 1) + ')');
              }

              topHalfTag.children = topHalfTag.children || [];

              var existingElseIndex = topHalfTag.children.findIndex(function (fork) {
                return fork.command && fork.command.cmd === 'else';
              });

              if (existingElseIndex !== -1) {
                var existingElse = topHalfTag.children[existingElseIndex];
                throw new Error('\'' + c.cmd + '\' (at command #' + (i + 1) + ') could not be used after \'' + existingElse.command.cmd + '\' (at command #' + (existingElse.index + 1) + ')');
              }

              topHalfTag.children.push({ index: i, command: c });

              break;
            }

          case 'break':
          case 'continue':
            {
              var targetHalfTag = halfTags.find(function (tag) {
                return (/^(do|while|forEach|times)/.test(tag.type)
                );
              });

              if (!targetHalfTag) {
                throw errorAtIndex(i, 'No matching loop command for this ' + c.cmd + ' (at command #' + (i + 1) + ')');
              }

              targetHalfTag.children = targetHalfTag.children || [];
              targetHalfTag.children.push({ index: i, command: c });

              break;
            }

          case 'end':
          case 'endWhile':
          case 'endif':
            {
              var _ref = function () {
                switch (c.cmd) {
                  case 'end':
                    return [/^(if|while|times|forEach)/, 'if/while/times/forEach'];

                  case 'endWhile':
                    return [/^while/, 'while'];

                  case 'endif':
                    return [/^if/, 'if'];
                }
              }(),
                  _ref2 = interpreter_slicedToArray(_ref, 2),
                  reg = _ref2[0],
                  text = _ref2[1];

              if (!topHalfTag || !reg.test(topHalfTag.type)) {
                throw errorAtIndex(i, 'No matching ' + text + ' for this end (at command #' + (i + 1) + ')');
              }

              nextState.tags.push(interpreter_extends({}, topHalfTag, {
                end: { index: i, command: c }
              }));

              halfTags.pop();
              break;
            }

          case 'label':
            {
              if (!c.target || !c.target.length) {
                throw new Error('invalid target for label command');
              }

              _this.__setState({
                labels: interpreter_extends({}, _this.state.labels, _defineProperty({}, normalizeLabelName(c.target), { index: i }))
              });

              break;
            }
        }
      });

      if (halfTags.length > 0) {
        var topHalfTag = halfTags[halfTags.length - 1];
        throw errorAtIndex(topHalfTag.start.index, 'Unclosed \'' + topHalfTag.type + '\' (at command #' + (topHalfTag.start.index + 1) + ')');
      }

      this.__setState(nextState);
    }
  }, {
    key: 'run',
    value: function run(command, index) {
      var _this2 = this;

      var cmd = command.cmd,
          target = command.target,
          value = command.value;


      var p = function () {
        switch (cmd) {
          case 'onError':
            {
              var _value = command.value && command.value.trim();
              var _target = command.target && command.target.trim();
              var isValidTarget = _target && (/^#restart$/i.test(_target) || /^#goto$/i.test(_target));

              if (!isValidTarget) {
                throw new Error('invalid target for onError command');
              }

              if (/^#goto$/i.test(_target)) {
                var labelName = normalizeLabelName(_value);

                if (!_this2.state.labels[labelName]) {
                  throw new Error('label ' + _value + ' doesn\'t exist');
                }
              }

              return Promise.resolve({ isFlowLogic: true });
            }

          case 'gotoLabel':
            {
              if (!target || !target.length) {
                throw new Error('invalid target for gotoLabel command');
              }

              var _labelName = normalizeLabelName(target);

              if (!_this2.state.labels[_labelName]) {
                throw new Error('label ' + target + ' doesn\'t exist');
              }

              return Promise.resolve({
                isFlowLogic: true,
                nextIndex: _this2.state.labels[_labelName].index
              });
            }

          case 'elseif':
            {
              var tag = _this2.state.tags.find(function (tag) {
                return (/^if/.test(tag.type) && tag.children && tag.children.find(function (fork) {
                    return fork.index === index && fork.command.cmd === cmd;
                  })
                );
              });

              if (!tag) {
                throw new Error('tag not found for this else (at command #' + (index + 1) + ')');
              }

              // Note: if the `if` tag has already tried some branch, then this `elseif` should act like `else`
              // otherwise it acts like `if`
              if (tag.alreadyRun) {
                return Promise.resolve({
                  isFlowLogic: true,
                  nextIndex: tag.end.index + 1
                });
              } else {
                return Promise.resolve({ isFlowLogic: false });
              }
            }

          case 'else':
            {
              // Note: 'else' and 'elseif' command itself will be skipped if condition is false,
              // But it will be run as the ending command of 'if-else' when condition is true
              var _tag = _this2.state.tags.find(function (tag) {
                return (/^if/.test(tag.type) && tag.children && tag.children.find(function (fork) {
                    return fork.index === index && fork.command.cmd === cmd;
                  })
                );
              });

              if (!_tag) {
                throw new Error('tag not found for this else (at command #' + (index + 1) + ')');
              }

              return Promise.resolve({
                isFlowLogic: true,
                nextIndex: _tag.end.index + 1
              });
            }

          case 'break':
            {
              var _tag2 = _this2.state.tags.find(function (tag) {
                return (/^(do|while|forEach|times)/.test(tag.type) && tag.children && tag.children.find(function (item) {
                    return item.index === index && item.command.cmd === cmd;
                  })
                );
              });

              if (!_tag2) {
                throw new Error('No loop found for this break (at command #' + (index + 1) + ')');
              }

              return Promise.resolve({
                isFlowLogic: true,
                nextIndex: _tag2.end.index + 1
              });
            }

          case 'continue':
            {
              var _tag3 = _this2.state.tags.find(function (tag) {
                return (/^(do|while|forEach|times)/.test(tag.type) && tag.children && tag.children.find(function (item) {
                    return item.index === index && item.command.cmd === cmd;
                  })
                );
              });

              if (!_tag3) {
                throw new Error('No loop found for this break (at command #' + (index + 1) + ')');
              }

              return Promise.resolve({
                isFlowLogic: true,
                nextIndex: _tag3.start.index
              });
            }

          case 'endif':
            {
              return Promise.resolve({ isFlowLogic: true });
            }

          case 'endWhile':
            {
              var _tag4 = _this2.state.tags.find(function (tag) {
                return (/^while/.test(tag.type) && tag.end.index === index
                );
              });

              if (!_tag4) {
                throw new Error('tag not found for this endWhile (at command #' + (index + 1) + ')');
              }

              return Promise.resolve({
                isFlowLogic: true,
                nextIndex: _tag4.start.index
              });
            }

          case 'end':
            {
              var _tag5 = _this2.state.tags.find(function (tag) {
                return (/^(if|while|times|forEach)/.test(tag.type) && tag.end.index === index
                );
              });

              if (!_tag5) {
                throw new Error('tag not found for this end (at command #' + (index + 1) + ')');
              }

              if (/^if/.test(_tag5.type)) {
                return Promise.resolve({ isFlowLogic: true });
              }

              // Then it's a `while`, `forEach`, `times`
              return Promise.resolve({
                isFlowLogic: true,
                nextIndex: _tag5.start.index
              });
            }

          case 'comment':
            return Promise.resolve({ isFlowLogic: true });

          // As of 'label', it doesn't do anything, so we just kind of skip it
          case 'label':
            return Promise.resolve({ isFlowLogic: true });

          case 'do':
            return Promise.resolve({ isFlowLogic: true });

          // Note: gotoIf, if and while need to run eval, which is not allowed in extension scope,
          // so we have to run eval in content script
          //
          // gotoIf_v2/if_v2/while_v2 will be run in extension scope (we've added `unsafe-eval` in `content_security_policy)
          case 'gotoIf':
          case 'if':
          case 'while':
          case 'gotoIf_v2':
          case 'if_v2':
          case 'while_v2':
          case 'repeatIf':
          default:
            return Promise.resolve({ isFlowLogic: false });
        }
      }();

      return p.then(function (result) {
        if (result.isFlowLogic) {
          return result;
        }

        if (_this2.__customRun) {
          var _p = _this2.__customRun(command, index);
          if (_p) return Promise.resolve(_p);
        }

        return result;
      });
    }
  }, {
    key: 'postRun',
    value: function postRun(command, index, result) {
      var _this3 = this;

      var cmd = command.cmd,
          target = command.target,
          value = command.value;


      if (this.__customPost) {
        var p = this.__customPost(command, index, result);
        if (p) return Promise.resolve(p);
      }

      switch (cmd) {
        case 'gotoIf_v2':
        case 'gotoIf':
          {
            // short-circuit the check on value
            if (!result.condition) return Promise.resolve();

            if (!value || !value.length) {
              throw new Error('invalid value for value command');
            }

            var labelName = normalizeLabelName(value);

            if (!this.state.labels[labelName]) {
              throw new Error('label ' + value + ' doesn\'t exist');
            }

            return Promise.resolve({
              nextIndex: this.state.labels[labelName].index
            });
          }

        case 'elseif':
        case 'if_v2':
        case 'if':
          {
            var cond = result.condition;
            var tag = function () {
              if (cmd === 'elseif') {
                return _this3.state.tags.find(function (tag) {
                  return (/^if/.test(tag.type) && tag.children && tag.children.find(function (fork) {
                      return fork.index === index && fork.command.cmd === 'elseif';
                    })
                  );
                });
              } else {
                return _this3.state.tags.find(function (tag) {
                  return (/^if/.test(tag.type) && tag.start.index === index
                  );
                });
              }
            }();

            if (!tag) {
              throw new Error('\'if\' tag not found for this ' + cmd + ' (at command #' + (index + 1) + ')');
            }

            // Mark this `if` tag as already run if condition fulfilled,
            // so that any coming `elseif` could know which role itself is
            tag.alreadyRun = !!cond;

            var forkIndex = function () {
              if (cmd !== 'elseif') {
                return 0;
              }

              var curIndex = (tag.children || []).findIndex(function (fork) {
                return fork.index === index && fork.command.cmd === 'elseif';
              });
              return curIndex === -1 ? -1 : curIndex + 1;
            }();

            if (forkIndex === -1) {
              throw new Error('Can\'t find fork for this elseif (at command #' + (index + 1) + ')');
            }

            var branchIndex = function () {
              var fork = tag.children && tag.children[forkIndex];

              if (!fork) {
                return null;
              }

              // Note: if next fork is elseif, it should execute that elseif
              // if next fork is else, it should go to the next line of that else
              var offset = fork && fork.command.cmd === 'else' ? 1 : 0;
              return fork.index + offset;
            }();
            var endIndex = tag.end && tag.end.index + 1;

            return Promise.resolve({
              nextIndex: cond ? index + 1 : branchIndex || endIndex
            });
          }

        case 'times':
        case 'forEach':
        case 'while_v2':
        case 'while':
          {
            var _cond = result.condition;
            var _tag6 = this.state.tags.find(function (tag) {
              return (/^while|times|forEach/.test(tag.type) && tag.start.index === index
              );
            });

            if (!_tag6) {
              throw new Error('tag not found for this ' + cmd + ' (at command #' + (index + 1) + ')');
            }

            if (!_tag6.end || _tag6.end.index === undefined || _tag6.end.index === null) {
              throw new Error('tag doesn\'t have a valid end index');
            }

            return Promise.resolve(_cond ? {} : { nextIndex: _tag6.end.index + 1 });
          }

        case 'repeatIf':
          {
            var _cond2 = result.condition;
            var _tag7 = this.state.tags.find(function (tag) {
              return (/^do$/.test(tag.type) && tag.end.index === index
              );
            });

            if (!_tag7) {
              throw new Error('tag not found for this repeatIf (at command #' + (index + 1) + ')');
            }

            if (!_tag7.end || _tag7.start.index === undefined || _tag7.start.index === null) {
              throw new Error('tag doesn\'t have a valid start index');
            }

            return Promise.resolve(_cond2 ? { nextIndex: _tag7.start.index + 1 } : {});
          }

        default:
          return Promise.resolve();
      }
    }
  }, {
    key: 'commandIndexByLabel',
    value: function commandIndexByLabel(labelName) {
      var label = this.state.labels[normalizeLabelName(labelName)];

      if (!label) {
        throw new Error('label \'' + labelName + '\' doesn\'t exist');
      }

      return label.index;
    }
  }, {
    key: 'backupState',
    value: function backupState() {
      return Object(ts_utils["clone"])(this.state);
    }
  }, {
    key: 'restoreState',
    value: function restoreState(state) {
      this.__setState(state);
    }
  }, {
    key: 'getKeyForTimes',
    value: function getKeyForTimes(commandIndex) {
      return 'times_' + commandIndex;
    }
  }, {
    key: 'getKeyForSurroundingTimes',
    value: function getKeyForSurroundingTimes(timesCommandIndex) {
      var _this4 = this;

      var tagIndex = this.state.tags.findIndex(function (tag) {
        return (/^(times)/.test(tag.type) && tag.start.index === timesCommandIndex
        );
      });

      if (tagIndex === -1) {
        return null;
      }

      var currentTimesTag = this.state.tags[tagIndex];
      var surroundingTimesTag = function () {
        for (var i = tagIndex; i < _this4.state.tags.length; i++) {
          var tag = _this4.state.tags[i];

          if (tag.type === 'times' && tag.start.index < currentTimesTag.start.index && tag.end.index > currentTimesTag.end.index) {
            return tag;
          }
        }

        return null;
      }();

      if (!surroundingTimesTag) {
        return null;
      }

      return this.getKeyForTimes(surroundingTimesTag.start.index);
    }
  }, {
    key: 'getExtraByKey',
    value: function getExtraByKey(key) {
      return this.state.extra[key];
    }
  }, {
    key: 'setExtraByKey',
    value: function setExtraByKey(key, value) {
      this.state.extra[key] = value;
    }
  }, {
    key: 'updateExtraByKey',
    value: function updateExtraByKey(key, updater) {
      this.setExtraByKey(key, updater(this.getExtraByKey[key]));
    }
  }, {
    key: 'removeExtraByKey',
    value: function removeExtraByKey(key) {
      delete this.state.extra[key];
    }
  }, {
    key: '__setState',
    value: function __setState(st) {
      this.state = interpreter_extends({}, this.state, st);
    }
  }]);

  return Interpreter;
}();

interpreter_Interpreter.DefaultState = {
  labels: {},
  tags: [],
  commands: [],
  // Any data specific to any command, for example, `times` and `forEach` uses it to store loop cursor
  extra: {}
};
/* harmony default export */ var common_interpreter = (interpreter_Interpreter);
// EXTERNAL MODULE: ./node_modules/csv/lib/index.js
var lib = __webpack_require__(534);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);

// CONCATENATED MODULE: ./src/common/csv.js


var csvDataURI = function csvDataURI(csvStr) {
  return 'data:text/csv;base64,' + window.btoa(unescape(encodeURIComponent(csvStr)));
};

function parseFromCSV(text) {
  return new Promise(function (resolve, reject) {
    lib_default.a.parse(text, function (err, data) {
      if (err) return reject(err);
      return resolve(data);
    });
  });
}

function stringifyToCSV(list) {
  return new Promise(function (resolve, reject) {
    lib_default.a.stringify(list, function (err, data) {
      if (err) return reject(err);
      return resolve(data);
    });
  });
}

function toCsvDataURI(list) {
  return stringifyToCSV(list).then(csvDataURI);
}
// EXTERNAL MODULE: ./src/common/log.ts
var common_log = __webpack_require__(11);
var log_default = /*#__PURE__*/__webpack_require__.n(common_log);

// EXTERNAL MODULE: ./src/common/macro_log.ts
var macro_log = __webpack_require__(161);

// EXTERNAL MODULE: ./src/common/command_runner.js + 2 modules
var command_runner = __webpack_require__(100);

// EXTERNAL MODULE: ./src/services/xy/index.ts
var xy = __webpack_require__(58);

// EXTERNAL MODULE: ./src/services/desktop/index.ts
var desktop = __webpack_require__(91);

// EXTERNAL MODULE: ./src/services/ocr/index.ts
var ocr = __webpack_require__(106);

// EXTERNAL MODULE: ./src/services/storage/flat/storage.ts
var flat_storage = __webpack_require__(76);

// EXTERNAL MODULE: ./src/services/ocr/types.ts
var types = __webpack_require__(112);

// EXTERNAL MODULE: ./src/common/counter/counter.ts
var counter = __webpack_require__(404);

// EXTERNAL MODULE: ./src/services/ocr/command_counter.ts
var command_counter = __webpack_require__(330);

// EXTERNAL MODULE: ./src/services/ocr/endpoint_picker.ts
var endpoint_picker = __webpack_require__(197);

// EXTERNAL MODULE: ./src/components/prompt.tsx
var components_prompt = __webpack_require__(187);

// EXTERNAL MODULE: ./src/desktop_screenshot_editor/types.ts
var desktop_screenshot_editor_types = __webpack_require__(87);

// EXTERNAL MODULE: ./src/services/player/call_stack/call_stack.ts
var call_stack = __webpack_require__(115);

// EXTERNAL MODULE: ./src/services/player/macro.ts
var player_macro = __webpack_require__(191);

// EXTERNAL MODULE: ./src/services/player/call_stack/types.ts
var call_stack_types = __webpack_require__(402);

// EXTERNAL MODULE: ./src/services/player/monitor/macro_monitor.ts
var macro_monitor = __webpack_require__(96);

// EXTERNAL MODULE: ./src/services/player/monitor/types.ts
var monitor_types = __webpack_require__(95);

// EXTERNAL MODULE: ./src/common/command.ts
var common_command = __webpack_require__(43);

// EXTERNAL MODULE: ./src/services/filesystem/index.ts
var filesystem = __webpack_require__(60);

// EXTERNAL MODULE: ./src/services/proxy/index.ts
var services_proxy = __webpack_require__(146);

// EXTERNAL MODULE: ./src/services/proxy/types.ts
var proxy_types = __webpack_require__(157);

// EXTERNAL MODULE: ./src/services/kv_data/macro_extra_data.ts
var macro_extra_data = __webpack_require__(105);

// EXTERNAL MODULE: ./src/common/dom_utils.ts
var dom_utils = __webpack_require__(22);

// EXTERNAL MODULE: ./src/common/encrypt.js
var encrypt = __webpack_require__(136);

// EXTERNAL MODULE: ./src/services/license/index.ts
var services_license = __webpack_require__(30);

// CONCATENATED MODULE: ./src/init_player.js



var init_player_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var init_player_slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var init_player_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function init_player_toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function init_player_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function init_player_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

















































var TimeTracker = function () {
  function TimeTracker() {
    init_player_classCallCheck(this, TimeTracker);

    this.reset();
  }

  init_player_createClass(TimeTracker, [{
    key: 'reset',
    value: function reset() {
      this.startTime = new Date();
    }
  }, {
    key: 'elapsed',
    value: function elapsed() {
      return new Date() - this.startTime;
    }
  }, {
    key: 'elapsedInSeconds',
    value: function elapsedInSeconds() {
      var diff = this.elapsed();
      return (diff / 1000).toFixed(2) + 's';
    }
  }]);

  return TimeTracker;
}();

var init_player_setProxy = function setProxy(proxy) {
  return ipc_cs["default"].ask('PANEL_SET_PROXY', { proxy: proxy });
};

var replaceEscapedChar = function replaceEscapedChar(str, command, field) {
  var shouldEscape = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  if (!shouldEscape) {
    return str;
  }

  if (['csvRead', 'csvReadArray', 'csvSave', 'gotoIf', 'if', 'while', 'gotoIf_v2', 'if_v2', 'while_v2', 'XType', 'elseif', 'repeatIf', 'executeScript', 'executeScript_Sandbox', 'executeAsyncScript', 'executeAsyncScript_Sandbox'].indexOf(command.cmd) !== -1 && field === 'target') {
    return str;
  }

  if (['csvSaveArray'].indexOf(command.cmd) !== -1 && field === 'value') {
    return str;
  }

  if (['XRun', 'XRunAndWait'].indexOf(command.cmd) !== -1) {
    return str;
  }

  return [[/\\n/g, '\n'], [/\\t/g, '\t'], [/\\b/g, '\b'], [/\\f/g, '\f'], [/\\t/g, '\t'], [/\\v/g, '\v']].reduce(function (prev, _ref) {
    var _ref2 = init_player_slicedToArray(_ref, 2),
        reg = _ref2[0],
        c = _ref2[1];

    return prev.replace(reg, c);
  }, str);
};

var init_player_retryIfHeartBeatExpired = function retryIfHeartBeatExpired(mainFunc, command) {
  var isOpen = command.cmd === 'open';
  var isSelectWindowTabOpen =  true && /^\s*tab=open\s*$/i.test(command.target);
  var shouldNotCheckHeartBeat = isOpen || isSelectWindowTabOpen;
  var runWithHeartBeat = function runWithHeartBeat() {
    var stop = false;

    var infiniteCheckHeartBeat = function () {
      var startTime = new Date().getTime();
      var stop = false;
      var lastSecret = null;

      var fn = function fn() {
        if (shouldNotCheckHeartBeat) {
          return new Promise(function () {});
        }

        log_default()('start to send heart beat to background');
        if (stop) return Promise.resolve();

        return ipc_cs["default"].ask('PANEL_HEART_BEAT', {}, 300).then(function (secret) {
          // Note: secret === -1 means no heart beat available
          if (secret === -1) return new Promise(function () {});

          if (secret === lastSecret) {
            throw new Error('lost background heart beat when running command');
          } else {
            lastSecret = secret;
          }

          return Object(utils["delay"])(function () {}, 3000).then(fn);
        }, function (e) {
          log_default.a.error('lost background heart beart!!', e.stack);
          throw new Error('lost background heart beat when running command');
        });
      };
      fn.stop = function () {
        log_default()('stopping background heart beat');
        stop = true;
      };

      return fn;
    }();

    return Promise.race([mainFunc().then(function (data) {
      infiniteCheckHeartBeat.stop();
      return data;
    }).catch(function (e) {
      infiniteCheckHeartBeat.stop();
      throw e;
    }), infiniteCheckHeartBeat()]);
  };

  var retryFn = Object(utils["retry"])(runWithHeartBeat, {
    timeout: 999999,
    shouldRetry: function shouldRetry(e, retryCount) {
      return e && e.message && e.message.indexOf('lost background heart beat when running command') !== -1 && retryCount < 10;
    },
    retryInterval: function retryInterval(retryCount, lastRetryInterval) {
      return Math.max(5 * 1000, Math.min(20 * 1000, lastRetryInterval * 1.2));
    }
  });

  return retryFn();
};

var init_player_getOcrResponse = function getOcrResponse(_ref3) {
  var searchArea = _ref3.searchArea,
      storedImageRect = _ref3.storedImageRect,
      ocrApiTimeout = _ref3.ocrApiTimeout,
      store = _ref3.store,
      lang = _ref3.lang,
      engine = _ref3.engine,
      scale = _ref3.scale,
      isTable = _ref3.isTable,
      isDesktop = _ref3.isDesktop;

  var ocrScale = scale;

  return new Promise(function (resolve, reject) {
    // Note: must make sure `getOcrCommandCounter` is called with args before this (currently it's in `initPlayer`)
    var ocrCmdCounter = Object(command_counter["getOcrCommandCounter"])();
    var getApiAndKey = function getApiAndKey() {
      var _store$getState$confi = store.getState().config,
          ocrMode = _store$getState$confi.ocrMode,
          ocrOfflineURL = _store$getState$confi.ocrOfflineURL,
          ocrOfflineAPIKey = _store$getState$confi.ocrOfflineAPIKey;


      switch (ocrMode) {
        case 'enabled':
          {
            return Object(endpoint_picker["getOcrEndpointPicker"])().bestPick();
          }

        case 'offline_enabled':
          {
            if (!/^https?:\/\//.test(ocrOfflineURL)) {
              throw new Error('Please set local OCR API first');
            }

            if (!ocrOfflineAPIKey || !ocrOfflineAPIKey.length) {
              throw new Error('Please set local OCR API key first');
            }

            return Promise.resolve({
              url: ocrOfflineURL,
              key: ocrOfflineAPIKey
            });
          }

        default:
          {
            throw new Error('Please enable OCR first');
          }
      }
    };
    var prepare = function () {
      // If version is not free version and the user reaches the 100th online OCR conversions,
      // then - before making the 101 conversion - call the API for a license check.
      // Of course, only if we've cached the license key and previous license check result
      if (Object(services_license["getLicenseService"])().hasNoLicense() || ocrCmdCounter.get() !== config_default.a.xmodulesLimit.unregistered.ocrCommandCount) {
        return Promise.resolve();
      }

      return Object(services_license["getLicenseService"])().recheckLicenseIfPossible().then(function () {
        var isExpired = Object(services_license["getLicenseService"])().isLicenseExpired();

        if (isExpired) {
          throw new Error('Activation check failed. Reset to free edition. If you believe this was an error, please contact tech support');
        }
      });
    }();

    return prepare.then(function () {
      return isDesktop ? Promise.resolve() : ipc_cs["default"].ask('PANEL_CLEAR_OCR_MATCHES_ON_PLAYING_PAGE');
    })
    // Note: add 1s delay here to make sure old OCR overlayed are cleared before taking new screenshot
    .then(function () {
      return Object(utils["delay"])(function () {}, 1000);
    }).then(function () {
      return ipc_cs["default"].ask('PANEL_CAPTURE_IMAGE', {
        isDesktop: isDesktop,
        storedImageRect: storedImageRect,
        searchArea: /\.png/i.test(searchArea) ? 'rect' : searchArea,
        scaleDpi: true
      });
    }).then(function (_ref4) {
      var dataUrl = _ref4.dataUrl,
          offset = _ref4.offset,
          viewportOffset = _ref4.viewportOffset,
          _ref4$scale = _ref4.scale,
          scale = _ref4$scale === undefined ? 1 : _ref4$scale;

      var blob = Object(utils["dataURItoBlob"])(dataUrl);
      var fileSize = Object(flat_storage["readableSize"])(blob.size);
      var startTime = new Date() * 1;
      var getDuration = function getDuration(startTime, endTime) {
        return ((endTime - startTime) / 1000).toFixed(1) + 's';
      };
      var cancelCountDown = Object(ts_utils["countDown"])({
        interval: 1000,
        timeout: ocrApiTimeout,
        onTick: function onTick(_ref5) {
          var past = _ref5.past,
              total = _ref5.total;

          store.dispatch(actions["setTimeoutStatus"]({
            past: past,
            total: total,
            type: 'OCR in progress'
          }));
        }
      });

      // Note: check in advance so that it throws error before making OCR requests
      ocrCmdCounter.check();
      store.dispatch(actions["addLog"]('info', 'OCR (' + lang + ') started (' + fileSize + ')'));

      return Object(ocr["runOCR"])({
        engine: engine,
        isTable: isTable,
        scale: ocrScale,
        image: dataUrl,
        language: lang,
        totalTimeout: ocrApiTimeout,
        singleApiTimeout: config_default.a.ocr.singleApiTimeout,
        isOverlayRequired: true,
        getApiUrlAndApiKey: function getApiUrlAndApiKey() {
          return getApiAndKey().then(function (data) {
            //  store.dispatch(act.addLog('info', `OCR request is sent to ${data.url}`))
            return data;
          });
        },
        shouldRetry: function shouldRetry() {
          var ocrMode = store.getState().config.ocrMode;


          switch (ocrMode) {
            case 'enabled':
              return Object(endpoint_picker["getOcrEndpointPicker"])().isAllDown().then(function (down) {
                return !down;
              });

            case 'offline_enabled':
            case 'disabled':
              return false;
          }
        },
        didGetResponse: function didGetResponse(data) {
          var server = data.server,
              startTime = data.startTime,
              endTime = data.endTime,
              response = data.response,
              error = data.error;

          var id = server.id || server.url;

          return Object(endpoint_picker["getOcrEndpointPicker"])().validServers().then(function (result) {
            // It hasn't marked current api, so it's safer to tell we have next to try if there are gte 2 servers.
            var hasNextToTry = result.servers.length >= 2;

            if (response) {
              store.dispatch(actions["addLog"]('info', 'OCR result received (' + getDuration(startTime, endTime) + ' from endpoint ' + id + ')'));
            } else if (error) {
              store.dispatch(actions["addLog"]('warning', 'Error in OCR endpoint ' + id + ' after ' + getDuration(startTime, endTime) + ': ' + error.message + (hasNextToTry ? ' - trying next.' : '')));
            }

            if (id && response) {
              Object(endpoint_picker["getOcrEndpointPicker"])().use(id);
            }

            if (!id) return Promise.resolve();
            // Note: only mark server as error if browser is online
            if (!window.navigator.onLine) return Promise.resolve();

            return Object(endpoint_picker["getOcrEndpointPicker"])().report(id, {
              lastError: error,
              lastOcrExitCode: response ? response.OCRExitCode : undefined,
              lastRequestTimestamp: startTime,
              lastResponseTimestamp: endTime,
              lastTotalMilliseconds: endTime - startTime
            }).then(function () {});
          });
        }
      }).then(function (data) {
        cancelCountDown();

        // Don't increase ocr counter if it's a local ocr requests
        if (store.getState().config.ocrMode === 'enabled') {
          ocrCmdCounter.inc();
        }

        return {
          offset: offset,
          viewportOffset: viewportOffset,
          response: Object(ocr["scaleOcrResponseCoordinates"])(data, scale)
        };
      }, function (e) {
        cancelCountDown();

        if (/All OCR servers are down/i.test(e.message)) {
          Object(endpoint_picker["getOcrEndpointPicker"])().reset();
        }

        throw e;
      });
    }).then(resolve, reject);
  });
};

var init_player_ocrViewport = function ocrViewport(_ref6) {
  var store = _ref6.store,
      isDesktop = _ref6.isDesktop;

  var clearBadge = function clearBadge() {
    return ipc_cs["default"].ask('PANEL_UPDATE_BADGE', { type: 'play', clear: true });
  };

  return init_player_getOcrResponse({
    store: store,
    isDesktop: isDesktop,
    lang: store.getState().config.ocrLanguage,
    engine: store.getState().config.ocrEngine,
    scale: 'true',
    searchArea: 'viewport',
    storedImageRect: null,
    ocrApiTimeout: config_default.a.ocr.apiTimeout
  }).then(function (_ref7) {
    var response = _ref7.response,
        offset = _ref7.offset,
        viewportOffset = _ref7.viewportOffset;

    var documentBasedParseResults = Object(ts_utils["safeUpdateIn"])(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
      return init_player_extends({}, word, {
        Top: word.Top + offset.y,
        Left: word.Left + offset.x
      });
    }, response.ParsedResults);

    var ocrMatches = [
    // All words identified by OCR into one group
    {
      similarity: 1,
      highlight: types["OcrHighlightType"].Matched,
      words: Object(ocr["allWordsWithPosition"])(documentBasedParseResults, [])
    }];

    // show overlay on website
    return ipc_cs["default"].ask('PANEL_HIGHLIGHT_OCR_MATCHES', { ocrMatches: ocrMatches, isDesktop: isDesktop });
  }).then(function () {
    clearBadge();
  }, function (e) {
    clearBadge();
    throw e;
  });
};

var init_player_withVisualHighlightHidden = function withVisualHighlightHidden(fn) {
  var hide = function hide() {
    return ipc_cs["default"].ask('PANEL_HIDE_VISION_HIGHLIGHT').catch(function () {});
  };
  var show = function show() {
    return ipc_cs["default"].ask('PANEL_SHOW_VISION_HIGHLIGHT').catch(function () {});
  };

  return hide().then(function () {
    return fn();
  }).then(function (data) {
    show();
    return data;
  }, function (e) {
    show();
    throw e;
  });
};

var init_player_hideDownloadBar = function hideDownloadBar() {
  return ipc_cs["default"].ask('PANEL_DISABLE_DOWNLOAD_BAR', {}).catch(function (e) {
    return true;
  });
};
var init_player_showDownloadbar = function showDownloadbar() {
  return ipc_cs["default"].ask('PANEL_ENABLE_DOWNLOAD_BAR', {}).catch(function (e) {
    return true;
  });
};
var showDownloadBarFinally = function showDownloadBarFinally(hasXCommand, fn) {
  return Promise.resolve(fn()).then(function (data) {
    if (!hasXCommand()) {
      return data;
    }

    return init_player_showDownloadbar().then(function () {
      return data;
    });
  }, function (e) {
    if (!hasXCommand()) {
      return Promise.reject(e);
    }

    return init_player_showDownloadbar().then(function () {
      return Promise.reject(e);
    });
  });
};

var interpretSpecialCommands = function interpretSpecialCommands(_ref8) {
  var store = _ref8.store,
      vars = _ref8.vars,
      getTcPlayer = _ref8.getTcPlayer,
      getInterpreter = _ref8.getInterpreter,
      xCmdCounter = _ref8.xCmdCounter;

  var commandRunners = [init_player_interpretCSVCommands({ store: store, vars: vars, getTcPlayer: getTcPlayer, getInterpreter: getInterpreter, xCmdCounter: xCmdCounter }), init_player_interpretCsFreeCommands({ store: store, vars: vars, getTcPlayer: getTcPlayer, getInterpreter: getInterpreter, xCmdCounter: xCmdCounter })];

  return function (command, index) {
    return commandRunners.reduce(function (prev, cur) {
      if (prev !== undefined) return prev;
      return cur(command, index);
    }, undefined);
  };
};

var init_player_interpretCsFreeCommands = function interpretCsFreeCommands(_ref9) {
  var store = _ref9.store,
      vars = _ref9.vars,
      getTcPlayer = _ref9.getTcPlayer,
      getInterpreter = _ref9.getInterpreter,
      xCmdCounter = _ref9.xCmdCounter;

  var runCsFreeCommands = function runCsFreeCommands(command, index) {
    var csvStorage = Object(storage["getStorageManager"])().getCSVStorage();
    var ssStorage = Object(storage["getStorageManager"])().getScreenshotStorage();
    var macroStorage = Object(storage["getStorageManager"])().getMacroStorage();
    var path = macroStorage.getPathLib();
    var cmd = command.cmd,
        target = command.target,
        value = command.value,
        extra = command.extra;

    var result = {
      isFlowLogic: true
    };
    var runCommand = function runCommand(command) {
      return init_player_askBackgroundToRunCommand({
        vars: vars,
        store: store,
        command: command,
        state: getTcPlayer().getState(),
        preRun: function preRun(command, state, askBgToRun) {
          return askBgToRun(command);
        }
      });
    };
    var guardOcrSettings = function guardOcrSettings() {
      if (store.getState().config.ocrMode === 'disabled') {
        throw new Error('OCR feature disabled.');
      }
    };

    log_default()('interpretCsFreeCommands', command);

    var playerState = getTcPlayer().getState();
    var curMacroRelativePath = Object(storage["getStorageManager"])().getMacroStorage().relativePath(playerState.extra.macroId);
    var curMacroDirPath = path.dirname(curMacroRelativePath);
    var resolvePath = function resolvePath(subpath) {
      subpath = subpath.replace(/\\/g, '/');

      if (subpath.indexOf('/') === 0) {
        return path.normalize(subpath).replace(/^(\/|\\)/, '');
      } else {
        return path.join(curMacroDirPath, subpath);
      }
    };

    switch (cmd) {
      case 'repeatIf':
      case 'elseif':
      case 'if_v2':
      case 'while_v2':
      case 'gotoIf_v2':
        {
          log_default()('Executing ' + cmd + ': ' + target);

          try {
            return {
              // eslint-disable-next-line no-eval
              condition: window.eval(target),
              byPass: true
            };
          } catch (e) {
            throw new Error('Error in condition of ' + cmd + ': ' + e.message);
          }
        }

      case 'times':
        {
          var interpreter = getInterpreter();
          var timesKey = interpreter.getKeyForTimes(index);
          var cursor = 1 + (interpreter.getExtraByKey(timesKey) || 0);
          var max = parseInt(target, 10);

          if (isNaN(max)) {
            throw new Error('target must be a positive number');
          }

          if (max < 1) {
            return {
              condition: false,
              byPass: true
            };
          }

          var shouldContinue = cursor <= max;

          if (shouldContinue) {
            interpreter.setExtraByKey(timesKey, cursor);
            vars.set({ '!TIMES': cursor }, true);
          } else {
            interpreter.removeExtraByKey(timesKey);

            var key = interpreter.getKeyForSurroundingTimes(index);
            var nextCursor = interpreter.getExtraByKey(key);

            if (nextCursor !== undefined) {
              vars.set({ '!TIMES': nextCursor }, true);
            } else {
              vars.set({ '!TIMES': cursor }, true);
            }
          }

          return {
            condition: shouldContinue,
            byPass: true
          };
        }

      case 'forEach':
        {
          var _interpreter = getInterpreter();
          var forEachKey = 'forEach_' + index;
          var current = _interpreter.getExtraByKey(forEachKey);
          var _cursor = 1 + (current === undefined ? -1 : current);
          var list = vars.get(target);

          if (!Array.isArray(list)) {
            throw new Error('target must be an array');
          }

          var len = list.length;
          var _shouldContinue = _cursor < len;
          var varsToSet = _shouldContinue ? init_player_defineProperty({}, value, list[_cursor]) : null;

          vars.set({
            '!FOREACH': _cursor
          }, true);

          if (!_shouldContinue) {
            _interpreter.removeExtraByKey(forEachKey);
          } else {
            _interpreter.setExtraByKey(forEachKey, _cursor);
          }

          return {
            vars: varsToSet,
            condition: _shouldContinue,
            byPass: true
          };
        }

      case 'assert':
      case 'verify':
        {
          var isAssert = cmd === 'assert';
          var varName = target;

          if (!varName || !varName.length) {
            throw new Error(cmd + ': target is required as variable name');
          }

          var actualString = '' + vars.get(varName);
          var expectedString = '' + value;

          if (actualString === expectedString) {
            return { byPass: true };
          }

          var _message = 'Expected variable ' + varName + ' to be ' + expectedString + ', but it is ' + actualString;

          if (isAssert) {
            throw new Error(_message);
          }

          return {
            byPass: true,
            log: {
              error: _message
            }
          };
        }

      case 'executeScript_Sandbox':
        {
          try {
            var code = ';(function () { ' + target + ' })();';
            // eslint-disable-next-line no-eval
            var _result = window.eval(code);

            if (value && value.length) {
              return {
                byPass: true,
                vars: init_player_defineProperty({}, value, _result)
              };
            }

            return {
              byPass: true
            };
          } catch (e) {
            throw new Error('Error in executeScript_Sandbox code: ' + e.message);
          }
        }

      case 'executeAsyncScript_Sandbox':
        {
          try {
            var _code = 'Promise.resolve((function () { ' + target + ' })());';
            // eslint-disable-next-line no-eval
            var p = window.eval(_code);

            return p.then(function (result) {
              if (value && value.length) {
                return {
                  byPass: true,
                  vars: init_player_defineProperty({}, value, result)
                };
              }

              return {
                byPass: true
              };
            });
          } catch (e) {
            throw new Error('Error in executeScriptAsync_Sandbox code: ' + e.message);
          }
        }

      case 'setProxy':
        {
          var _p = function () {
            if (/direct/i.test(target && target.trim())) {
              return init_player_setProxy(null).then(function () {
                return store.dispatch(actions["addLog"]('info', 'Proxy reset to none'));
              });
            }

            var _ref11 = function () {
              if (/default/i.test(target && target.trim())) {
                return [store.getState().config.defaultProxy, store.getState().config.defaultProxyAuth];
              }
              return [target, value];
            }(),
                _ref12 = init_player_slicedToArray(_ref11, 2),
                proxyUrl = _ref12[0],
                auth = _ref12[1];

            var proxy = Object(services_proxy["parseProxyUrl"])(proxyUrl, auth);
            var isSocks = proxy.type === proxy_types["ProxyScheme"].Socks4 || proxy.type === proxy_types["ProxyScheme"].Socks5;
            var hasAuth = !!proxy.username;

            if (isSocks && hasAuth && !Object(dom_utils["isFirefox"])()) {
              store.dispatch(actions["addLog"]('warning', 'Browser doesn\'t support authentication on socks proxy'));
            }

            return init_player_setProxy(proxy).then(function () {
              vars.set({
                '!PROXY_EXEC_COUNT': 1 + (vars.get('!PROXY_EXEC_COUNT') || 0)
              }, true);

              store.dispatch(actions["addLog"]('info', 'Proxy set to ' + proxyUrl));
            });
          }();

          return _p.then(function () {
            return { byPass: true };
          });
        }

      case 'run':
        {
          var state = store.getState();
          var macroRelativePath = resolvePath(target);
          var macroNode = Object(recomputed["findMacroNodeWithCaseInsensitiveRelativePath"])(state, macroRelativePath);
          var _macroStorage = Object(storage["getStorageManager"])().getMacroStorage();

          return _macroStorage.read(macroNode && macroNode.fullPath || macroRelativePath, 'Text').then(function (macro) {
            var openCmd = macro.data.commands.find(function (command) {
              return command.cmd.toLowerCase() === 'open';
            });
            var playerState = actions["commonPlayerState"](store.getState(), {
              extra: {
                id: macro.id
              },
              mode: Object(common_player["b" /* getPlayer */])().C.MODE.STRAIGHT,
              startIndex: 0,
              startUrl: openCmd ? openCmd.target : null,
              resources: macro.data.commands,
              postDelay: state.config.playCommandInterval * 1000,
              isStep: Object(common_player["b" /* getPlayer */])().getState().isStep,
              loopsCursor: 1,
              loopsStart: 1,
              loopsEnd: 1
            }, macro.id, macro.name);

            return Object(utils["delay"])(function () {}, 500).then(function () {
              return Object(call_stack["getMacroCallStack"])().call(macro, {
                playerState: playerState,
                status: player_macro["MacroStatus"].Running,
                nextIndex: 0,
                commandResults: []
              });
            }).then(function () {
              store.dispatch(actions["updateMacroPlayStatus"](macro.id, macro_extra_data["MacroResultStatus"].Success));

              return {
                byPass: true
              };
            });
          });
        }

      case 'store':
        {
          return {
            byPass: true,
            vars: init_player_defineProperty({}, value, target)
          };
        }

      case 'echo':
        {
          var _extra = function () {
            if (value === '#shownotification') return { options: { notification: true } };
            if (value) return { options: { color: value } };
            return {};
          }();

          return {
            byPass: true,
            log: init_player_extends({
              info: target
            }, _extra)
          };
        }

      case 'prompt':
        {
          var _target$match = target.match(/^([^@]+)(?:@(.+))?$/),
              _target$match2 = init_player_slicedToArray(_target$match, 3),
              _ = _target$match2[0],
              _message2 = _target$match2[1],
              defaultAnswer = _target$match2[2];

          return ipc_cs["default"].ask('PANEL_BRING_PANEL_TO_FOREGROUND').then(function () {
            return Object(components_prompt["prompt"])({ message: _message2, value: defaultAnswer || '' });
          }).then(function (text) {
            return {
              byPass: true,
              vars: init_player_defineProperty({}, value, text)
            };
          });
        }

      case 'throwError':
        {
          throw new Error(target);
        }

      case 'pause':
        {
          var n = parseInt(target);

          if (!target || !target.length || n === 0) {
            return {
              byPass: true,
              control: {
                type: 'pause'
              }
            };
          }

          if (isNaN(n) || n < 0) {
            throw new Error('target of pause command must be a positive integer');
          }

          var currentPlayUID = getTcPlayer().getPlayUID();

          return Object(ts_utils["withCountDown"])({
            timeout: n,
            interval: 1000,
            onTick: function onTick(_ref13) {
              var total = _ref13.total,
                  past = _ref13.past,
                  cancel = _ref13.cancel;

              if (store.getState().player.status !== constant["PLAYER_STATUS"].PLAYING) {
                return cancel();
              }

              if (!getTcPlayer().checkPlayUID(currentPlayUID)) {
                return cancel();
              }

              store.dispatch(actions["setTimeoutStatus"]({
                past: past,
                total: total,
                type: 'pause'
              }));
            }
          }).then(function () {
            return { byPass: true };
          });
        }

      case 'localStorageExport':
        {
          var deleteAfterExport = /\s*#DeleteAfterExport\s*/i.test(value);

          if (/^\s*log\s*$/i.test(target)) {
            var text = store.getState().logs.map(macro_log["renderLog"]).join('\n');
            file_saver_default.a.saveAs(new Blob([text]), 'uivision_log.txt');

            if (deleteAfterExport) {
              store.dispatch(actions["clearLogs"]());
            }

            return result;
          }

          if (/\.csv$/i.test(target)) {
            return csvStorage.exists(target).then(function (existed) {
              if (!existed) throw new Error(target + ' doesn\'t exist');

              return csvStorage.read(target, 'Text').then(function (text) {
                file_saver_default.a.saveAs(new Blob([text]), target);

                if (deleteAfterExport) {
                  csvStorage.remove(target).then(function () {
                    return store.dispatch(actions["listCSV"]());
                  });
                }

                return result;
              });
            });
          }

          if (/\.png$/i.test(target)) {
            return ssStorage.exists(target).then(function (existed) {
              if (!existed) throw new Error(target + ' doesn\'t exist');

              return ssStorage.read(target, 'ArrayBuffer').then(function (buffer) {
                file_saver_default.a.saveAs(new Blob([new Uint8Array(buffer)]), target);

                if (deleteAfterExport) {
                  ssStorage.remove(target).then(function () {
                    return store.dispatch(actions["listScreenshots"]());
                  });
                }

                return result;
              });
            });
          }

          throw new Error(target + ' doesn\'t exist');
        }

      case 'OCRSearch':
        {
          guardOcrSettings();

          if (!value || !value.length) {
            throw new Error('value is required');
          }

          var lang = vars.get('!ocrLanguage').toLowerCase();
          var engine = vars.get('!ocrEngine');
          var scale = vars.get('!ocrScale');
          var isTable = vars.get('!ocrTableExtraction');
          var searchArea = vars.get('!visualSearchArea');
          var storedImageRect = vars.get('!storedImageRect');
          var ocrApiTimeout = config_default.a.ocr.apiTimeout;

          var _ref14 = function () {
            var match = target.match(/^(.+)@POS=(\d+)$/i);
            if (!match) return [target, 0, false];
            return [match[1], parseInt(match[2]) - 1, true];
          }(),
              _ref15 = init_player_slicedToArray(_ref14, 3),
              str = _ref15[0],
              _index = _ref15[1],
              hasPos = _ref15[2];

          var run = function run() {
            return init_player_getOcrResponse({
              store: store,
              lang: lang,
              scale: scale,
              engine: engine,
              isTable: isTable,
              searchArea: searchArea,
              storedImageRect: storedImageRect,
              ocrApiTimeout: ocrApiTimeout,
              isDesktop: Object(cv_utils["isCVTypeForDesktop"])(vars.get('!CVSCOPE'))
            }).then(function (_ref16) {
              var response = _ref16.response,
                  offset = _ref16.offset,
                  viewportOffset = _ref16.viewportOffset;

              var viewportBasedParseResults = Object(ts_utils["safeUpdateIn"])(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
                return init_player_extends({}, word, {
                  Top: word.Top + viewportOffset.y,
                  Left: word.Left + viewportOffset.x
                });
              }, response.ParsedResults);
              var documentBasedParseResults = Object(ts_utils["safeUpdateIn"])(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
                return init_player_extends({}, word, {
                  Top: word.Top + offset.y,
                  Left: word.Left + offset.x
                });
              }, response.ParsedResults);
              var searchResult = Object(ocr["searchTextInOCRResponse"])({
                text: str,
                index: _index,
                exhaust: true,
                parsedResults: viewportBasedParseResults
              });
              var hit = searchResult.hit,
                  all = searchResult.all;

              var newVars = function () {
                if (!hit) {
                  var _ref17;

                  return _ref17 = {}, init_player_defineProperty(_ref17, value, 0), init_player_defineProperty(_ref17, '!ocrx', 0), init_player_defineProperty(_ref17, '!ocry', 0), _ref17;
                } else {
                  var _ref18;

                  var center = Object(ocr["ocrMatchCenter"])(hit);

                  // Note: when '@POS=xx' is used, the possible values are only 0 and 1
                  return _ref18 = {}, init_player_defineProperty(_ref18, value, hasPos ? 1 : all.length), init_player_defineProperty(_ref18, '!ocrx', center.x), init_player_defineProperty(_ref18, '!ocry', center.y), _ref18;
                }
              }();

              var ocrMatches = [
              // All words identified by OCR into one group
              {
                similarity: 1,
                highlight: types["OcrHighlightType"].Identified,
                words: Object(ocr["allWordsWithPosition"])(documentBasedParseResults, Object(ts_utils["flatten"])(all.map(function (item) {
                  return item.words.map(function (word) {
                    return word.position;
                  });
                })))
              }].concat(init_player_toConsumableArray(Object(ts_utils["compose"])(all[_index] ? Object(utils["setIn"])([_index, 'highlight'], types["OcrHighlightType"].TopMatched) : function (x) {
                return x;
              }, Object(utils["setIn"])(['[]', 'highlight'], types["OcrHighlightType"].Matched), Object(utils["updateIn"])(['[]', 'words', '[]', 'word'], function (word) {
                return init_player_extends({}, word, {
                  Top: word.Top + offset.y - viewportOffset.y,
                  Left: word.Left + offset.x + viewportOffset.x
                });
              }))(all)));

              if (extra && extra.debugVisual) {
                // show overlay on website
                ipc_cs["default"].ask('PANEL_HIGHLIGHT_OCR_MATCHES', {
                  ocrMatches: ocrMatches,
                  isDesktop: Object(cv_utils["isCVTypeForDesktop"])(vars.get('!CVSCOPE'))
                });
              }

              var pScaleFactor = Object(cv_utils["isCVTypeForDesktop"])(vars.get('!CVSCOPE')) ? Object(xy["getNativeXYAPI"])().getScalingFactor() : Promise.resolve(1);

              // Note: In desktop mode, `!ocrx`, `!ocry` and `best` should be desktop coordinates
              return pScaleFactor.then(function (factor) {
                return Object(ts_utils["compose"])(newVars['!ocrx'] === undefined ? ts_utils["id"] : Object(ts_utils["safeUpdateIn"])(['vars', '!ocrx'], function (n) {
                  return n * factor;
                }), newVars['!ocry'] === undefined ? ts_utils["id"] : Object(ts_utils["safeUpdateIn"])(['vars', '!ocry'], function (n) {
                  return n * factor;
                }), Object(ts_utils["safeUpdateIn"])(['best'], function (match) {
                  return match && match.similarity ? Object(ocr["scaleOcrTextSearchMatch"])(match, factor) : null;
                }))({
                  vars: newVars,
                  byPass: true,
                  best: hit
                });
              });
            });
          };

          return run();
        }

      case 'OCRExtract':
      case 'OCRExtractRelative':
        {
          guardOcrSettings();

          if (!value || !value.length) {
            throw new Error('value is required');
          }

          var _lang = vars.get('!ocrLanguage').toLowerCase();
          var _engine = vars.get('!ocrEngine');
          var _scale = vars.get('!ocrScale');
          var _isTable = vars.get('!ocrTableExtraction');
          var _ocrApiTimeout = config_default.a.ocr.apiTimeout;
          var isRelative = /relative/i.test(cmd);

          return ipc_cs["default"].ask('PANEL_CLEAR_OCR_MATCHES_ON_PLAYING_PAGE').catch(function () {}).then(function () {
            return Object(utils["delay"])(function () {}, 1000);
          }).then(function () {
            return Promise.all([runCsFreeCommands(init_player_extends({}, command, {
              cmd: 'visualAssert',
              target: target,
              value: '',
              extra: init_player_extends({}, command.extra || {}, {
                // Note: `relativeVisual` is used in bg.js, for call of `visualAssert` that doesn't specify relativeVisual,
                // it still uses file name postfix "_relative" to tell whether it's relative (green/pink boxes) or not
                relativeVisual: isRelative,
                debugVisual: false
              })
            })), Object(cv_utils["isCVTypeForDesktop"])(vars.get('!CVSCOPE')) ? Object(xy["getNativeXYAPI"])().getScalingFactor() : Promise.resolve(1)]);
          }).then(function (_ref19) {
            var _ref20 = init_player_slicedToArray(_ref19, 2),
                result = _ref20[0],
                scalingFactor = _ref20[1];

            var best = result.best;

            if (!best) throw new Error('no matched vision found for \'' + target + '\'');

            return init_player_withVisualHighlightHidden(function () {
              return init_player_getOcrResponse({
                store: store,
                lang: _lang,
                scale: _scale,
                engine: _engine,
                isTable: _isTable,
                ocrApiTimeout: _ocrApiTimeout,
                searchArea: 'rect',
                storedImageRect: {
                  // Note: In desktop mode, coordinates returned by `visualXXX` is already desktop mouse coordinates
                  // must convert it back to css coordinates (for later use in image cropping or preview highlight)
                  x: best.viewportLeft / scalingFactor,
                  y: best.viewportTop / scalingFactor,
                  width: best.width / scalingFactor,
                  height: best.height / scalingFactor
                },
                isDesktop: Object(cv_utils["isCVTypeForDesktop"])(vars.get('!CVSCOPE'))
              }).then(function (_ref21) {
                var response = _ref21.response,
                    offset = _ref21.offset,
                    viewportOffset = _ref21.viewportOffset;

                var documentBasedParseResults = Object(ts_utils["safeUpdateIn"])(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
                  return init_player_extends({}, word, {
                    Top: word.Top + offset.y,
                    Left: word.Left + offset.x
                  });
                }, response.ParsedResults);

                var ocrMatches = [
                // All words identified by OCR into one group
                {
                  similarity: 1,
                  highlight: types["OcrHighlightType"].Matched,
                  words: Object(ocr["allWordsWithPosition"])(documentBasedParseResults, [])
                }];

                if (extra && extra.debugVisual) {
                  // show overlay on website
                  ipc_cs["default"].ask('PANEL_HIGHLIGHT_OCR_MATCHES', {
                    ocrMatches: ocrMatches,
                    isDesktop: Object(cv_utils["isCVTypeForDesktop"])(vars.get('!CVSCOPE'))
                  });
                }

                return {
                  byPass: true,
                  vars: init_player_defineProperty({}, value, response.ParsedResults && response.ParsedResults[0] ? response.ParsedResults[0].ParsedText : '')
                };
              });
            });
          });
        }

      case 'visualVerify':
      case 'visualAssert':
      case 'visualSearch':
      case 'visionFind':
        {
          if (cmd === 'visualSearch') {
            if (!value || !value.length) {
              throw new Error(cmd + ': Must specify a variable to save the result');
            }
          }

          var verifyPatternImage = function verifyPatternImage(fileName, command) {
            return Object(storage["getStorageManager"])().getVisionStorage().exists(fileName).then(function (existed) {
              if (!existed) throw new Error('Error #120: ' + command + ': No input image found for file name \'' + fileName + '\'');
            });
          };

          var imageTarget = Object(common_command["parseImageTarget"])(target);

          if (!target) {
            throw new Error('Target should be like \'abc.png@0.8#1\'');
          }

          var imageUrl = imageTarget.imageUrl,
              visionFileName = imageTarget.fileName,
              _imageTarget$confiden = imageTarget.confidence,
              minSimilarity = _imageTarget$confiden === undefined ? store.getState().config.defaultVisionSearchConfidence : _imageTarget$confiden,
              rawIndex = imageTarget.index;


          var resultIndex = typeof rawIndex !== 'number' || isNaN(rawIndex) ? 0 : rawIndex;
          var isNotVerifyOrAssert = ['visualVerify', 'visualAssert'].indexOf(cmd) === -1;
          var _searchArea = vars.get('!visualSearchArea');
          var timeout = vars.get('!TIMEOUT_WAIT') * 1000;
          var cvScope = vars.get('!CVSCOPE');

          var saveImageFirstIfNeeded = function saveImageFirstIfNeeded() {
            if (!imageUrl || !imageUrl.length) {
              return Promise.resolve();
            }

            var getBlob = function getBlob() {
              if (imageUrl.indexOf('data:') === 0) {
                return Promise.resolve(Object(utils["dataURItoBlob"])(imageUrl));
              }

              return Object(utils["loadImage"])(imageUrl);
            };

            return getBlob().then(function (blob) {
              return Object(storage["getStorageManager"])().getVisionStorage().write(visionFileName, blob);
            }).then(function () {
              store.dispatch(actions["listVisions"]());
            });
          };

          var _run = function _run() {
            var prepare = Object(cv_utils["isCVTypeForDesktop"])(cvScope) ? Promise.resolve() : ipc_cs["default"].ask('PANEL_CLEAR_VISION_RECTS_ON_PLAYING_PAGE');
            // #324 .then(() => delay(() => {}, 500))

            return prepare.then(saveImageFirstIfNeeded).then(function () {
              return ipc_cs["default"].ask('PANEL_SEARCH_VISION_ON_PLAYING_PAGE', {
                visionFileName: visionFileName,
                minSimilarity: minSimilarity,
                searchArea: _searchArea,
                cvScope: cvScope,
                command: command,
                storedImageRect: vars.get('!storedImageRect')
              });
            }).then(function (_ref22) {
              var regions = _ref22.regions,
                  imageInfo = _ref22.imageInfo;

              log_default()('regions', regions, imageInfo);

              var notFound = regions.length === 0;
              var outOfRange = regions.length <= resultIndex;

              if (notFound || outOfRange) {
                // Reset image related vars to 0 if not found
                vars.set({
                  '!imageX': 0,
                  '!imageY': 0,
                  '!imageWidth': 0,
                  '!imageHeight': 0
                }, true);

                if (notFound) {
                  throw new Error('Image \'' + visionFileName + '\' (conf. = ' + minSimilarity + ') not found');
                }

                if (outOfRange) {
                  throw new Error('Found ' + regions.length + ' ' + (regions.length > 1 ? 'matches' : 'match') + ', but you are looking for #' + (resultIndex + 1));
                }
              }

              // Note: if rawIndex is set, sort by top > left (treat all matches above threshold equally)
              // otherwise, by score > top > left (= BEST match from all above threshold, see #836)
              if (resultIndex === rawIndex) {
                regions.sort(function (a, b) {
                  var vSign = Math.sign(a.matched.offsetTop - b.matched.offsetTop);
                  var hSign = Math.sign(a.matched.offsetLeft - b.matched.offsetLeft);

                  return vSign || hSign;
                });
              } else {
                regions.sort(function (a, b) {
                  var scoreSign = Math.sign(b.matched.score - a.matched.score);
                  var vSign = Math.sign(a.matched.offsetTop - b.matched.offsetTop);
                  var hSign = Math.sign(a.matched.offsetLeft - b.matched.offsetLeft);

                  return scoreSign || vSign || hSign;
                });
              }

              var best = regions[resultIndex].matched;

              if (!Object(cv_utils["isCVTypeForDesktop"])(cvScope)) {
                var shouldHighlightElements = store.getState().config.playHighlightElements || extra && extra.debugVisual;

                if (shouldHighlightElements) {
                  ipc_cs["default"].ask('PANEL_HIGHLIGHT_RECTS', {
                    selectedIndex: resultIndex,
                    scoredRects: regions.map(function (r) {
                      return init_player_extends({}, r.matched, {
                        left: r.matched.pageLeft,
                        top: r.matched.pageTop
                      });
                    })
                  });
                }
              } else if (extra && extra.debugVisual) {
                var convert = function convert(rect, index, type) {
                  if (!rect) return null;

                  return {
                    type: type,
                    index: index,
                    x: rect.viewportLeft,
                    y: rect.viewportTop,
                    width: rect.width,
                    height: rect.height,
                    score: rect.score
                  };
                };

                ipc_cs["default"].ask('PANEL_HIGHLIGHT_DESKTOP_RECTS', {
                  imageInfo: imageInfo,
                  selectedIndex: resultIndex,
                  scoredRects: Object(ts_utils["flatten"])(regions.map(function (r, i) {
                    return [convert(r.reference, i, i === resultIndex ? desktop_screenshot_editor_types["DesktopScreenshot"].RectType.ReferenceOfBestMatch : desktop_screenshot_editor_types["DesktopScreenshot"].RectType.Reference), convert(r.matched, i, i === resultIndex ? desktop_screenshot_editor_types["DesktopScreenshot"].RectType.BestMatch : desktop_screenshot_editor_types["DesktopScreenshot"].RectType.Match)].filter(function (x) {
                      return x;
                    });
                  }))
                });
              }

              var pScaleFactor = Object(cv_utils["isCVTypeForDesktop"])(cvScope) ? Object(xy["getNativeXYAPI"])().getScalingFactor() : Promise.resolve(1);

              // Note: Make sure `best`, `!imageX` and `!imageY` are all desktop coordinates (for later use in XClick)
              // While in PANEL_HIGHLIGHT_DESKTOP_RECTS, it uses css coordinates
              var top = best.viewportTop;
              var left = best.viewportLeft;

              return pScaleFactor.then(function (factor) {
                return {
                  byPass: true,
                  vars: init_player_extends({
                    '!imageX': Math.round(factor * (left + best.width / 2)),
                    '!imageY': Math.round(factor * (top + best.height / 2)),
                    '!imageWidth': Math.round(factor * best.width),
                    '!imageHeight': Math.round(factor * best.height)
                  }, isNotVerifyOrAssert && value && value.length ? init_player_defineProperty({}, value, regions.length) : {}),
                  best: Object(utils["objMap"])(function (n) {
                    return n * factor;
                  }, best)
                };
              }).then(function (res) {
                return Object(utils["delay"])(function () {
                  return res;
                }, 100);
              });
            });
          };
          var runWithRetry = Object(utils["retry"])(_run, {
            timeout: timeout,
            shouldRetry: function shouldRetry(e) {
              return store.getState().status === constant["APP_STATUS"].PLAYER && /Image.*\(conf\. =.*\) not found/.test(e.message);
            },
            retryInterval: function retryInterval(retryCount, lastRetryInterval) {
              return 0.5 + 0.25 * retryCount;
            },
            onFirstFail: function onFirstFail() {
              ipc_cs["default"].ask('PANEL_TIMEOUT_STATUS', { timeout: timeout, type: 'Vision waiting' });
            },
            onFinal: function onFinal() {
              ipc_cs["default"].ask('PANEL_CLEAR_TIMEOUT_STATUS');
            }
          });

          return verifyPatternImage(visionFileName, cmd).then(function () {
            return runWithRetry().catch(function (e) {
              // Note: extra.throwError === true, when "Find" button is used
              if (cmd === 'visualAssert' || extra && extra.throwError) {
                throw e;
              }

              return init_player_extends({
                byPass: true
              }, isNotVerifyOrAssert && value && value.length ? {
                vars: init_player_defineProperty({}, value, 0)
              } : {}, cmd === 'visualVerify' ? {
                log: {
                  error: e.message
                }
              } : {});
            });
          });
        }

      case 'visionLimitSearchArea':
      case 'visionLimitSearchAreaRelative':
        {
          var _isRelative = /relative/i.test(cmd);
          var area = target.trim();
          var _p2 = Promise.resolve({ byPass: true });

          // This method is helping you to debug visionLimitSearchArea
          // It takes screenshot according to coordinates to be set
          //
          // Overall, visionLimitSearchArea takes screenshot on the search area if its value is not viewport or full
          // `element: xxx` achieve that by sharing same logic as storeImage (you can find it in command_runner.js)
          var setImageRectVarAndTakeScreenshot = function setImageRectVarAndTakeScreenshot(_ref24) {
            var rect = _ref24.rect,
                isDesktop = _ref24.isDesktop,
                searchArea = _ref24.searchArea;

            vars.set({ '!storedImageRect': rect }, true);

            return ipc_cs["default"].ask('PANEL_CAPTURE_IMAGE', {
              isDesktop: isDesktop,
              storedImageRect: rect,
              searchArea: /\.png/i.test(searchArea) ? 'rect' : searchArea,
              scaleDpi: true
            });
          };

          // Note: In desktop mode, we assume coordinates users provide in 'area=...' are returned by `visualXXX`,
          // which is already desktop mouse coordinates, we must convert it back to css coordinates (for later use in image cropping or preview highlight)
          var _scale2 = function _scale2(rect) {
            switch (vars.get('!CVSCOPE')) {
              case cv_utils["ComputerVisionType"].Browser:
                return Promise.resolve(rect);

              case cv_utils["ComputerVisionType"].Desktop:
              case cv_utils["ComputerVisionType"].DesktopScreenCapture:
                return Object(xy["getNativeXYAPI"])().getScalingFactor().then(function (factor) {
                  return {
                    x: rect.x / factor,
                    y: rect.y / factor,
                    width: rect.width / factor,
                    height: rect.height / factor
                  };
                });
            }
          };

          if (_isRelative && !/\.png/i.test(area)) {
            throw new Error(cmd + ' only accepts a vision image as target');
          }

          if (/^viewport$/.test(area)) {
            vars.set({ '!visualSearchArea': 'viewport' }, true);
            return _p2;
          }

          if (/^full$/.test(area)) {
            vars.set({ '!visualSearchArea': 'full' }, true);
            return _p2;
          }

          if (/^area=/i.test(area)) {
            var coordinates = area.replace(/^area=/i, '').split(/\s*,\s*/g).map(function (str) {
              return parseFloat(str.trim());
            });

            var isValid = coordinates.length === 4 && utils["and"].apply(undefined, init_player_toConsumableArray(coordinates.map(function (n) {
              return typeof n === 'number' && !isNaN(n);
            })));

            if (!isValid) {
              throw new Error('area should be in format of "area=x1,y1,x2,y2"');
            }

            var rect = {
              x: coordinates[0],
              y: coordinates[1],
              width: coordinates[2] - coordinates[0],
              height: coordinates[3] - coordinates[1]
            };

            vars.set({ '!visualSearchArea': 'rect' }, true);

            return _scale2(rect).then(function (finalRect) {
              return setImageRectVarAndTakeScreenshot({
                isDesktop: Object(cv_utils["isCVTypeForDesktop"])(vars.get('!CVSCOPE')),
                searchArea: 'rect',
                rect: finalRect
              }).then(function () {
                return { byPass: true };
              });
            });
          }

          if (/\.png/.test(area)) {
            return runCsFreeCommands(init_player_extends({}, command, {
              cmd: 'visualAssert',
              target: area,
              value: '',
              extra: init_player_extends({}, command.extra || {}, {
                // Note: `relativeVisual` is used in bg.js, for call of `visualAssert` that doesn't specify relativeVisual,
                // it still uses file name postfix "_relative" to tell whether it's relative (green/pink boxes) or not
                relativeVisual: _isRelative
              })
            })).then(function (result) {
              var best = result.best;

              if (!best) throw new Error('No match found for ' + area + ' in screenshot');

              vars.set({ '!visualSearchArea': area }, true);

              return _scale2({
                // Note: In desktop mode, coordinates returned by `visualXXX` is already desktop mouse coordinates
                // must convert it back to css coordinates (for later use in image cropping or preview highlight)
                x: best.offsetLeft,
                y: best.offsetTop,
                width: best.width,
                height: best.height
              }).then(function (rect) {
                return setImageRectVarAndTakeScreenshot({
                  rect: rect,
                  searchArea: area,
                  isDesktop: Object(cv_utils["isCVTypeForDesktop"])(vars.get('!CVSCOPE'))
                });
              }).then(function () {
                return { byPass: true };
              });
            });
          }

          // If it doesn't match patterns above, we assume it's element in browser mode, or an vision image in desktop mode
          switch (vars.get('!CVSCOPE')) {
            case cv_utils["ComputerVisionType"].Browser:
              if (/^element:/.test(area)) {
                vars.set({ '!visualSearchArea': area }, true);

                return ipc_cs["default"].ask('PANEL_CLEAR_VISION_RECTS_ON_PLAYING_PAGE').then(function () {
                  // Note: let cs page to process this case, it acts almost the same as a `storeImage` command
                  return Promise.resolve({ byPass: false });
                });
              } else {
                throw new Error('Target of visionLimitSearchArea could only be either \'viewport\', \'full\' or \'element:...\'');
              }

            case cv_utils["ComputerVisionType"].Desktop:
            case cv_utils["ComputerVisionType"].DesktopScreenCapture:
              throw new Error('In desktop mode, target of visionLimitSearchArea could only be a vision image name or area');
          }

          break;
        }

      case 'visualGetPixelColor':
        {
          var targetReg = /^\s*(\d+)\s*,\s*(\d+)\s*$/;

          if (!targetReg.test(target)) {
            throw new Error('visualGetPixelColor: target must be a position in this fomrat: 100,200');
          }

          if (!value || !value.length) {
            throw new Error('visualGetPixelColor: must specify a variable name as value');
          }

          var isDesktopMode = Object(cv_utils["isCVTypeForDesktop"])(vars.get('!CVSCOPE'));

          var _target$match3 = target.match(targetReg),
              _target$match4 = init_player_slicedToArray(_target$match3, 3),
              _2 = _target$match4[0],
              xStr = _target$match4[1],
              yStr = _target$match4[2];

          var x = parseInt(xStr, 10);
          var y = parseInt(yStr, 10);

          var rectSize = 16;

          return ipc_cs["default"].ask('PANEL_GET_PIXEL_COLOR_IN_SCREENSHOT', {
            type: vars.get('!CVSCOPE'),
            offset: { x: x, y: y }
          }).then(function (colorHex) {
            if (isDesktopMode) {
              if (extra && extra.debugVisual) {
                // This scaling is due to we show desktop screenshot in its base size, so retina screens like 2560 x 1440
                // are shown as 2560 x 1440 (css px) images instead of its device size 5120 x 2880.
                // That said, the image is scaled down by 2, so we need to do the same to rects
                var _scale3 = 1 / window.devicePixelRatio;

                ipc_cs["default"].ask('PANEL_HIGHLIGHT_DESKTOP_RECTS', {
                  imageInfo: {
                    source: desktop_screenshot_editor_types["DesktopScreenshot"].ImageSource.Storage,
                    path: Object(utils["ensureExtName"])('.png', constant["LAST_DESKTOP_SCREENSHOT_FILE_NAME"])
                  },
                  selectedIndex: 0,
                  scoredRects: [{
                    x: _scale3 * (y - rectSize / 2),
                    y: _scale3 * (x - rectSize / 2),
                    width: _scale3 * rectSize,
                    height: _scale3 * rectSize,
                    text: colorHex,
                    type: desktop_screenshot_editor_types["DesktopScreenshot"].RectType.BestMatch
                  }]
                });
              }
            } else {
              ipc_cs["default"].ask('PANEL_SCREENSHOT_PAGE_INFO').then(function (pageInfo) {
                ipc_cs["default"].ask('PANEL_HIGHLIGHT_RECT', {
                  rect: {
                    top: pageInfo.originalY + y - rectSize / 2,
                    left: pageInfo.originalX + x - rectSize / 2,
                    width: rectSize,
                    height: rectSize,
                    text: colorHex
                  }
                });
              });
            }

            vars.set(init_player_defineProperty({}, value, colorHex));
            return { byPass: true };
          });
        }

      case 'XRun':
      case 'XRunAndWait':
        {
          var fileName = target;
          var args = value;
          var waitForExit = /AndWait/.test(cmd);

          return Object(xfile["getXFile"])().sanityCheck().then(function () {
            return Object(filesystem["getNativeFileSystemAPI"])().runProcess({
              fileName: fileName,
              waitForExit: waitForExit,
              arguments: args
            });
          }).then(function (result) {
            if (cmd === 'XRunAndWait') {
              vars.set({
                '!XRUN_EXITCODE': result.exitCode
              }, true);

              store.dispatch(actions["addLog"]('info', 'App close detected, Exit code=' + result.exitCode));
            }

            return { byPass: true };
          });
        }

      case 'XDesktopAutomation':
        {
          var shouldEnableDesktopAutomation = Object(ts_utils["parseBoolLike"])(target, false);

          store.dispatch(actions["updateUI"]({ shouldEnableDesktopAutomation: shouldEnableDesktopAutomation }));
          vars.set({
            '!CVSCOPE': shouldEnableDesktopAutomation ? 'desktop' : 'browser'
          }, true);

          return Promise.resolve({ byPass: true });
        }

      case 'bringBrowserToForeground':
        {
          var shouldHide = void 0;

          try {
            shouldHide = target === '' || target === undefined ? false : !Object(ts_utils["strictParseBoolLike"])(target);
          } catch (e) {
            throw new Error('Invalid target for bringBrowserToForeground. It should be true / false or leave it blank');
          }

          var _p3 = shouldHide ? ipc_cs["default"].ask('PANEL_MINIMIZE_ALL_WINDOWS_BUT_PANEL') : ipc_cs["default"].ask('PANEL_BRING_PLAYING_WINDOW_TO_FOREGROUND');

          return _p3.then(function () {
            return { byPass: true };
          });
        }

      case 'bringIDEandBrowserToBackground':
        {
          return ipc_cs["default"].ask('PANEL_MINIMIZE_ALL_WINDOWS').then(function () {
            return { byPass: true };
          });
        }

      case 'setWindowSize':
      case 'resize':
        {
          var _ref25 = function () {
            if (cmd === 'resize') {
              if (!/\s*\d+@\d+\s*/.test(target)) {
                throw new Error('Syntax for target of resize command is x@y, e.g. 800@600');
              }
              return target.split('@');
            } else {
              if (!/\s*\d+x\d+\s*/i.test(target)) {
                throw new Error('Syntax for target of setWindowSize command is WidthxHeight, e.g. 800x600');
              }
              return target.split(/x/i);
            }
          }(),
              _ref26 = init_player_slicedToArray(_ref25, 2),
              strWidth = _ref26[0],
              strHeight = _ref26[1];

          var width = parseInt(strWidth, 10);
          var height = parseInt(strHeight, 10);

          log_default()('resize', width, height);
          return ipc_cs["default"].ask('PANEL_RESIZE_PLAY_TAB', { width: width, height: height }).then(function (_ref27) {
            var actual = _ref27.actual,
                desired = _ref27.desired,
                diff = _ref27.diff;

            if (diff.length === 0) return { byPass: true };

            return {
              byPass: true,
              log: {
                warning: 'Only able to resize it to ' + actual.width + '@' + actual.height + ', given ' + desired.width + '@' + desired.height
              }
            };
          });
        }

      case 'XType':
        {
          return Object(x_user_io["getXUserIO"])().sanityCheck()
          // .then(() => csIpc.ask('PANEL_IS_PLAYING_WINDOW_IN_FOREGROUND'))
          // .then(isInForeGround => {
          //   if (isInForeGround) return
          //   return runCsFreeCommands({ cmd: 'bringBrowserToForeground' })
          // })
          .then(function () {
            if (xCmdCounter.get() === 1) {
              return init_player_hideDownloadBar();
            }
          }).then(function () {
            return Object(utils["delay"])(function () {}, 300);
          }).then(function () {
            return Object(encrypt["a" /* decryptIfNeeded */])(target);
          }).then(function (text) {
            return Object(xy["getNativeXYAPI"])().sendText({ text: text }).then(function (success) {
              if (!success) throw new Error('Failed to XType \'' + target + '\'');
              return { byPass: true };
            });
          });
        }

      case 'XMouseWheel':
        {
          var deltaX = parseFloat(target);

          if (isNaN(deltaX)) {
            throw new Error('Target of XMouseWheel must be a number');
          }

          return Object(x_user_io["getXUserIO"])().sanityCheck().then(function () {
            if (xCmdCounter.get() === 1) {
              return init_player_hideDownloadBar();
            }
          }).then(function () {
            return Object(xy["getNativeXYAPI"])().sendMouseWheelEvent({
              deltaX: deltaX,
              deltaY: 0,
              deltaZ: 0
            }).then(function (success) {
              if (!success) throw new Error('Failed to XMouseWheel \'' + target + '\'');
              return { byPass: true };
            });
          });
        }

      case 'XMove':
      case 'XMoveRelative':
      case 'XClickRelative':
      case 'XClick':
        {
          var parseTarget = function parseTarget() {
            var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

            var trimmedTarget = target.trim();
            var isDesktopMode = Object(cv_utils["isCVTypeForDesktop"])(vars.get('!CVSCOPE'));

            if (/^ocr=/i.test(trimmedTarget)) {
              guardOcrSettings();

              return {
                type: 'ocr',
                value: { query: trimmedTarget.substr(4) }
              };
            }

            if (Object(command_runner["c" /* isLocator */])(trimmedTarget)) {
              if (isDesktopMode) {
                throw new Error('Locator is not support in desktop mode');
              }

              return {
                type: 'locator',
                value: { locator: trimmedTarget }
              };
            }

            if (/^[dD](\d+(\.\d+)?)\s*,\s*(\d+(\.\d+)?)$/.test(trimmedTarget)) {
              return {
                type: 'desktop_coordinates',
                value: { coordinates: trimmedTarget.substr(1).split(/\s*,\s*/) }
              };
            }

            if (/^(\d+(\.\d+)?)\s*,\s*(\d+(\.\d+)?)$/.test(trimmedTarget)) {
              return {
                type: isDesktopMode ? 'desktop_coordinates' : 'viewport_coordinates',
                value: { coordinates: trimmedTarget.split(/\s*,\s*/) }
              };
            }

            if (/^.*\.png(@\d\.\d+)?(#\d+)?(\[[^\]]+\])?$/.test(trimmedTarget)) {
              return {
                type: 'visual_search',
                value: { query: trimmedTarget }
              };
            }

            throw new Error('XClick: invalid target, \'' + target + '\'');
          };
          var parseValueForXClick = function parseValueForXClick() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

            var normalValue = value.trim().toLowerCase();

            switch (normalValue) {
              case '':
                return '#left';

              case '#left':
              case '#middle':
              case '#right':
              case '#doubleclick':
              case '#tripleclick':
              case '#shiftclick':
              case '#ctrlclick':
                return normalValue;

              default:
                throw new Error('XClick: invalid value, \'' + value + '\'');
            }
          };
          var parseValueForXMove = function parseValueForXMove() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

            var normalValue = value.trim().toLowerCase();

            switch (normalValue) {
              case '':
                return '#move';

              case '#move':
              case '#up':
              case '#down':
                return normalValue;

              default:
                throw new Error('XMove: invalid value, \'' + value + '\'');
            }
          };
          var parseValue = {
            XClick: parseValueForXClick,
            XClickRelative: parseValueForXClick,
            XMove: parseValueForXMove,
            XMoveRelative: parseValueForXMove
          }[cmd];

          var _isRelative2 = /relative/i.test(cmd);

          return Object(x_user_io["getXUserIO"])().sanityCheck().then(function () {
            if (xCmdCounter.get() === 1) {
              return init_player_hideDownloadBar();
            }
          }).then(function () {
            var realTarget = parseTarget(target);
            var realValue = parseValue(value);

            var pNativeXYParams = function () {
              if (_isRelative2 && realTarget.type !== 'visual_search') {
                throw new Error(cmd + ' only accepts a vision image as target');
              }

              switch (realTarget.type) {
                case 'locator':
                  {
                    return runCommand(init_player_extends({}, command, {
                      cmd: 'locate',
                      target: realTarget.value.locator,
                      value: ''
                    })).then(function (result) {
                      var rect = result.rect;

                      if (!rect) throw new Error('no rect data returned');

                      var x = rect.x + rect.width / 2;
                      var y = rect.y + rect.height / 2;

                      if (isNaN(x)) throw new Error('empty x');
                      if (isNaN(y)) throw new Error('empty y');

                      return {
                        type: 'viewport',
                        offset: { x: x, y: y }
                      };
                    });
                  }

                case 'visual_search':
                  {
                    return runCsFreeCommands(init_player_extends({}, command, {
                      cmd: 'visualAssert',
                      target: realTarget.value.query,
                      value: '',
                      extra: init_player_extends({}, command.extra || {}, {
                        // Note: `relativeVisual` is used in bg.js, for call of `visualAssert` that doesn't specify relativeVisual,
                        // it still uses file name postfix "_relative" to tell whether it's relative (green/pink boxes) or not
                        relativeVisual: _isRelative2
                      })
                    })).then(function (result) {
                      var best = result.best;

                      if (!best) throw new Error('no best found from result of verifyAssert triggered by XClick');

                      var isForDesktop = Object(cv_utils["isCVTypeForDesktop"])(vars.get('!CVSCOPE'));
                      var x = best.viewportLeft + best.width / 2;
                      var y = best.viewportTop + best.height / 2;

                      if (isNaN(x)) throw new Error('empty x');
                      if (isNaN(y)) throw new Error('empty y');

                      return {
                        type: isForDesktop ? 'desktop' : 'viewport',
                        offset: { x: x, y: y },
                        originalResult: result
                      };
                    });
                  }

                case 'ocr':
                  {
                    return runCsFreeCommands(init_player_extends({}, command, {
                      cmd: 'OCRSearch',
                      target: realTarget.value.query,
                      value: '__ocrResult__'
                    })).then(function (result) {
                      var best = result.best;

                      if (!best) throw new Error('no match found for \'' + target + '\'');

                      return {
                        type: Object(cv_utils["isCVTypeForDesktop"])(vars.get('!CVSCOPE')) ? 'desktop' : 'viewport',
                        offset: Object(ocr["ocrMatchCenter"])(best),
                        originalResult: result
                      };
                    });
                  }

                case 'desktop_coordinates':
                  {
                    var _coordinates = realTarget.value.coordinates;


                    return Promise.resolve({
                      type: 'desktop',
                      offset: {
                        x: parseFloat(_coordinates[0]),
                        y: parseFloat(_coordinates[1])
                      }
                    });
                  }

                case 'viewport_coordinates':
                  {
                    var _coordinates2 = realTarget.value.coordinates;


                    return Promise.resolve({
                      type: 'viewport',
                      offset: {
                        x: parseFloat(_coordinates2[0]),
                        y: parseFloat(_coordinates2[1])
                      }
                    });
                  }
              }
            }();

            return pNativeXYParams.then(function (_ref28) {
              var type = _ref28.type,
                  offset = _ref28.offset,
                  _ref28$originalResult = _ref28.originalResult,
                  originalResult = _ref28$originalResult === undefined ? {} : _ref28$originalResult;

              // Note: should not bring play tab to front if it's in desktop mode
              var prepare = Object(cv_utils["isCVTypeForDesktop"])(vars.get('!CVSCOPE')) ? Promise.resolve() : runCsFreeCommands({ cmd: 'bringBrowserToForeground' });

              return prepare.then(function () {
                return Object(utils["delay"])(function () {}, 300);
              }).then(function () {
                var api = Object(xy["getNativeXYAPI"])();

                var _ref29 = function () {
                  switch (realValue) {
                    case '#left':
                      return [xy["MouseButton"].Left, xy["MouseEventType"].Click];
                    case '#middle':
                      return [xy["MouseButton"].Middle, xy["MouseEventType"].Click];
                    case '#right':
                      return [xy["MouseButton"].Right, xy["MouseEventType"].Click];
                    case '#doubleclick':
                      return [xy["MouseButton"].Left, xy["MouseEventType"].DoubleClick];
                    case '#tripleclick':
                      return [xy["MouseButton"].Left, xy["MouseEventType"].TripleClick];
                    case '#shiftclick':
                      return [xy["MouseButton"].Left, xy["MouseEventType"].ShiftClick];
                    case '#ctrlclick':
                      return [xy["MouseButton"].Left, xy["MouseEventType"].CtrlClick];
                    case '#move':
                      return [xy["MouseButton"].Left, xy["MouseEventType"].Move];
                    case '#up':
                      return [xy["MouseButton"].Left, xy["MouseEventType"].Up];
                    case '#down':
                      return [xy["MouseButton"].Left, xy["MouseEventType"].Down];
                    default:
                      throw new Error('Unsupported realValue: ' + realValue);
                  }
                }(),
                    _ref30 = init_player_slicedToArray(_ref29, 2),
                    button = _ref30[0],
                    eventType = _ref30[1];

                var event = {
                  button: button,
                  x: offset.x,
                  y: offset.y,
                  type: eventType
                };

                var pSendMouseEvent = type === 'desktop' ? api.sendMouseEvent(event) : api.sendViewportMouseEvent(event, {
                  getViewportRectInScreen: function getViewportRectInScreen() {
                    return ipc_cs["default"].ask('PANEL_GET_VIEWPORT_RECT_IN_SCREEN');
                  }
                });

                return pSendMouseEvent.then(function (success) {
                  if (!success) throw new Error('E201: Failed to ' + cmd + ' ' + type + ' coordinates at [' + offset.x + ', ' + offset.y + ']');

                  // Note: `originalResult` is used by visualAssert to update !imageX and !imageY
                  return init_player_extends({}, originalResult, {
                    byPass: true
                  });
                });
              });
            });
          });
        }

      case 'captureDesktopScreenshot':
        {
          var cvApi = Object(desktop["getNativeCVAPI"])();
          var isJustFileName = function isJustFileName(str) {
            return !/[\\/]/.test(str);
          };
          var _path = target && target.trim();
          var filePath = _path && _path.length > 0 ? Object(utils["ensureExtName"])('.png', _path) : undefined;
          var next = filePath && isJustFileName(filePath) ? function (actualPath) {
            return cvApi.readFileAsBlob(actualPath).then(function (blob) {
              return Object(storage["getStorageManager"])().getScreenshotStorage().overwrite(_path, blob).then(function () {
                store.dispatch(actions["listScreenshots"]());
                store.dispatch(actions["addLog"]('info', 'desktop screenshot saved to screenshot storage with file name \'' + _path + '\''));
              });
            });
          } : function (actualPath) {
            store.dispatch(actions["addLog"]('info', 'desktop screenshot saved to hard drive at \'' + actualPath + '\''));
          };

          return cvApi.captureDesktop().then(next).then(function () {
            return {
              byPass: true
            };
          });
        }

      default:
        return undefined;
    }
  };

  return runCsFreeCommands;
};

var init_player_interpretCSVCommands = function interpretCSVCommands(_ref31) {
  var store = _ref31.store,
      vars = _ref31.vars;
  return function (command, index) {
    var csvStorage = Object(storage["getStorageManager"])().getCSVStorage();
    var cmd = command.cmd,
        target = command.target,
        value = command.value;

    var assertCsvExist = function assertCsvExist(target) {
      return csvStorage.exists(target).then(function (isExisted) {
        if (isExisted) {
          return;
        }

        vars.set({ '!CsvReadStatus': 'FILE_NOT_FOUND' }, true);

        var errMsg = 'csv file \'' + target + '\' does not exist';

        if (Object(storage["getStorageManager"])().isBrowserMode() && (lib_path["posix"].isAbsolute(target) || lib_path["win32"].isAbsolute(target))) {
          errMsg += '. Full path works only in hard-drive mode.';
        }

        throw new Error(errMsg);
      });
    };

    switch (cmd) {
      case 'csvRead':
        {
          if (value && value.length > 0) {
            store.dispatch(actions["addLog"]('warning', 'csvRead: Value field should be empty (not used)'));
          }

          return assertCsvExist(target).then(function () {
            return csvStorage.read(target, 'Text').then(parseFromCSV).then(function (rows) {
              // Note: !CsvReadLineNumber starts from 1
              var index = vars.get('!CsvReadLineNumber') - 1;
              var row = rows[index];

              if (index >= rows.length) {
                vars.set({ '!CsvReadStatus': 'END_OF_FILE' }, true);
                throw new Error('end of csv file reached');
              } else {
                vars.set({
                  '!CsvReadStatus': 'OK',
                  '!CsvReadMaxRow': rows.length
                }, true);
              }

              vars.clear(/^!COL\d+$/i);

              row.forEach(function (data, i) {
                vars.set(init_player_defineProperty({}, '!COL' + (i + 1), data));
              });

              return {
                isFlowLogic: true
              };
            });
          });
        }

      case 'csvSave':
        {
          var csvLine = vars.get('!CSVLINE');

          if (!csvLine || !csvLine.length) {
            throw new Error('No data to save to csv');
          }

          return stringifyToCSV([csvLine]).then(function (newLineText) {
            var fileName = /\.csv$/i.test(target) ? target : target + '.csv';

            return csvStorage.exists(fileName).then(function (isExisted) {
              if (!isExisted) {
                return csvStorage.write(fileName, new Blob([newLineText]));
              }

              return csvStorage.read(fileName, 'Text').then(function (originalText) {
                var text = (originalText + '\n' + newLineText).replace(/\n+/g, '\n');
                return csvStorage.overwrite(fileName, new Blob([text]));
              });
            });
          }).then(function () {
            vars.clear(/^!CSVLINE$/);
            store.dispatch(actions["listCSV"]());
          }).then(function () {
            return {
              isFlowLogic: true
            };
          });
        }

      case 'csvReadArray':
        {
          if (!value || !value.length) {
            throw new Error('Please provide variable name as value');
          }

          return assertCsvExist(target).then(function () {
            return csvStorage.read(target, 'Text').then(parseFromCSV).then(function (rows) {
              vars.set({
                '!CsvReadStatus': true,
                '!CsvReadMaxRow': rows.length
              }, true);

              return {
                byPass: true,
                vars: init_player_defineProperty({}, value, rows)
              };
            }, function (e) {
              vars.set({ '!CsvReadStatus': false }, true);
              return Promise.reject(e);
            });
          });
        }

      case 'csvSaveArray':
        {
          if (!value || !value.length) {
            throw new Error('Please provide csv file name as value');
          }

          if (!target || !target.length) {
            throw new Error('Please provide array variable name as target');
          }

          var arr = vars.get(target);

          if (!arr) {
            throw new Error('No variable found with name \'' + target + '\'');
          }

          var isValidCsvArray = Array.isArray(arr) && Array.from(arr).every(function (item) {
            return Array.isArray(item);
          });

          if (!isValidCsvArray) {
            throw new Error('Array must be two dimensional array');
          }

          return stringifyToCSV(arr).then(function (csvText) {
            var fileName = /\.csv$/i.test(value) ? value : value + '.csv';
            return csvStorage.overwrite(fileName, new Blob([csvText]));
          }).then(function () {
            store.dispatch(actions["listCSV"]());
          }).then(function () {
            return {
              isFlowLogic: true
            };
          });
        }

      default:
        return undefined;
    }
  };
};

// Note: initialize the player, and listen to all events it emits
var init_player_initPlayer = function initPlayer(store) {
  var vars = varsFactory('main', {}, { '!TESTSUITE_LOOP': 1 });
  var macroCallStack = Object(call_stack["createMacroCallStack"])({
    getCurrentMacroRunningStatus: function getCurrentMacroRunningStatus() {
      var playerState = tcPlayer.getState();
      var reducerState = store.getState();
      var commandResults = Object(player_macro["getCommandResults"])({
        count: playerState.resources.length,
        doneIndices: Object(recomputed["getDoneCommandIndices"])(reducerState),
        errorIndices: Object(recomputed["getErrorCommandIndices"])(reducerState),
        warningIndices: Object(recomputed["getWarningCommandIndices"])(reducerState)
      });

      return {
        playerState: playerState,
        commandResults: commandResults,
        status: player_macro["MacroStatus"].Running,
        nextIndex: playerState.nextIndex,
        interpreterState: interpreter.backupState()
      };
    },
    updateSelectedMacro: function updateSelectedMacro(macro, runningStatus) {
      return store.dispatch(actions["editTestCase"](macro.id));
    },
    restorePlayerState: function restorePlayerState(macro, runningStatus) {
      // Steps:
      // 1. Restore macro player state
      // 2. Restore player state in reducer
      var playerState = runningStatus.playerState,
          _runningStatus$interp = runningStatus.interpreterState,
          interpreterState = _runningStatus$interp === undefined ? Object(ts_utils["clone"])(common_interpreter.DefaultState) : _runningStatus$interp;


      tcPlayer.setState(playerState);

      store.dispatch(actions["setPlayerState"]({
        // Note: since we don't show loop info for subroutines,
        // `currentLoop` and `loops` in reducer state is always for initial call frame,
        // so no neep to restore that info from call stack before playing any frame
        //
        // currentLoop:         playerState.loopsCursor - playerState.loopsStart + 1,
        // loops:               playerState.loopsEnd - playerState.loopsStart + 1,
        nextCommandIndex: playerState.nextIndex
      }));

      interpreter.restoreState(interpreterState);
    },
    playMacro: function playMacro(macro, runningStatus, _ref32) {
      var isBottom = _ref32.isBottom,
          isResume = _ref32.isResume,
          frameId = _ref32.frameId;

      // Note: do not use clone here, otherwise will lose `callback` in playerState
      var playerState = init_player_extends({}, runningStatus.playerState);

      playerState.noEndEvent = !isBottom;

      // Note: frameId in extra will be available in all kinds of player events,
      // frameId is used as id for monitor, so that we can control monitors in player events
      playerState.extra = init_player_extends({}, playerState.extra || {}, {
        frameId: frameId,
        macroId: macro.id,
        isBottomFrame: isBottom,
        isBackFromCalling: isResume
      });

      return showDownloadBarFinally(function () {
        return xCmdCounter.get() > 0;
      }, function () {
        if (isResume) {
          tcPlayer.setState(playerState);
          // Note: already increase `nextIndex` by one
          tcPlayer.__setNext(runningStatus.nextIndex);

          return tcPlayer.play(tcPlayer.getState());
        } else {
          var needDelayAfterLoop = utils["and"].apply(undefined, init_player_toConsumableArray(playerState.resources.map(function (command) {
            return Object(common_command["isExtensionResourceOnlyCommand"])(command.cmd);
          })));
          var args = init_player_extends({}, playerState, {
            needDelayAfterLoop: needDelayAfterLoop
          });
          return tcPlayer.play(args);
        }
      });
    }
  });

  var ocrCmdCounter = Object(command_counter["getOcrCommandCounter"])({
    initial: 0,
    getMax: function getMax() {
      return Object(services_license["getLicenseService"])().getMaxOcrCalls();
    },
    onMax: function onMax(cur, max, initial) {
      throw new Error('OCR conversion limit reached');
    }
  });
  var xCmdCounter = new counter["Counter"]({
    initial: 0,
    getMax: function getMax() {
      return Object(services_license["getLicenseService"])().getMaxXCommandCalls();
    },
    onMax: function onMax(cur, max, initial) {
      throw new Error('XClick/XMove/XType ' + max + ' commands limit reached');
    }
  });
  var proxyCounter = new counter["Counter"]({
    initial: 0,
    getMax: function getMax() {
      return Object(services_license["getLicenseService"])().getMaxProxyCalls();
    },
    onMax: function onMax(cur, max, initial) {
      throw new Error('PROXY ' + max + ' commands limit reached');
    }
  });
  var interpreter = new common_interpreter({
    run: interpretSpecialCommands({
      vars: vars,
      store: store,
      xCmdCounter: xCmdCounter,
      getTcPlayer: function getTcPlayer() {
        return tcPlayer;
      },
      getInterpreter: function getInterpreter() {
        return interpreter;
      }
    })
  });
  var tcPlayer = init_player_initTestCasePlayer({ store: store, vars: vars, interpreter: interpreter, xCmdCounter: xCmdCounter, ocrCmdCounter: ocrCmdCounter, proxyCounter: proxyCounter });
  var tsPlayer = init_player_initTestSuitPlayer({ store: store, vars: vars, tcPlayer: tcPlayer, xCmdCounter: xCmdCounter, ocrCmdCounter: ocrCmdCounter, proxyCounter: proxyCounter });

  initMacroMonitor({ vars: vars, store: store });

  macroCallStack.on(call_stack_types["CallStackEvent"].BeforeRun, function (macroInfoList) {
    var lastMacroInfo = macroInfoList[macroInfoList.length - 1];
    var lastName = lastMacroInfo.name;
    var prevNames = macroInfoList.slice(0, -1).map(function (item) {
      return '\'' + item.name + '\'';
    });

    if (prevNames.length > 0) {
      store.dispatch(actions["addLog"]('status', 'Running \'' + lastName + '\', called by ' + prevNames.join(' > ')));
    }
  });

  macroCallStack.on(call_stack_types["CallStackEvent"].AfterReturn, function (macroInfoList) {
    var lastMacroInfo = macroInfoList[macroInfoList.length - 1];
    var lastName = lastMacroInfo.name;
    var lastFrameId = lastMacroInfo.frameId;
    var prevNames = macroInfoList.slice(0, -1).map(function (item) {
      return '\'' + item.name + '\'';
    });

    Object(macro_monitor["getMacroMonitor"])().removeTarget(lastFrameId);

    if (prevNames.length > 0) {
      store.dispatch(actions["addLog"]('status', 'Finished running \'' + lastName + '\', returning to ' + prevNames.join(' > ')));
    }
  });

  ipc_cs["default"].onAsk(function (cmd, args) {
    switch (cmd) {
      case 'DOWNLOAD_COMPLETE':
        {
          var fileName = args ? lib_path["default"].basename(args.filename) : null;

          if (!fileName) {
            return false;
          }

          vars.set({ '!LAST_DOWNLOADED_FILE_NAME': fileName }, true);
          return true;
        }
    }
  });

  // Note: No need to return anything in this method.
  // Because both test case player and test suite player are cached in player.js
  // All later usage of player utilize `getPlayer` method
};

// Note: Standalone function to ask background to run a command
var init_player_askBackgroundToRunCommand = function askBackgroundToRunCommand(_ref33) {
  var command = _ref33.command,
      state = _ref33.state,
      store = _ref33.store,
      vars = _ref33.vars,
      preRun = _ref33.preRun;

  var useClipboard = /!clipboard/i.test(command.target + ';' + command.value);
  var prepare = !useClipboard ? Promise.resolve({ useClipboard: false }) : ipc_cs["default"].ask('GET_CLIPBOARD').then(function (clipboard) {
    return { useClipboard: true, clipboard: clipboard };
  });

  if (web_extension_default.a.isFirefox()) {
    switch (command.cmd) {
      case 'onDownload':
        store.dispatch(actions["addLog"]('warning', 'onDownload - changing file names not supported by Firefox extension api yet'));
        break;
    }
  }

  switch (command.cmd) {
    case 'XType':
      if (command.value && command.value.length > 0) {
        throw new Error('XType currently doesn\'t use the "Value" field');
      }

      break;
  }

  return prepare.then(function (_ref34) {
    var useClipboard = _ref34.useClipboard,
        _ref34$clipboard = _ref34.clipboard,
        clipboard = _ref34$clipboard === undefined ? '' : _ref34$clipboard;

    // Set clipboard variable if it is used
    if (useClipboard) {
      vars.set({ '!CLIPBOARD': clipboard });
    }

    if (state.extra.isBottomFrame) {
      vars.set({
        '!LOOP': state.loopsCursor
      }, true);
    }

    vars.set({
      '!RUNTIME': Object(ts_utils["milliSecondsToStringInSecond"])(Object(macro_monitor["getMacroMonitor"])().getDataFromInspector(Object(call_stack["getMacroCallStack"])().bottom().id, monitor_types["MacroInspector"].LoopTimer))
    }, true);

    if (command.cmd === 'open') {
      command = init_player_extends({}, command, { href: state.startUrl });
    }

    // Note: translate shorthand '#efp'
    if (command.target && /^#efp$/i.test(command.target.trim())) {
      // eslint-disable-next-line no-template-curly-in-string
      command.target = '#elementfrompoint (${!imageX}, ${!imageY})';
    }

    var isRelatedToExecuteScript = ['executeScript', 'executeScript_Sandbox', 'executeAsyncScript', 'executeAsyncScript_Sandbox', 'if_v2', 'while_v2', 'gotoIf_v2', 'elseif', 'repeatIf'].indexOf(command.cmd) !== -1;

    if (command.cmd !== 'comment') {
      // Replace variables in 'target' and 'value' of commands
      ;['target', 'value'].forEach(function (field) {
        if (command[field] === undefined) return;

        var oldEval = command.cmd === 'storeEval' && field === 'target' || command.cmd === 'gotoIf' && field === 'target' || command.cmd === 'if' && field === 'target' || command.cmd === 'while' && field === 'target';

        var opts = oldEval ? { withHashNotation: true } : {};

        opts.shouldStringify = oldEval || isRelatedToExecuteScript;

        command = init_player_extends({}, command, init_player_defineProperty({}, field, vars.render(replaceEscapedChar(command.cmd === 'type' ? command[field] : command[field].trim(), command, field, vars.get('!StringEscape')), opts)));
      });
    }

    // add timeout info to each command's extra
    // Please note that we must set the timeout info at runtime for each command,
    // so that timeout could be modified by some 'store' commands and affect
    // the rest of commands
    command = Object(utils["updateIn"])(['extra'], function (extra) {
      return init_player_extends({}, extra || {}, {
        timeoutPageLoad: vars.get('!TIMEOUT_PAGELOAD'),
        timeoutElement: vars.get('!TIMEOUT_WAIT'),
        timeoutDownload: vars.get('!TIMEOUT_DOWNLOAD'),
        timeoutDownloadStart: vars.get('!TIMEOUT_DOWNLOAD_START') || Math.max(10, vars.get('!TIMEOUT_WAIT')),
        lastCommandOk: vars.get('!LASTCOMMANDOK'),
        errorIgnore: !!vars.get('!ERRORIGNORE'),
        waitForVisible: !!vars.get('!WAITFORVISIBLE')
      });
    }, command);

    return preRun(command, state, function (command) {
      // Note: -1 will disable ipc timeout for 'pause' command
      var timeout = command.cmd === 'pause' ? -1 : null;

      return init_player_retryIfHeartBeatExpired(function () {
        return ipc_cs["default"].ask('PANEL_RUN_COMMAND', {
          command: command,
          playUID: state.playUID
        }, timeout);
      }, command);
    });
  });
};

function initMacroMonitor(_ref35) {
  var store = _ref35.store,
      vars = _ref35.vars;

  Object(macro_monitor["getMacroMonitor"])(function (actionType, name, id, notBatch) {
    switch (actionType) {
      case macro_monitor["MacroParamsProviderType"].Constructor:
        {
          switch (name) {
            case monitor_types["MacroInspector"].Countdown:
              return [function () {
                Object(common_player["b" /* getPlayer */])().stopWithError(new Error('macro \'' + Object(call_stack["getMacroCallStack"])().peek().resource.name + '\' timeout ' + vars.get('!TIMEOUT_MACRO') + 's (change the value in the settings if needed)'));
              }];

            case monitor_types["MacroInspector"].Timer:
            case monitor_types["MacroInspector"].LoopTimer:
            default:
              return [];
          }
        }

      case macro_monitor["MacroParamsProviderType"].Restart:
        {
          switch (name) {
            case monitor_types["MacroInspector"].Countdown:
              return [vars.get('!TIMEOUT_MACRO') * 1000, true];

            case monitor_types["MacroInspector"].Timer:
            case monitor_types["MacroInspector"].LoopTimer:
            default:
              return [];
          }
        }
    }
  });
}

function isPausedOrStopped(str) {
  return (/player: paused or stopped/.test(str)
  );
}

var init_player_initTestCasePlayer = function initTestCasePlayer(_ref36) {
  var store = _ref36.store,
      vars = _ref36.vars,
      interpreter = _ref36.interpreter,
      xCmdCounter = _ref36.xCmdCounter,
      ocrCmdCounter = _ref36.ocrCmdCounter,
      proxyCounter = _ref36.proxyCounter;

  // Note: use this to track `onError` command
  // `onError` works like a global try catch, it takes effects on any commands coming after `onError`
  // Multilple `onError` are allowed, latter one overwrites previous one.
  // The scope of `onError` is current loop
  var onErrorCommand = null;
  var player = Object(common_player["b" /* getPlayer */])({
    prepare: function prepare(state) {
      // Each 'replay' has an independent variable scope,
      // with global variables as initial scope

      if (state.extra.isBottomFrame && !state.extra.isBackFromCalling) {
        vars.reset({ keepGlobal: true });
        vars.set(state.public.scope || {}, true);
        vars.set({
          '!StatusOK': true,
          '!WaitForVisible': false,
          '!StringEscape': true,
          '!IMAGEX': 0,
          '!IMAGEY': 0,
          '!OCRX': 0,
          '!OCRY': 0,
          '!OCRENGINE': store.getState().config.ocrEngine,
          '!BROWSER': web_extension_default.a.isFirefox() ? 'firefox' : 'chrome',
          '!OS': function () {
            var ua = window.navigator.userAgent;
            if (/windows/i.test(ua)) return 'windows';
            if (/mac/i.test(ua)) return 'mac';
            return 'linux';
          }()
        }, true);
      }

      if (!state.extra.isBackFromCalling) {
        interpreter.reset();
        interpreter.preprocess(state.resources);
      }

      return ipc_cs["default"].ask('PANEL_START_PLAYING', {
        url: state.startUrl,
        shouldNotActivateTab: true
      });
    },
    run: function run(command, state) {
      return init_player_askBackgroundToRunCommand({
        command: command,
        state: state,
        store: store,
        vars: vars,
        preRun: function preRun(command, state, askBgToRun) {
          // Note: all commands need to be run by interpreter before it is sent to bg
          // so that interpreter could pick those flow logic commands and do its job

          return new Promise(function (resolve, reject) {
            // Note: inc() has a chance to throw xCommand limit reached error,
            // so it's easier to keep it in the Promise constructor
            if (/^(XType|XClick|XMove|XClickRelative|XMoveRelative|XMouseWheel)$/i.test(command.cmd)) {
              xCmdCounter.inc();
            }

            if (command.cmd === 'setProxy') {
              proxyCounter.inc();
            }

            interpreter.run(command, state.nextIndex).then(function (result) {
              var byPass = result.byPass,
                  isFlowLogic = result.isFlowLogic,
                  nextIndex = result.nextIndex,
                  resetVars = result.resetVars;

              // Record onError command

              if (command.cmd === 'onError') {
                onErrorCommand = command;
              }

              if (byPass) return Promise.resolve(result);
              if (isFlowLogic) return Promise.resolve({ nextIndex: nextIndex });

              return askBgToRun(command);
            }).then(resolve, reject);
          });
        }
      }).catch(function (e) {
        // Note: it will just log errors instead of a stop of whole macro, in following situations
        // 1. variable !ERRORIGNORE is set to true
        // 2. There is an `onError` command ahead in current loop.
        // 3. it's in loop mode, and it's not the last loop, and onErrorInLoop is continue_next_loop,
        if (vars.get('!ERRORIGNORE')) {
          return {
            log: {
              error: e.message
            }
          };
        }

        if (onErrorCommand) {
          var value = onErrorCommand.value && onErrorCommand.value.trim();
          var target = onErrorCommand.target && onErrorCommand.target.trim();

          if (/^#restart$/i.test(target)) {
            store.dispatch(actions["addLog"]('status', 'onError - about to restart'));

            e.restart = true;
            throw e;
          } else if (/^#goto$/i.test(target)) {
            store.dispatch(actions["addLog"]('status', 'onError - about to goto label \'' + value + '\''));

            return Promise.resolve({
              log: {
                error: e.message
              },
              nextIndex: interpreter.commandIndexByLabel(value)
            });
          }
        }

        var isPausedStopped = isPausedOrStopped(e.message);
        var continueNextLoop = state.mode === common_player["a" /* Player */].C.MODE.LOOP && state.loopsCursor < state.loopsEnd && store.getState().config.onErrorInLoop === 'continue_next_loop';

        if (continueNextLoop) {
          if (isPausedStopped) {
            return {
              // Note: simply set nextIndex to command count, it will enter next loop
              nextIndex: state.resources.length
            };
          }

          return {
            log: {
              error: e.message
            },
            // Note: simply set nextIndex to command count, it will enter next loop
            nextIndex: state.resources.length
          };
        }

        // Note: set these status values to false
        // status of those logs above will be taken care of by `handleResult`
        vars.set({
          '!LastCommandOK': false,
          '!StatusOK': false
        }, true);

        throw e;
      });
    },
    handleResult: function handleResult(result, command, state) {
      var prepares = [];
      var getCurrentPlayer = function getCurrentPlayer() {
        var state = store.getState();

        switch (state.player.mode) {
          case constant["PLAYER_MODE"].TEST_CASE:
            return Object(common_player["b" /* getPlayer */])({ name: 'testCase' });

          case constant["PLAYER_MODE"].TEST_SUITE:
            return Object(common_player["b" /* getPlayer */])({ name: 'testSuite' });
        }
      };

      // Every command should return its window.url
      if (result && result.pageUrl) {
        vars.set({ '!URL': result.pageUrl }, true);
      }

      if (result && result.vars) {
        var newVars = Object(utils["objMap"])(function (val) {
          if (val && val.__undefined__) return undefined;
          return val;
        }, result.vars);

        log_default()('set vars', newVars);

        try {
          vars.set(newVars);

          // Note: if set value to !Clipboard, there is an async job we must get done before handleResult could return
          var clipBoardKey = Object.keys(result.vars).find(function (key) {
            return (/!clipboard/i.test(key)
            );
          });
          if (clipBoardKey) {
            prepares.push(ipc_cs["default"].ask('SET_CLIPBOARD', { value: result.vars[clipBoardKey] }));
          }

          // Note: if user sets !timeout_macro to some other value, re-calculate the time left
          var timeoutMacroKey = Object.keys(result.vars).find(function (key) {
            return (/!timeout_macro/i.test(key)
            );
          });

          if (timeoutMacroKey) {
            var frameId = Object(call_stack["getMacroCallStack"])().peek().id;
            Object(macro_monitor["getMacroMonitor"])().restartInspector(frameId, monitor_types["MacroInspector"].Countdown);
          }
        } catch (e) {
          return Promise.reject(e);
        }
      }

      var hasError = false;

      if (result && result.log) {
        if (result.log.info) {
          store.dispatch(actions["addLog"]('echo', result.log.info, result.log.options));

          if (result.log.options && result.log.options.notification) {
            ipc_cs["default"].ask('PANEL_NOTIFY_ECHO', { text: result.log.info });
          }
        }

        if (result.log.warning) {
          store.dispatch(actions["addLog"]('warning', result.log.warning, result.log.options));
        }

        if (result.log.error && !isPausedOrStopped(result.log.error)) {
          store.dispatch(actions["addPlayerWarningCommandIndex"](state.nextIndex));
          store.dispatch(actions["addLog"]('error', result.log.error, { ignored: true }));
          hasError = true;
        }
      }

      // From spec: !StatusOK, very similar to !LastCommandOK but it does not get reset by a good command.
      // If set to error, it remains like this. But a user can use store | true | !StatusOK to manually reset it.
      if (command.cmd !== 'echo') {
        vars.set({ '!LastCommandOK': !hasError }, true);
      }

      if (hasError) {
        vars.set({ '!StatusOK': false }, true);
      }

      if (result && result.screenshot) {
        store.dispatch(actions["addLog"]('info', 'a new screenshot captured'));

        Object(storage["getStorageManager"])().getScreenshotStorage().getLink(result.screenshot.name).then(function (link) {
          return init_player_extends({}, result.screenshot, {
            url: link
          });
        }).then(function (ss) {
          store.dispatch(actions["listScreenshots"]());
        }).catch(function (e) {
          log_default.a.error('screenshot obj error 1', e);
          log_default.a.error('screenshot obj error stack', e.stack);
        });
      }

      if (result && result.control) {
        switch (result.control.type) {
          case 'pause':
            // Important: should only pause test case player, not test suite player
            // Because once test suite player is paused, it is supposed to run the test case from start again
            ipc_cs["default"].ask('PANEL_NOTIFY_AUTO_PAUSE', {});

            // pause() returns a promise that doesn't resolve,
            // must return that promise here to pause any further execution
            return Object(common_player["b" /* getPlayer */])({ name: 'testCase' }).pause();

          default:
            throw new Error('Control type \'' + result.control.type + '\' not supported yet');
        }
      }

      if (/^(fast|medium|slow|nodisplay)$/i.test(vars.get('!REPLAYSPEED'))) {
        var val = vars.get('!REPLAYSPEED').toUpperCase();

        player.setPostDelay({
          NODISPLAY: 1,
          FAST: 1, // avoid UI freezing (DemoCsvReadArray: Fast=0 is ~30-40% faster as no UI updates)
          MEDIUM: 300,
          SLOW: 2000
        }[val]);
      }

      var replaySpeedKey = Object.keys(result.vars || {}).find(function (key) {
        return key.toUpperCase() === '!REPLAYSPEED';
      });

      // Save nodisplay to store to reflect it in rendering
      // if !REPLAYSPEED is updated in vars
      if (replaySpeedKey) {
        store.dispatch(simple_actions["Actions"].setNoDisplayInPlay(/^nodisplay$/i.test(vars.get('!REPLAYSPEED'))));
      }

      // For those flow logic that set nextIndex directly in Interpreter.run method
      if (result && result.nextIndex !== undefined) {
        return Promise.all(prepares).then(function () {
          return result.nextIndex;
        });
      }

      // For those flow logic that has to get result from bg
      // and return nextIndex in Interpreter.postRun
      return Promise.all(prepares).then(function () {
        return interpreter.postRun(command, state.nextIndex, result);
      }).then(function () {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return data.nextIndex;
      });
    }
  }, {
    preDelay: 0
  });

  player.on('BREAKPOINT', function () {
    ipc_cs["default"].ask('PANEL_NOTIFY_BREAKPOINT', {});
  });

  player.on('LOOP_START', function (_ref37) {
    var loopsCursor = _ref37.loopsCursor,
        extra = _ref37.extra;

    if (extra.isBottomFrame) {
      // Note: set 'csv read line number' to loops whenever a new loop starts
      vars.set({
        '!CsvReadLineNumber': loopsCursor,
        '!visualSearchArea': 'viewport',
        '!StatusOK': true
      }, true);
    }

    var frameId = extra.frameId;

    // Note: reset macro timeout, and loop timer on each loop

    Object(macro_monitor["getMacroMonitor"])().restartInspector(frameId, monitor_types["MacroInspector"].LoopTimer);
    Object(macro_monitor["getMacroMonitor"])().restartInspector(frameId, monitor_types["MacroInspector"].Countdown);

    if (extra.isBottomFrame) {
      // Note: reset onErrorCommand on each loop
      onErrorCommand = null;
    }
  });

  player.on('LOOP_RESTART', function (_ref38) {
    var currentLoop = _ref38.currentLoop,
        loopsCursor = _ref38.loopsCursor;

    ipc_cs["default"].ask('PANEL_STOP_PLAYING', {});
    ipc_cs["default"].ask('PANEL_START_PLAYING', { shouldNotActivateTab: true });
    store.dispatch(actions["addLog"]('status', 'Current loop: ' + currentLoop));
  });

  player.on('START', function (_ref39) {
    var title = _ref39.title,
        extra = _ref39.extra,
        loopsCursor = _ref39.loopsCursor;

    log_default()('START');

    if (store.getState().player.mode === constant["PLAYER_MODE"].TEST_CASE && extra.isBottomFrame && !extra.isBackFromCalling) {
      xCmdCounter.reset();
      proxyCounter.reset();
    }

    store.dispatch(actions["startPlaying"]());

    store.dispatch(actions["setPlayerState"]({
      status: constant["PLAYER_STATUS"].PLAYING,
      nextCommandIndex: null
    }));

    if (!extra.isBackFromCalling) {
      store.dispatch(actions["updateMacroExtra"](Object(recomputed["getCurrentMacroId"])(store.getState()), {
        doneCommandIndices: [],
        errorCommandIndices: [],
        warningCommandIndices: []
      }));
    }

    store.dispatch(actions["addLog"]('status', 'Playing macro ' + title));
  });

  player.on('PREPARED', function (_ref40) {
    var extra = _ref40.extra;

    if (!extra.isBackFromCalling) {
      // PREPARED event means all variables are already set
      var frameId = extra.frameId;

      Object(macro_monitor["getMacroMonitor"])().addTarget(frameId);
    }
  });

  player.on('PAUSED', function () {
    log_default()('PAUSED');
    store.dispatch(actions["setPlayerState"]({
      status: constant["PLAYER_STATUS"].PAUSED
    }));

    store.dispatch(actions["addLog"]('status', 'Macro paused'));

    // Pause all monitors (timers, coundown)
    Object(macro_monitor["getMacroMonitor"])().pause();
  });

  player.on('RESUMED', function () {
    log_default()('RESUMED');
    store.dispatch(actions["setPlayerState"]({
      status: constant["PLAYER_STATUS"].PLAYING
    }));

    store.dispatch(actions["addLog"]('status', 'Macro resumed'));

    // Resume all monitors (timers, coundown)
    Object(macro_monitor["getMacroMonitor"])().resume();
  });

  player.on('END', function (obj) {
    var _logMsg;

    log_default()('END', obj);

    ipc_cs["default"].ask('PANEL_STOP_PLAYING', {});

    store.dispatch(actions["stopPlaying"]());

    var state = store.getState();
    var extraState = state.player.nextCommandIndex !== null ? { lastNextCommandIndex: state.player.nextCommandIndex } : {};

    store.dispatch(actions["setPlayerState"](init_player_extends({
      status: constant["PLAYER_STATUS"].STOPPED,
      stopReason: obj.reason,
      nextCommandIndex: null,
      timeoutStatus: null
    }, extraState)));

    if (vars.get('!PROXY_EXEC_COUNT') > 0 && store.getState().config.turnOffProxyAfterReplay) {
      init_player_setProxy(null);
      store.dispatch(actions["addLog"]('info', 'Proxy reset to none'));
    }

    var tcId = obj.extra && obj.extra.id;

    switch (obj.reason) {
      case player.C.END_REASON.COMPLETE:
        if (tcId) store.dispatch(actions["updateMacroPlayStatus"](tcId, macro_extra_data["MacroResultStatus"].Success));
        message_default.a.success('Macro completed running', 1.5);
        break;

      case player.C.END_REASON.ERROR:
        var stacks = Object(call_stack["getMacroCallStack"])().toArray();
        var len = stacks.length;

        stacks.forEach(function (item, i) {
          var status = i === len - 1 ? macro_extra_data["MacroResultStatus"].Error : macro_extra_data["MacroResultStatus"].ErrorInSub;
          store.dispatch(actions["updateMacroPlayStatus"](item.resource.id, status));
        });

        message_default.a.error('Macro encountered some error', 1.5);
        break;
    }

    var logMsg = (_logMsg = {}, init_player_defineProperty(_logMsg, player.C.END_REASON.COMPLETE, 'Macro completed'), init_player_defineProperty(_logMsg, player.C.END_REASON.ERROR, 'Macro failed'), init_player_defineProperty(_logMsg, player.C.END_REASON.MANUAL, 'Macro was stopped manually'), _logMsg);

    var frameId = obj.extra.frameId;

    var ms = Object(macro_monitor["getMacroMonitor"])().getDataFromInspector(frameId, monitor_types["MacroInspector"].Timer);

    store.dispatch(actions["addLog"]('info', logMsg[obj.reason] + (' (Runtime ' + Object(ts_utils["milliSecondsToStringInSecond"])(ms) + ')')));

    Object(macro_monitor["getMacroMonitor"])().stopInspector(frameId, monitor_types["MacroInspector"].Timer);
    Object(macro_monitor["getMacroMonitor"])().stopInspector(frameId, monitor_types["MacroInspector"].LoopTimer);
    Object(macro_monitor["getMacroMonitor"])().stopInspector(frameId, monitor_types["MacroInspector"].Countdown);

    // Note: show in badage the play result
    if (obj.reason === player.C.END_REASON.COMPLETE || obj.reason === player.C.END_REASON.ERROR) {
      ipc_cs["default"].ask('PANEL_UPDATE_BADGE', init_player_extends({
        type: 'play',
        blink: 5000,
        text: obj.reason === player.C.END_REASON.COMPLETE ? 'done' : 'err'
      }, obj.reason === player.C.END_REASON.COMPLETE ? {} : { color: 'orange' }));
    }

    if (store.getState().player.mode !== constant["PLAYER_MODE"].TEST_SUITE) {
      store.dispatch(actions["updateUI"]({ shouldEnableDesktopAutomation: undefined }));
    }
  });

  player.on('TO_PLAY', function (_ref41) {
    var index = _ref41.index,
        currentLoop = _ref41.currentLoop,
        loops = _ref41.loops,
        resource = _ref41.resource,
        extra = _ref41.extra;

    log_default()('TO_PLAY', index, resource, 'currentLoop', currentLoop);

    store.dispatch(actions["setPlayerState"](init_player_extends({
      timeoutStatus: null,
      nextCommandIndex: index
    }, extra.isBottomFrame ? {
      currentLoop: currentLoop,
      loops: loops
    } : {})));

    var triple = [resource.cmd, resource.target, resource.value];
    var str = [''].concat(triple, ['']).join(' | ');
    store.dispatch(actions["addLog"]('reflect', 'Executing: ' + str));

    // Note: show in badage the current command index (start from 1)
    ipc_cs["default"].ask('PANEL_UPDATE_BADGE', {
      type: 'play',
      text: '' + (index + 1)
    });
  });

  player.on('PLAYED_LIST', function (_ref42) {
    var indices = _ref42.indices;

    log_default()('PLAYED_LIST', indices);

    store.dispatch(actions["updateMacroDoneCommandsIndices"](Object(recomputed["getCurrentMacroId"])(store.getState()), indices));
  });

  player.on('ERROR', function (_ref43) {
    var errorIndex = _ref43.errorIndex,
        msg = _ref43.msg,
        restart = _ref43.restart;

    log_default.a.error('command index: ' + errorIndex + ', Error: ' + msg);
    store.dispatch(actions["addPlayerErrorCommandIndex"](errorIndex));
    store.dispatch(actions["addLog"]('error', msg));

    // Note: restart this player if restart is set to true in error, and it's not in test suite mode
    // Delay the execution so that 'END' event is emitted, and player is in stopped state
    if (restart && store.getState().player.mode === constant["PLAYER_MODE"].TEST_CASE) {
      setTimeout(function () {
        return player.replayLastConfig();
      }, 50);
    }
  });

  player.on('DELAY', function (_ref44) {
    var total = _ref44.total,
        past = _ref44.past;

    store.dispatch(actions["setPlayerState"]({
      timeoutStatus: {
        type: 'delay',
        total: total,
        past: past
      }
    }));
  });

  return player;
};

var init_player_initTestSuitPlayer = function initTestSuitPlayer(_ref45) {
  var store = _ref45.store,
      vars = _ref45.vars,
      tcPlayer = _ref45.tcPlayer,
      xCmdCounter = _ref45.xCmdCounter,
      ocrCmdCounter = _ref45.ocrCmdCounter,
      proxyCounter = _ref45.proxyCounter;

  var tsTracker = new TimeTracker();
  var tcTracker = new TimeTracker();
  var state = {
    isPlaying: false,
    tsId: null,
    lastErrMsg: '',
    testCasePromiseHandlers: null,
    reports: [],
    stopReason: null

  };
  var setState = function setState(st) {
    state = init_player_extends({}, state, st);
  };
  var addReport = function addReport(report) {
    setState({
      reports: state.reports.concat(report)
    });
  };
  var tsPlayer = Object(common_player["b" /* getPlayer */])({
    name: 'testSuite',
    prepare: function prepare() {
      setState({
        isPlaying: true,
        reports: []
      });

      vars.set({
        '!TESTSUITE_LOOP': 1,
        '!GLOBAL_TESTSUITE_STOP_ON_ERROR': false
      }, true);
    },
    run: function run(testCase, playerState) {
      var tcId = testCase.id;
      var tcLoops = testCase.loops > 1 ? parseInt(testCase.loops, 10) : 1;
      var state = store.getState();

      return Object(storage["getStorageManager"])().getMacroStorage().read(tcId, 'Text').then(function (tc) {
        var openTc = tc && tc.data.commands.find(function (c) {
          return c.cmd.toLowerCase() === 'open';
        });

        if (!tc) {
          throw new Error('macro does not exist');
        }

        // update editing && start to play tcPlayer
        store.dispatch(actions["editTestCase"](tc.id));
        store.dispatch(actions["playerPlay"]({
          macroId: tc.id,
          title: tc.name,
          extra: {
            id: tc.id,
            name: tc.name,
            shouldNotActivateTab: true
          },
          mode: tcLoops === 1 ? common_player["a" /* Player */].C.MODE.STRAIGHT : common_player["a" /* Player */].C.MODE.LOOP,
          loopsStart: 1,
          loopsEnd: tcLoops,
          startIndex: 0,
          startUrl: openTc ? openTc.target : null,
          resources: tc.data.commands,
          postDelay: state.config.playCommandInterval * 1000,
          // Note: This logic is to make sure !CMD_VAR${n} only take effect on first macro in a test suite
          overrideScope: playerState.nextIndex !== 0 ? {} : playerState.public.scope
        }));

        return new Promise(function (resolve, reject) {
          setState({
            testCasePromiseHandlers: { resolve: resolve, reject: reject }
          });
        });
      });
    },
    handleResult: function handleResult(result, testCase, state) {
      // return undefined, so that player will play the next one
      return Promise.resolve(undefined);
    }
  }, { preDelay: 0 });

  tsPlayer.on('START', function (_ref46) {
    var title = _ref46.title,
        extra = _ref46.extra;

    log_default()('START SUITE');
    tsTracker.reset();
    xCmdCounter.reset();
    proxyCounter.reset();

    setState({
      tsId: extra.id,
      isPlaying: true,
      stopReason: null
    });

    store.dispatch(actions["addLog"]('status', 'Playing test suite ' + title));
    store.dispatch(actions["setPlayerMode"](constant["PLAYER_MODE"].TEST_SUITE));
    store.dispatch(simple_actions["Actions"].updateTestSuite(extra.id, function (ts) {
      return init_player_extends({}, ts, {
        playStatus: {
          isPlaying: true,
          currentIndex: -1,
          errorIndices: [],
          doneIndices: []
        }
      });
    }));
  });

  tsPlayer.on('LOOP_START', function (_ref47) {
    var loopsCursor = _ref47.loopsCursor;

    vars.set({
      '!TESTSUITE_LOOP': loopsCursor
    }, true);
  });

  tsPlayer.on('LOOP_RESTART', function (_ref48) {
    var currentLoop = _ref48.currentLoop;

    store.dispatch(actions["addLog"]('status', 'Current test suite loop: ' + currentLoop));
  });

  tsPlayer.on('PAUSED', function (_ref49) {
    var extra = _ref49.extra;

    log_default()('PAUSED SUITE');
    store.dispatch(actions["addLog"]('status', 'Test suite paused'));
    tcPlayer.pause();
  });

  tsPlayer.on('RESUMED', function (_ref50) {
    var extra = _ref50.extra;

    log_default()('RESUMED SUIITE');
    store.dispatch(actions["addLog"]('status', 'Test suite resumed'));
    tcPlayer.resume();
  });

  tsPlayer.on('TO_PLAY', function (_ref51) {
    var index = _ref51.index,
        extra = _ref51.extra;

    tcTracker.reset();

    setState({
      lastErrMsg: '',
      tcIndex: index
    });

    store.dispatch(simple_actions["Actions"].updateTestSuite(extra.id, function (ts) {
      return init_player_extends({}, ts, {
        playStatus: init_player_extends({}, ts.playStatus, {
          currentIndex: index
        })
      });
    }));
  });

  tsPlayer.on('PLAYED_LIST', function (_ref52) {
    var indices = _ref52.indices,
        extra = _ref52.extra;

    store.dispatch(simple_actions["Actions"].updateTestSuite(extra.id, function (ts) {
      return init_player_extends({}, ts, {
        playStatus: init_player_extends({}, ts.playStatus, {
          doneIndices: indices
        })
      });
    }));
  });

  tsPlayer.on('END', function (_ref53) {
    var reason = _ref53.reason,
        extra = _ref53.extra,
        opts = _ref53.opts;

    if (!state.isPlaying) return;

    vars.set({
      '!TESTSUITE_LOOP': 1
    }, true);

    setState({
      isPlaying: false
    });

    // Note: reset player mode to 'test case', it will only be 'test suite'
    // during replays of test suites
    store.dispatch(actions["setPlayerMode"](constant["PLAYER_MODE"].TEST_CASE));
    store.dispatch(simple_actions["Actions"].updateTestSuite(extra.id, function (ts) {
      return init_player_extends({}, ts, {
        playStatus: init_player_extends({}, ts.playStatus, {
          isPlaying: false,
          currentIndex: -1
        })
      });
    }));

    store.dispatch(actions["updateUI"]({ shouldEnableDesktopAutomation: undefined }));

    if (reason === common_player["a" /* Player */].C.END_REASON.MANUAL && (!opts || !opts.tcPlayerStopped)) {
      tcPlayer.stop();
    }

    // Note: give it some time, in case we're stopping tc player above
    setTimeout(function () {
      var _statusMap;

      var totalCount = state.reports.length;
      var failureCount = state.reports.filter(function (r) {
        return r.stopReason === common_player["a" /* Player */].C.END_REASON.ERROR;
      }).length;
      var successCount = totalCount - failureCount;

      var statusMap = (_statusMap = {}, init_player_defineProperty(_statusMap, common_player["a" /* Player */].C.END_REASON.MANUAL, 'Manually stopped'), init_player_defineProperty(_statusMap, common_player["a" /* Player */].C.END_REASON.COMPLETE, 'OK'), init_player_defineProperty(_statusMap, common_player["a" /* Player */].C.END_REASON.ERROR, 'Error'), _statusMap);
      var tsStatus = statusMap[state.stopReason || reason];
      var lines = ['Test Suite name: ' + extra.name, 'Start Time: ' + tsTracker.startTime.toString(), 'Overall status: ' + tsStatus + ', Runtime: ' + tsTracker.elapsedInSeconds(), 'Macro run: ' + totalCount, 'Success: ' + successCount, 'Failure: ' + failureCount, 'Macro executed:'];

      var render = function render(_ref54) {
        var renderText = _ref54.renderText;

        return [react_default.a.createElement(
          'span',
          null,
          lines.join('\n')
        )].concat(init_player_toConsumableArray(state.reports.map(function (r, i) {
          return react_default.a.createElement(
            'div',
            null,
            r.name,
            '\xA0 (',
            statusMap[r.stopReason],
            r.stopReason === common_player["a" /* Player */].C.END_REASON.ERROR ? ': ' : '',
            r.stopReason === common_player["a" /* Player */].C.END_REASON.ERROR ? renderText({ type: 'error', text: r.errMsg, stack: r.stack }) : null,
            ', Runtime: ',
            r.usedTime,
            ')'
          );
        })));
      };

      store.dispatch(actions["addLog"]('report', render));
    }, 200);
  });

  // Test Case Player: we should handle cases when test case player stops automatically
  tcPlayer.on('END', function (_ref55) {
    var reason = _ref55.reason,
        extra = _ref55.extra;

    if (store.getState().player.mode !== constant["PLAYER_MODE"].TEST_SUITE) return;

    var btm = Object(call_stack["getMacroCallStack"])().bottom();
    var callStack = Object(call_stack["getMacroCallStack"])().toArray();
    var storeState = store.getState();
    var nextCommandIndex = storeState.player.lastNextCommandIndex;

    addReport({
      id: btm.resource.id,
      name: btm.resource.name,
      errMsg: state.lastErrMsg,
      stopReason: reason,
      usedTime: tcTracker.elapsedInSeconds(),
      stack: callStack.map(function (item, i) {
        return {
          macroId: item.resource.id,
          macroName: item.resource.name,
          commandIndex: i === callStack.length - 1 ? nextCommandIndex : item.runningStatus.nextIndex,
          isSubroutine: i !== 0
        };
      })
    });

    // Avoid a 'stop' loop between tsPlayer and tcPlayer
    switch (reason) {
      case common_player["a" /* Player */].C.END_REASON.MANUAL:
        break;

      case common_player["a" /* Player */].C.END_REASON.COMPLETE:
        // Note: delay the next macro run of test suite for a little bit,
        // so call stack has time to take care of itself first (like pop current frame)
        setTimeout(function () {
          state.testCasePromiseHandlers.resolve(true);
        }, 10);
        break;

      case common_player["a" /* Player */].C.END_REASON.ERROR:
        store.dispatch(simple_actions["Actions"].updateTestSuite(state.tsId, function (ts) {
          return init_player_extends({}, ts, {
            playStatus: init_player_extends({}, ts.playStatus, {
              errorIndices: ts.playStatus.errorIndices.concat([tsPlayer.state.nextIndex])
            })
          });
        }));

        setState({
          stopReason: common_player["a" /* Player */].C.END_REASON.ERROR
        });

        if (vars.get('!GLOBAL_TESTSUITE_STOP_ON_ERROR')) {
          state.testCasePromiseHandlers.reject(new Error());
          tsPlayer.stop({ tcPlayerStopped: true });
          break;
        }

        // Updated on 2017-12-15, Even if there is error, test suite should move on to next macro
        // Note: tell tsPlayer not to trigger tcPlayer stop again
        // tsPlayer.stop({ tcPlayerStopped: true })
        state.testCasePromiseHandlers.resolve(true);
        break;
    }
  });

  tcPlayer.on('ERROR', function (_ref56) {
    var msg = _ref56.msg,
        restart = _ref56.restart;

    setState({
      lastErrMsg: msg
    });

    // Note: restart this player if restart is set to true in error, and it's not in test suite mode
    // Delay the execution so that 'END' event is emitted, and player is in stopped state
    //
    // Note that a couple moments after tcPlayer encounters an error and enter stopped state, it tries to set player mode
    // back to test case mode  (in tsPlayer 'END' event)
    if (restart && store.getState().player.mode === constant["PLAYER_MODE"].TEST_SUITE) {
      setTimeout(function () {
        return tsPlayer.replayLastConfig();
      }, 50);
    }
  });

  return tsPlayer;
};
// EXTERNAL MODULE: ./src/common/convert_utils.js
var convert_utils = __webpack_require__(50);

// EXTERNAL MODULE: ./src/services/side/convert.ts
var side_convert = __webpack_require__(641);

// EXTERNAL MODULE: ./src/services/backup/restore.ts
var restore = __webpack_require__(642);

// EXTERNAL MODULE: ./src/services/api/http_api.ts
var http_api = __webpack_require__(523);

// EXTERNAL MODULE: ./src/services/license/types.ts
var license_types = __webpack_require__(84);

// CONCATENATED MODULE: ./src/components/header.js



























































































































































var header_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var header_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function header_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function header_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







































var ocrLanguageOptions = function () {
  var list = Object.keys(languages["languages"]).map(function (key) {
    return {
      text: languages["languages"][key].name,
      value: languages["languages"][key].lang
    };
  });

  list.sort(function (a, b) {
    if (a.text < b.text) return -1;
    if (a.text > b.text) return 1;
    return 0;
  });

  return list;
}();

var header_Header = function (_React$Component) {
  _inherits(Header, _React$Component);

  function Header() {
    var _ref;

    var _temp, _this, _ret;

    header_classCallCheck(this, Header);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Header.__proto__ || Object.getPrototypeOf(Header)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      showPlayLoops: false,
      loopsStart: 1,
      loopsEnd: 3,
      xModules: [Object(xfile["getXFile"])(), Object(x_user_io["getXUserIO"])(), Object(xdesktop["getXDesktop"])(), Object(x_screen_capture["getXScreenCapture"])()],
      xModuleData: {},
      xFileRootDirChanged: false,
      registerKey: '',
      websiteWhiteListText: '',

      // Security Tab - Encrypt Text
      textToEncrypt: '',
      encryptedText: '',
      showText: false,

      isCheckingLicense: false
    }, _this.getPlayer = function (name) {
      if (name) return Object(common_player["b" /* getPlayer */])({ name: name });

      switch (_this.props.player.mode) {
        case constant["PLAYER_MODE"].TEST_CASE:
          return Object(common_player["b" /* getPlayer */])({ name: 'testCase' });

        case constant["PLAYER_MODE"].TEST_SUITE:
          return Object(common_player["b" /* getPlayer */])({ name: 'testSuite' });
      }
    }, _this.getTestCaseName = function () {
      var src = _this.props.editing.meta.src;

      return src && src.name && src.name.length ? src.name : 'Untitled';
    }, _this.togglePlayLoopsModal = function (toShow) {
      _this.setState({
        showPlayLoops: toShow
      });
    }, _this.onToggleRecord = function () {
      if (Object(cv_utils["isCVTypeForDesktop"])(_this.props.config.cvScope)) {
        var msg = 'Recording is only available for browser automation. Desktop automation macros are created by adding XClick and other visual commands step by step.';

        _this.props.addLog('warning', msg);
        return message_default.a.warn(msg, 2.5);
      }

      if (_this.props.status === constant["APP_STATUS"].RECORDER) {
        _this.props.stopRecording();
        // Note: remove targetOptions from all commands
        _this.props.normalizeCommands();
      } else {
        _this.props.startRecording();
      }

      _this.setState({ lastOperation: 'record' });
    }, _this.onClickPlayLoops = function () {
      var _this$state = _this.state,
          loopsStart = _this$state.loopsStart,
          loopsEnd = _this$state.loopsEnd;


      if (loopsStart < 0) {
        return message_default.a.error('Start value must be no less than zero', 1.5);
      }

      if (loopsEnd < loopsStart) {
        return message_default.a.error('Max value must be greater than start value', 1.5);
      }

      var player = _this.getPlayer();
      var commands = _this.props.editing.commands;
      var src = _this.props.editing.meta.src;

      var openTc = commands.find(function (tc) {
        return tc.cmd.toLowerCase() === 'open';
      });

      _this.props.playerPlay({
        macroId: src && src.id,
        loopsEnd: loopsEnd,
        loopsStart: loopsStart,
        title: _this.getTestCaseName(),
        extra: {
          id: src && src.id
        },
        mode: player.C.MODE.LOOP,
        startIndex: 0,
        startUrl: openTc ? openTc.target : null,
        resources: _this.props.editing.commands,
        postDelay: _this.props.config.playCommandInterval * 1000
      });

      _this.setState({ lastOperation: 'play' });
      _this.togglePlayLoopsModal(false);
    }, _this.onCancelPlayLoops = function () {
      _this.togglePlayLoopsModal(false);
      _this.setState({
        loopsToPlay: 2
      });
    }, _this.onChangePlayLoops = function (field, value) {
      _this.setState(header_defineProperty({}, field, parseInt(value, 10)));
    }, _this.onClickSave = function () {
      return Object(save_test_case["default"])().save();
    }, _this.playCurrentMacro = function (isStep) {
      var commands = _this.props.editing.commands;
      var src = _this.props.editing.meta.src;

      var openTc = commands.find(function (tc) {
        return tc.cmd.toLowerCase() === 'open';
      });

      _this.setState({ lastOperation: 'play' });

      _this.props.playerPlay({
        macroId: src && src.id,
        title: _this.getTestCaseName(),
        extra: {
          id: src && src.id
        },
        mode: Object(common_player["b" /* getPlayer */])().C.MODE.STRAIGHT,
        startIndex: 0,
        startUrl: openTc ? openTc.target : null,
        resources: commands,
        postDelay: _this.props.config.playCommandInterval * 1000,
        isStep: isStep
      });
    }, _this.playCurrentLine = function () {
      var commands = _this.props.editing.commands;
      var _this$props$editing$m = _this.props.editing.meta,
          src = _this$props$editing$m.src,
          selectedIndex = _this$props$editing$m.selectedIndex;

      var commandIndex = selectedIndex === -1 ? 0 : selectedIndex || 0;

      return _this.props.playerPlay({
        macroId: src && src.id,
        title: _this.getTestCaseName(),
        extra: {
          id: src && src.id
        },
        mode: common_player["a" /* Player */].C.MODE.SINGLE,
        startIndex: commandIndex,
        startUrl: null,
        resources: commands,
        postDelay: _this.props.config.playCommandInterval * 1000,
        callback: function callback(err, res) {
          if (err) return;

          // Note: auto select next command
          if (commandIndex + 1 < commands.length) {
            _this.props.selectCommand(commandIndex + 1, true);
          }
        }
      });
    }, _this.checkRegisterKey = function () {
      var registerKey = _this.state.registerKey;

      var checkBasicPattern = function checkBasicPattern(str) {
        return str.length === 15 && str.charAt(0) === 'K';
      };
      var checkUnregistered = function checkUnregistered(str) {
        return str === 'freeman';
      };

      if (checkUnregistered(registerKey)) {
        _this.props.updateConfig({ xmodulesStatus: 'unregistered' });
        message_default.a.success('Unregistered');
        Object(storage["getStorageManager"])().emit(storage["StorageManagerEvent"].RootDirChanged);
        _this.resetRegisterKey();
        _this.forceUpdate();
        return;
      }

      var notifyLicenseError = function notifyLicenseError() {
        return message_default.a.error('Invalid license key');
      };

      if (!checkBasicPattern(registerKey)) {
        return notifyLicenseError();
      }

      _this.setState({ isCheckingLicense: true });

      return Object(services_license["getLicenseService"])().checkLicense(registerKey).then(function (license) {
        if (license.status === 'key_not_found') {
          return notifyLicenseError();
        }

        _this.resetRegisterKey();
        _this.forceUpdate();
        Object(storage["getStorageManager"])().emit(storage["StorageManagerEvent"].RootDirChanged);
        message_default.a.success('License key verified');
      }).catch(function (e) {
        var text = Object(http_api["isNetworkError"])(e) ? 'Internet connection required for activation. If you want use the software on a machine without Internet connection, please contact tech support' : e.message;

        message_default.a.error(text, 4);
      }).finally(function () {
        _this.setState({ isCheckingLicense: false });
      });
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  // Play loops relative


  header_createClass(Header, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var history = this.props.history;


      this.props.setRoute(history.location.pathname);
      this.props.history.listen(function (location, action) {
        _this2.props.setRoute(history.location.pathname);
      });

      Object(services_license["getLicenseService"])().getLatestInfo(function (info) {
        _this2.setState({
          licenseInfo: info
        });
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.ui.showSettings && !this.props.ui.showSettings) {
        this.onShowSettings();
      }

      if (nextProps.ui.showWebsiteWhiteList && !this.props.ui.showWebsiteWhiteList) {
        this.setState({
          websiteWhiteListText: (this.props.config.websiteWhiteList || []).join('\n')
        });
      }
    }
  }, {
    key: 'initXModules',
    value: function initXModules() {
      var _this3 = this;

      var xModules = this.state.xModules;

      // versionInfo: {
      //  installed: boolean
      //  version: string
      // },
      // checkResult: {
      //  error: string | null
      // }
      Promise.all(xModules.map(function (mod) {
        // Note: call init config for each xmodule and discard any error
        return mod.initConfig().catch(function (e) {}).then(function () {
          return mod.getVersion();
        }).then(function (versionInfo) {
          if (versionInfo.installed) {
            return mod.sanityCheck().then(function () {
              return { error: null };
            }, function (e) {
              return { error: e.message };
            }).then(function (checkResult) {
              return {
                versionInfo: versionInfo,
                checkResult: checkResult
              };
            });
          } else {
            return {
              versionInfo: versionInfo,
              checkResult: null
            };
          }
        });
      })).then(function (results) {
        var xModuleData = results.reduce(function (prev, r, i) {
          prev[xModules[i].getName()] = header_extends({}, r.versionInfo, {
            checkResult: r.checkResult,
            config: xModules[i].getCachedConfig()
          });
          return prev;
        }, {});

        _this3.setState({
          xModuleData: xModuleData,
          xFileRootDirChanged: false
        });
      });
    }
  }, {
    key: 'isEitherXModuleInstalled',
    value: function isEitherXModuleInstalled() {
      var xFileData = this.state.xModuleData[Object(xfile["getXFile"])().getName()];
      var xUserIOData = this.state.xModuleData[Object(x_user_io["getXUserIO"])().getName()];

      return xFileData && xFileData.installed || xUserIOData && xUserIOData.installed;
    }
  }, {
    key: 'resetRegisterKey',
    value: function resetRegisterKey() {
      this.setState({
        registerKey: ''
      });
    }
  }, {
    key: 'onShowSettings',
    value: function onShowSettings() {
      this.initXModules();
      this.resetRegisterKey();
    }
  }, {
    key: 'showSettingsModal',
    value: function showSettingsModal() {
      this.props.updateUI({ showSettings: true });
    }
  }, {
    key: 'renderPublicWebsiteWhiteList',
    value: function renderPublicWebsiteWhiteList() {
      var _this4 = this;

      return react_default.a.createElement(
        modal_default.a,
        {
          title: 'Embedded Macros Website Whitelist',
          className: 'whitelist-modal',
          width: 450,
          okText: 'Save',
          visible: this.props.ui.showWebsiteWhiteList,
          onCancel: function onCancel() {
            return _this4.props.updateUI({ showWebsiteWhiteList: false });
          },
          onOk: function onOk(close) {
            var text = _this4.state.websiteWhiteListText;
            var lines = text.split(/\n/g).map(function (str) {
              return str.trim();
            }).filter(function (str) {
              return str.length > 0;
            });

            _this4.props.updateConfig({ websiteWhiteList: lines });
            _this4.props.updateUI({ showWebsiteWhiteList: false });
            message_default.a.success('Saved');

            return Promise.resolve(true);
          }
        },
        react_default.a.createElement(
          'p',
          {
            style: { marginBottom: '10px' }
          },
          'Allow embedded macros to run ',
          react_default.a.createElement(
            'em',
            null,
            'without warning dialog'
          ),
          ', if started from the following sites:'
        ),
        react_default.a.createElement(input_default.a.TextArea, {
          placeholder: 'One url per line, e. g. https://ui.vision/rpa',
          autosize: { minRows: 6, maxRows: 12 },
          value: this.state.websiteWhiteListText,
          style: { resize: 'vertical' },
          onChange: function onChange(e) {
            return _this4.setState({ websiteWhiteListText: e.target.value });
          }
        }),
        react_default.a.createElement(
          'p',
          {
            style: { color: 'green', marginTop: '20px' }
          },
          react_default.a.createElement(
            'a',
            {
              style: { float: 'right', marginLeft: '20px' },
              href: 'https://ui.vision/x/idehelp?help=website_whitelist',
              target: '_blank'
            },
            'More info'
          ),
          'Only run embedded macros from websites you trust'
        )
      );
    }
  }, {
    key: 'renderPlayLoopModal',
    value: function renderPlayLoopModal() {
      var _this5 = this;

      return react_default.a.createElement(
        modal_default.a,
        {
          title: 'How many loops to play?',
          okText: 'Play',
          cancelText: 'Cancel',
          className: 'play-loop-modal',
          visible: this.state.showPlayLoops,
          onOk: this.onClickPlayLoops,
          onCancel: this.onCancelPlayLoops
        },
        react_default.a.createElement(
          row_default.a,
          null,
          react_default.a.createElement(
            col_default.a,
            { span: 10 },
            react_default.a.createElement(
              form_default.a.Item,
              { label: 'Start value' },
              react_default.a.createElement(input_default.a, {
                type: 'number',
                min: '0',
                value: this.state.loopsStart,
                onKeyDown: function onKeyDown(e) {
                  if (e.keyCode === 13) _this5.onClickPlayLoops();
                },
                onChange: function onChange(e) {
                  return _this5.onChangePlayLoops('loopsStart', e.target.value);
                }
              })
            )
          ),
          react_default.a.createElement(
            col_default.a,
            { span: 10, offset: 2 },
            react_default.a.createElement(
              form_default.a.Item,
              { label: 'Max' },
              react_default.a.createElement(input_default.a, {
                type: 'number',
                min: '0',
                value: this.state.loopsEnd,
                onKeyDown: function onKeyDown(e) {
                  if (e.keyCode === 13) _this5.onClickPlayLoops();
                },
                onChange: function onChange(e) {
                  return _this5.onChangePlayLoops('loopsEnd', e.target.value);
                }
              })
            )
          )
        ),
        react_default.a.createElement(
          'p',
          null,
          'The value of the loop counter is available in $',
          '{',
          '!LOOP',
          '}',
          ' variable'
        )
      );
    }
  }, {
    key: 'renderSettingModal',
    value: function renderSettingModal() {
      var _this6 = this;

      var onConfigChange = function onConfigChange(key, val) {
        _this6.props.updateConfig(header_defineProperty({}, key, val));
      };

      var displayConfig = {
        labelCol: { span: 8 },
        wrapperCol: { span: 16 }
      };

      return react_default.a.createElement(
        modal_default.a,
        {
          title: 'Settings',
          className: 'settings-modal',
          width: 650,
          footer: null,
          visible: this.props.ui.showSettings,
          onCancel: function onCancel() {
            _this6.props.updateUI({ showSettings: false });
            _this6.setState({ textToEncrypt: '', encryptedText: '' });
          }
        },
        react_default.a.createElement(
          tabs_default.a,
          {
            activeKey: this.props.ui.settingsTab || 'replay',
            onChange: function onChange(activeKey) {
              return _this6.props.updateUI({ settingsTab: activeKey });
            }
          },
          react_default.a.createElement(
            tabs_default.a.TabPane,
            { tab: 'Replay', key: 'replay' },
            react_default.a.createElement(
              form_default.a,
              null,
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({ label: 'Replay Helper' }, displayConfig),
                react_default.a.createElement(
                  checkbox_default.a,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('playScrollElementsIntoView', e.target.checked);
                    },
                    checked: this.props.config.playScrollElementsIntoView
                  },
                  'Scroll elements into view during replay'
                ),
                react_default.a.createElement(
                  checkbox_default.a,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('playHighlightElements', e.target.checked);
                    },
                    checked: this.props.config.playHighlightElements
                  },
                  'Highlight elements during replay'
                )
              ),
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({
                  label: react_default.a.createElement(
                    'a',
                    { target: '_blank', href: 'https://ui.vision/x/idehelp?help=command_interval' },
                    'Command Interval'
                  )
                }, displayConfig),
                react_default.a.createElement(
                  select_default.a,
                  {
                    style: { width: '200px' },
                    placeholder: 'interval',
                    value: '' + this.props.config.playCommandInterval,
                    onChange: function onChange(val) {
                      return onConfigChange('playCommandInterval', val);
                    }
                  },
                  react_default.a.createElement(
                    select_default.a.Option,
                    { value: '0' },
                    'Fast (no delay)'
                  ),
                  react_default.a.createElement(
                    select_default.a.Option,
                    { value: '0.3' },
                    'Medium (0.3s delay)'
                  ),
                  react_default.a.createElement(
                    select_default.a.Option,
                    { value: '2' },
                    'Slow (2s delay)'
                  )
                )
              ),
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({
                  label: react_default.a.createElement(
                    'a',
                    { target: '_blank', href: 'https://ui.vision/x/idehelp?help=timeout_pageload' },
                    '!TIMEOUT_PAGELOAD'
                  )
                }, displayConfig),
                react_default.a.createElement(input_default.a, {
                  type: 'number',
                  min: '0',
                  style: { width: '70px' },
                  value: this.props.config.timeoutPageLoad,
                  onChange: function onChange(e) {
                    return onConfigChange('timeoutPageLoad', e.target.value);
                  },
                  placeholder: 'in seconds'
                }),
                react_default.a.createElement(
                  'span',
                  { className: 'tip' },
                  'Max. time for new page load'
                )
              ),
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({
                  label: react_default.a.createElement(
                    'a',
                    { target: '_blank', href: 'https://ui.vision/x/idehelp?help=timeout_wait' },
                    '!TIMEOUT_WAIT'
                  )
                }, displayConfig),
                react_default.a.createElement(input_default.a, {
                  type: 'number',
                  min: '0',
                  style: { width: '70px' },
                  value: this.props.config.timeoutElement,
                  onChange: function onChange(e) {
                    return onConfigChange('timeoutElement', e.target.value);
                  },
                  placeholder: 'in seconds'
                }),
                react_default.a.createElement(
                  'span',
                  { className: 'tip' },
                  'Max. time per step'
                )
              ),
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({
                  label: react_default.a.createElement(
                    'a',
                    { target: '_blank', href: 'https://ui.vision/x/idehelp?help=timeout_macro' },
                    '!TIMEOUT_MACRO'
                  )
                }, displayConfig),
                react_default.a.createElement(input_default.a, {
                  type: 'number',
                  min: '0',
                  style: { width: '70px' },
                  value: this.props.config.timeoutMacro,
                  onChange: function onChange(e) {
                    return onConfigChange('timeoutMacro', e.target.value);
                  },
                  placeholder: 'in seconds'
                }),
                react_default.a.createElement(
                  'span',
                  { className: 'tip' },
                  'Max. overall macro runtime'
                )
              ),
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({
                  label: react_default.a.createElement(
                    'a',
                    { target: '_blank', href: 'https://ui.vision/x/idehelp?help=timeout_download' },
                    '!TIMEOUT_DOWNLOAD'
                  )
                }, displayConfig),
                react_default.a.createElement(input_default.a, {
                  type: 'number',
                  min: '0',
                  style: { width: '70px' },
                  value: this.props.config.timeoutDownload,
                  onChange: function onChange(e) {
                    return onConfigChange('timeoutDownload', e.target.value);
                  },
                  placeholder: 'in seconds'
                }),
                react_default.a.createElement(
                  'span',
                  { className: 'tip' },
                  'Max. allowed time for file'
                )
              ),
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({ label: 'If error happens in loop' }, displayConfig),
                react_default.a.createElement(
                  radio_default.a.Group,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('onErrorInLoop', e.target.value);
                    },
                    value: this.props.config.onErrorInLoop
                  },
                  react_default.a.createElement(
                    radio_default.a,
                    { value: 'continue_next_loop' },
                    'Continue next loop'
                  ),
                  react_default.a.createElement(
                    radio_default.a,
                    { value: 'stop' },
                    'Stop'
                  )
                )
              )
            )
          ),
          react_default.a.createElement(
            tabs_default.a.TabPane,
            { tab: 'API', key: 'api', className: 'api-pane' },
            react_default.a.createElement(
              'p',
              null,
              'The RPA command line API allows you to run macros and test suites from the command line and to control UI.Vision RPA from any scripting or programming language (',
              react_default.a.createElement(
                'a',
                { href: 'https://ui.vision/x/idehelp?help=cmdline', target: '_blank' },
                'more info'
              ),
              ').'
            ),
            react_default.a.createElement(
              'p',
              null,
              react_default.a.createElement(
                button_default.a,
                {
                  type: 'primary',
                  onClick: function onClick() {
                    var str = Object(convert_utils["generateEmptyHtml"])();
                    var blob = new Blob([str], { type: 'text/plain;charset=utf-8' });

                    file_saver_default.a.saveAs(blob, 'ui.vision.html', true);
                  }
                },
                'Generate Autostart HTML Page'
              )
            ),
            react_default.a.createElement(
              form_default.a,
              null,
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({
                  label: react_default.a.createElement(
                    'a',
                    { target: '_blank', href: 'https://ui.vision/x/idehelp?help=cmdline' },
                    'Allow Command Line'
                  )
                }, displayConfig, {
                  labelCol: { span: 6 }
                }),
                react_default.a.createElement(
                  checkbox_default.a,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('allowRunFromBookmark', e.target.checked);
                    },
                    checked: this.props.config.allowRunFromBookmark
                  },
                  'Run macro and test suite shortcuts from Javascript Bookmarklets'
                ),
                react_default.a.createElement(
                  checkbox_default.a,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('allowRunFromFileSchema', e.target.checked);
                    },
                    checked: this.props.config.allowRunFromFileSchema
                  },
                  'Run embedded macros from local files'
                ),
                react_default.a.createElement(
                  checkbox_default.a,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('allowRunFromHttpSchema', e.target.checked);
                    },
                    checked: this.props.config.allowRunFromHttpSchema
                  },
                  'Run embedded macros from public websites',
                  react_default.a.createElement(
                    'a',
                    {
                      href: '#',
                      style: {
                        position: 'relative',
                        marginLeft: '10px',
                        padding: '15px 0'
                      },
                      onClick: function onClick(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        _this6.props.updateUI({ showWebsiteWhiteList: true });
                      }
                    },
                    'Edit Whitelist'
                  )
                )
              )
            )
          ),
          react_default.a.createElement(
            tabs_default.a.TabPane,
            { tab: 'Selenium', key: 'selenium', className: 'selenium-pane' },
            react_default.a.createElement(
              'h4',
              null,
              'Import Selenium IDE Projects'
            ),
            react_default.a.createElement(
              'p',
              null,
              'Import web tests created in the classic Selenium IDE. Unknown commands (if any) are imported as comments. If you want us to add a certain not yet supported command, or find any other import issues, please let us know in the ',
              react_default.a.createElement(
                'a',
                { href: 'https://ui.vision/x/idehelp?help=forum', target: '_blank' },
                'user forum'
              ),
              '.'
            ),
            react_default.a.createElement(
              'div',
              { className: 'import-row' },
              react_default.a.createElement('input', {
                type: 'file',
                accept: '.side',
                id: 'select_side_file',
                ref: function ref(_ref2) {
                  _this6.sideFileInput = _ref2;
                },
                style: { display: 'none' },
                onChange: function onChange(e) {
                  setTimeout(function () {
                    _this6.sideFileInput.value = null;
                  }, 500);

                  var file = e.target.files[0];

                  Object(ts_utils["readFileAsText"])(file).then(function (sideText) {
                    var sideProject = JSON.parse(sideText);

                    Object(side_convert["importSideProject"])(sideProject).then(function (result) {
                      var lines = ['Project "' + result.projectName + '" import into folder: "' + result.folderName + '"', '- ' + result.macros.successCount + ' ' + (result.macros.successCount === 1 ? 'macro' : 'macros') + ' (imported)', '- ' + result.suites.ignoreCount + ' ' + (result.suites.ignoreCount === 1 ? 'test suite' : 'test suites') + ' (test suites are not imported yet)'];

                      _this6.props.addLog('info', lines.join('\n'));
                      message_default.a.success('Project "' + result.projectName + '" import into folder: "' + result.folderName + '"');
                    }).catch(function (e) {
                      message_default.a.error(e.message);
                    });
                  });
                }
              }),
              react_default.a.createElement(
                button_default.a,
                {
                  type: 'primary',
                  onClick: function onClick() {
                    var $el = document.querySelector('#select_side_file');

                    if ($el) {
                      $el.click();
                    }
                  }
                },
                'Import .SIDE projects'
              ),
              react_default.a.createElement(
                'span',
                null,
                'Imports projects from Selenium IDE V3.x (',
                react_default.a.createElement(
                  'a',
                  { href: 'https://ui.vision/x/idehelp?help=import_side', target: '_blank' },
                  'more info'
                ),
                ')'
              )
            ),
            react_default.a.createElement(
              'div',
              { className: 'import-row' },
              react_default.a.createElement('input', {
                multiple: true,
                type: 'file',
                accept: '.html',
                id: 'select_html_files_for_macros',
                ref: function ref(_ref3) {
                  _this6.jsonFileInput = _ref3;
                },
                style: { display: 'none' },
                onChange: function onChange(e) {
                  setTimeout(function () {
                    _this6.jsonFileInput.value = null;
                  }, 500);

                  return _this6.props.readFilesAndImportTestCases({
                    files: e.target.files,
                    type: 'text',
                    process: function process(content, fileName) {
                      return {
                        macros: [Object(convert_utils["fromHtml"])(content, fileName)],
                        csvs: [],
                        images: []
                      };
                    }
                  });
                }
              }),
              react_default.a.createElement(
                button_default.a,
                {
                  type: 'primary',
                  onClick: function onClick() {
                    var $el = document.querySelector('#select_html_files_for_macros');

                    if ($el) {
                      $el.click();
                    }
                  }
                },
                'Import .HTML projects'
              ),
              react_default.a.createElement(
                'span',
                null,
                'Import projects from Selenium IDE V2.x (',
                react_default.a.createElement(
                  'a',
                  { href: 'https://ui.vision/x/idehelp?help=import_html', target: '_blank' },
                  'more info'
                ),
                ')'
              )
            ),
            react_default.a.createElement(
              'h4',
              null,
              'Web Recording Options'
            ),
            react_default.a.createElement(
              form_default.a,
              null,
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({ label: 'Notification' }, displayConfig),
                react_default.a.createElement(
                  checkbox_default.a,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('recordNotification', e.target.checked);
                    },
                    checked: this.props.config.recordNotification
                  },
                  'Show notifications when recording'
                )
              ),
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({ label: 'Locators' }, displayConfig),
                react_default.a.createElement(
                  checkbox_default.a,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('saveAlternativeLocators', e.target.checked);
                    },
                    checked: this.props.config.saveAlternativeLocators
                  },
                  'Store alternative locators in macro (',
                  react_default.a.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?help=alternative_locators', target: '_blank' },
                    'more info'
                  ),
                  ')'
                )
              ),
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({ label: 'click / clickAt' }, displayConfig),
                react_default.a.createElement(
                  radio_default.a.Group,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('recordClickType', e.target.value);
                    },
                    value: this.props.config.recordClickType
                  },
                  react_default.a.createElement(
                    radio_default.a,
                    { value: 'click' },
                    'Record click'
                  ),
                  react_default.a.createElement(
                    radio_default.a,
                    { value: 'clickAt' },
                    'Record clickAt'
                  )
                )
              )
            ),
            react_default.a.createElement(
              'h4',
              null,
              'Proxy Options'
            ),
            react_default.a.createElement(
              form_default.a,
              null,
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({ label: 'Default Proxy (IP:Port)' }, displayConfig),
                react_default.a.createElement(input_default.a, {
                  type: 'text',
                  style: { width: '300px' },
                  value: this.props.config.defaultProxy,
                  onChange: function onChange(e) {
                    return onConfigChange('defaultProxy', e.target.value);
                  },
                  placeholder: 'eg. http://0.0.0.0:1234'
                })
              ),
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({ label: 'User name, Password' }, displayConfig),
                react_default.a.createElement(input_default.a, {
                  type: 'text',
                  style: { width: '300px' },
                  value: this.props.config.defaultProxyAuth,
                  onChange: function onChange(e) {
                    return onConfigChange('defaultProxyAuth', e.target.value);
                  },
                  placeholder: 'eg. admin, mypassword'
                })
              ),
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({ label: 'Status' }, displayConfig),
                react_default.a.createElement(
                  radio_default.a.Group,
                  {
                    value: this.props.proxy ? 'on' : 'off',
                    onChange: function onChange(e) {
                      switch (e.target.value) {
                        case 'off':
                          return ipc_cs["default"].ask('PANEL_SET_PROXY', { proxy: null });

                        case 'on':
                          {
                            var proxy = void 0;

                            try {
                              proxy = Object(services_proxy["parseProxyUrl"])(_this6.props.config.defaultProxy, _this6.props.config.defaultProxyAuth);
                            } catch (e) {
                              return message_default.a.error(e.message);
                            }

                            return ipc_cs["default"].ask('PANEL_SET_PROXY', { proxy: proxy });
                          }
                      }
                    }
                  },
                  react_default.a.createElement(
                    radio_default.a,
                    { value: 'on' },
                    'Proxy ON'
                  ),
                  react_default.a.createElement(
                    radio_default.a,
                    { value: 'off' },
                    'Proxy OFF'
                  )
                ),
                react_default.a.createElement(
                  checkbox_default.a,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('turnOffProxyAfterReplay', e.target.checked);
                    },
                    checked: this.props.config.turnOffProxyAfterReplay
                  },
                  'Turn off at end of replay (Proxy controlled by ',
                  react_default.a.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?cmd=setproxy', target: '_blank' },
                    'setProxy command'
                  ),
                  ')'
                )
              )
            ),
            react_default.a.createElement(
              'h4',
              null,
              'Old-Style Test Cases'
            ),
            react_default.a.createElement(
              form_default.a,
              null,
              react_default.a.createElement(
                form_default.a.Item,
                header_extends({ label: 'Sidebar' }, displayConfig),
                react_default.a.createElement(
                  checkbox_default.a,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('showTestCaseTab', e.target.checked);
                    },
                    checked: this.props.config.showTestCaseTab
                  },
                  'Show test case tab (',
                  react_default.a.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?help=old_style_test_cases', target: '_blank' },
                    'more info'
                  ),
                  ')'
                )
              )
            )
          ),
          react_default.a.createElement(
            tabs_default.a.TabPane,
            { tab: 'Backup', key: 'backup', className: 'backup-pane' },
            react_default.a.createElement(
              'h4',
              null,
              'Automatic Backup'
            ),
            react_default.a.createElement(
              'p',
              null,
              'The automatic backup reminder helps to you to regularly export macros and other data as ZIP archive. As browser extension UI.Vision RPA must store its data ',
              react_default.a.createElement(
                'em',
                null,
                'inside the browser extension'
              ),
              '. This means that when you uninstall the extension, the data is removed, too. Therefore it is good to have backups! Note that if the hard drive storage mode of the File Access XModule is active, then the backup archive contains these files.'
            ),
            react_default.a.createElement(
              'div',
              { className: 'row' },
              react_default.a.createElement(checkbox_default.a, {
                onChange: function onChange(e) {
                  return onConfigChange('enableAutoBackup', e.target.checked);
                },
                checked: this.props.config.enableAutoBackup
              }),
              react_default.a.createElement(
                'span',
                null,
                'Show backup reminder every'
              ),
              react_default.a.createElement(input_default.a, {
                type: 'number',
                min: 1,
                disabled: !this.props.config.enableAutoBackup,
                value: this.props.config.autoBackupInterval,
                onChange: function onChange(e) {
                  return onConfigChange('autoBackupInterval', e.target.value);
                },
                style: { width: '40px' }
              }),
              react_default.a.createElement(
                'span',
                null,
                ' days'
              )
            ),
            react_default.a.createElement(
              'div',
              { className: 'row' },
              react_default.a.createElement(
                'p',
                null,
                'Backup includes'
              ),
              react_default.a.createElement(
                'ul',
                null,
                react_default.a.createElement(
                  'li',
                  null,
                  react_default.a.createElement(checkbox_default.a, {
                    onChange: function onChange(e) {
                      return onConfigChange('autoBackupTestCases', e.target.checked);
                    },
                    checked: this.props.config.autoBackupTestCases
                  }),
                  react_default.a.createElement(
                    'span',
                    null,
                    'Macros and Folders (includes Folders as Test Suites)'
                  )
                ),
                react_default.a.createElement(
                  'li',
                  null,
                  react_default.a.createElement(checkbox_default.a, {
                    onChange: function onChange(e) {
                      return onConfigChange('autoBackupTestSuites', e.target.checked);
                    },
                    checked: this.props.config.autoBackupTestSuites
                  }),
                  react_default.a.createElement(
                    'span',
                    null,
                    'Old-style Test Suites'
                  )
                ),
                react_default.a.createElement(
                  'li',
                  null,
                  react_default.a.createElement(checkbox_default.a, {
                    onChange: function onChange(e) {
                      return onConfigChange('autoBackupScreenshots', e.target.checked);
                    },
                    checked: this.props.config.autoBackupScreenshots
                  }),
                  react_default.a.createElement(
                    'span',
                    null,
                    'Screenshots'
                  )
                ),
                react_default.a.createElement(
                  'li',
                  null,
                  react_default.a.createElement(checkbox_default.a, {
                    onChange: function onChange(e) {
                      return onConfigChange('autoBackupCSVFiles', e.target.checked);
                    },
                    checked: this.props.config.autoBackupCSVFiles
                  }),
                  react_default.a.createElement(
                    'span',
                    null,
                    'CSV Files'
                  )
                ),
                react_default.a.createElement(
                  'li',
                  null,
                  react_default.a.createElement(checkbox_default.a, {
                    onChange: function onChange(e) {
                      return onConfigChange('autoBackupVisionImages', e.target.checked);
                    },
                    checked: this.props.config.autoBackupVisionImages
                  }),
                  react_default.a.createElement(
                    'span',
                    null,
                    'Visual UI Test images'
                  )
                )
              )
            ),
            react_default.a.createElement(
              'div',
              { className: 'row' },
              react_default.a.createElement(
                button_default.a,
                {
                  type: 'primary',
                  onClick: function onClick() {
                    return _this6.props.runBackup();
                  }
                },
                'Run Backup Now'
              ),
              react_default.a.createElement(
                'span',
                null,
                ' Create a backup ZIP file now.'
              )
            ),
            react_default.a.createElement(
              'div',
              {
                style: { paddingTop: '30px' },
                className: 'row'
              },
              react_default.a.createElement(
                button_default.a,
                {
                  type: 'primary',
                  onClick: function onClick() {
                    var $input = document.getElementById('select_zip_file');

                    if ($input) {
                      $input.click();
                    }
                  }
                },
                'Restore Data from Backup'
              ),
              react_default.a.createElement(
                'span',
                null,
                ' Select a backup ZIP file to import it (',
                react_default.a.createElement(
                  'a',
                  { href: 'https://ui.vision/x/idehelp?help=bkup_import', target: '_blank' },
                  'more info'
                ),
                '). '
              ),
              react_default.a.createElement('input', {
                type: 'file',
                accept: '.zip',
                id: 'select_zip_file',
                ref: function ref(_ref4) {
                  _this6.zipFileInput = _ref4;
                },
                style: { display: 'none' },
                onChange: function onChange(e) {
                  setTimeout(function () {
                    _this6.zipFileInput.value = null;
                  }, 500);

                  var file = e.target.files[0];

                  Object(restore["restoreBackup"])({
                    file: file,
                    storage: Object(storage["getStorageManager"])().getCurrentStrategyType()
                  }).then(function (result) {
                    Object(storage["getStorageManager"])().emit(storage["StorageManagerEvent"].ForceReload);
                    message_default.a.success('Backup restored');

                    _this6.props.addLog('info', ['Backup restored:', result.count.macro + ' macros', result.count.testSuite + ' test suites', result.count.csv + ' csvs', result.count.screenshot + ' screenshots', result.count.vision + ' vision images'].join('\n'));
                  }, function (e) {
                    message_default.a.error('Failed to restore: ' + e.message);
                    console.error(e);
                  });
                }
              })
            )
          ),
          react_default.a.createElement(
            tabs_default.a.TabPane,
            { tab: 'Security', key: 'security', className: 'security-pane' },
            react_default.a.createElement(
              'h4',
              null,
              'Master password for Password Encryption'
            ),
            react_default.a.createElement(
              'p',
              null,
              'A master password is used to encrypt and decrypt all stored website passwords. The websites passwords are encrypted using strong encryption.\xA0\xA0',
              react_default.a.createElement(
                'a',
                { target: '_blank', href: 'https://ui.vision/x/idehelp?help=encryption' },
                'More info >>'
              )
            ),
            react_default.a.createElement(
              'div',
              null,
              react_default.a.createElement(
                radio_default.a.Group,
                {
                  onChange: function onChange(e) {
                    return onConfigChange('shouldEncryptPassword', e.target.value);
                  },
                  value: this.props.config.shouldEncryptPassword
                },
                react_default.a.createElement(
                  radio_default.a,
                  { value: 'no' },
                  'Do not encrypt passwords'
                ),
                react_default.a.createElement(
                  radio_default.a,
                  { value: 'master_password' },
                  'Enter master password here to store it'
                )
              ),
              this.props.config.shouldEncryptPassword === 'master_password' ? react_default.a.createElement(
                'div',
                null,
                react_default.a.createElement(
                  'div',
                  null,
                  react_default.a.createElement(
                    'label',
                    null,
                    'Master password:'
                  ),
                  react_default.a.createElement(input_default.a, {
                    type: 'password',
                    style: { width: '200px' },
                    value: this.props.config.masterPassword,
                    onChange: function onChange(e) {
                      return onConfigChange('masterPassword', e.target.value);
                    }
                  })
                ),
                react_default.a.createElement(
                  'div',
                  null,
                  react_default.a.createElement('hr', { style: { margin: '20px 0' } }),
                  react_default.a.createElement(
                    'h4',
                    null,
                    'Create encrypted text string'
                  ),
                  react_default.a.createElement(
                    'p',
                    null,
                    'The feature uses the master password to encrypt text. The encrypted string can be used with TYPE, SENDKEY and XTYPE.'
                  ),
                  react_default.a.createElement(
                    'div',
                    { className: 'input-line' },
                    react_default.a.createElement(
                      'span',
                      { className: 'input-label' },
                      'Text to encrypt:'
                    ),
                    react_default.a.createElement(input_default.a, {
                      type: this.state.showText ? 'text' : 'password',
                      style: { width: '200px' },
                      value: this.state.textToEncrypt,
                      onChange: function onChange(e) {
                        _this6.setState({
                          textToEncrypt: e.target.value,
                          encryptedText: ''
                        });
                      }
                    }),
                    react_default.a.createElement(
                      checkbox_default.a,
                      {
                        onChange: function onChange(e) {
                          _this6.setState({ showText: e.target.checked });
                        },
                        checked: this.state.showText
                      },
                      'Show text'
                    )
                  ),
                  react_default.a.createElement(
                    'div',
                    { className: 'input-line' },
                    react_default.a.createElement(
                      'span',
                      { className: 'input-label' },
                      'Encrypted string:'
                    ),
                    react_default.a.createElement(input_default.a, {
                      readOnly: true,
                      type: 'text',
                      style: { width: '200px' },
                      value: this.state.encryptedText
                    })
                  ),
                  react_default.a.createElement(
                    'div',
                    { className: 'input-line' },
                    react_default.a.createElement('span', { className: 'input-label' }),
                    react_default.a.createElement(
                      button_default.a,
                      {
                        type: 'primary',
                        onClick: function onClick() {
                          Object(encrypt["b" /* encrypt */])(_this6.state.textToEncrypt).then(function (text) {
                            _this6.setState({ encryptedText: text });

                            copy_to_clipboard_default()(text, {
                              format: 'text/plain'
                            });

                            message_default.a.success('Copied to clipboard');
                          });
                        }
                      },
                      'Encrypt & Copy'
                    ),
                    react_default.a.createElement(
                      'a',
                      { href: 'https://ui.vision/x/idehelp?help=encrypt', target: '_blank' },
                      '(More info)'
                    )
                  )
                )
              ) : null
            )
          ),
          react_default.a.createElement(
            tabs_default.a.TabPane,
            {
              tab: 'OCR',
              key: 'ocr',
              className: Object(utils["cn"])('ocr-pane', {
                'ocr-disabled': this.props.config.ocrMode === 'disabled',
                'ocr-enabled': this.props.config.ocrMode === 'enabled',
                'ocr-offline': this.props.config.ocrMode === 'offline_enabled'
              })
            },
            react_default.a.createElement(
              'p',
              null,
              'This tab manages the ',
              react_default.a.createElement(
                'a',
                { href: 'https://ui.vision/x/idehelp?help=ocr', target: '_blank' },
                'OCR commands'
              ),
              '. Please note that the Online OCR option sends screenshots to our Cloud OCR API. All screenshots are deleted after processing. But since this means that data leaves your machine, you must explicitly allow it. By default (after installation) Online OCR is disabled.'
            ),
            react_default.a.createElement(
              'div',
              { className: 'row' },
              react_default.a.createElement(
                radio_default.a.Group,
                {
                  className: 'radio-block',
                  onChange: function onChange(e) {
                    return onConfigChange('ocrMode', e.target.value);
                  },
                  value: this.props.config.ocrMode
                },
                react_default.a.createElement(
                  radio_default.a,
                  { value: 'disabled' },
                  'OCR feature disabled'
                ),
                react_default.a.createElement(
                  radio_default.a,
                  { value: 'enabled' },
                  'Online OCR enabled (',
                  react_default.a.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?help=ocronline', target: '_blank' },
                    'more info'
                  ),
                  ')',
                  react_default.a.createElement('br', null),
                  'Conversion counter: You used ',
                  Object(command_counter["getOcrCommandCounter"])().get(),
                  ' from ',
                  Object(command_counter["getOcrCommandCounter"])().getMaximum(),
                  ' conversions/day (',
                  react_default.a.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?help=ocradd', target: '_blank' },
                    'add more'
                  ),
                  ')'
                ),
                react_default.a.createElement(
                  radio_default.a,
                  {
                    value: 'offline_enabled',
                    disabled: !Object(services_license["getLicenseService"])().isProLicense(),
                    'class': Object(utils["cn"])({ 'need-pro': !Object(services_license["getLicenseService"])().isProLicense() })
                  },
                  'Offline OCR - use ',
                  react_default.a.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?help=ocroffline', target: '_blank' },
                    'local OCR engine'
                  ),
                  ' (Requires XModules Enterprise Edition)',
                  react_default.a.createElement('br', null),
                  react_default.a.createElement(
                    'span',
                    { className: 'offline-label' },
                    'Local OCR'
                  ),
                  react_default.a.createElement(input_default.a, {
                    type: 'text',
                    style: { width: '200px' },
                    disabled: this.props.config.ocrMode !== 'offline_enabled',
                    value: this.props.config.ocrOfflineURL,
                    onChange: function onChange(e) {
                      return onConfigChange('ocrOfflineURL', e.target.value);
                    }
                  }),
                  react_default.a.createElement('br', null),
                  react_default.a.createElement(
                    'span',
                    { className: 'offline-label' },
                    'Local API key'
                  ),
                  react_default.a.createElement(input_default.a, {
                    type: 'password',
                    style: { width: '200px' },
                    disabled: this.props.config.ocrMode !== 'offline_enabled',
                    value: this.props.config.ocrOfflineAPIKey,
                    onChange: function onChange(e) {
                      return onConfigChange('ocrOfflineAPIKey', e.target.value);
                    }
                  })
                )
              )
            ),
            react_default.a.createElement(
              'div',
              { className: 'row' },
              react_default.a.createElement(
                'p',
                null,
                react_default.a.createElement(
                  'span',
                  { className: 'label-text' },
                  'Default OCR Engine'
                ),
                react_default.a.createElement(
                  radio_default.a.Group,
                  {
                    onChange: function onChange(e) {
                      return onConfigChange('ocrEngine', parseInt(e.target.value, 10));
                    },
                    value: '' + this.props.config.ocrEngine
                  },
                  react_default.a.createElement(
                    radio_default.a,
                    { value: '1' },
                    'Engine 1'
                  ),
                  react_default.a.createElement(
                    radio_default.a,
                    { value: '2' },
                    'Engine 2'
                  )
                )
              )
            ),
            react_default.a.createElement(
              'div',
              { className: 'row' },
              react_default.a.createElement(
                'p',
                null,
                react_default.a.createElement(
                  'span',
                  { className: 'label-text' },
                  'Default OCR language'
                ),
                react_default.a.createElement(
                  select_default.a,
                  {
                    style: { width: '150px' },
                    placeholder: 'OCR Language',
                    value: this.props.config.ocrLanguage,
                    disabled: this.props.config.ocrMode === 'disabled' || this.props.config.ocrEngine === 2,
                    onChange: function onChange(val) {
                      return onConfigChange('ocrLanguage', val);
                    }
                  },
                  ocrLanguageOptions.map(function (item) {
                    return react_default.a.createElement(
                      select_default.a.Option,
                      { value: item.value, key: item.value },
                      item.text
                    );
                  })
                )
              ),
              react_default.a.createElement(
                'div',
                null,
                'You can overwrite the default OCR settings in the macro with ',
                react_default.a.createElement(
                  'a',
                  { href: 'https://ui.vision/x/idehelp?help=ocrlanguage', target: '_blank' },
                  '!OCRLanguage'
                ),
                ' and ',
                react_default.a.createElement(
                  'a',
                  { href: 'https://ui.vision/x/idehelp?help=ocrengine', target: '_blank' },
                  '!OCREngine'
                ),
                '.'
              )
            ),
            react_default.a.createElement(
              'div',
              { className: 'row' },
              react_default.a.createElement(
                'p',
                null,
                react_default.a.createElement(
                  button_default.a,
                  {
                    type: 'primary',
                    loading: this.state.testingOcrAPI,
                    disabled: this.props.config.ocrMode === 'disabled',
                    onClick: function onClick() {
                      _this6.setState({
                        testingOcrAPI: true
                      });

                      init_player_ocrViewport({
                        store: window['store'],
                        isDesktop: Object(cv_utils["isCVTypeForDesktop"])(_this6.props.config.cvScope)
                      }).catch(function (e) {
                        message_default.a.error(e.message);
                      }).then(function () {
                        _this6.setState({
                          testingOcrAPI: false
                        });
                      });
                    }
                  },
                  'Show OCR Overlay'
                )
              ),
              react_default.a.createElement(
                'p',
                null,
                'The test runs OCR on the currently active browser tab and displays the result as overlay.'
              )
            )
          ),
          react_default.a.createElement(
            tabs_default.a.TabPane,
            { tab: 'Vision', key: 'vision', className: 'vision-pane' },
            react_default.a.createElement(
              'p',
              null,
              'UI.Vision RPA\'s eyes can look inside the web browser or search the complete desktop.'
            ),
            react_default.a.createElement(
              'div',
              { className: 'row' },
              react_default.a.createElement(
                radio_default.a.Group,
                {
                  onChange: function onChange(e) {
                    return onConfigChange('cvScope', e.target.value);
                  },
                  value: this.props.config.cvScope
                },
                react_default.a.createElement(
                  radio_default.a,
                  { value: 'browser' },
                  'Browser Automation (Look inside browser)'
                ),
                react_default.a.createElement(
                  radio_default.a,
                  {
                    value: 'desktop',
                    disabled: !(this.state.xModuleData[Object(xdesktop["getXDesktop"])().getName()] && this.state.xModuleData[Object(xdesktop["getXDesktop"])().getName()].installed)
                  },
                  react_default.a.createElement(
                    'span',
                    null,
                    'Desktop Automation (Search complete desktop)'
                  ),
                  this.state.xModuleData[Object(xdesktop["getXDesktop"])().getName()] && this.state.xModuleData[Object(xdesktop["getXDesktop"])().getName()].installed ? null : react_default.a.createElement(
                    'a',
                    {
                      target: '_blank',
                      href: Object(xdesktop["getXDesktop"])().downloadLink(),
                      style: {
                        marginLeft: '15px'
                      }
                    },
                    'Install the DesktopAutomation XModule first.'
                  ),
                  react_default.a.createElement(
                    'div',
                    null,
                    react_default.a.createElement(
                      checkbox_default.a,
                      {
                        onChange: function onChange(e) {
                          return onConfigChange('useDesktopScreenCapture', e.target.checked);
                        },
                        checked: this.props.config.useDesktopScreenCapture,
                        disabled: this.props.config.cvScope !== 'desktop' || !(this.state.xModuleData[Object(x_screen_capture["getXScreenCapture"])().getName()] && this.state.xModuleData[Object(x_screen_capture["getXScreenCapture"])().getName()].installed)
                      },
                      react_default.a.createElement(
                        'span',
                        null,
                        'Use native ',
                        react_default.a.createElement(
                          'a',
                          { href: Object(x_screen_capture["getXScreenCapture"])().infoLink(), target: '_blank' },
                          'desktop screen capture (BETA)'
                        ),
                        ' if installed (see XModule below)'
                      ),
                      this.state.xModuleData[Object(x_screen_capture["getXScreenCapture"])().getName()] && this.state.xModuleData[Object(x_screen_capture["getXScreenCapture"])().getName()].installed ? null : react_default.a.createElement(
                        'a',
                        {
                          target: '_blank',
                          href: Object(x_screen_capture["getXScreenCapture"])().downloadLink(),
                          style: {
                            marginLeft: '15px'
                          }
                        },
                        'Install the ScreenCapture XModule first.'
                      )
                    )
                  )
                )
              )
            ),
            react_default.a.createElement(
              'p',
              null,
              'Inside a macro the computer vision scope can be changed with the ',
              react_default.a.createElement(
                'a',
                { href: Object(xdesktop["getXDesktop"])().infoLink(), target: '_blank' },
                'XDesktopAutomation'
              ),
              ' command. In addition, you can restrict the image search  area with the ',
              react_default.a.createElement(
                'a',
                { href: 'https://ui.vision/x/idehelp?help=limitsearcharea', target: '_blank' },
                'visionLimitSearchArea'
              ),
              ' command.'
            ),
            react_default.a.createElement(
              'div',
              { className: 'row', style: { marginTop: '30px' } },
              react_default.a.createElement(
                'p',
                null,
                'Default Vision Search Confidence'
              ),
              react_default.a.createElement(
                select_default.a,
                {
                  style: { width: '200px' },
                  placeholder: 'interval',
                  value: '' + this.props.config.defaultVisionSearchConfidence,
                  onChange: function onChange(val) {
                    return onConfigChange('defaultVisionSearchConfidence', parseFloat(val));
                  }
                },
                Object(utils["range"])(1, 11, 1).map(function (n) {
                  return react_default.a.createElement(
                    select_default.a.Option,
                    { key: n, value: '' + (0.1 * n).toFixed(1) },
                    (0.1 * n).toFixed(1)
                  );
                })
              )
            ),
            react_default.a.createElement(
              'div',
              { className: 'row', style: { marginTop: '30px' } },
              react_default.a.createElement(
                checkbox_default.a,
                {
                  onChange: function onChange(e) {
                    return onConfigChange('waitBeforeDesktopScreenCapture', e.target.checked);
                  },
                  checked: this.props.config.waitBeforeDesktopScreenCapture
                },
                react_default.a.createElement(
                  'span',
                  null,
                  'Wait'
                ),
                react_default.a.createElement(input_default.a, {
                  type: 'number',
                  min: '0',
                  max: '60',
                  value: this.props.config.secondsBeforeDesktopScreenCapture,
                  style: { width: '60px', margin: '0 10px' },
                  onChange: function onChange(e) {
                    return onConfigChange('secondsBeforeDesktopScreenCapture', Math.min(60, Number(e.target.value)));
                  }
                }),
                react_default.a.createElement(
                  'span',
                  null,
                  'seconds before taking screenshots. This allows you to switch windows'
                )
              )
            ),
            react_default.a.createElement(
              'div',
              {
                style: { margin: '30px 0 0' },
                className: 'xmodule-item'
              },
              react_default.a.createElement(
                'div',
                { className: 'xmodule-title' },
                react_default.a.createElement(
                  'span',
                  null,
                  react_default.a.createElement(
                    'b',
                    null,
                    'Screen Capture XModule'
                  ),
                  ' - Select images more quickly'
                ),
                react_default.a.createElement(
                  'a',
                  { href: Object(x_screen_capture["getXScreenCapture"])().infoLink(), target: '_blank' },
                  'More Info'
                ),
                react_default.a.createElement(
                  button_default.a,
                  {
                    type: 'primary',
                    onClick: function onClick() {
                      Object(x_screen_capture["getXScreenCapture"])().getVersion().then(function (data) {
                        var installed = data.installed,
                            version = data.version;

                        var msg = installed ? 'Installed (v' + version + ')' : 'Not Installed';
                        message_default.a.info('status updated: ' + msg);

                        _this6.setState(Object(utils["updateIn"])(['xModuleData', Object(x_screen_capture["getXScreenCapture"])().getName()], function (orig) {
                          return header_extends({}, orig, data, { config: Object(x_screen_capture["getXScreenCapture"])().getCachedConfig() });
                        }, _this6.state));
                      });
                    }
                  },
                  'Test it'
                )
              ),
              react_default.a.createElement(
                'div',
                { className: 'xmodule-status' },
                react_default.a.createElement(
                  'label',
                  null,
                  'Status:'
                ),
                this.state.xModuleData[Object(x_screen_capture["getXScreenCapture"])().getName()] && this.state.xModuleData[Object(x_screen_capture["getXScreenCapture"])().getName()].installed ? react_default.a.createElement(
                  'div',
                  { className: 'status-box' },
                  react_default.a.createElement(
                    'span',
                    null,
                    'Installed (v',
                    this.state.xModuleData[Object(x_screen_capture["getXScreenCapture"])().getName()].version,
                    ')'
                  ),
                  react_default.a.createElement(
                    'a',
                    {
                      target: '_blank',
                      href: Object(x_screen_capture["getXScreenCapture"])().checkUpdateLink(this.state.xModuleData[Object(x_screen_capture["getXScreenCapture"])().getName()] && this.state.xModuleData[Object(x_screen_capture["getXScreenCapture"])().getName()].version, web_extension_default.a.runtime.getManifest().version)
                    },
                    'Check for update'
                  )
                ) : react_default.a.createElement(
                  'div',
                  { className: 'status-box' },
                  react_default.a.createElement(
                    'span',
                    null,
                    'Not Installed'
                  ),
                  react_default.a.createElement(
                    'a',
                    { href: Object(x_screen_capture["getXScreenCapture"])().downloadLink(), target: '_blank' },
                    'Download it'
                  )
                )
              )
            )
          ),
          react_default.a.createElement(
            tabs_default.a.TabPane,
            { tab: 'XModules', key: 'xmodules', className: 'xmodules-pane' },
            react_default.a.createElement(
              'div',
              { className: 'xmodule-item' },
              react_default.a.createElement(
                'div',
                { className: 'xmodule-title' },
                react_default.a.createElement(
                  'span',
                  null,
                  react_default.a.createElement(
                    'b',
                    null,
                    'FileAccess XModule'
                  ),
                  ' - Read and write to your hard drive'
                ),
                react_default.a.createElement(
                  'a',
                  { href: Object(xfile["getXFile"])().infoLink(), target: '_blank' },
                  'More Info'
                ),
                react_default.a.createElement(
                  button_default.a,
                  {
                    type: 'primary',
                    onClick: function onClick() {
                      Object(xfile["getXFile"])().getVersion().then(function (data) {
                        var installed = data.installed,
                            version = data.version;

                        var msg = installed ? 'Installed (v' + version + ')' : 'Not Installed';
                        message_default.a.info('status updated: ' + msg);

                        var p = !installed ? Promise.resolve() : Object(xfile["getXFile"])().initConfig();

                        p.catch(function (e) {}).then(function () {
                          _this6.setState(Object(utils["updateIn"])(['xModuleData', Object(xfile["getXFile"])().getName()], function (orig) {
                            return header_extends({}, orig, data, { config: Object(xfile["getXFile"])().getCachedConfig() });
                          }, _this6.state));
                        });
                      });
                    }
                  },
                  'Test it'
                )
              ),
              react_default.a.createElement(
                'div',
                { className: 'xmodule-status' },
                react_default.a.createElement(
                  'label',
                  null,
                  'Status:'
                ),
                this.state.xModuleData[Object(xfile["getXFile"])().getName()] && this.state.xModuleData[Object(xfile["getXFile"])().getName()].installed ? react_default.a.createElement(
                  'div',
                  { className: 'status-box' },
                  react_default.a.createElement(
                    'span',
                    null,
                    'Installed (v',
                    this.state.xModuleData[Object(xfile["getXFile"])().getName()].version,
                    ')'
                  ),
                  react_default.a.createElement(
                    'a',
                    {
                      target: '_blank',
                      href: Object(xfile["getXFile"])().checkUpdateLink(this.state.xModuleData[Object(xfile["getXFile"])().getName()] && this.state.xModuleData[Object(xfile["getXFile"])().getName()].version, web_extension_default.a.runtime.getManifest().version)
                    },
                    'Check for update'
                  )
                ) : react_default.a.createElement(
                  'div',
                  { className: 'status-box' },
                  react_default.a.createElement(
                    'span',
                    null,
                    'Not Installed'
                  ),
                  react_default.a.createElement(
                    'a',
                    { href: Object(xfile["getXFile"])().downloadLink(), target: '_blank' },
                    'Download it'
                  )
                )
              ),
              react_default.a.createElement(
                'div',
                { className: 'xmodule-settings' },
                react_default.a.createElement(
                  'h3',
                  null,
                  'Settings'
                ),
                react_default.a.createElement(
                  'div',
                  { className: 'xmodule-settings-item' },
                  react_default.a.createElement(
                    'div',
                    { className: 'settings-detail' },
                    react_default.a.createElement(
                      'label',
                      null,
                      'Home Folder'
                    ),
                    react_default.a.createElement(
                      'div',
                      { className: 'settings-detail-content' },
                      react_default.a.createElement(input_default.a, {
                        type: 'text',
                        value: Object(xfile["getXFile"])().getCachedConfig().rootDir,
                        disabled: !(this.state.xModuleData[Object(xfile["getXFile"])().getName()] && this.state.xModuleData[Object(xfile["getXFile"])().getName()].installed),
                        onChange: function onChange(e) {
                          var rootDir = e.target.value;

                          _this6.setState(Object(utils["compose"])(Object(utils["setIn"])(['xModuleData', Object(xfile["getXFile"])().getName(), 'config', 'rootDir'], rootDir), Object(utils["setIn"])(['xFileRootDirChanged'], true))(_this6.state));

                          Object(xfile["getXFile"])().setConfig({ rootDir: rootDir });
                        },
                        onBlur: function onBlur() {
                          if (_this6.state.xFileRootDirChanged) {
                            _this6.setState({ xFileRootDirChanged: false });

                            Object(xfile["getXFile"])().sanityCheck().then(function () {
                              _this6.setState(Object(utils["setIn"])(['xModuleData', Object(xfile["getXFile"])().getName(), 'checkResult'], { error: null }, _this6.state));

                              Object(storage["getStorageManager"])().emit(storage["StorageManagerEvent"].RootDirChanged);
                            }, function (e) {
                              _this6.setState(Object(utils["setIn"])(['xModuleData', Object(xfile["getXFile"])().getName(), 'checkResult'], { error: e.message }, _this6.state));

                              _this6.props.updateUI({ showSettings: true, settingsTab: 'xmodules' });
                            });
                          }
                        }
                      }),
                      this.state.xModuleData[Object(xfile["getXFile"])().getName()] && this.state.xModuleData[Object(xfile["getXFile"])().getName()].checkResult && this.state.xModuleData[Object(xfile["getXFile"])().getName()].checkResult.error ? react_default.a.createElement(
                        'div',
                        { className: 'check-result' },
                        this.state.xModuleData[Object(xfile["getXFile"])().getName()].checkResult.error
                      ) : null
                    )
                  ),
                  react_default.a.createElement(
                    'div',
                    { className: 'settings-desc' },
                    'In this folder, UI.Vision RPA creates /macros, /images, /testsuites, /datasources'
                  )
                )
              )
            ),
            react_default.a.createElement(
              'div',
              { className: 'xmodule-item' },
              react_default.a.createElement(
                'div',
                { className: 'xmodule-title' },
                react_default.a.createElement(
                  'span',
                  null,
                  react_default.a.createElement(
                    'b',
                    null,
                    'RealUser XModule'
                  ),
                  ' - Click / Type / Drag with OS native events'
                ),
                react_default.a.createElement(
                  'a',
                  { href: Object(x_user_io["getXUserIO"])().infoLink(), target: '_blank' },
                  'More Info'
                ),
                react_default.a.createElement(
                  button_default.a,
                  {
                    type: 'primary',
                    onClick: function onClick() {
                      Object(x_user_io["getXUserIO"])().getVersion().then(function (data) {
                        var installed = data.installed,
                            version = data.version;

                        var msg = installed ? 'Installed (v' + version + ')' : 'Not Installed';
                        message_default.a.info('status updated: ' + msg);

                        _this6.setState(Object(utils["updateIn"])(['xModuleData', Object(x_user_io["getXUserIO"])().getName()], function (orig) {
                          return header_extends({}, orig, data, { config: Object(x_user_io["getXUserIO"])().getCachedConfig() });
                        }, _this6.state));
                      });
                    }
                  },
                  'Test it'
                )
              ),
              react_default.a.createElement(
                'div',
                { className: 'xmodule-status' },
                react_default.a.createElement(
                  'label',
                  null,
                  'Status:'
                ),
                this.state.xModuleData[Object(x_user_io["getXUserIO"])().getName()] && this.state.xModuleData[Object(x_user_io["getXUserIO"])().getName()].installed ? react_default.a.createElement(
                  'div',
                  { className: 'status-box' },
                  react_default.a.createElement(
                    'span',
                    null,
                    'Installed (v',
                    this.state.xModuleData[Object(x_user_io["getXUserIO"])().getName()].version,
                    ')'
                  ),
                  react_default.a.createElement(
                    'a',
                    {
                      target: '_blank',
                      href: Object(x_user_io["getXUserIO"])().checkUpdateLink(this.state.xModuleData[Object(x_user_io["getXUserIO"])().getName()] && this.state.xModuleData[Object(x_user_io["getXUserIO"])().getName()].version, web_extension_default.a.runtime.getManifest().version)
                    },
                    'Check for update'
                  )
                ) : react_default.a.createElement(
                  'div',
                  { className: 'status-box' },
                  react_default.a.createElement(
                    'span',
                    null,
                    'Not Installed'
                  ),
                  react_default.a.createElement(
                    'a',
                    { href: Object(x_user_io["getXUserIO"])().downloadLink(), target: '_blank' },
                    'Download it'
                  )
                )
              )
            ),
            react_default.a.createElement(
              'div',
              { className: 'xmodule-item' },
              react_default.a.createElement(
                'div',
                { className: 'xmodule-title' },
                react_default.a.createElement(
                  'span',
                  null,
                  react_default.a.createElement(
                    'b',
                    null,
                    'DesktopAutomation XModule'
                  ),
                  ' - Visual Desktop Automation'
                ),
                react_default.a.createElement(
                  'a',
                  { href: Object(xdesktop["getXDesktop"])().infoLink(), target: '_blank' },
                  'More Info'
                ),
                react_default.a.createElement(
                  button_default.a,
                  {
                    type: 'primary',
                    onClick: function onClick() {
                      Object(xdesktop["getXDesktop"])().getVersion().then(function (data) {
                        var installed = data.installed,
                            version = data.version;

                        var msg = installed ? 'Installed (v' + version + ')' : 'Not Installed';
                        message_default.a.info('status updated: ' + msg);

                        _this6.setState(Object(utils["updateIn"])(['xModuleData', Object(xdesktop["getXDesktop"])().getName()], function (orig) {
                          return header_extends({}, orig, data, { config: Object(xdesktop["getXDesktop"])().getCachedConfig() });
                        }, _this6.state));
                      });
                    }
                  },
                  'Test it'
                )
              ),
              react_default.a.createElement(
                'div',
                { className: 'xmodule-status' },
                react_default.a.createElement(
                  'label',
                  null,
                  'Status:'
                ),
                this.state.xModuleData[Object(xdesktop["getXDesktop"])().getName()] && this.state.xModuleData[Object(xdesktop["getXDesktop"])().getName()].installed ? react_default.a.createElement(
                  'div',
                  { className: 'status-box' },
                  react_default.a.createElement(
                    'span',
                    null,
                    'Installed (v',
                    this.state.xModuleData[Object(xdesktop["getXDesktop"])().getName()].version,
                    ')'
                  ),
                  react_default.a.createElement(
                    'a',
                    {
                      target: '_blank',
                      href: Object(xdesktop["getXDesktop"])().checkUpdateLink(this.state.xModuleData[Object(xdesktop["getXDesktop"])().getName()] && this.state.xModuleData[Object(xdesktop["getXDesktop"])().getName()].version, web_extension_default.a.runtime.getManifest().version)
                    },
                    'Check for update'
                  )
                ) : react_default.a.createElement(
                  'div',
                  { className: 'status-box' },
                  react_default.a.createElement(
                    'span',
                    null,
                    'Not Installed'
                  ),
                  react_default.a.createElement(
                    'a',
                    { href: Object(xdesktop["getXDesktop"])().downloadLink(), target: '_blank' },
                    'Download it'
                  )
                )
              )
            )
          ),
          react_default.a.createElement(
            tabs_default.a.TabPane,
            { tab: 'XModules PRO', key: 'register', className: 'register-pane' },
            react_default.a.createElement(
              'div',
              {
                className: Object(utils["cn"])('register-note', {
                  inactive: !Object(services_license["getLicenseService"])().hasNoLicense()
                })
              },
              react_default.a.createElement(
                'p',
                null,
                'Thank you for using the UI.Vision RPA Community Edition. For unlimited real user commands (XClick, XMove and XType), unlimited direct file access and priority support, please upgrade to our PRO and Enterprise Editions. If you have already purchased a license key, you can enter it here:'
              ),
              react_default.a.createElement(
                'div',
                { className: 'actions' },
                react_default.a.createElement(
                  'a',
                  {
                    href: Object(services_license["getLicenseService"])().getUpgradeUrl(),
                    target: '_blank'
                  },
                  'Click here to upgrade.'
                )
              )
            ),
            react_default.a.createElement(
              'div',
              { className: 'register-form' },
              react_default.a.createElement(
                'label',
                null,
                'Enter license key:'
              ),
              react_default.a.createElement(
                'div',
                { className: 'register-row' },
                react_default.a.createElement(input_default.a, {
                  value: this.state.registerKey,
                  type: 'text',
                  onChange: function onChange(e) {
                    _this6.setState({
                      registerKey: e.target.value
                    });
                  }
                }),
                react_default.a.createElement(
                  button_default.a,
                  {
                    type: 'primary',
                    loading: this.state.isCheckingLicense,
                    onClick: this.checkRegisterKey
                  },
                  'Check Key'
                )
              )
            ),
            react_default.a.createElement(
              'div',
              { className: 'register-status' },
              Object(services_license["getLicenseService"])().hasNoLicense() ? react_default.a.createElement(
                'div',
                null,
                react_default.a.createElement(
                  'span',
                  null,
                  'XModules status: '
                ),
                react_default.a.createElement(
                  'b',
                  null,
                  this.isEitherXModuleInstalled() ? Object(services_license["getLicenseService"])().getEditionName() + ' active' : 'Not installed'
                ),
                '.',
                react_default.a.createElement(
                  'a',
                  {
                    href: Object(services_license["getLicenseService"])().getUpgradeUrl(),
                    target: '_blank'
                  },
                  'Upgrade to XModules Personal, PRO or Enterprise'
                )
              ) : null,
              Object(services_license["getLicenseService"])().isPersonalLicense() ? react_default.a.createElement(
                'div',
                null,
                'XModules status: ',
                react_default.a.createElement(
                  'b',
                  null,
                  Object(services_license["getLicenseService"])().getEditionName(),
                  ' active'
                ),
                '.',
                react_default.a.createElement(
                  'a',
                  {
                    href: Object(services_license["getLicenseService"])().getUpgradeUrl(),
                    target: '_blank'
                  },
                  'Upgrade to PRO or Enterprise'
                )
              ) : null,
              Object(services_license["getLicenseService"])().isProLicense() ? react_default.a.createElement(
                'div',
                null,
                'XModules status: ',
                react_default.a.createElement(
                  'b',
                  null,
                  Object(services_license["getLicenseService"])().getEditionName(),
                  ' active'
                ),
                '.',
                react_default.a.createElement(
                  'a',
                  {
                    href: Object(services_license["getLicenseService"])().getUpgradeUrl(),
                    target: '_blank'
                  },
                  'Contact Support'
                )
              ) : null,
              Object(services_license["getLicenseService"])().isPlayerLicense() ? react_default.a.createElement(
                'div',
                null,
                'XModules status: ',
                react_default.a.createElement(
                  'b',
                  null,
                  Object(services_license["getLicenseService"])().getEditionName(),
                  ' active'
                ),
                '.',
                react_default.a.createElement(
                  'a',
                  {
                    href: Object(services_license["getLicenseService"])().getUpgradeUrl(),
                    target: '_blank'
                  },
                  'Contact Support'
                )
              ) : null
            )
          )
        )
      );
    }
  }, {
    key: 'renderMainMenu',
    value: function renderMainMenu() {
      var _this7 = this;

      var _state = this.state,
          htmlUri = _state.htmlUri,
          jsonUri = _state.jsonUri;
      var _props = this.props,
          status = _props.status,
          editing = _props.editing;
      var commands = editing.commands,
          meta = editing.meta;
      var src = meta.src;

      var canPlay = this.props.player.status === constant["PLAYER_STATUS"].STOPPED;
      var downloadNamePrefix = src ? src.name : 'Untitled';

      var onClickMenuItem = function onClickMenuItem(_ref5) {
        var key = _ref5.key;

        switch (key) {
          case 'play_settings':
            {
              _this7.showSettingsModal();
              break;
            }
        }
      };

      return react_default.a.createElement(
        menu_default.a,
        { onClick: onClickMenuItem, selectable: false },
        react_default.a.createElement(
          menu_default.a.Item,
          { key: 'play_settings', disabled: !canPlay },
          'Replay settings..'
        )
      );
    }
  }, {
    key: 'renderStatus',
    value: function renderStatus() {
      var _props2 = this.props,
          status = _props2.status,
          player = _props2.player;

      var renderInner = function renderInner() {
        switch (status) {
          case constant["APP_STATUS"].RECORDER:
            return 'Recording';

          case constant["APP_STATUS"].PLAYER:
            {
              switch (player.status) {
                case constant["PLAYER_STATUS"].PLAYING:
                  {
                    var nextCommandIndex = player.nextCommandIndex,
                        loops = player.loops,
                        currentLoop = player.currentLoop,
                        timeoutStatus = player.timeoutStatus;


                    if (nextCommandIndex === null || loops === null || currentLoop === 0) {
                      return '';
                    }

                    var parts = ['Line ' + (nextCommandIndex + 1), 'Round ' + currentLoop + '/' + loops];

                    if (timeoutStatus && timeoutStatus.type && timeoutStatus.total) {
                      var type = timeoutStatus.type,
                          total = timeoutStatus.total,
                          past = timeoutStatus.past;

                      parts.unshift(type + ' ' + past / 1000 + 's (' + total / 1000 + ')');
                    }

                    return parts.join(' | ');
                  }

                case constant["PLAYER_STATUS"].PAUSED:
                  return 'Player paused';

                default:
                  return '';
              }
            }

          default:
            return '';
        }
      };

      return react_default.a.createElement(
        'div',
        { className: 'status' },
        renderInner()
      );
    }
  }, {
    key: 'renderActions',
    value: function renderActions() {
      var _this8 = this;

      var _props3 = this.props,
          player = _props3.player,
          status = _props3.status;


      var onClickMenuItem = function onClickMenuItem(_ref6) {
        var key = _ref6.key;

        switch (key) {
          case 'play_loop':
            {
              _this8.togglePlayLoopsModal(true);
              break;
            }
        }
      };

      var playMenu = react_default.a.createElement(
        menu_default.a,
        { onClick: onClickMenuItem, selectable: false },
        react_default.a.createElement(
          menu_default.a.Item,
          { key: 'play_loop', disabled: false },
          'Play loop..'
        )
      );

      if (status === constant["APP_STATUS"].RECORDER) {
        return react_default.a.createElement(
          'div',
          { className: 'actions' },
          react_default.a.createElement(
            button_default.a,
            {
              onClick: this.onToggleRecord,
              style: { color: '#ff0000' }
            },
            react_default.a.createElement(
              'span',
              null,
              'Stop Record'
            )
          )
        );
      }

      switch (player.status) {
        case constant["PLAYER_STATUS"].PLAYING:
          {
            return react_default.a.createElement(
              'div',
              { className: 'actions' },
              react_default.a.createElement(
                button_default.a.Group,
                null,
                react_default.a.createElement(
                  button_default.a,
                  { onClick: function onClick() {
                      return _this8.getPlayer().stop();
                    } },
                  react_default.a.createElement(
                    'span',
                    null,
                    'Stop'
                  )
                ),
                react_default.a.createElement(
                  button_default.a,
                  { onClick: function onClick() {
                      return _this8.getPlayer('testCase').pause();
                    } },
                  react_default.a.createElement(
                    'span',
                    null,
                    'Pause'
                  )
                )
              )
            );
          }

        case constant["PLAYER_STATUS"].PAUSED:
          {
            return react_default.a.createElement(
              'div',
              { className: 'actions' },
              react_default.a.createElement(
                button_default.a.Group,
                null,
                this.props.player.mode === constant["PLAYER_MODE"].TEST_CASE ? react_default.a.createElement(
                  button_default.a,
                  { onClick: function onClick() {
                      return _this8.getPlayer('testCase').resume(true);
                    } },
                  'Step'
                ) : null,
                react_default.a.createElement(
                  button_default.a,
                  { onClick: function onClick() {
                      return _this8.getPlayer().stop();
                    } },
                  'Stop'
                ),
                react_default.a.createElement(
                  button_default.a,
                  { onClick: function onClick() {
                      return _this8.getPlayer('testCase').resume();
                    } },
                  'Resume'
                )
              )
            );
          }

        case constant["PLAYER_STATUS"].STOPPED:
          {
            return react_default.a.createElement(
              'div',
              { className: 'actions' },
              react_default.a.createElement(
                button_default.a,
                {
                  disabled: !Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Record),
                  onClick: this.onToggleRecord
                },
                react_default.a.createElement(
                  'span',
                  null,
                  'Record'
                )
              ),
              react_default.a.createElement(
                button_default.a.Group,
                { className: 'play-actions' },
                react_default.a.createElement(
                  button_default.a,
                  { onClick: function onClick() {
                      return _this8.playCurrentMacro(true);
                    } },
                  'Step'
                ),
                react_default.a.createElement(
                  dropdown_default.a.Button,
                  { onClick: function onClick() {
                      return _this8.playCurrentMacro(false);
                    }, overlay: playMenu },
                  react_default.a.createElement(
                    'span',
                    null,
                    'Play Macro'
                  )
                )
              ),
              react_default.a.createElement(
                button_default.a,
                { shape: 'circle', onClick: function onClick() {
                    return _this8.showSettingsModal();
                  } },
                react_default.a.createElement(icon_default.a, { type: 'setting' })
              )
            );
          }
      }
    }
  }, {
    key: 'renderMacro',
    value: function renderMacro() {
      var _props4 = this.props,
          editing = _props4.editing,
          player = _props4.player,
          hasUnsaved = _props4.hasUnsaved;
      var src = editing.meta.src;

      var isPlayerStopped = player.status === constant["PLAYER_STATUS"].STOPPED;
      var klass = hasUnsaved ? 'unsaved' : '';

      var saveBtnState = {
        text: src ? 'Save' : 'Save..',
        disabled: !hasUnsaved
      };

      return react_default.a.createElement(
        'div',
        { className: 'select-case' },
        react_default.a.createElement(
          'span',
          { className: 'test-case-name ' + klass },
          src ? src.name : 'Untitled'
        ),
        !isPlayerStopped ? null : react_default.a.createElement(
          button_default.a,
          { disabled: saveBtnState.disabled, onClick: this.onClickSave },
          react_default.a.createElement(
            'span',
            null,
            saveBtnState.text
          )
        )
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var player = this.props.player;

      var isPlayerStopped = player.status === constant["PLAYER_STATUS"].STOPPED;

      return react_default.a.createElement(
        'div',
        { className: 'header ' + this.props.status.toLowerCase() },
        this.renderMacro(),
        this.renderStatus(),
        this.renderActions(),
        this.renderPlayLoopModal(),
        this.renderSettingModal(),
        this.renderPublicWebsiteWhiteList()
      );
    }
  }]);

  return Header;
}(react_default.a.Component);

/* harmony default export */ var components_header = (Object(react_redux_es["b" /* connect */])(function (state) {
  return {
    hasUnsaved: Object(recomputed["hasUnsavedMacro"])(state),
    route: state.route,
    editing: state.editor.editing,
    player: state.player,
    status: state.status,
    config: state.config,
    ui: state.ui,
    proxy: state.proxy
  };
}, function (dispatch) {
  return Object(redux_es["b" /* bindActionCreators */])(header_extends({}, actions, simple_actions["Actions"]), dispatch);
})(Object(es["b" /* withRouter */])(header_Header)));
// EXTERNAL MODULE: ./src/containers/sidebar/sidebar.scss
var sidebar = __webpack_require__(1033);

// EXTERNAL MODULE: ./node_modules/antd/lib/alert/index.js
var lib_alert = __webpack_require__(405);
var alert_default = /*#__PURE__*/__webpack_require__.n(lib_alert);

// EXTERNAL MODULE: ./node_modules/react-click-outside/build/index.js
var build = __webpack_require__(406);
var build_default = /*#__PURE__*/__webpack_require__.n(build);

// EXTERNAL MODULE: ./node_modules/jszip/dist/jszip.min.js
var jszip_min = __webpack_require__(142);
var jszip_min_default = /*#__PURE__*/__webpack_require__.n(jszip_min);

// EXTERNAL MODULE: ./src/common/convert_suite_utils.js
var convert_suite_utils = __webpack_require__(69);

// CONCATENATED MODULE: ./src/common/bookmark.js
var bookmark_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



// Note: Get ids of bookmarks bar and other bookmarks
var pBookmarksBarId = function getIdsOfOtherBookmarksAndBookmarksBar() {
  var bookmarksBarIndex = web_extension_default.a.isFirefox() ? 1 : 0;

  return web_extension_default.a.bookmarks.getTree().then(function (nodes) {
    var bookmarksBar = nodes[0].children[bookmarksBarIndex];
    return bookmarksBar.id;
  });
}();

var bookmark_createBookmarkOnBar = function createBookmarkOnBar(bookmark) {
  return pBookmarksBarId.then(function (barId) {
    return web_extension_default.a.bookmarks.create(bookmark_extends({}, bookmark, { parentId: barId }));
  });
};
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(1);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./node_modules/react-codemirror2/index.js
var react_codemirror2 = __webpack_require__(194);

// EXTERNAL MODULE: ./node_modules/codemirror/lib/codemirror.js
var codemirror = __webpack_require__(183);

// EXTERNAL MODULE: ./node_modules/codemirror/mode/javascript/javascript.js
var javascript = __webpack_require__(507);

// EXTERNAL MODULE: ./node_modules/codemirror/addon/edit/matchbrackets.js
var matchbrackets = __webpack_require__(508);

// EXTERNAL MODULE: ./node_modules/codemirror/addon/edit/closebrackets.js
var closebrackets = __webpack_require__(509);

// EXTERNAL MODULE: ./node_modules/codemirror/lib/codemirror.css
var lib_codemirror = __webpack_require__(510);

// CONCATENATED MODULE: ./src/components/edit_test_suite.js


var edit_test_suite_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function edit_test_suite_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function edit_test_suite_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function edit_test_suite_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }











var edit_test_suite_EditTestSuite = function (_React$Component) {
  edit_test_suite_inherits(EditTestSuite, _React$Component);

  function EditTestSuite() {
    var _ref;

    var _temp, _this, _ret;

    edit_test_suite_classCallCheck(this, EditTestSuite);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = edit_test_suite_possibleConstructorReturn(this, (_ref = EditTestSuite.__proto__ || Object.getPrototypeOf(EditTestSuite)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      value: '',
      valueModified: null,
      errMsg: null
    }, _this.onSave = function () {
      var errMsg = null;

      try {
        _this.props.validate(_this.state.valueModified);
        _this.props.onChange(_this.state.valueModified);
      } catch (e) {
        errMsg = e.message;
      } finally {
        _this.setState({ errMsg: errMsg });
      }
    }, _temp), edit_test_suite_possibleConstructorReturn(_this, _ret);
  }

  edit_test_suite_createClass(EditTestSuite, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState({
        value: this.props.value,
        valueModified: this.props.value
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.value !== this.props.value) {
        this.setState({
          value: nextProps.value,
          valueModified: nextProps.value
        });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      return react_default.a.createElement(
        modal_default.a,
        {
          visible: this.props.visible,
          okText: 'Save',
          onOk: this.onSave,
          onCancel: this.props.onClose,
          width: '80%'
        },
        react_default.a.createElement(
          'pre',
          { style: { color: 'red', lineHeight: '18px', marginBottom: '10px' } },
          this.state.errMsg
        ),
        react_default.a.createElement(react_codemirror2["UnControlled"], {
          className: this.state.sourceErrMsg ? 'has-error' : 'no-error',
          value: this.state.value,
          onChange: function onChange(editor, data, text) {
            return _this2.setState({ valueModified: text });
          },
          options: {
            mode: { name: 'javascript', json: true },
            lineNumbers: true,
            matchBrackets: true,
            autoCloseBrackets: true
          }
        })
      );
    }
  }]);

  return EditTestSuite;
}(react_default.a.Component);

edit_test_suite_EditTestSuite.propTypes = {
  value: prop_types_default.a.string.isRequired,
  onClose: prop_types_default.a.func.isRequired,
  visible: prop_types_default.a.bool,
  validate: prop_types_default.a.func,
  onChange: prop_types_default.a.func
};
edit_test_suite_EditTestSuite.defaultProps = {
  visible: false,
  validate: function validate() {
    return true;
  },
  onChange: function onChange() {}
};
/* harmony default export */ var edit_test_suite = (edit_test_suite_EditTestSuite);
// CONCATENATED MODULE: ./src/components/editable_text.js



var editable_text_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var editable_text_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function editable_text_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function editable_text_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function editable_text_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var editable_text_EditableText = function (_React$Component) {
  editable_text_inherits(EditableText, _React$Component);

  function EditableText() {
    var _ref;

    var _temp, _this, _ret;

    editable_text_classCallCheck(this, EditableText);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = editable_text_possibleConstructorReturn(this, (_ref = EditableText.__proto__ || Object.getPrototypeOf(EditableText)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      isEditing: false
    }, _this.onChange = function (e) {
      _this.setState({
        value: e.target.value
      });
    }, _this.onKeyDown = function (e) {
      if (e.keyCode === 13) {
        _this.submit();
      } else if (e.keyCode === 27) {
        _this.setState({
          value: _this.props.value
        }, _this.submit);
      }
    }, _this.onBlur = function (e) {
      _this.submit();
    }, _this.onClickText = function () {
      if (_this.props.clickToEdit) {
        _this.setState({ isEditing: true });
      }
    }, _this.submit = function () {
      _this.setState({
        isEditing: false
      });

      if (_this.props.onChange) {
        _this.props.onChange(_this.state.value).catch(function () {
          return false;
        }).then(function (success) {
          if (!success) {
            _this.setState({
              value: _this.props.value
            });
          }
        });
      }
    }, _temp), editable_text_possibleConstructorReturn(_this, _ret);
  }

  editable_text_createClass(EditableText, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState({
        isEditing: this.props.isEditing,
        value: this.props.value
      });

      if (this.props.isEditing) {
        this.focusOnInput();
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var nextState = {};

      if (this.props.isEditing !== nextProps.isEditing) {
        nextState.isEditing = nextProps.isEditing;

        if (nextState.isEditing) {
          this.focusOnInput();
        }
      }

      if (this.props.value !== nextProps.value) {
        nextState.value = nextProps.value;
      }

      this.setState(nextState);
    }
  }, {
    key: 'focusOnInput',
    value: function focusOnInput() {
      var _this2 = this;

      setTimeout(function () {
        var $input = _this2.input.refs.input;

        if ($input) {
          $input.focus();
          $input.selectionStart = 0;
          $input.selectionEnd = $input.value.length;
        }
      }, 200);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _state = this.state,
          isEditing = _state.isEditing,
          value = _state.value;


      return react_default.a.createElement(
        'div',
        { className: this.props.className },
        isEditing ? react_default.a.createElement(input_default.a, editable_text_extends({
          value: value,
          onChange: this.onChange,
          onBlur: this.onBlur,
          onKeyDown: this.onKeyDown,
          ref: function ref(_ref2) {
            _this3.input = _ref2;
          }
        }, this.props.inputProps || {})) : react_default.a.createElement(
          'span',
          { onClick: this.onClickText },
          react_default.a.createElement(
            'span',
            null,
            value
          ),
          this.props.clickToEdit ? react_default.a.createElement(icon_default.a, { type: 'edit', style: { marginLeft: '10px' } }) : null
        )
      );
    }
  }]);

  return EditableText;
}(react_default.a.Component);

editable_text_EditableText.propTypes = {
  value: prop_types_default.a.string,
  isEditing: prop_types_default.a.bool,
  onChange: prop_types_default.a.func,
  inputProps: prop_types_default.a.object,
  textProps: prop_types_default.a.object,
  className: prop_types_default.a.any,
  clickToEdit: prop_types_default.a.bool
};
/* harmony default export */ var editable_text = (editable_text_EditableText);
// EXTERNAL MODULE: ./src/reducers/state.ts
var reducers_state = __webpack_require__(62);

// EXTERNAL MODULE: ./src/containers/common/resource_not_loaded.tsx
var resource_not_loaded = __webpack_require__(195);

// CONCATENATED MODULE: ./src/containers/sidebar/test_suites.js




































var test_suites_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var test_suites_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function test_suites_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function test_suites_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function test_suites_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




























var test_suites_downloadTestSuite = function downloadTestSuite(ts, macros) {
  var str = Object(convert_suite_utils["stringifyTestSuite"])({
    name: ts.name,
    cases: ts.cases
  });
  var blob = new Blob([str], { type: 'text/plain;charset=utf-8' });

  // Note: must add third param as true here to remove BOM for UTF8 files
  // reference: https://github.com/eligrey/FileSaver.js/issues/432
  file_saver_default.a.saveAs(blob, 'suite_' + ts.name + '.json', true);
};

var test_suites_downloadTestSuiteAsHTML = function downloadTestSuiteAsHTML(ts) {
  var str = Object(convert_suite_utils["toHtml"])({ name: ts.name });
  var blob = new Blob([str], { type: 'text/plain;charset=utf-8' });

  file_saver_default.a.saveAs(blob, ts.name + '.html', true);
};

var test_suites_SidebarTestSuites = function (_React$Component) {
  test_suites_inherits(SidebarTestSuites, _React$Component);

  function SidebarTestSuites() {
    var _ref;

    var _temp, _this, _ret;

    test_suites_classCallCheck(this, SidebarTestSuites);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = test_suites_possibleConstructorReturn(this, (_ref = SidebarTestSuites.__proto__ || Object.getPrototypeOf(SidebarTestSuites)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      tsContextMenu: {
        x: null,
        y: null,
        isShown: false
      },

      tscContextMenu: {
        x: null,
        y: null,
        isShown: false
      },

      tsEditingNameIndex: -1,

      editTestSuiteSource: {
        ts: null,
        visible: false
      }
    }, _this.addTestSuite = function () {
      return Object(ts_utils["uniqueName"])('__Untitled__', {
        check: function check(fullName) {
          return !_this.props.testSuites.find(function (ts) {
            return ts.name === fullName;
          });
        }
      }).then(function (newTestSuiteName) {
        return _this.props.addTestSuite({
          name: newTestSuiteName,
          cases: []
        });
      }).catch(function (e) {
        message_default.a.error(e.message, 1.5);
      });
    }, _this.addTestCaseToTestSuite = function (ts) {
      _this.props.updateTestSuite(ts.id, {
        cases: ts.cases.concat({
          testCaseId: _this.props.macros[0] && _this.props.macros[0].relativePath,
          loops: 1
        })
      });
    }, _this.removeTestCaseFromTestSuite = function (ts, index) {
      ts.cases.splice(index, 1);

      _this.props.updateTestSuite(ts.id, {
        cases: ts.cases,
        playStatus: function () {
          var _ts$playStatus = ts.playStatus,
              playStatus = _ts$playStatus === undefined ? {} : _ts$playStatus;
          var _playStatus$doneIndic = playStatus.doneIndices,
              doneIndices = _playStatus$doneIndic === undefined ? [] : _playStatus$doneIndic,
              _playStatus$errorIndi = playStatus.errorIndices,
              errorIndices = _playStatus$errorIndi === undefined ? [] : _playStatus$errorIndi;

          var updateIndex = function updateIndex(n) {
            if (n === undefined) return -1;
            if (n === index) return -1;
            if (n > index) return n - 1;
            return n;
          };

          return {
            errorIndices: errorIndices.map(updateIndex).filter(function (i) {
              return i !== -1;
            }),
            doneIndices: doneIndices.map(updateIndex).filter(function (i) {
              return i !== -1;
            })
          };
        }()
      });
    }, _this.toggleTestSuiteFold = function (ts) {
      _this.props.updateTestSuite(ts.id, {
        fold: !ts.fold
      });
    }, _this.foldAllTestSuites = function () {
      _this.props.testSuites.forEach(function (ts) {
        _this.props.updateTestSuite(ts.id, {
          fold: true
        });
      });
    }, _this.onClickTestSuiteMore = function (e, ts, tsIndex) {
      e.stopPropagation();
      e.preventDefault();

      var updated = {
        tsContextMenu: {
          x: e.clientX,
          y: e.clientY,
          isShown: true,
          ts: ts,
          tsIndex: tsIndex
        }

        // Note: to make it work in Firefox, have to delay this new state a little bit
        // Because hideTcContextMenu could be executed at the same time via clickOutside
      };setTimeout(function () {
        return _this.setState(updated);
      }, 20);
    }, _this.onClickTsTestCaseMore = function (e, tc, tcIndex, ts, tsIndex) {
      e.stopPropagation();
      e.preventDefault();

      var updated = {
        tscContextMenu: {
          x: e.clientX,
          y: e.clientY,
          isShown: true,
          tc: tc,
          ts: ts,
          tcIndex: tcIndex,
          tsIndex: tsIndex
        }

        // Note: to make it work in Firefox, have to delay this new state a little bit
        // Because hideTcContextMenu could be executed at the same time via clickOutside
      };setTimeout(function () {
        return _this.setState(updated);
      }, 20);
    }, _this.hideTsContextMenu = function () {
      _this.setState({
        tsContextMenu: test_suites_extends({}, _this.state.tsContextMenu, {
          isShown: false
        })
      });
    }, _this.hideTscContextMenu = function () {
      _this.setState({
        tscContextMenu: test_suites_extends({}, _this.state.tscContextMenu, {
          isShown: false
        })
      });
    }, _this.onTsMenuClick = function (_ref2, ts, tsIndex) {
      var key = _ref2.key;

      _this.hideTsContextMenu();

      switch (key) {
        case 'play':
          Object(common_player["b" /* getPlayer */])({ name: 'testSuite' }).play({
            title: ts.name,
            extra: {
              id: ts.id,
              name: ts.name
            },
            mode: Object(common_player["b" /* getPlayer */])().C.MODE.STRAIGHT,
            startIndex: 0,
            resources: ts.cases.map(function (item) {
              return {
                id: item.testCaseId,
                loops: item.loops
              };
            })
          });
          break;

        case 'edit_source':
          _this.setState({
            editTestSuiteSource: {
              ts: ts,
              visible: true
            }
          });
          break;

        case 'rename':
          _this.setState({
            tsEditingNameIndex: tsIndex
          });
          break;

        case 'export':
          test_suites_downloadTestSuite(ts, _this.props.macros);
          break;

        case 'create_bookmark':
          {
            var bookmarkTitle = prompt('Title for this bookmark', '#' + ts.name + '.rpa');
            if (bookmarkTitle === null) return;

            return bookmark_createBookmarkOnBar(Object(convert_suite_utils["toBookmarkData"])({
              bookmarkTitle: bookmarkTitle,
              name: ts.name
            })).then(function () {
              message_default.a.success('successfully created bookmark!', 1.5);
            });
          }

        case 'export_html':
          {
            if (!web_extension_default.a.isFirefox()) {
              web_extension_default.a.extension.isAllowedFileSchemeAccess().then(function (isAllowed) {
                if (isAllowed) return;
                var msg = 'To run test suite from html file, you need to enable "Allow access to file URLs" in extension details page';
                message_default.a.warn(msg);
                _this.props.addLog('warning', msg);
              });
            }

            return test_suites_downloadTestSuiteAsHTML(ts);
          }

        case 'delete':
          modal_default.a.confirm({
            title: 'Are your sure to delete this test suite?',
            okText: 'Confirm',
            onOk: function onOk() {
              return _this.props.removeTestSuite(ts.id);
            }
          });
          break;
      }
    }, _this.onTscMenuClick = function (_ref3, tc, tcIndex, ts, tsIndex) {
      var key = _ref3.key;

      _this.hideTscContextMenu();

      switch (key) {
        case 'play_from_here':
          Object(common_player["b" /* getPlayer */])({ name: 'testSuite' }).play({
            title: ts.name,
            extra: {
              id: ts.id,
              name: ts.name
            },
            mode: Object(common_player["b" /* getPlayer */])().C.MODE.STRAIGHT,
            startIndex: tcIndex,
            resources: ts.cases.map(function (item) {
              return {
                id: item.testCaseId,
                loops: item.loops
              };
            })
          });
          break;
      }
    }, _this.onChangeTsName = function (val, ts, tsIndex) {
      _this.setState({
        tsEditingNameIndex: -1
      });

      return _this.props.updateTestSuite(ts.id, {
        name: val
      }).then(function () {
        return true;
      }, function (e) {
        message_default.a.error(e.message, 1.5);
        return false;
      });
    }, _this.onChangeTsCase = function (key, val, tcIndex, ts, tsIndex) {
      _this.props.updateTestSuite(ts.id, {
        cases: Object(utils["setIn"])([tcIndex, key], val, ts.cases)
      });
    }, _this.getTsTestCaseClass = function (tcIndex, tsPlayStatus) {
      if (!tsPlayStatus) return '';
      var _tsPlayStatus$doneInd = tsPlayStatus.doneIndices,
          doneIndices = _tsPlayStatus$doneInd === undefined ? [] : _tsPlayStatus$doneInd,
          _tsPlayStatus$errorIn = tsPlayStatus.errorIndices,
          errorIndices = _tsPlayStatus$errorIn === undefined ? [] : _tsPlayStatus$errorIn,
          currentIndex = tsPlayStatus.currentIndex;


      if (tcIndex === currentIndex) {
        return 'current-tc';
      } else if (errorIndices.indexOf(tcIndex) !== -1) {
        return 'error-tc';
      } else if (doneIndices.indexOf(tcIndex) !== -1) {
        return 'done-tc';
      } else {
        return '';
      }
    }, _this.onJSONFileChange = function (e) {
      setTimeout(function () {
        _this.jsonFileInput.value = null;
      }, 500);
      return _this.onReadFile(function (str) {
        return Object(convert_suite_utils["parseTestSuite"])(str);
      })(e);
    }, _this.onReadFile = function (process) {
      return function (e) {
        var files = [].slice.call(e.target.files);
        if (!files || !files.length) return;

        var read = function read(file) {
          return new Promise(function (resolve, reject) {
            var reader = new FileReader();

            reader.onload = function (readerEvent) {
              try {
                var text = readerEvent.target.result;
                var obj = process(text, file.name);
                resolve({ data: obj });
              } catch (e) {
                resolve({ err: e, fileName: file.name });
              }
            };

            reader.readAsText(file);
          });
        };

        Promise.all(files.map(read)).then(function (list) {
          var doneList = list.filter(function (x) {
            return x.data;
          });
          var failList = list.filter(function (x) {
            return x.err;
          });

          _this.props.addTestSuites(doneList.map(function (x) {
            return x.data;
          })).then(function (_ref4) {
            var passCount = _ref4.passCount,
                failCount = _ref4.failCount,
                failTcs = _ref4.failTcs;

            message_default.a.info([passCount + ' test suite' + (passCount > 1 ? 's' : '') + ' imported!', failList.length + failCount + ' test suite' + (failList.length + failCount > 1 ? 's' : '') + ' failed!'].join(', '), 3);

            failList.forEach(function (fail) {
              _this.props.addLog('error', 'in parsing ' + fail.fileName + ': ' + fail.err.message);
            });

            failTcs.forEach(function (fail) {
              _this.props.addLog('error', 'duplicated test suite name: ' + fail.name);
            });
          });
        });
      };
    }, _temp), test_suites_possibleConstructorReturn(_this, _ret);
  }

  test_suites_createClass(SidebarTestSuites, [{
    key: 'getPortalContainer',
    value: function getPortalContainer() {
      var id = '__context_menu_container__';
      var $el = document.getElementById(id);
      if ($el) return $el;

      var $new = document.createElement('div');
      $new.id = id;
      document.body.appendChild($new);
      return $new;
    }
  }, {
    key: 'renderTestSuiteContextMenu',
    value: function renderTestSuiteContextMenu() {
      var _this2 = this;

      var contextMenu = this.state.tsContextMenu;
      var mw = 230;
      var x = contextMenu.x + window.scrollX;
      var y = contextMenu.y + window.scrollY;

      if (x - mw > 0) x -= mw;

      var style = {
        position: 'absolute',
        top: y,
        left: x,
        display: contextMenu.isShown ? 'block' : 'none'
      };

      var menuStyle = {
        width: mw + 'px'
      };

      var content = react_default.a.createElement(
        'div',
        { style: style, className: 'context-menu' },
        react_default.a.createElement(
          build_default.a,
          { onClickOutside: this.hideTsContextMenu },
          react_default.a.createElement(
            menu_default.a,
            {
              onClick: function onClick(e) {
                return _this2.onTsMenuClick(e, contextMenu.ts, contextMenu.tsIndex);
              },
              style: menuStyle,
              mode: 'vertical',
              selectable: false
            },
            react_default.a.createElement(
              menu_default.a.Item,
              { key: 'play' },
              'Play'
            ),
            react_default.a.createElement(
              menu_default.a.Item,
              { key: 'edit_source' },
              'Edit source..'
            ),
            react_default.a.createElement(
              menu_default.a.Item,
              { key: 'rename' },
              'Rename..'
            ),
            react_default.a.createElement(
              menu_default.a.Item,
              { key: 'export' },
              'Export'
            ),
            react_default.a.createElement(
              menu_default.a.Item,
              { key: 'create_bookmark' },
              'Add to Bookmarks'
            ),
            react_default.a.createElement(menu_default.a.Divider, null),
            react_default.a.createElement(
              menu_default.a.Item,
              { key: 'delete' },
              'Delete'
            )
          )
        )
      );

      return react_dom_default.a.createPortal(content, this.getPortalContainer());
    }
  }, {
    key: 'renderTestSuiteCaseContextMenu',
    value: function renderTestSuiteCaseContextMenu() {
      var _this3 = this;

      var contextMenu = this.state.tscContextMenu;
      var mw = 150;
      var x = contextMenu.x + window.scrollX;
      var y = contextMenu.y + window.scrollY;

      if (x - mw > 0) x -= mw;

      var style = {
        position: 'absolute',
        top: y,
        left: x,
        display: contextMenu.isShown ? 'block' : 'none'
      };

      var menuStyle = {
        width: mw + 'px'
      };

      var content = react_default.a.createElement(
        'div',
        { style: style, className: 'context-menu' },
        react_default.a.createElement(
          build_default.a,
          { onClickOutside: this.hideTscContextMenu },
          react_default.a.createElement(
            menu_default.a,
            {
              onClick: function onClick(e) {
                return _this3.onTscMenuClick(e, contextMenu.tc, contextMenu.tcIndex, contextMenu.ts, contextMenu.tsIndex);
              },
              style: menuStyle,
              mode: 'vertical',
              selectable: false
            },
            react_default.a.createElement(
              menu_default.a.Item,
              { key: 'play_from_here' },
              'Replay from here'
            )
          )
        )
      );

      return react_dom_default.a.createPortal(content, this.getPortalContainer());
    }
  }, {
    key: 'renderTestSuiteMenu',
    value: function renderTestSuiteMenu() {
      var _this4 = this;

      var onClickMenuItem = function onClickMenuItem(_ref5) {
        var key = _ref5.key;

        switch (key) {
          case 'export_all':
            {
              var zip = new jszip_min_default.a();

              if (_this4.props.testSuites.length === 0) {
                return message_default.a.error('No saved test suites to export', 1.5);
              }

              var genName = Object(utils["nameFactory"])();

              _this4.props.testSuites.forEach(function (ts) {
                var name = genName(ts.name);
                zip.file(name + '.json', Object(convert_suite_utils["stringifyTestSuite"])(ts));
              });

              zip.generateAsync({ type: 'blob' }).then(function (blob) {
                file_saver_default.a.saveAs(blob, 'all_suites.zip');
              });

              break;
            }

          case 'import':
            {
              break;
            }
        }
      };

      return react_default.a.createElement(
        menu_default.a,
        { onClick: onClickMenuItem, selectable: false },
        react_default.a.createElement(
          menu_default.a.Item,
          { key: 'export_all' },
          'Export all (JSON)'
        ),
        react_default.a.createElement(
          menu_default.a.Item,
          { key: '4' },
          react_default.a.createElement(
            'label',
            { htmlFor: 'select_json_files_for_ts' },
            'Import JSON'
          ),
          react_default.a.createElement('input', {
            multiple: true,
            type: 'file',
            accept: '.json',
            id: 'select_json_files_for_ts',
            onChange: this.onJSONFileChange,
            style: { display: 'none' },
            ref: function ref(el) {
              _this4.jsonFileInput = el;
            }
          })
        )
      );
    }
  }, {
    key: 'renderEditTestSuiteSource',
    value: function renderEditTestSuiteSource() {
      var _this5 = this;

      if (!this.state.editTestSuiteSource.visible) return null;
      var ts = this.state.editTestSuiteSource.ts;
      var source = Object(convert_suite_utils["stringifyTestSuite"])(ts);

      return react_default.a.createElement(edit_test_suite, {
        visible: true,
        value: source,
        validate: function validate(text) {
          return Object(convert_suite_utils["validateTestSuiteText"])(text, _this5.props.macros);
        },
        onClose: function onClose() {
          return _this5.setState({ editTestSuiteSource: { visible: false } });
        },
        onChange: function onChange(text) {
          var newTestSuite = Object(convert_suite_utils["parseTestSuite"])(text);

          _this5.props.updateTestSuite(ts.id, newTestSuite);
          _this5.setState({ editTestSuiteSource: { visible: false } });
        }
      });
    }
  }, {
    key: 'renderTestSuites',
    value: function renderTestSuites() {
      var _this6 = this;

      return react_default.a.createElement(
        'div',
        null,
        react_default.a.createElement(
          'div',
          { className: 'test-suite-actions' },
          react_default.a.createElement(
            button_default.a,
            { type: 'primary', onClick: this.addTestSuite },
            '+ Test Suite'
          ),
          react_default.a.createElement(
            button_default.a,
            { type: 'default', onClick: this.foldAllTestSuites },
            'Fold'
          ),
          react_default.a.createElement(
            dropdown_default.a,
            { overlay: this.renderTestSuiteMenu(), trigger: ['click'] },
            react_default.a.createElement(
              button_default.a,
              { shape: 'circle' },
              react_default.a.createElement(icon_default.a, { type: 'setting' })
            )
          )
        ),
        !this.props.config.hidePlayTestSuiteTip && this.props.testSuites.length > 0 ? react_default.a.createElement(alert_default.a, {
          type: 'info',
          message: 'Right click to play test suite',
          onClose: function onClose() {
            _this6.props.updateConfig({
              hidePlayTestSuiteTip: true
            });
          },
          closable: true,
          showIcon: true,
          style: { margin: '10px', paddingRight: '30px' }
        }) : null,
        !this.props.config.hideFolderAsTestSuiteTip ? react_default.a.createElement(alert_default.a, {
          type: 'info',
          message: react_default.a.createElement(
            'span',
            null,
            'New: ',
            react_default.a.createElement(
              'a',
              { href: 'https://ui.vision/x/idehelp?help=folder_as_testsuites', target: '_blank' },
              'Use folders as test suites'
            )
          ),
          onClose: function onClose() {
            _this6.props.updateConfig({
              hideFolderAsTestSuiteTip: true
            });
          },
          closable: true,
          showIcon: true,
          style: { margin: '10px', paddingRight: '30px' }
        }) : null,
        this.props.testSuites.length === 0 ? react_default.a.createElement(
          'div',
          { className: 'no-data' },
          'No test suite'
        ) : null,
        react_default.a.createElement(
          'ul',
          { className: 'sidebar-test-suites' },
          this.props.testSuites.map(function (ts, tsIndex) {
            return react_default.a.createElement(
              'li',
              {
                key: ts.id,
                className: Object(utils["cn"])('test-suite-item ', {
                  fold: ts.fold,
                  playing: ts.playStatus && ts.playStatus.isPlaying
                })
              },
              react_default.a.createElement(
                'div',
                { className: 'test-suite-row',
                  onClick: function onClick() {
                    return _this6.toggleTestSuiteFold(ts);
                  },
                  onContextMenu: function onContextMenu(e) {
                    return _this6.onClickTestSuiteMore(e, ts, tsIndex);
                  }
                },
                react_default.a.createElement(icon_default.a, { type: ts.fold ? 'folder' : 'folder-open' }),
                react_default.a.createElement(editable_text, {
                  className: 'test-suite-title',
                  value: ts.name,
                  onChange: function onChange(val) {
                    return _this6.onChangeTsName(val, ts, tsIndex);
                  },
                  isEditing: tsIndex === _this6.state.tsEditingNameIndex,
                  inputProps: {
                    onClick: function onClick(e) {
                      return e.stopPropagation();
                    },
                    onContextMenu: function onContextMenu(e) {
                      return e.stopPropagation();
                    }
                  }
                }),
                tsIndex === _this6.state.tsEditingNameIndex ? null : react_default.a.createElement(icon_default.a, {
                  type: 'bars',
                  className: 'more-button',
                  onClick: function onClick(e) {
                    return _this6.onClickTestSuiteMore(e, ts, tsIndex);
                  }
                })
              ),
              ts.cases.length > 0 ? react_default.a.createElement(
                'ul',
                { className: 'test-suite-cases' },
                ts.cases.map(function (item, tcIndex) {
                  return react_default.a.createElement(
                    'li',
                    {
                      key: tcIndex,
                      className: _this6.getTsTestCaseClass(tcIndex, ts.playStatus),
                      onContextMenu: function onContextMenu(e) {
                        return _this6.onClickTsTestCaseMore(e, item, tcIndex, ts, tsIndex);
                      }
                    },
                    react_default.a.createElement(icon_default.a, {
                      type: 'file',
                      style: { marginRight: '10px', cursor: 'pointer' },
                      onClick: function onClick() {
                        var src = _this6.props.editing.meta.src;

                        var go = function go() {
                          _this6.props.editTestCase(item.testCaseId);
                          return Promise.resolve();
                        };

                        return Object(save_test_case["default"])().saveOrNot().then(go);
                      }
                    }),
                    react_default.a.createElement(
                      select_default.a,
                      {
                        showSearch: true,
                        optionFilterProp: 'children',
                        value: item.testCaseId,
                        onChange: function onChange(val) {
                          return _this6.onChangeTsCase('testCaseId', val, tcIndex, ts, tsIndex);
                        },
                        filterOption: function filterOption(input, data) {
                          return data.props.children.toLowerCase().indexOf(input.toLowerCase()) !== -1;
                        },
                        style: { flex: 1, marginRight: '10px', maxWidth: '50%' },
                        dropdownClassName: 'macros-dropdown'
                      },
                      _this6.props.macros.map(function (macro) {
                        return react_default.a.createElement(
                          select_default.a.Option,
                          { value: macro.relativePath, key: macro.relativePath },
                          macro.relativePath.replace(/\.json$/, '')
                        );
                      })
                    ),
                    react_default.a.createElement(input_default.a, {
                      type: 'number',
                      min: 1,
                      value: item.loops,
                      onChange: function onChange(e) {
                        return _this6.onChangeTsCase('loops', e.target.value.trim().length === 0 ? '1' : e.target.value, tcIndex, ts, tsIndex);
                      },
                      style: { width: '45px', marginRight: '10px' }
                    }),
                    react_default.a.createElement(icon_default.a, {
                      type: 'close',
                      style: { cursor: 'pointer' },
                      onClick: function onClick() {
                        return _this6.removeTestCaseFromTestSuite(ts, tcIndex);
                      }
                    })
                  );
                })
              ) : null,
              react_default.a.createElement(
                'div',
                { className: 'test-suite-more-actions' },
                react_default.a.createElement(
                  button_default.a,
                  {
                    type: 'default',
                    onClick: function onClick() {
                      return _this6.addTestCaseToTestSuite(ts);
                    }
                  },
                  '+ Macro'
                )
              )
            );
          })
        )
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _this7 = this;

      if (!this.props.shouldLoadResources) {
        return react_default.a.createElement(resource_not_loaded["ResourceNotLoaded"], {
          name: 'Test suite list',
          from: this.props.from,
          showList: function showList() {
            _this7.props.setFrom(reducers_state["RunBy"].Manual);
          }
        });
      }

      return react_default.a.createElement(
        'div',
        null,
        this.renderTestSuites(),
        this.renderTestSuiteContextMenu(),
        this.renderTestSuiteCaseContextMenu(),
        this.renderEditTestSuiteSource()
      );
    }
  }]);

  return SidebarTestSuites;
}(react_default.a.Component);

/* harmony default export */ var test_suites = (Object(react_redux_es["b" /* connect */])(function (state) {
  return {
    status: state.status,
    from: state.from,
    shouldLoadResources: Object(recomputed["getShouldLoadResources"])(state),
    macros: Object(recomputed["getMacroFileNodeList"])(state),
    testSuites: Object(recomputed["getTestSuitesWithAllInfo"])(state),
    editing: state.editor.editing,
    player: state.player,
    config: state.config
  };
}, function (dispatch) {
  return Object(redux_es["b" /* bindActionCreators */])(test_suites_extends({}, actions, simple_actions["Actions"]), dispatch);
})(test_suites_SidebarTestSuites));
// EXTERNAL MODULE: ./node_modules/keycode/index.js
var keycode = __webpack_require__(407);
var keycode_default = /*#__PURE__*/__webpack_require__.n(keycode);

// CONCATENATED MODULE: ./src/components/search_box.js




var search_box_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var search_box_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function search_box_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function search_box_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function search_box_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var search_box_SearchBox = function (_Input) {
  search_box_inherits(SearchBox, _Input);

  function SearchBox() {
    search_box_classCallCheck(this, SearchBox);

    return search_box_possibleConstructorReturn(this, (SearchBox.__proto__ || Object.getPrototypeOf(SearchBox)).apply(this, arguments));
  }

  search_box_createClass(SearchBox, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _ref = this.props.inputProps || {},
          value = _ref.value;

      var canClear = value !== undefined && value.length > 0;

      return react_default.a.createElement(
        'span',
        {
          className: this.props.className,
          style: search_box_extends({}, this.props.style || {}, {
            position: 'relative'
          })
        },
        react_default.a.createElement(input_default.a, this.props.inputProps || {}),
        react_default.a.createElement(icon_default.a, {
          type: canClear ? 'close' : 'search',
          onClick: function onClick(e) {
            if (!canClear) return;
            if (!_this2.props.inputProps || !_this2.props.inputProps.onChange) return;
            _this2.props.inputProps.onChange({ target: { value: '' } });
          },
          style: {
            position: 'absolute',
            right: '10px',
            top: '50%',
            transform: 'translateY(-50%)',
            cursor: canClear ? 'pointer' : 'auto'
          }
        })
      );
    }
  }]);

  return SearchBox;
}(input_default.a);

/* harmony default export */ var search_box = (search_box_SearchBox);
// EXTERNAL MODULE: ./src/components/tree_file.tsx
var tree_file = __webpack_require__(137);

// EXTERNAL MODULE: ./src/components/context_menu.tsx
var context_menu = __webpack_require__(71);

// EXTERNAL MODULE: ./src/common/messages.ts
var messages = __webpack_require__(159);
var messages_default = /*#__PURE__*/__webpack_require__.n(messages);

// CONCATENATED MODULE: ./src/containers/sidebar/test_cases.js























var test_cases_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var test_cases_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _templateObject = _taggedTemplateLiteral([''], ['']);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function test_cases_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function test_cases_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function test_cases_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
































var test_cases_SidebarTestCases = function (_React$Component) {
  test_cases_inherits(SidebarTestCases, _React$Component);

  function SidebarTestCases() {
    var _ref;

    var _temp, _this, _ret;

    test_cases_classCallCheck(this, SidebarTestCases);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = test_cases_possibleConstructorReturn(this, (_ref = SidebarTestCases.__proto__ || Object.getPrototypeOf(SidebarTestCases)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      showRename: false,
      rename: '',
      folderToImport: '/'
    }, _this.unbindKeydown = function () {}, _this.onClickRename = function () {
      _this.props.renameTestCase(_this.state.rename, _this.state.renameTcId).then(function () {
        message_default.a.success('successfully renamed!', 1.5);
        _this.toggleRenameModal(false);
      }).catch(function (e) {
        message_default.a.error(e.message, 1.5);
      });
    }, _this.onCancelRename = function () {
      _this.toggleRenameModal(false);
      _this.setState({
        rename: null
      });
    }, _this.onChangeRename = function (e) {
      _this.setState({
        rename: e.target.value
      });
    }, _this.toggleRenameModal = function (toShow, macroNode) {
      _this.setState({
        showRename: toShow,
        renameTcId: macroNode && macroNode.fullPath
      });

      if (toShow) {
        setTimeout(function () {
          var input = _this.inputRenameTestCase.refs.input;
          input.focus();
          input.selectionStart = input.selectionEnd = input.value.length;
        }, 100);
      }
    }, _this.changeTestCase = function (id) {
      return new Promise(function (resolve) {
        if (_this.props.status !== constant["APP_STATUS"].NORMAL) return resolve(false);
        if (_this.props.editing.meta.src && _this.props.editing.meta.src.id === id) return resolve(true);

        var go = function go() {
          _this.props.editTestCase(id);
          resolve(true);
        };

        // Do not ask for save if it's currently on Untitled and no commands in it
        if (_this.props.editing.commands.length === 0 && !_this.props.editing.meta.src) {
          return go();
        }

        return Object(save_test_case["default"])().saveOrNot().then(go);
      });
    }, _this.playTestCase = function (id) {
      if (_this.props.status !== constant["APP_STATUS"].NORMAL) return;

      _this.changeTestCase(id).then(function (shouldPlay) {
        if (!shouldPlay) return;

        setTimeout(function () {
          var commands = _this.props.editing.commands;

          var openTc = commands.find(function (item) {
            return item.cmd.toLowerCase() === 'open';
          });
          var src = _this.props.editing.meta.src;

          var getMacroName = function getMacroName() {
            return src && src.name && src.name.length ? src.name : 'Untitled';
          };
          var getMacroId = function getMacroId() {
            return src ? src.id : constant["UNTITLED_ID"];
          };

          _this.props.playerPlay({
            macroId: getMacroId(),
            title: getMacroName(),
            extra: { id: getMacroId() },
            mode: Object(common_player["b" /* getPlayer */])().C.MODE.STRAIGHT,
            startIndex: 0,
            startUrl: openTc ? openTc.target : null,
            resources: commands,
            postDelay: _this.props.player.playInterval * 1000
          });
        }, 500);
      });
    }, _this.onJsonOrZipFileChange = function (e) {
      setTimeout(function () {
        _this.jsonFileInput.value = null;
      }, 500);

      return _this.props.importMacroJsonOrZipFiles(e.target.files, _this.state.folderToImport);
    }, _this.addTestCase = function () {
      return Object(save_test_case["default"])().saveOrNot().then(function () {
        _this.props.macroCreateFile({
          dir: '/'
        });
      });
    }, _this.onClickMacroNode = function (data, paths, e) {
      if (data.type === tree_file["FileNodeType"].File) {
        _this.changeTestCase(data.id);
      }
    }, _this.onContextMenuNode = function (data, paths, e) {
      return _this.showContextMenuForEntry(data, e);
    }, _this.onToggleNode = function (data, paths) {
      return _this.props.updateMacroExtra(data.id, { folded: !data.folded });
    }, _this.onMoveNode = function (sourceId, targetId, isDirectory) {
      _this.props.macroMoveEntry({
        entryId: sourceId,
        dirId: targetId,
        isSourceDirectory: isDirectory
      });
    }, _this.onDoubleClickNode = function (data, paths, e) {
      if (data.type === tree_file["FileNodeType"].File) {
        _this.playTestCase(data.id);
      }
    }, _temp), test_cases_possibleConstructorReturn(_this, _ret);
  }

  // Rename relative


  test_cases_createClass(SidebarTestCases, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.bindKeydown();
    }
  }, {
    key: 'bindKeydown',
    value: function bindKeydown() {
      var _this2 = this;

      var fn = function fn(e) {
        if (!_this2.props.canUseKeyboardShortcuts) {
          return;
        }

        if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey) {
          return;
        }

        switch (keycode_default()(e)) {
          case 'up':
            e.preventDefault();
            return _this2.props.editMacroByOffset(-1);

          case 'down':
            e.preventDefault();
            return _this2.props.editMacroByOffset(1);
        }
      };

      document.addEventListener('keydown', fn, true);
      this.unbindKeydown = function () {
        return document.removeEventListener('keydown', fn, true);
      };
    }
  }, {
    key: 'renderMacros',
    value: function renderMacros() {
      var filteredMacroFileNodeData = this.props.filteredMacroFileNodeData;


      if (this.props.isLoadingMacros && this.props.isMacroFolderNodeListEmpty) {
        return react_default.a.createElement(
          'div',
          { className: 'no-data' },
          'Loading macros...'
        );
      }

      return react_default.a.createElement(
        'div',
        { className: 'sidebar-macros' },
        filteredMacroFileNodeData.length === 0 ? react_default.a.createElement(
          'div',
          { className: 'no-data' },
          'No macro found'
        ) : null,
        react_default.a.createElement(tree_file["FileTree"], {
          nodes: filteredMacroFileNodeData,
          rootPath: Object(storage["getStorageManager"])().getMacroStorage().dirPath(''),
          onClick: this.onClickMacroNode,
          onContextMenu: this.onContextMenuNode,
          onToggle: this.onToggleNode,
          onMove: this.onMoveNode,
          onDoubleClick: this.onDoubleClickNode
        })
      );
    }
  }, {
    key: 'showContextMenuForEntry',
    value: function showContextMenuForEntry(entry, e) {
      switch (entry.type) {
        case tree_file["FileNodeType"].File:
          return this.showContextMenuForMacro(entry, e);

        case tree_file["FileNodeType"].Folder:
          return this.showContextMenuForFolder(entry, e);
      }
    }
  }, {
    key: 'showContextMenuForFolder',
    value: function showContextMenuForFolder(folderEntry, e) {
      var _this3 = this;

      e.stopPropagation();
      e.preventDefault();

      return Object(context_menu["showContextMenu"])({
        x: e.clientX,
        y: e.clientY,
        onHide: function onHide() {},
        menuItems: [{
          type: context_menu["MenuItemType"].Button,
          disabled: !Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Edit),
          data: {
            content: 'New macro',
            onClick: function onClick() {
              return Object(save_test_case["default"])().saveOrNot().then(function () {
                _this3.props.macroCreateFile({
                  dir: folderEntry.entryPath
                });
              });
            }
          }
        }, {
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'New folder',
            onClick: function onClick() {
              _this3.props.macroCreateFolder({
                name: 'untitled',
                dir: folderEntry.entryPath
              });
            }
          }
        }, {
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'Rename',
            onClick: function onClick() {
              _this3.props.macroRenameFolder({
                dir: folderEntry.entryPath
              });
            }
          }
        }, {
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'Delete',
            onClick: function onClick() {
              _this3.props.macroDeleteFolder({
                dir: folderEntry.entryPath
              });
            }
          }
        }, {
          type: context_menu["MenuItemType"].Divider,
          data: {}
        }, {
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'Testsuite: Play all in folder',
            onClick: function onClick() {
              var folderName = folderEntry.name;
              var macros = folderEntry.children.filter(function (item) {
                return item.type === tree_file["FileNodeType"].File;
              });

              Object(common_player["b" /* getPlayer */])({ name: 'testSuite' }).play({
                title: folderName,
                mode: Object(common_player["b" /* getPlayer */])().C.MODE.STRAIGHT,
                startIndex: 0,
                resources: macros.map(function (item) {
                  return {
                    id: item.id,
                    loops: 1
                  };
                }),
                extra: {
                  id: folderEntry.id,
                  name: folderName
                }
              });
            }
          }
        }, {
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'Testsuite: Play in loop',
            onClick: function onClick() {
              var playInLoops = function playInLoops(loopsStr) {
                var loops = parseInt(loopsStr);

                if (isNaN(loops) || loops < 1) {
                  throw new Error('Invalid loops: ' + loopsStr);
                }

                var folderName = folderEntry.name;
                var macros = folderEntry.children.filter(function (item) {
                  return item.type === tree_file["FileNodeType"].File;
                });

                Object(common_player["b" /* getPlayer */])({ name: 'testSuite' }).play({
                  title: folderName,
                  mode: loops === 1 ? Object(common_player["b" /* getPlayer */])().C.MODE.STRAIGHT : Object(common_player["b" /* getPlayer */])().C.MODE.LOOP,
                  loopsStart: 1,
                  loopsEnd: loops,
                  startIndex: 0,
                  resources: macros.map(function (item) {
                    return {
                      id: item.id,
                      loops: 1
                    };
                  }),
                  extra: {
                    id: folderEntry.id,
                    name: folderName
                  }
                });
              };

              var run = function run() {
                return Object(components_prompt["prompt"])({
                  width: 400,
                  title: 'How many loops?',
                  message: '',
                  value: '2',
                  placeholder: 'Loops',
                  inputType: 'number',
                  selectionStart: 0,
                  selectionEnd: 1,
                  okText: 'Play',
                  cancelText: 'Cancel',
                  onCancel: function onCancel() {
                    return Promise.resolve(true);
                  },
                  onOk: playInLoops
                }).catch(function (e) {
                  message_default.a.error(e.message);
                  setTimeout(run, 0);
                });
              };

              return run();
            }
          }
        }, {
          type: context_menu["MenuItemType"].Divider,
          data: {}
        }, {
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'Import JSON or ZIP',
            onClick: function onClick() {
              var $selectFile = document.getElementById('select_json_files_for_macros');

              if ($selectFile) {
                _this3.setState({ folderToImport: folderEntry.entryPath });
                $selectFile.click();
              }
            }
          }
        }]
      });
    }
  }, {
    key: 'showContextMenuForMacro',
    value: function showContextMenuForMacro(macroEntry, event) {
      var _this4 = this;

      var macros = this.props.macros;

      var macroNode = macros.find(function (item) {
        return item.fullPath === macroEntry.id;
      });

      if (!macroNode) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();

      var e = {
        clientX: event.clientX,
        clientY: event.clientY,
        stopPropagation: function stopPropagation() {},
        preventDefault: function preventDefault() {}
      };

      return Object(context_menu["showContextMenu"])({
        x: e.clientX,
        y: e.clientY,
        onHide: function onHide() {},
        menuItems: [{
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'Play',
            onClick: function onClick() {
              _this4.playTestCase(macroNode.fullPath);
            }
          }
        }, {
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'Testsuite: Play from here',
            onClick: function onClick() {
              var macroStorage = Object(storage["getStorageManager"])().getMacroStorage();
              var path = macroStorage.getPathLib();
              var dirPath = path.dirname(macroEntry.entryPath);

              return macroStorage.list(dirPath).then(function (entries) {
                var macros = entries.filter(function (entry) {
                  return entry.isFile;
                });
                var index = macros.findIndex(function (macro) {
                  return macro.fullPath === macroEntry.entryPath;
                });

                if (index === -1) {
                  return;
                }

                var folderName = path.basename(dirPath);

                Object(common_player["b" /* getPlayer */])({ name: 'testSuite' }).play({
                  title: folderName,
                  mode: Object(common_player["b" /* getPlayer */])().C.MODE.STRAIGHT,
                  startIndex: index,
                  resources: macros.map(function (item) {
                    return {
                      id: item.fullPath,
                      loops: 1
                    };
                  }),
                  extra: {
                    id: dirPath,
                    name: folderName
                  }
                });
              });
            }
          }
        }, {
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'Rename..',
            onClick: function onClick() {
              return Object(save_test_case["default"])().saveOrNot().then(function () {
                _this4.setState({
                  rename: macroNode.name
                });
                _this4.toggleRenameModal(true, macroNode);
              });
            }
          }
        }, {
          type: context_menu["MenuItemType"].Button,
          disabled: !Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Edit),
          data: {
            content: 'Duplicate..',
            onClick: function onClick() {
              return Object(save_test_case["default"])().saveOrNot().then(function () {
                _this4.props.duplicateTestCase(macroNode);
              });
            }
          }
        }, {
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'Export as JSON',
            onClick: function onClick() {
              _this4.props.downloadMacroAsJson(macroNode.fullPath);
            }
          }
        }, {
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'Export as ZIP (json, img & csv)',
            onClick: function onClick() {
              _this4.props.downloadMacroAsZip(macroNode.fullPath);
            }
          }
        }, {
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'Create autorun HTML',
            onClick: function onClick() {
              if (!web_extension_default.a.isFirefox()) {
                web_extension_default.a.extension.isAllowedFileSchemeAccess().then(function (isAllowed) {
                  if (isAllowed) return;
                  var msg = 'To run macro from html file, you need to enable "Allow access to file URLs" in extension details page';
                  message_default.a.warn(msg);
                  _this4.props.addLog('warning', msg);
                });
              }

              function downloadUiVisionHtml() {
                var str = Object(convert_utils["generateEmptyHtml"])();
                var blob = new Blob([str], { type: 'text/plain;charset=utf-8' });

                file_saver_default.a.saveAs(blob, 'ui.vision.html', true);
              }

              function downloadEntryHtml(macroNode) {
                var str = Object(convert_utils["generateMacroEntryHtml"])(macroNode.relativePath);
                var blob = new Blob([str], { type: 'text/plain;charset=utf-8' });

                file_saver_default.a.saveAs(blob, 'start-' + macroNode.name + '.html', true);
              }

              downloadUiVisionHtml();
              downloadEntryHtml(macroNode);
            }
          }
        }, {
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'Add shortcut to bookmarks bar',
            onClick: function onClick() {
              var bookmarkTitle = window.prompt('Title for this bookmark', '#' + macroNode.name + '.rpa');
              if (bookmarkTitle === null) return;

              bookmark_createBookmarkOnBar(Object(convert_utils["toBookmarkData"])({
                bookmarkTitle: bookmarkTitle,
                path: macroNode.relativePath
              })).then(function () {
                message_default.a.success('successfully created bookmark!', 1.5);
              });
            }
          }
        }, Object(storage["getStorageManager"])().isXFileMode() ? {
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'Copy to Local Storage',
            onClick: function onClick() {
              Object(storage["getStorageManager"])().isStrategyTypeAvailable(storage["StorageStrategyType"].Browser).then(function () {
                var macroStorage = Object(storage["getStorageManager"])().getStorageForTarget(storage["StorageTarget"].Macro, storage["StorageStrategyType"].Browser);

                return Object(storage["getStorageManager"])().getStorageForTarget(storage["StorageTarget"].Macro, storage["StorageStrategyType"].XFile).read(macroNode.fullPath, 'Text').then(function (macro) {
                  var tcCopy = test_cases_extends({}, macro, { id: Object(ts_utils["uid"])() });
                  delete tcCopy.status;

                  return macroStorage.write(tcCopy.name, tcCopy).then(function () {
                    return message_default.a.success('copied');
                  });
                });
              }).catch(function (e) {
                message_default.a.warn(e.message);
              });
            }
          }
        } : null, Object(storage["getStorageManager"])().isBrowserMode() ? {
          type: context_menu["MenuItemType"].Button,
          data: {
            content: 'Copy to Macro Folder',
            onClick: function onClick() {
              Object(storage["getStorageManager"])().isStrategyTypeAvailable(storage["StorageStrategyType"].XFile).then(function () {
                var macroStorage = Object(storage["getStorageManager"])().getStorageForTarget(storage["StorageTarget"].Macro, storage["StorageStrategyType"].XFile);

                return Object(storage["getStorageManager"])().getStorageForTarget(storage["StorageTarget"].Macro, storage["StorageStrategyType"].Browser).read(macroNode.fullPath, 'Text').then(function (macro) {
                  var tcCopy = test_cases_extends({}, macro, { id: Object(ts_utils["uid"])() });
                  delete tcCopy.status;

                  return macroStorage.write(tcCopy.name, tcCopy).then(function () {
                    return message_default.a.success('copied');
                  });
                });
              }).catch(function (e) {
                log_default.a.error(e);
                _this4.props.updateUI({ showXFileNotInstalledDialog: 1 });
              });
            }
          }
        } : null, {
          type: context_menu["MenuItemType"].Divider,
          data: {}
        }, {
          type: context_menu["MenuItemType"].Button,
          disabled: !Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Edit),
          data: {
            content: 'Delete',
            onClick: function onClick() {
              var go = function go() {
                return _this4.props.removeTestCase(macroNode.fullPath).then(function () {
                  message_default.a.success('successfully deleted!', 1.5);
                }).catch(function (e) {
                  modal_default.a.warning({
                    title: 'Failed to delete',
                    content: e.message
                  });
                });
              };

              modal_default.a.confirm({
                title: 'Sure to delete?',
                content: 'Do you really want to delete "' + macroNode.name + '"?',
                okText: 'Delete',
                cancelText: 'Cancel',
                onOk: go,
                onCancel: function onCancel() {}
              });
            }
          }
        }].filter(function (x) {
          return x;
        })
      });
    }
  }, {
    key: 'renderTestCaseMenu',
    value: function renderTestCaseMenu() {
      var _this5 = this;

      var onClickMenuItem = function onClickMenuItem(_ref2) {
        var key = _ref2.key;

        switch (key) {
          case 'new_macro_folder':
            {
              _this5.props.macroCreateFolder({
                name: 'untitled',
                dir: '/'
              });
              break;
            }

          case 'export_all_json':
            {
              var macroStorage = Object(storage["getStorageManager"])().getMacroStorage();
              var path = macroStorage.getPathLib();
              var zip = new jszip_min_default.a();
              var getFolder = function getFolder(relativePath, zipRoot) {
                var dirs = relativePath.split(/\/|\\/g);

                return dirs.reduce(function (prev, dir) {
                  return prev.folder(dir);
                }, zipRoot);
              };

              if (_this5.props.macros.length === 0) {
                return message_default.a.error('No saved macros to export', 1.5)(_templateObject);
              }

              return Promise.all(_this5.props.macros.map(function (macroNode) {
                var dirPath = path.dirname(macroNode.relativePath);
                var fileName = path.basename(macroNode.relativePath);
                var folder = getFolder(dirPath, zip);

                return Object(storage["getStorageManager"])().getMacroStorage().read(macroNode.fullPath, 'Text').then(function (macro) {
                  folder.file(fileName, Object(convert_utils["toJSONString"])({
                    name: macro.name,
                    commands: macro.data.commands
                  }, {
                    ignoreTargetOptions: _this5.props.ignoreTargetOptions
                  }));
                });
              })).then(function () {
                return zip.generateAsync({ type: 'blob' }).then(function (blob) {
                  file_saver_default.a.saveAs(blob, 'all_test_cases.zip');
                });
              });
            }

          case 'import_json':
            {
              var $selectFile = document.getElementById('select_json_files_for_macros');

              if ($selectFile) {
                _this5.setState({ folderToImport: '/' });
                $selectFile.click();
              }

              break;
            }
        }
      };

      return react_default.a.createElement(
        menu_default.a,
        { onClick: onClickMenuItem, selectable: false },
        react_default.a.createElement(
          menu_default.a.Item,
          {
            key: 'new_macro_folder'
          },
          'New Folder'
        ),
        react_default.a.createElement(menu_default.a.Divider, null),
        react_default.a.createElement(
          menu_default.a.Item,
          {
            key: 'import_json'
          },
          'Import JSON or ZIP'
        )
      );
    }
  }, {
    key: 'renderRenameModal',
    value: function renderRenameModal() {
      var _this6 = this;

      return react_default.a.createElement(
        modal_default.a,
        {
          title: 'Rename the macro as..',
          okText: 'Save',
          cancelText: 'Cancel',
          visible: this.state.showRename,
          onOk: this.onClickRename,
          onCancel: this.onCancelRename,
          className: 'rename-modal'
        },
        react_default.a.createElement(input_default.a, {
          style: { width: '100%' },
          value: this.state.rename,
          onKeyDown: function onKeyDown(e) {
            e.keyCode === 13 && _this6.onClickRename();
          },
          onChange: this.onChangeRename,
          placeholder: 'macro name',
          ref: function ref(el) {
            _this6.inputRenameTestCase = el;
          }
        })
      );
    }
  }, {
    key: 'renderShowListAction',
    value: function renderShowListAction() {
      var _this7 = this;

      return react_default.a.createElement(resource_not_loaded["ResourceNotLoaded"], {
        name: 'Macro list',
        from: this.props.from,
        showList: function showList() {
          _this7.props.setFrom(reducers_state["RunBy"].Manual);
        }
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this8 = this;

      if (!this.props.shouldLoadResources) {
        return this.renderShowListAction();
      }

      if (this.props.isPlaying && this.props.macros.length > config_default.a.performanceLimit.fileCount) {
        return react_default.a.createElement(
          'div',
          { className: 'hidden-during-replay' },
          messages_default.a.contentHidden
        );
      }

      return react_default.a.createElement(
        'div',
        null,
        react_default.a.createElement('input', {
          multiple: true,
          type: 'file',
          accept: '.json, .zip',
          id: 'select_json_files_for_macros',
          onChange: this.onJsonOrZipFileChange,
          ref: function ref(_ref3) {
            _this8.jsonFileInput = _ref3;
          },
          style: { display: 'none' }
        }),
        react_default.a.createElement(
          'div',
          { className: 'test-case-actions' },
          react_default.a.createElement(
            button_default.a,
            {
              type: 'primary',
              disabled: !Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Edit),
              onClick: this.addTestCase
            },
            '+ Macro'
          ),
          react_default.a.createElement(
            dropdown_default.a,
            {
              overlay: this.renderTestCaseMenu(),
              trigger: ['click']
            },
            react_default.a.createElement(
              button_default.a,
              { shape: 'circle' },
              react_default.a.createElement(icon_default.a, { type: 'folder-add' })
            )
          ),
          react_default.a.createElement(search_box, {
            style: { flex: 1 },
            inputProps: {
              placeholder: 'search macro',
              value: this.props.searchText,
              onChange: function onChange(e) {
                return _this8.props.setMacroQuery(e.target.value);
              }
            }
          })
        ),
        this.renderMacros(),
        this.renderRenameModal()
      );
    }
  }]);

  return SidebarTestCases;
}(react_default.a.Component);

/* harmony default export */ var test_cases = (Object(react_redux_es["b" /* connect */])(function (state) {
  return {
    status: state.status,
    from: state.from,
    shouldLoadResources: Object(recomputed["getShouldLoadResources"])(state),
    isLoadingMacros: state.isLoadingMacros,
    isMacroFolderNodeListEmpty: Object(recomputed["isMacroFolderNodeListEmpty"])(state),
    macroFileNodeData: Object(recomputed["getMacroFileNodeData"])(state),
    macros: Object(recomputed["getMacroFileNodeList"])(state),
    isPlaying: Object(recomputed["isPlaying"])(state),
    testSuites: state.editor.testSuites,
    editing: state.editor.editing,
    player: state.player,
    config: state.config,
    ignoreTargetOptions: Object(recomputed["getShouldSaveAlternativeLocators"])(state),
    searchText: state.macroQuery,
    filteredMacroFileNodeData: Object(recomputed["getFilteredMacroFileNodeData"])(state),
    canUseKeyboardShortcuts: Object(recomputed["isFocusOnSidebar"])(state) && state.ui.sidebarTab !== 'test_suites'
  };
}, function (dispatch) {
  return Object(redux_es["b" /* bindActionCreators */])(test_cases_extends({}, actions, simple_actions["Actions"]), dispatch);
})(test_cases_SidebarTestCases));
// CONCATENATED MODULE: ./src/containers/sidebar/index.js











var sidebar_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var sidebar_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function sidebar_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function sidebar_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function sidebar_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }















var sidebar_Sidebar = function (_React$Component) {
  sidebar_inherits(Sidebar, _React$Component);

  function Sidebar() {
    var _ref;

    var _temp, _this, _ret;

    sidebar_classCallCheck(this, Sidebar);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = sidebar_possibleConstructorReturn(this, (_ref = Sidebar.__proto__ || Object.getPrototypeOf(Sidebar)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      drag: {
        isDragging: false,
        startX: 0,
        movingX: 0,
        lastWidth: 260,
        currentMinWidth: 260
      }
    }, _this.getSideBarMinWidth = function () {
      var _this$state$drag = _this.state.drag,
          isDragging = _this$state$drag.isDragging,
          lastWidth = _this$state$drag.lastWidth,
          currentMinWidth = _this$state$drag.currentMinWidth;

      return (isDragging ? currentMinWidth : lastWidth) + 'px';
    }, _this.onResizeDragStart = function (e) {
      // Note: Firefox requires us to set something to DataTransfer, otherwise drag and dragEnd won't be triggered
      // refer to https://stackoverflow.com/questions/33434275/firefox-on-drag-end-is-not-called-in-a-react-component
      e.dataTransfer.setData('text', '');

      var style = window.getComputedStyle(_this.$dom);
      var width = parseInt(style.width);

      _this.setState(Object(utils["setIn"])(['drag'], {
        isDragging: true,
        // Check out the note on `screenX` in `onResizeDragEnd` event
        startX: e.screenX,
        lastWidth: width,
        currentWidth: width
      }, _this.state));
    }, _this.onResizeDragEnd = function (e) {
      // Note: use `screenX` instead of `clientX`, because `clientX` of dragEnd events in Firefox
      // is always set to 0, while `screenX` is luckily still available. And since we only make use of
      // difference of X coordinate. `screenX` and `clientX` both work for us.
      //
      // reference:
      // https://bugzilla.mozilla.org/show_bug.cgi?id=505521
      // https://developer.mozilla.org/en-US/docs/Web/Events/dragend
      var diff = e.screenX - _this.state.drag.startX;
      var width = diff + _this.state.drag.lastWidth;

      _this.setState(Object(utils["setIn"])(['drag'], {
        isDragging: false,
        startX: 0,
        lastWidth: width,
        currentMinWidth: width
      }));
    }, _this.onTryToChangeStorageMode = function (storageMode) {
      // Steps:
      // 1. [pseudo code] StorageManager.changeMode()
      // 2. Try to refresh / reload all resources (macros, test suites, csvs, vision images)
      // 3. Be aware of any pending changes in current storage
      //
      // There should be no exception when switching back to browser mode
      // But `[pseudo code] StorageManager.changeMode(xFileMode)` should throw error when xFile is not ready.
      //
      // Once catched that error, should do following:
      // 1. Reset mode back to browser mode
      // 2. Show info dialog to encourage users to download xFile host

      var man = Object(storage["getStorageManager"])();

      man.isStrategyTypeAvailable(storageMode).then(function (isOk) {
        if (isOk) {
          // Note: it will emit events, so that `index.js` could handle the rest (refresh / reload resources)
          _this.props.updateConfig({ storageMode: storageMode });
          return man.setCurrentStrategyType(storageMode);
        }

        throw new Error('It should be impossible to get isOk as false');
      }).catch(function (e) {
        message_default.a.warn(e.message);

        if (e.message && /xFile is not installed yet/.test(e.message)) {
          _this.props.updateUI({ showXFileNotInstalledDialog: true });
        } else {
          _this.props.updateUI({ showSettings: true, settingsTab: 'xmodules' });
        }
      });
    }, _this.openRegisterSettings = function (e) {
      if (e && e.preventDefault) e.preventDefault();
      _this.props.updateUI({ showSettings: true, settingsTab: 'register' });
    }, _this.onClickSidebar = function () {
      _this.props.updateUI({ focusArea: reducers_state["FocusArea"].Sidebar });
    }, _temp), sidebar_possibleConstructorReturn(_this, _ret);
  }

  sidebar_createClass(Sidebar, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var type = Object(storage["getStorageManager"])().getCurrentStrategyType();
      this.setState({ storageMode: type });
    }
  }, {
    key: 'prefixHardDisk',
    value: function prefixHardDisk(str) {
      var isXFileMode = Object(storage["getStorageManager"])().isXFileMode();
      if (!isXFileMode) return str;

      return react_default.a.createElement(
        'div',
        {
          style: {
            display: 'inline-block'
          }
        },
        react_default.a.createElement('img', {
          src: './img/hard-drive.svg',
          style: {
            position: 'relative',
            top: '3px',
            marginRight: '5px',
            height: '15px'
          }
        }),
        react_default.a.createElement(
          'span',
          null,
          str
        )
      );
    }
  }, {
    key: 'renderXFileNotInstalledModal',
    value: function renderXFileNotInstalledModal() {
      var _this2 = this;

      return react_default.a.createElement(
        modal_default.a,
        {
          title: '',
          className: Object(utils["cn"])('xfile-not-installed-modal', { 'left-bottom': this.props.ui.showXFileNotInstalledDialog === true }),
          width: 350,
          footer: null,
          visible: this.props.ui.showXFileNotInstalledDialog,
          onCancel: function onCancel() {
            _this2.props.updateUI({ showXFileNotInstalledDialog: false });
          }
        },
        react_default.a.createElement(
          'p',
          null,
          'XFileAccess Module not installed.'
        ),
        react_default.a.createElement(
          'div',
          null,
          react_default.a.createElement(
            button_default.a,
            {
              type: 'primary',
              onClick: function onClick() {
                _this2.props.updateUI({
                  showXFileNotInstalledDialog: false,
                  showSettings: true,
                  settingsTab: 'xmodules'
                });
              }
            },
            'Open Settings'
          )
        )
      );
    }
  }, {
    key: 'shouldRenderMacroNote',
    value: function shouldRenderMacroNote() {
      var _props$config = this.props.config,
          xmodulesStatus = _props$config.xmodulesStatus,
          storageMode = _props$config.storageMode;


      if (storageMode !== storage["StorageStrategyType"].XFile) return false;
      if (xmodulesStatus === 'pro') return false;

      var macroStorage = Object(storage["getStorageManager"])().getMacroStorage();
      return macroStorage.getDisplayCount() < macroStorage.getTotalCount();
    }
  }, {
    key: 'renderMacroNote',
    value: function renderMacroNote() {
      if (!this.shouldRenderMacroNote()) return null;

      var max = Object(services_license["getLicenseService"])().getMaxXFileMacros();
      var link = Object(services_license["getLicenseService"])().getUpgradeUrl();

      return react_default.a.createElement(
        'div',
        { className: 'note-for-macros' },
        Object(services_license["getLicenseService"])().hasNoLicense() ? react_default.a.createElement(
          'div',
          null,
          'XModules Free Edition:',
          react_default.a.createElement('br', null),
          'Only the first ',
          max,
          ' files/folders are displayed.',
          react_default.a.createElement('br', null),
          react_default.a.createElement(
            'a',
            { href: link, onClick: this.openRegisterSettings },
            'Upgrade to PRO'
          ),
          ' to add more.'
        ) : null,
        Object(services_license["getLicenseService"])().isPersonalLicense() ? react_default.a.createElement(
          'div',
          null,
          'XModules PRO1 Edition:',
          react_default.a.createElement('br', null),
          'Only the first ',
          max,
          ' files/folders displayed.',
          react_default.a.createElement('br', null),
          react_default.a.createElement(
            'a',
            { href: link, onClick: this.openRegisterSettings },
            'Upgrade to PRO2 or Enterprise'
          ),
          ' for unlimited files'
        ) : null
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      return react_default.a.createElement(
        'div',
        {
          className: Object(utils["cn"])('sidebar', { 'with-xmodules-note': this.shouldRenderMacroNote() }),
          ref: function ref(el) {
            _this3.$dom = el;
          },
          style: { minWidth: this.getSideBarMinWidth() },
          onClickCapture: this.onClickSidebar
        },
        react_default.a.createElement(
          'div',
          { className: Object(utils["cn"])('sidebar-inner', { 'no-tab': !this.props.config.showTestCaseTab }) },
          !this.props.config.showTestCaseTab ? react_default.a.createElement(test_cases, null) : react_default.a.createElement(
            tabs_default.a,
            {
              defaultActiveKey: 'macros',
              activeKey: this.props.ui.sidebarTab || 'macros',
              onChange: function onChange(activeKey) {
                return _this3.props.updateUI({ sidebarTab: activeKey });
              }
            },
            react_default.a.createElement(
              tabs_default.a.TabPane,
              { tab: this.prefixHardDisk('Macros'), key: 'macros' },
              react_default.a.createElement(test_cases, null)
            ),
            react_default.a.createElement(
              tabs_default.a.TabPane,
              { tab: this.prefixHardDisk('Test Suites'), key: 'test_suites' },
              react_default.a.createElement(test_suites, null)
            )
          )
        ),
        react_default.a.createElement(
          'div',
          { className: 'sidebar-storage-mode' },
          this.renderMacroNote(),
          react_default.a.createElement(
            'div',
            { className: 'storage-mode-header' },
            react_default.a.createElement(
              'h3',
              null,
              'Storage Mode'
            ),
            Object(storage["getStorageManager"])().isXFileMode() ? react_default.a.createElement('img', {
              src: './img/reload.svg',
              title: 'Reload all resources on hard drive',
              style: {
                height: '15px',
                cursor: 'pointer'
              },
              onClick: function onClick() {
                Object(storage["getStorageManager"])().emit(storage["StorageManagerEvent"].ForceReload);
                message_default.a.info('reloaded from hard drive');
              }
            }) : null,
            react_default.a.createElement(
              'a',
              { href: 'https://ui.vision/x/idehelp?help=storage_mode', target: '_blank' },
              'More Info'
            )
          ),
          react_default.a.createElement(
            select_default.a,
            {
              style: { width: '100%' },
              placeholder: 'Storage Mode',
              value: this.props.config.storageMode,
              onChange: this.onTryToChangeStorageMode
            },
            react_default.a.createElement(
              select_default.a.Option,
              { value: storage["StorageStrategyType"].Browser },
              'Local Storage (in browser)'
            ),
            react_default.a.createElement(
              select_default.a.Option,
              { value: storage["StorageStrategyType"].XFile },
              'File system (on hard drive)'
            )
          )
        ),
        react_default.a.createElement('div', {
          className: Object(utils["cn"])('resize-handler', { focused: this.state.drag.isDragging }),
          draggable: 'true',
          onDragStart: this.onResizeDragStart,
          onDragEnd: this.onResizeDragEnd,
          onMouseDown: function onMouseDown() {
            return _this3.setState(Object(utils["setIn"])(['drag', 'isDragging'], true, _this3.state));
          }
        }),
        this.renderXFileNotInstalledModal()
      );
    }
  }]);

  return Sidebar;
}(react_default.a.Component);

/* harmony default export */ var containers_sidebar = (Object(react_redux_es["b" /* connect */])(function (state) {
  return {
    status: state.status,
    testSuites: state.editor.testSuites,
    editing: state.editor.editing,
    player: state.player,
    config: state.config,
    ui: state.ui
  };
}, function (dispatch) {
  return Object(redux_es["b" /* bindActionCreators */])(sidebar_extends({}, actions), dispatch);
})(sidebar_Sidebar));
// EXTERNAL MODULE: ./src/containers/dashboard/dashboard.scss
var dashboard = __webpack_require__(1036);

// EXTERNAL MODULE: ./node_modules/antd/lib/table/index.js
var table = __webpack_require__(408);
var table_default = /*#__PURE__*/__webpack_require__.n(table);

// EXTERNAL MODULE: ./node_modules/react-virtual-list/lib/VirtualList.js
var VirtualList = __webpack_require__(643);
var VirtualList_default = /*#__PURE__*/__webpack_require__.n(VirtualList);

// EXTERNAL MODULE: ./src/components/select_input.tsx
var select_input = __webpack_require__(644);

// EXTERNAL MODULE: ./src/containers/dashboard/command_item.tsx
var command_item = __webpack_require__(645);

// EXTERNAL MODULE: ./src/common/inspector.js
var inspector = __webpack_require__(49);

// CONCATENATED MODULE: ./src/containers/dashboard/editor.js











































var editor_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var editor_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function editor_toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function editor_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function editor_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function editor_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function editor_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }


































var newCommand = {
  cmd: '',
  target: '',
  value: ''
};

var defaultDataSource = [newCommand];

var ITEM_HEIGHT = config_default.a.ui.commandItemHeight;

var editor_DashboardEditor = function (_React$Component) {
  editor_inherits(DashboardEditor, _React$Component);

  function DashboardEditor() {
    var _ref;

    var _temp, _this, _ret;

    editor_classCallCheck(this, DashboardEditor);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = editor_possibleConstructorReturn(this, (_ref = DashboardEditor.__proto__ || Object.getPrototypeOf(DashboardEditor)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      cursor: null,

      contextMenu: {
        x: null,
        y: null,
        isShown: false
      },

      visionFindPreview: {
        visible: false,
        url: null,
        timer: null,
        left: -9999,
        top: -9999
      },

      targetEditor: {
        visible: false,
        text: ''
      }
    }, _this.resetSourceCodeCursor = function (resetCursor) {
      return editor_extends({}, resetCursor ? { cursor: { line: 0, ch: 0 } } : {});
    }, _this.onDetailChange = function (key, value) {
      _this.props.updateSelectedCommand(editor_defineProperty({}, key, value));
    }, _this.onChangeCommandsView = function (type) {
      switch (type) {
        case 'table_view':
        case 'source_view':
          {
            var forceType = _this.props.sourceErrMsg ? 'source_view' : type;

            _this.props.setEditorActiveTab(forceType);

            if (type === 'source_view' && _this.codeMirror && _this.state.cursor) {
              // Note: must delay a while so that focus will take effect
              setTimeout(function () {
                _this.codeMirror.setCursor(_this.state.cursor, true, true);
              }, 200);
            }

            break;
          }
      }
    }, _this.onSourceBlur = function () {
      var _this$props = _this.props,
          sourceTextModified = _this$props.sourceTextModified,
          sourceText = _this$props.sourceText;

      _this.props.saveSourceCodeToEditing(sourceTextModified);
    }, _this.onChangeEditSource = function (editor, data, text) {
      _this.props.setSourceCurrent(text);
    }, _this.onClickFind = function () {
      var lastOperation = _this.state.lastOperation;
      var selectedCommand = _this.props.selectedCommand;


      var p = new Promise(function (resolve, reject) {
        switch (selectedCommand.cmd) {
          case 'visualGetPixelColor':
          case 'visionFind':
          case 'visualSearch':
          case 'visualAssert':
          case 'visualVerify':
          case 'visionLimitSearchArea':
          case 'visionLimitSearchAreaRelative':
          case 'XClick':
          case 'XClickRelative':
          case 'XMove':
          case 'XMoveRelative':
          case 'OCRExtract':
          case 'OCRExtractRelative':
          case 'OCRSearch':
            {
              var selectedIndex = _this.props.editing.meta.selectedIndex;
              var run = function run() {
                // Note: run visionFind/visualSearch as single line command, but without timeout waiting
                _this.playLine(selectedIndex, {
                  overrideScope: { '!TIMEOUT_WAIT': 0 },
                  commandExtra: {
                    throwError: true,
                    // visualXXX uses this flag in desktop mode to open Desktop Screenshot Editor to preview result
                    debugVisual: true
                  }
                });
                return resolve(true);
              };

              return _this.waitBeforeScreenCapture().then(run);
            }

          default:
            {
              return ipc_cs["default"].ask('PANEL_HIGHLIGHT_DOM', {
                lastOperation: lastOperation,
                locator: selectedCommand.target
              }).then(resolve, reject);
            }
        }
      });

      p.catch(function (e) {
        message_default.a.error(e.message, 1.5);
      });
    }, _this.onToggleSelect = function () {
      var _this$props2 = _this.props,
          selectedCommand = _this$props2.selectedCommand,
          config = _this$props2.config;

      var p = new Promise(function (resolve, reject) {
        var defaultAction = function defaultAction() {
          if (_this.props.status === constant["APP_STATUS"].INSPECTOR) {
            _this.props.stopInspecting();
          } else {
            _this.props.startInspecting();
          }

          resolve(true);
        };
        var takeImage = function takeImage() {
          var isDesktop = Object(cv_utils["isCVTypeForDesktop"])(config.cvScope);

          return _this.waitBeforeScreenCapture().then(function () {
            if (isDesktop) {
              return ipc_cs["default"].ask('PANEL_SELECT_AREA_ON_DESKTOP');
            } else {
              return ipc_cs["default"].ask('PANEL_SELECT_AREA_ON_CURRENT_PAGE');
            }
          }).then(function (res) {
            return _this.props.renameVisionImage(res.fileName);
          }).then(resolve, reject);
        };

        switch (selectedCommand.cmd) {
          case 'visionFind':
          case 'visualSearch':
          case 'visualAssert':
          case 'visualVerify':
          case 'OCRExtract':
          case 'OCRExtractRelative':
          case 'visionLimitSearchAreaRelative':
          case 'XClickRelative':
          case 'XMoveRelative':
          case 'XMove':
            {
              return takeImage();
            }

          case 'OCRSearch':
            throw new Error('No select possible in OCR mode, just enter the text');

          case 'XClick':
            {
              if (/^ocr=/i.test(selectedCommand.target)) {
                throw new Error('No select possible in OCR mode, just enter the text');
              } else {
                return takeImage();
              }
            }

          case 'visionLimitSearchArea':
            {
              if (Object(cv_utils["isCVTypeForDesktop"])(config.cvScope)) {
                return takeImage();
              } else {
                return defaultAction();
              }
            }

          default:
            {
              return defaultAction();
            }
        }
      });

      p.catch(function (e) {
        message_default.a.error(e.message);
      });
    }, _this.onKeyDown = function (e) {
      if (!_this.props.canUseKeyboardShortcuts) {
        return;
      }

      if (['INPUT', 'TEXTAREA'].indexOf(e.target.tagName) !== -1) {
        return;
      }

      var code = keycode_default()(e.keyCode);
      var isValidCtrlKeyPressed = Object(ts_utils["isMac"])() ? e.metaKey : e.ctrlKey;
      var noModifierKeyPressed = !e.metaKey && !e.ctrlKey && !e.shiftKey && !e.altKey;

      if (isValidCtrlKeyPressed) {
        switch (code) {
          case 'c':
            return _this.props.copyCurrentCommand();

          case 'x':
            return _this.props.cutCurrentCommand();

          case 'v':
            return _this.props.pasteAtCurrentCommand();
        }
      }

      if (noModifierKeyPressed) {
        switch (code) {
          case 'delete':
          case 'backspace':
            {
              var selectedIndex = _this.props.editing.meta.selectedIndex;


              if (selectedIndex === -1) {
                return;
              }

              return _this.props.removeCommand(selectedIndex);
            }

          case 'up':
            if (_this.props.selectedCommandIndex !== null) {
              var commandIndexToSelect = Math.max(0, _this.props.selectedCommandIndex - 1);
              _this.selectCommandAndScroll(commandIndexToSelect);
            }
            break;

          case 'down':
            {
              if (_this.props.selectedCommandIndex !== null) {
                var _commandIndexToSelect = Math.min(_this.props.commandCount - 1, _this.props.selectedCommandIndex + 1);
                _this.selectCommandAndScroll(_commandIndexToSelect);
              }
              break;
            }
        }
      }
    }, _this.onDoubleClick = function () {
      var lastScreenX = void 0;
      var lastScreenY = void 0;
      var lastTime = void 0;

      return function (e) {
        var go = function go() {
          var $row = inspector["a" /* default */].parentWithClass('real-command', e.target);
          if (!$row) return;

          var index = parseInt($row.getAttribute('data-index'));
          if (isNaN(index)) return;

          _this.playLine(index);
        };

        var now = new Date() * 1;

        if (lastScreenX === e.screenX && lastScreenY === e.screenY && now - lastTime < 300) {
          if (e.target.tagName !== 'BUTTON') {
            go();
          }
        }

        lastScreenX = e.screenX;
        lastScreenY = e.screenY;
        lastTime = now;
      };
    }(), _this.onMoveCommand = function (startIndex, endIndex) {
      _this.props.moveCommands(startIndex, endIndex);
    }, _this.onStartDraggingCommand = function () {
      _this.props.setIsDraggingCommand(true);
    }, _this.onEndDraggingCommand = function () {
      _this.props.setIsDraggingCommand(false);
    }, _this.scheduleHideVisionFindPreview = function () {
      log_default()('scheduleHideVisionFindPreview');
      var timer = _this.state.visionFindPreview.timer;


      clearTimeout(timer);

      return setTimeout(function () {
        var visible = _this.state.visionFindPreview.visible;


        if (visible) {
          log_default()('to hide preview');

          _this.setState({
            visionFindPreview: {
              visible: false
            }
          });
        }
      }, 3000);
    }, _this.onMouseEnterTarget = function (e, command) {
      log_default()('onMouseOverTarget');
      if (!_this.commandHasVisionImage(command)) return;
      if (_this.state.visionFindPreview.visible) return;

      clearTimeout(_this.state.visionFindPreview.timer);

      var visionStorage = Object(storage["getStorageManager"])().getVisionStorage();
      var rect = e.target.getBoundingClientRect();
      var file = command.target.trim().split('@')[0];
      var common = {
        visible: true,
        left: rect.left,
        top: rect.top + rect.height
      };

      visionStorage.exists(file).then(function (existed) {
        if (!existed) {
          return _this.setState({
            visionFindPreview: editor_extends({}, common, {
              url: './img/not_found.png',
              timer: _this.scheduleHideVisionFindPreview()
            })
          });
        }

        return visionStorage.getLink(file).then(function (link) {
          return _this.setState({
            visionFindPreview: editor_extends({}, common, {
              url: link,
              timer: _this.scheduleHideVisionFindPreview()
            })
          });
        });
      });
    }, _this.onMouseLeaveTarget = function (e, command) {
      log_default()('onMouseOutTarget');
      if (!_this.commandHasVisionImage(command)) return;
      if (!_this.state.visionFindPreview.visible) return;

      clearTimeout(_this.state.visionFindPreview.timer);

      _this.setState({
        visionFindPreview: {
          visible: false
        }
      });
    }, _this.jumpToSourceCode = function (commandIndex) {
      _this.props.setEditorActiveTab('source_view');
      setTimeout(function () {
        var editing = _this.props.editing;
        var commands = editing.commands;

        var instance = _this.state.cmEdtiorInstance;
        var headingLineCount = 4;
        var ch = 0;

        var $tab = document.querySelector('.source-view');
        var tabHeight = parseInt(window.getComputedStyle($tab).height, 10);
        var margin = (tabHeight - 60) / 2;

        var lineCountForCommand = function lineCountForCommand(command) {
          return 6 + (command.targetOptions ? command.targetOptions.length + 2 : 0);
        };

        var startLine = headingLineCount;

        for (var i = 0; i < commandIndex; i++) {
          startLine += lineCountForCommand(commands[i]);
        }

        var endLine = startLine + lineCountForCommand(commands[commandIndex]);

        log_default()('margin', margin, tabHeight);
        instance.scrollIntoView({ ch: ch, line: startLine }, margin);
        instance.setSelection({ ch: ch, line: startLine }, { ch: ch, line: endLine }, { scroll: false });
      }, 100);
    }, _this.commandClassName = function (record, index) {
      var _this$props3 = _this.props,
          editing = _this$props3.editing,
          player = _this$props3.player,
          breakpointIndices = _this$props3.breakpointIndices,
          doneCommandIndices = _this$props3.doneCommandIndices,
          errorCommandIndices = _this$props3.errorCommandIndices,
          warningCommandIndices = _this$props3.warningCommandIndices;
      var nextCommandIndex = player.nextCommandIndex;
      var commands = editing.commands;

      var classNames = [];

      if (breakpointIndices.indexOf(index) !== -1) {
        classNames.push('breakpoint-command');
      }

      if (record.cmd === 'comment' || record.cmd === '') {
        classNames.push('comment-command');
      }

      if (!_this.props.canUseKeyboardShortcuts) {
        classNames.push('blur');
      }

      if (index === nextCommandIndex) {
        classNames.push('running-command');
      } else if (warningCommandIndices.indexOf(index) !== -1) {
        classNames.push('warning-command');
      } else if (errorCommandIndices.indexOf(index) !== -1) {
        classNames.push('error-command');
      } else if (doneCommandIndices.indexOf(index) !== -1) {
        classNames.push('done-command');
      }

      if (index === editing.meta.selectedIndex) {
        classNames.push('selected-command');
      }

      return classNames.join(' ');
    }, _this.needVirtualList = function () {
      var _this$props$editing$c = _this.props.editing.commands,
          commands = _this$props$editing$c === undefined ? [] : _this$props$editing$c;

      var threshold = 0;

      return commands.length >= threshold;
    }, _this.virtualCommmandList = function (_ref2) {
      var virtual = _ref2.virtual,
          itemHeight = _ref2.itemHeight;
      var commands = _this.props.editing.commands;

      var editable = _this.isPlayerStopped() && Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Edit);
      var renderItem = function renderItem(item, i) {
        if (item.header) {
          return react_default.a.createElement(
            'div',
            { className: 'command-row header-row', key: 'header' },
            react_default.a.createElement('div', { className: 'row-col index-col' }),
            react_default.a.createElement(
              'div',
              { className: 'row-col command-col' },
              'Command'
            ),
            react_default.a.createElement(
              'div',
              { className: 'row-col target-col' },
              'Target'
            ),
            react_default.a.createElement(
              'div',
              { className: 'row-col value-col' },
              'Value'
            ),
            react_default.a.createElement(
              'div',
              { className: 'row-col op-col' },
              'Ops'
            )
          );
        }

        if (item.footer) {
          return react_default.a.createElement(
            'div',
            { className: 'command-row footer-row', key: 'footer', onClick: function onClick() {
                if (!Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Edit)) {
                  return;
                }

                _this.props.updateUI({ focusArea: reducers_state["FocusArea"].CommandTable });
                _this.props.insertCommand(newCommand, commands.length);
              } },
            'Add'
          );
        }

        return react_default.a.createElement(command_item["CommandItem"], {
          key: item.key,
          index: item.realIndex + 1,
          command: item,
          style: { height: itemHeight + 'px' },
          className: 'command-row real-command ' + _this.commandClassName(item, item.realIndex),
          attributes: { 'data-index': '' + item.realIndex },
          editable: editable,
          onClick: function onClick(e, command) {
            return _this.onClickCommand(e, command);
          },
          onContextMenu: function onContextMenu(e, command) {
            return _this.onContextMenu(e, command.realIndex);
          },
          onToggleComment: function onToggleComment(e, command) {
            _this.props.toggleComment(command.realIndex);e.stopPropagation();
          },
          onDuplicate: function onDuplicate(e, command) {
            _this.props.duplicateCommand(command.realIndex);e.stopPropagation();
          },
          onMouseEnterTarget: _this.onMouseEnterTarget,
          onMouseLeaveTarget: _this.onMouseLeaveTarget,
          onMoveCommand: _this.onMoveCommand,
          onDragStart: _this.onStartDraggingCommand,
          onDragEnd: _this.onEndDraggingCommand
        });
      };

      return react_default.a.createElement(
        'div',
        { style: virtual.style },
        virtual.items.map(renderItem)
      );
    }, _this.onContextMenu = function (e, index) {
      log_default()('onContextMenu');

      _this.setState({
        contextMenu: {
          x: e.clientX,
          y: e.clientY,
          isShown: true,
          commandIndex: index
        }
      });

      _this.props.selectCommand(index, true);
      e.preventDefault();
      e.stopPropagation();
    }, _this.onHideMenu = function (e) {
      if (e.button !== 0) return;

      _this.setState({
        contextMenu: editor_extends({}, _this.state.contextMenu, {
          isShown: false
        })
      });
    }, _this.onClickCommand = function (e, command) {
      _this.props.updateUI({ focusArea: reducers_state["FocusArea"].CommandTable });
      _this.props.selectCommand(command.realIndex, true);
    }, _this.getTestCaseName = function () {
      var src = _this.props.editing.meta.src;

      return src && src.name && src.name.length ? src.name : 'Untitled';
    }, _this.playLine = function (commandIndex) {
      var extraOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var commands = _this.props.editing.commands;
      var src = _this.props.editing.meta.src;


      _this.setState({ lastOperation: 'play' });

      return _this.props.playerPlay(editor_extends({
        macroId: src && src.id,
        title: _this.getTestCaseName(),
        extra: {
          id: src && src.id
        },
        mode: common_player["a" /* Player */].C.MODE.SINGLE,
        startIndex: commandIndex,
        startUrl: null,
        resources: commands,
        postDelay: _this.props.config.playCommandInterval * 1000
      }, extraOptions));
    }, _temp), editor_possibleConstructorReturn(_this, _ret);
  }

  // Note: virtual-list eats up double click events. so have to manually track click event instead


  editor_createClass(DashboardEditor, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      document.addEventListener('click', this.onHideMenu);
      document.addEventListener('click', this.onDoubleClick);
      document.addEventListener('keydown', this.onKeyDown);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      // Note: update sourceText whenever editing changed
      if (nextProps.editing.meta.src !== this.props.editing.meta.src || nextProps.editing.commands !== this.props.editing.commands) {
        var resetCursor = nextProps.editing.meta.src !== this.props.editing.meta.src;

        this.setState(this.resetSourceCodeCursor(resetCursor));
      }

      if (nextProps.status === constant["APP_STATUS"].PLAYER && nextProps.player.nextCommandIndex !== this.props.player.nextCommandIndex) {
        var $tableBody = document.querySelector('.table-wrapper');
        var itemHeight = ITEM_HEIGHT;

        if (!$tableBody) return;

        $tableBody.scrollTop = itemHeight * nextProps.player.nextCommandIndex;
      }

      if (nextProps.status === constant["APP_STATUS"].RECORDER && nextProps.editing.commands.length > this.props.editing.commands.length) {
        var _$tableBody = document.querySelector('.table-wrapper');
        var _itemHeight = ITEM_HEIGHT;

        if (!_$tableBody) return;

        setTimeout(function () {
          _$tableBody.scrollTop = _itemHeight * nextProps.editing.commands.length * 2;
        }, 100);
      }
    }
  }, {
    key: 'isPlayerStopped',
    value: function isPlayerStopped() {
      return this.props.player.status === constant["PLAYER_STATUS"].STOPPED;
    }
  }, {
    key: 'waitBeforeScreenCapture',
    value: function waitBeforeScreenCapture() {
      if (!Object(cv_utils["isCVTypeForDesktop"])(this.props.config.cvScope)) {
        return Promise.resolve();
      }

      if (this.props.config.waitBeforeDesktopScreenCapture && this.props.config.secondsBeforeDesktopScreenCapture > 0) {
        message_default.a.info('About to take desktop screenshot in ' + this.props.config.secondsBeforeDesktopScreenCapture + ' seconds');
        return Object(ts_utils["delay"])(function () {}, this.props.config.secondsBeforeDesktopScreenCapture * 1000);
      }

      return Promise.resolve();
    }
  }, {
    key: 'isSelectedCommandVisualSearch',
    value: function isSelectedCommandVisualSearch(command) {
      var _props = this.props,
          editing = _props.editing,
          config = _props.config;
      var commands = editing.commands,
          meta = editing.meta;
      var selectedIndex = meta.selectedIndex;


      var dataSource = commands && commands.length ? commands : defaultDataSource;
      var selectedCmd = command || dataSource[selectedIndex];

      var selectedCmdIsVisualSearch = function () {
        if (!selectedCmd) return false;
        if (Object(cv_utils["isCVTypeForDesktop"])(config.cvScope) && selectedCmd.cmd === 'visionLimitSearchArea') return true;

        return ['visionFind', 'visualSearch', 'visualAssert', 'visualVerify', 'XClick', 'XMove', 'XClickRelative', 'XMoveRelative', 'OCRExtract', 'OCRExtractRelative', 'visionLimitSearchAreaRelative'].indexOf(selectedCmd.cmd) !== -1;
      }();

      return selectedCmdIsVisualSearch;
    }
  }, {
    key: 'commandHasVisionImage',
    value: function commandHasVisionImage(command) {
      if (!this.isSelectedCommandVisualSearch(command)) return false;

      var commandsCouldHaveVisionImage = ['XClick', 'XClickRelative', 'XMove', 'XMoveRelative', 'OCRExtract', 'OCRExtractRelative', 'visionLimitSearchArea', 'visionLimitSearchAreaRelative'];

      if (commandsCouldHaveVisionImage.indexOf(command.cmd) !== -1 && !/\.png/i.test(command.target)) return false;
      return true;
    }
  }, {
    key: 'selectCommandAndScroll',
    value: function selectCommandAndScroll(commandIndex) {
      this.props.selectCommand(commandIndex, true);
      this.props.scrollToCommandAtIndex(commandIndex);
    }
  }, {
    key: 'renderVisionFindPreview',
    value: function renderVisionFindPreview() {
      var _state$visionFindPrev = this.state.visionFindPreview,
          visible = _state$visionFindPrev.visible,
          url = _state$visionFindPrev.url,
          left = _state$visionFindPrev.left,
          top = _state$visionFindPrev.top;

      if (!visible) return null;

      return react_default.a.createElement('div', { style: {
          position: 'absolute',
          width: '100px',
          height: '100px',
          border: '1px solid #ccc',
          left: left + 'px',
          top: top + 'px',
          backgroundColor: '#eee',
          backgroundImage: 'url(' + url + ')',
          backgroundSize: 'contain',
          backgroundRepeat: 'no-repeat',
          backgroundPosition: 'center'
        } });
    }
  }, {
    key: 'renderContextMenu',
    value: function renderContextMenu() {
      var _this2 = this;

      var _props2 = this.props,
          clipboard = _props2.clipboard,
          status = _props2.status;
      var contextMenu = this.state.contextMenu;

      var isNormal = status === constant["APP_STATUS"].NORMAL;
      var dw = document.documentElement.clientWidth;
      var dh = document.documentElement.clientHeight;
      var mw = 240;
      var x = contextMenu.x + window.scrollX;
      var y = contextMenu.y + window.scrollY;

      if (!isNormal) {
        return null;
      }

      if (x + mw > dw) x -= mw;

      var style = {
        position: 'absolute',
        top: y,
        left: x,
        display: contextMenu.isShown ? 'block' : 'none'
      };

      var menuStyle = {
        width: mw + 'px'
      };

      var commandIndex = contextMenu.commandIndex;

      var isBreakpoint = this.props.breakpointIndices.indexOf(commandIndex) !== -1;

      var handleClick = function handleClick(e) {
        switch (e.key) {
          case 'cut':
            return _this2.props.cutCommand(commandIndex);
          case 'copy':
            return _this2.props.copyCommand(commandIndex);
          case 'paste':
            return _this2.props.pasteCommand(commandIndex);
          case 'insert':
            return _this2.props.insertCommand(newCommand, commandIndex + 1);
          case 'delete':
            return _this2.props.removeCommand(commandIndex);
          case 'run_line':
            {
              return _this2.playLine(commandIndex);
            }
          case 'play_from_here':
            {
              var commands = _this2.props.editing.commands;


              _this2.setState({ lastOperation: 'play' });

              return _this2.props.playerPlay({
                macroId: _this2.props.macroId,
                title: _this2.getTestCaseName(),
                extra: { id: _this2.props.macroId },
                mode: common_player["a" /* Player */].C.MODE.STRAIGHT,
                startIndex: commandIndex,
                startUrl: null,
                resources: commands,
                postDelay: _this2.props.config.playCommandInterval * 1000
              });
            }
          case 'play_to_here':
            {
              var _commands = _this2.props.editing.commands;


              _this2.setState({ lastOperation: 'play' });

              return _this2.props.playerPlay({
                macroId: _this2.props.macroId,
                title: _this2.getTestCaseName(),
                extra: { id: _this2.props.macroId },
                mode: common_player["a" /* Player */].C.MODE.STRAIGHT,
                startIndex: 0,
                startUrl: null,
                resources: _commands,
                postDelay: _this2.props.config.playCommandInterval * 1000,
                breakpoints: [commandIndex]
              });
            }
          case 'add_breakpoint':
            {
              return _this2.props.addBreakpoint(_this2.props.macroId, commandIndex);
            }
          case 'remove_breakpoint':
            {
              return _this2.props.removeBreakpoint(_this2.props.macroId, commandIndex);
            }
          case 'jump_to_source_code':
            {
              return _this2.jumpToSourceCode(commandIndex);
            }
          case 'record_from_here':
            {
              _this2.props.setIndexToInsertRecorded(commandIndex + 1);
              _this2.props.toggleRecorderSkipOpen(true);
              return _this2.props.startRecording();
            }
        }
      };

      var ctrlKey = Object(ts_utils["isMac"])() ? '' : 'CTRL-';

      return react_default.a.createElement(
        'div',
        { style: style, id: 'context_menu' },
        react_default.a.createElement(
          menu_default.a,
          { onClick: handleClick, style: menuStyle, mode: 'vertical', selectable: false },
          react_default.a.createElement(
            menu_default.a.Item,
            {
              key: 'cut',
              disabled: !Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Edit)
            },
            react_default.a.createElement(
              'span',
              null,
              'Cut'
            ),
            react_default.a.createElement(
              'span',
              { className: 'shortcut' },
              ctrlKey,
              'X'
            )
          ),
          react_default.a.createElement(
            menu_default.a.Item,
            {
              key: 'copy',
              disabled: !Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Edit)
            },
            react_default.a.createElement(
              'span',
              null,
              'Copy'
            ),
            react_default.a.createElement(
              'span',
              { className: 'shortcut' },
              ctrlKey,
              'C'
            )
          ),
          react_default.a.createElement(
            menu_default.a.Item,
            {
              key: 'paste',
              disabled: clipboard.commands.length === 0
            },
            react_default.a.createElement(
              'span',
              null,
              'Paste'
            ),
            react_default.a.createElement(
              'span',
              { className: 'shortcut' },
              ctrlKey,
              'P'
            )
          ),
          react_default.a.createElement(
            menu_default.a.Item,
            {
              key: 'delete',
              disabled: !Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Edit)
            },
            react_default.a.createElement(
              'span',
              null,
              'Delete'
            )
          ),
          react_default.a.createElement(menu_default.a.Divider, null),
          react_default.a.createElement(
            menu_default.a.Item,
            {
              key: 'insert',
              disabled: !Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Edit)
            },
            'Insert new line'
          ),
          react_default.a.createElement(menu_default.a.Divider, null),
          react_default.a.createElement(
            menu_default.a.Item,
            { key: 'jump_to_source_code' },
            'Jump to source code'
          ),
          react_default.a.createElement(
            menu_default.a.Item,
            { key: isBreakpoint ? 'remove_breakpoint' : 'add_breakpoint' },
            isBreakpoint ? 'Remove breakpoint' : 'Add breakpoint'
          ),
          react_default.a.createElement(menu_default.a.Divider, null),
          react_default.a.createElement(
            menu_default.a.Item,
            { key: 'run_line' },
            'Execute this command'
          ),
          react_default.a.createElement(
            menu_default.a.Item,
            { key: 'play_from_here' },
            'Play from here'
          ),
          react_default.a.createElement(
            menu_default.a.Item,
            { key: 'play_to_here' },
            'Play to this point'
          ),
          react_default.a.createElement(
            menu_default.a.Item,
            {
              key: 'record_from_here',
              disabled: !Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Record)
            },
            'Record from here'
          )
        )
      );
    }
  }, {
    key: 'renderTargetEditor',
    value: function renderTargetEditor() {
      var _this3 = this;

      var _props3 = this.props,
          status = _props3.status,
          editing = _props3.editing,
          config = _props3.config,
          ui = _props3.ui;
      var commands = editing.commands,
          meta = editing.meta;
      var selectedIndex = meta.selectedIndex;


      var isPlayerStopped = this.isPlayerStopped();
      var dataSource = commands && commands.length ? commands : defaultDataSource;
      var selectedCmd = dataSource[selectedIndex];
      var isCmdEditable = isPlayerStopped && !!selectedCmd;

      if (!isCmdEditable || !this.state.targetEditor.visible) {
        return null;
      }

      return react_default.a.createElement(
        'div',
        { className: 'target-full-editor' },
        react_default.a.createElement('div', { className: 'mask' }),
        react_default.a.createElement(button_default.a, {
          shape: 'circle',
          icon: 'close',
          className: 'close-button',
          onClick: function onClick() {
            _this3.setState({
              targetEditor: {
                visible: false,
                text: ''
              }
            });
          }
        }),
        react_default.a.createElement(react_codemirror2["UnControlled"], {
          value: this.state.targetEditor.text,
          onChange: function onChange(editor, _, text) {
            _this3.onDetailChange('target', text);
          },
          onCursor: function onCursor(editor, data) {
            // this.setState({ cmEdtiorInstance: editor })
            // // Note: when value updated, code mirror will automatically emit onCursor with cursor at bottom
            // // It can be tell with `sticky` as null
            // if (data.sticky) {
            //   this.setState({ cursor: { line: data.line, ch: data.ch } })
            // }
          },
          onFocus: function onFocus() {
            _this3.props.updateUI({ focusArea: reducers_state["FocusArea"].CodeSource });
          },
          options: {
            mode: { name: 'javascript', json: true },
            lineNumbers: true,
            matchBrackets: true,
            autoCloseBrackets: true
          }
        })
      );
    }
  }, {
    key: 'renderTable',
    value: function renderTable() {
      var _props4 = this.props,
          editing = _props4.editing,
          player = _props4.player;
      var commands = editing.commands;

      var _reduce = (commands && commands.length ? commands : defaultDataSource).reduce(function (_ref3, command, i) {
        var dataSource = _ref3.dataSource,
            indent = _ref3.indent;

        var _indentCreatedByComma = Object(common_command["indentCreatedByCommand"])(command.cmd),
            selfIndent = _indentCreatedByComma.selfIndent,
            nextIndent = _indentCreatedByComma.nextIndent;

        dataSource.push(editor_extends({}, command, {
          key: Math.random(),
          indent: indent + selfIndent,
          realIndex: i
        }));

        return {
          dataSource: dataSource,
          indent: Math.max(0, indent + selfIndent + nextIndent)
        };
      }, { dataSource: [], indent: 0 }),
          dataSource = _reduce.dataSource;

      return this.needVirtualList() ? this.renderVirtualTable(dataSource) : this.renderNormalTable(dataSource);
    }
  }, {
    key: 'renderVirtualTable',
    value: function renderVirtualTable(dataSource) {
      var CommandVirtualList = VirtualList_default()({ container: this.listContainer })(this.virtualCommmandList);
      var paddedDataSource = [{ header: true }].concat(editor_toConsumableArray(dataSource), [{ footer: true }]);

      return react_default.a.createElement(
        'div',
        { className: 't-body' },
        !this.listContainer ? null : react_default.a.createElement(CommandVirtualList, { itemHeight: ITEM_HEIGHT, items: paddedDataSource })
      );
    }
  }, {
    key: 'renderNormalTable',
    value: function renderNormalTable(dataSource) {
      var _this4 = this;

      var _props5 = this.props,
          editing = _props5.editing,
          player = _props5.player,
          doneCommandIndices = _props5.doneCommandIndices,
          errorCommandIndices = _props5.errorCommandIndices;
      var nextCommandIndex = player.nextCommandIndex;
      var commands = editing.commands;

      var editable = this.isPlayerStopped();

      var columns = [{ title: 'Command', dataIndex: 'cmd', key: 'cmd', width: 130 }, { title: 'Target', dataIndex: 'target', key: 'target', width: 190 }, { title: 'Value', dataIndex: 'value', key: 'value' }, {
        title: 'Ops',
        key: 'ops',
        width: 80,
        render: function render(text, record, index) {
          return react_default.a.createElement(
            'div',
            null,
            react_default.a.createElement(
              button_default.a,
              {
                disabled: !editable,
                shape: 'circle',
                onClick: function onClick(e) {
                  _this4.props.removeCommand(index);e.stopPropagation();
                }
              },
              react_default.a.createElement(icon_default.a, { type: 'minus' })
            ),
            react_default.a.createElement(
              button_default.a,
              {
                disabled: !editable,
                shape: 'circle',
                onClick: function onClick(e) {
                  _this4.props.duplicateCommand(index);e.stopPropagation();
                }
              },
              react_default.a.createElement(icon_default.a, { type: 'plus' })
            )
          );
        }
      }];

      var tableConfig = {
        dataSource: dataSource,
        columns: columns,
        pagination: false,
        footer: function footer() {
          return react_default.a.createElement(
            'div',
            { className: 'table-footer', onClick: function onClick(e) {
                if (!Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Edit)) {
                  return;
                }

                _this4.props.insertCommand(newCommand, commands.length);
              } },
            'Add'
          );
        },
        onRowClick: function onRowClick(record, index, e) {
          _this4.props.selectCommand(index);
        },
        rowClassName: this.commandClassName
      };

      return react_default.a.createElement(table_default.a, tableConfig);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this5 = this;

      var _props6 = this.props,
          status = _props6.status,
          editing = _props6.editing,
          config = _props6.config,
          ui = _props6.ui;
      var commands = editing.commands,
          meta = editing.meta;
      var selectedIndex = meta.selectedIndex;


      var isPlayerStopped = this.isPlayerStopped();
      var dataSource = commands && commands.length ? commands : defaultDataSource;
      var selectedCmd = dataSource[selectedIndex];
      var editable = isPlayerStopped && !!selectedCmd;
      var isCmdEditable = editable && Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Edit);
      var isInspecting = status === constant["APP_STATUS"].INSPECTOR;

      var selectedCmdIsVisualSearch = this.isSelectedCommandVisualSearch();

      var isSelectEnabled = selectedCmd && selectedCmd.cmd && Object(common_command["canCommandSelect"])(selectedCmd.cmd);
      var isFindEnabled = selectedCmd && selectedCmd.cmd && Object(common_command["canCommandFind"])(selectedCmd.cmd);

      var shouldUseSelectInputForTarget = selectedCmd && selectedCmd.targetOptions && selectedCmd.targetOptions.length && Object(common_command["doesCommandSupportTargetOptions"])(selectedCmd.cmd);
      var shouldUseTextareaForTarget = selectedCmd && ['executeScript', 'executeScript_Sandbox'].indexOf(selectedCmd.cmd) !== -1;
      var shouldUseNormalInputForTarget = !shouldUseSelectInputForTarget && !shouldUseTextareaForTarget;

      return react_default.a.createElement(
        'div',
        { className: 'editor-wrapper' },
        react_default.a.createElement(
          'div',
          { className: 'tabs-wrapper' },
          react_default.a.createElement(
            tabs_default.a,
            {
              type: 'card',
              className: Object(utils["cn"])('commands-view', { 'target-as-textarea': shouldUseTextareaForTarget }),
              activeKey: this.props.editor.activeTab,
              onChange: this.onChangeCommandsView
            },
            react_default.a.createElement(
              tabs_default.a.TabPane,
              { tab: 'Table View', key: 'table_view' },
              react_default.a.createElement(
                'div',
                { className: 'form-group table-wrapper', style: { marginBottom: 0 }, ref: function ref(_ref4) {
                    _this5.listContainer = _ref4;
                  } },
                this.renderTable()
              ),
              react_default.a.createElement(
                'div',
                { className: 'form-group fields-wrapper', style: { marginBottom: 0 } },
                react_default.a.createElement(
                  form_default.a,
                  null,
                  react_default.a.createElement(
                    form_default.a.Item,
                    { label: 'Command', labelCol: { span: 4 }, wrapperCol: { span: 20 } },
                    react_default.a.createElement(
                      'div',
                      { className: 'flex-row' },
                      react_default.a.createElement(
                        select_default.a,
                        {
                          showSearch: true,
                          optionFilterProp: 'children',
                          placeholder: 'command',
                          disabled: !isCmdEditable,
                          value: selectedCmd && selectedCmd.cmd,
                          onChange: function onChange(value) {
                            return _this5.onDetailChange('cmd', value);
                          },
                          filterOption: function filterOption(input, _ref5) {
                            var key = _ref5.key;
                            return key.toLowerCase().indexOf(input.toLowerCase()) !== -1;
                          },
                          style: { flex: 1, maxWidth: '60%', marginRight: '10px' },
                          size: 'default'
                        },
                        common_command["availableCommands"].map(function (cmd) {
                          return react_default.a.createElement(
                            select_default.a.Option,
                            { value: cmd, key: cmd },
                            Object(common_command["commandText"])(cmd)
                          );
                        })
                      ),
                      react_default.a.createElement(
                        'div',
                        { style: {
                            flex: 0.6,
                            display: 'flex',
                            justifyContent: 'space-between'
                          } },
                        selectedCmd && selectedCmd.cmd ? react_default.a.createElement(
                          'a',
                          {
                            style: { marginRight: '10px', whiteSpace: 'nowrap' },
                            href: 'https://ui.vision/x/idehelp?cmd=' + selectedCmd.cmd.toLowerCase(),
                            target: '_blank'
                          },
                          'Info for this command'
                        ) : react_default.a.createElement('span', null),
                        react_default.a.createElement(
                          button_default.a,
                          {
                            style: { padding: '0 10px' },
                            title: 'Toggle comment',
                            disabled: !isCmdEditable,
                            onClick: function onClick() {
                              _this5.props.toggleCommentOnSelectedCommand();
                            }
                          },
                          '//'
                        )
                      )
                    )
                  ),
                  react_default.a.createElement(
                    form_default.a.Item,
                    { label: 'Target', className: 'target-row', labelCol: { span: 4 }, wrapperCol: { span: 20 } },
                    react_default.a.createElement(
                      'div',
                      { className: 'flex-row' },
                      shouldUseNormalInputForTarget ? react_default.a.createElement(input_default.a, {
                        style: { flex: 1, maxWidth: '60%', marginRight: '10px' },
                        placeholder: 'target',
                        disabled: !isCmdEditable,
                        value: selectedCmd && selectedCmd.target,
                        onChange: function onChange(e) {
                          return _this5.onDetailChange('target', e.target.value);
                        },
                        size: 'default'
                      }) : null,
                      shouldUseSelectInputForTarget ? react_default.a.createElement(select_input["SelectInput"], {
                        disabled: !isCmdEditable,
                        getId: function getId(str) {
                          return str;
                        },
                        stringifyOption: function stringifyOption(str) {
                          return str;
                        },
                        value: selectedCmd.target,
                        options: selectedCmd.targetOptions,
                        onChange: function onChange(val) {
                          return _this5.onDetailChange('target', val);
                        }
                      }) : null,
                      shouldUseTextareaForTarget ? react_default.a.createElement(
                        'div',
                        { className: 'textarea-wrapper' },
                        react_default.a.createElement(input_default.a.TextArea, {
                          rows: 2,
                          placeholder: 'target',
                          disabled: !isCmdEditable,
                          value: selectedCmd && selectedCmd.target,
                          onChange: function onChange(e) {
                            return _this5.onDetailChange('target', e.target.value);
                          },
                          size: 'default'
                        }),
                        react_default.a.createElement(icon_default.a, {
                          type: 'arrows-alt',
                          className: 'open-full-editor',
                          title: 'Open full editor',
                          onClick: function onClick() {
                            _this5.setState({
                              targetEditor: {
                                visible: true,
                                text: selectedCmd.target
                              }
                            });
                          }
                        })
                      ) : null,
                      react_default.a.createElement(
                        button_default.a,
                        {
                          disabled: !isCmdEditable || !isSelectEnabled,
                          onClick: this.onToggleSelect
                        },
                        isInspecting ? react_default.a.createElement(
                          'span',
                          null,
                          (selectedCmdIsVisualSearch ? '' : '') + 'Cancel'
                        ) : react_default.a.createElement(
                          'span',
                          null,
                          (selectedCmdIsVisualSearch ? '' : '') + 'Select'
                        )
                      ),
                      react_default.a.createElement(
                        button_default.a,
                        {
                          disabled: !editable || !isFindEnabled,
                          onClick: this.onClickFind
                        },
                        (selectedCmdIsVisualSearch ? '' : '') + 'Find'
                      )
                    )
                  ),
                  react_default.a.createElement(
                    form_default.a.Item,
                    { label: 'Value', labelCol: { span: 4 }, wrapperCol: { span: 20 } },
                    react_default.a.createElement(input_default.a, {
                      disabled: !isCmdEditable,
                      value: selectedCmd && selectedCmd.value,
                      onChange: function onChange(e) {
                        return _this5.onDetailChange('value', e.target.value);
                      },
                      style: { width: '100%' },
                      placeholder: 'value',
                      size: 'default'
                    })
                  ),
                  react_default.a.createElement(
                    form_default.a.Item,
                    { label: 'Description', labelCol: { span: 4 }, wrapperCol: { span: 20 }, style: { marginBottom: 0 } },
                    react_default.a.createElement(input_default.a, {
                      disabled: !isCmdEditable,
                      value: selectedCmd && selectedCmd.description,
                      onChange: function onChange(e) {
                        return _this5.onDetailChange('description', e.target.value);
                      },
                      style: { width: '100%' },
                      placeholder: 'description',
                      size: 'default'
                    })
                  )
                )
              )
            ),
            react_default.a.createElement(
              tabs_default.a.TabPane,
              { tab: 'Source View (JSON)', key: 'source_view', className: 'source-view' },
              react_default.a.createElement(
                'pre',
                { className: 'source-error' },
                this.props.sourceErrMsg
              ),
              react_default.a.createElement(react_codemirror2["UnControlled"], {
                ref: function ref(el) {
                  _this5.codeMirror = el;
                },
                className: this.props.sourceErrMsg ? 'has-error' : 'no-error',
                value: this.props.sourceText,
                onChange: this.onChangeEditSource,
                onBlur: this.onSourceBlur,
                onCursor: function onCursor(editor, data) {
                  _this5.setState({ cmEdtiorInstance: editor });
                  // Note: when value updated, code mirror will automatically emit onCursor with cursor at bottom
                  // It can be tell with `sticky` as null
                  if (data.sticky) {
                    _this5.setState({ cursor: { line: data.line, ch: data.ch } });
                  }
                },
                onFocus: function onFocus() {
                  _this5.props.updateUI({ focusArea: reducers_state["FocusArea"].CodeSource });
                },
                options: {
                  mode: { name: 'javascript', json: true },
                  lineNumbers: true,
                  matchBrackets: true,
                  autoCloseBrackets: true,
                  readOnly: !Object(services_license["getLicenseService"])().canPerform(license_types["Feature"].Edit)
                }
              })
            )
          ),
          Object(cv_utils["isCVTypeForDesktop"])(config.cvScope) && ui.shouldEnableDesktopAutomation !== false || ui.shouldEnableDesktopAutomation === true ? react_default.a.createElement(
            'div',
            {
              className: 'vision-type',
              onClick: function onClick() {
                _this5.props.updateUI({ showSettings: true, settingsTab: 'vision' });
              }
            },
            react_default.a.createElement('img', { src: './img/computer.svg' }),
            react_default.a.createElement(
              'span',
              null,
              'Desktop mode active'
            )
          ) : null
        ),
        this.renderContextMenu(),
        this.renderVisionFindPreview(),
        this.renderTargetEditor()
      );
    }
  }]);

  return DashboardEditor;
}(react_default.a.Component);

/* harmony default export */ var editor = (Object(react_redux_es["b" /* connect */])(function (state) {
  return {
    status: state.status,
    editor: state.editor,
    editing: state.editor.editing,
    clipboard: state.editor.clipboard,
    player: state.player,
    config: state.config,
    ui: state.ui,
    sourceErrMsg: state.editor.editingSource.error,
    sourceText: state.editor.editingSource.pure,
    sourceTextModified: state.editor.editingSource.current,
    selectedCommand: Object(recomputed["editorSelectedCommand"])(state),
    selectedCommandIndex: Object(recomputed["editorSelectedCommandIndex"])(state),
    commandCount: Object(recomputed["editorCommandCount"])(state),
    breakpointIndices: Object(recomputed["getBreakpoints"])(state),
    doneCommandIndices: Object(recomputed["getDoneCommandIndices"])(state),
    errorCommandIndices: Object(recomputed["getErrorCommandIndices"])(state),
    warningCommandIndices: Object(recomputed["getWarningCommandIndices"])(state),
    macroId: Object(recomputed["getCurrentMacroId"])(state),
    canUseKeyboardShortcuts: Object(recomputed["isFocusOnCommandTable"])(state)
  };
}, function (dispatch) {
  return Object(redux_es["b" /* bindActionCreators */])(editor_extends({}, actions, simple_actions["Actions"]), dispatch);
})(editor_DashboardEditor));
// EXTERNAL MODULE: ./src/components/edit_in_place.tsx
var edit_in_place = __webpack_require__(619);

// EXTERNAL MODULE: ./src/containers/dashboard/bottom/csv_list.tsx
var csv_list = __webpack_require__(646);

// EXTERNAL MODULE: ./src/containers/dashboard/bottom/vision_list.tsx
var vision_list = __webpack_require__(647);

// EXTERNAL MODULE: ./src/containers/dashboard/bottom/screenshot_list.tsx
var screenshot_list = __webpack_require__(648);

// CONCATENATED MODULE: ./src/containers/dashboard/bottom/index.js




































var bottom_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var bottom_slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var bottom_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function bottom_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bottom_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function bottom_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






























var bottom_DashboardBottom = function (_React$Component) {
  bottom_inherits(DashboardBottom, _React$Component);

  function DashboardBottom() {
    var _ref;

    var _temp, _this, _ret;

    bottom_classCallCheck(this, DashboardBottom);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = bottom_possibleConstructorReturn(this, (_ref = DashboardBottom.__proto__ || Object.getPrototypeOf(DashboardBottom)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      activeTabForLogScreenshot: 'Logs',

      showCSVModal: false,
      csvText: '',
      csvFile: '',

      drag: {
        isDragging: false,
        // Check out the note on `screenX` in `onResizeDragEnd` event
        startY: 0,
        lastHeight: 220,
        currentMinHeight: 220
      },

      searchImageText: ''
    }, _this.getBottomMinHeight = function () {
      var _this$state$drag = _this.state.drag,
          isDragging = _this$state$drag.isDragging,
          lastHeight = _this$state$drag.lastHeight,
          currentMinHeight = _this$state$drag.currentMinHeight;

      return (isDragging ? currentMinHeight : lastHeight) + 'px';
    }, _this.onResizeDragStart = function (e) {
      // Note: Firefox requires us to set something to DataTransfer, otherwise drag and dragEnd won't be triggered
      // refer to https://stackoverflow.com/questions/33434275/firefox-on-drag-end-is-not-called-in-a-react-component
      e.dataTransfer.setData('text', '');

      var style = window.getComputedStyle(_this.$dom);
      var height = parseInt(style.height);

      _this.setState(Object(utils["setIn"])(['drag'], {
        isDragging: true,
        startY: e.screenY,
        lastHeight: height,
        currentHeight: height
      }, _this.state));
    }, _this.onResizeDragEnd = function (e) {
      // Note: use `screenY` instead of `clientY`, because `clientY` of dragEnd events in Firefox
      // is always set to 0, while `screenY` is luckily still available. And since we only make use of
      // difference of X coordinate. `screenY` and `clientY` both work for us.
      //
      // reference:
      // https://bugzilla.mozilla.org/show_bug.cgi?id=505521
      // https://developer.mozilla.org/en-US/docs/Web/Events/dragend
      var diff = e.screenY - _this.state.drag.startY;
      var height = _this.state.drag.lastHeight - diff;

      _this.setState(Object(utils["setIn"])(['drag'], {
        isDragging: false,
        startY: 0,
        lastHeight: height,
        currentMinHeight: height
      }));
    }, _this.onFileChange = function (e) {
      var csvStorage = Object(storage["getStorageManager"])().getCSVStorage();
      var files = [].slice.call(e.target.files);
      if (!files || !files.length) return;

      var read = function read(file) {
        return new Promise(function (resolve, reject) {
          var reader = new FileReader();

          reader.onload = function (readerEvent) {
            var text = readerEvent.target.result;
            resolve({
              text: text,
              fileName: file.name
            });
          };

          reader.readAsText(file);
        });
      };

      Promise.all(files.map(read)).then(function (list) {
        var names = list.map(function (item) {
          return item.fileName;
        });
        var ps = list.map(function (fileItem) {
          return csvStorage.write(Object(utils["sanitizeFileName"])(fileItem.fileName), new Blob([fileItem.text]));
        });

        return Promise.all(ps).then(function () {
          return _this.props.listCSV();
        }).then(function () {
          message_default.a.info(list.length + ' csv files imported');
          _this.props.addLog('info', list.length + ' csv files imported: ' + names.join(', '));
        });
      }).catch(function (e) {
        _this.props.addLog('error', e.message);
      });
    }, _this.removeCSV = function (csv) {
      var csvStorage = Object(storage["getStorageManager"])().getCSVStorage();

      csvStorage.remove(csv.name).then(function () {
        return _this.props.listCSV();
      }).then(function () {
        message_default.a.success('successfully deleted');
        _this.props.addLog('info', csv.name + ' deleted');
      });
    }, _this.viewCSV = function (csv) {
      window.open('./csv_editor.html?csv=' + csv.name, '', 'width=600,height=500,scrollbars=true');
    }, _this.downloadCSV = function (csv) {
      Object(storage["getStorageManager"])().getCSVStorage().read(csv.fullPath, 'Text').then(function (text) {
        var blob = new Blob([text]);
        file_saver_default.a.saveAs(blob, csv.name);
      });
    }, _this.onImageFileChange = function (e) {
      var files = [].slice.call(e.target.files);
      if (!files || !files.length) return;

      var read = function read(file) {
        return new Promise(function (resolve, reject) {
          var reader = new FileReader();

          reader.onload = function (readerEvent) {
            try {
              var dataUrl = readerEvent.target.result;
              var obj = storeImage({ dataUrl: dataUrl, name: file.name });
              resolve(obj);
            } catch (e) {
              resolve({ err: e, fileName: file.name });
            }
          };

          reader.readAsDataURL(file);
        });
      };

      var storeImage = function storeImage(_ref2) {
        var dataUrl = _ref2.dataUrl,
            name = _ref2.name;

        return Object(utils["uniqueName"])(name, {
          check: function check(name) {
            return Object(storage["getStorageManager"])().getVisionStorage().exists(name).then(function (result) {
              return !result;
            });
          }
        }).then(function (fileName) {
          return Object(storage["getStorageManager"])().getVisionStorage().write(Object(utils["sanitizeFileName"])(fileName), Object(utils["dataURItoBlob"])(dataUrl)).then(function () {
            return fileName;
          });
        }).catch(function (e) {
          log_default.a.error(e.stack);
        });
      };

      Promise.all(files.map(read)).then(function (fileNames) {
        message_default.a.success(fileNames.length + ' image files imported into Vision tab');
        _this.props.addLog('info', fileNames.length + ' image files imported: ' + fileNames.join(', '));
        _this.props.listVisions();
      }).catch(function (e) {
        log_default.a.error(e.stack);
        _this.props.addLog('error', e.message);
      });
    }, _this.viewVision = function (filePath) {
      window.open('./vision_editor.html?vision=' + filePath, '', 'width=600,height=500,scrollbars=true');
    }, _this.renameVision = function (oldName, newName) {
      return Object(storage["getStorageManager"])().getVisionStorage().rename(oldName, Object(utils["ensureExtName"])('.png', newName)).then(function () {
        message_default.a.success('Successfully renamed');
        _this.props.listVisions();
      }).catch(function (e) {
        message_default.a.error(e.message);
        throw e;
      });
    }, _this.isVisionNameValid = function (name) {
      return Promise.resolve(Object(utils["withFileExtension"])(name, function (baseName) {
        try {
          Object(utils["validateStandardName"])(baseName, true);
        } catch (e) {
          message_default.a.error(e.message);
          throw e;
        }
        return baseName;
      })).then(function () {
        return Object(storage["getStorageManager"])().getVisionStorage().exists(name).then(function (result) {
          if (result) {
            message_default.a.error('\'' + name + '\' already exists');
          }
          return !result;
        });
      }, function () {
        return false;
      });
    }, _this.duplicateVision = function (name) {
      _this.props.duplicateVisionImage(name);
    }, _this.deleteVision = function (name) {
      return modal_default.a.confirm({
        title: 'Sure to delete?',
        okText: 'Delete',
        onOk: function onOk() {
          return Object(storage["getStorageManager"])().getVisionStorage().remove(name).then(function () {
            message_default.a.success('Successfully deleted');
            _this.props.listVisions();
          }).catch(function (e) {
            log_default.a.error(e);
          });
        },
        onCancel: function onCancel() {
          return Promise.resolve(true);
        }
      });
    }, _this.addVisionNameToTargetBox = function (filePath) {
      var _this$props = _this.props,
          config = _this$props.config,
          selectedCmd = _this$props.selectedCommand;

      var selectedCmdIsVisualSearch = function () {
        if (!selectedCmd) return false;
        if (Object(cv_utils["isCVTypeForDesktop"])(config.cvScope) && selectedCmd.cmd === 'visionLimitSearchArea') return true;

        return ['visionFind', 'visualSearch', 'visualAssert', 'visualVerify', 'XClick', 'XMove', 'XClickRelative', 'XMoveRelative', 'OCRExtract', 'OCRExtractRelative', 'visionLimitSearchAreaRelative'].indexOf(selectedCmd.cmd) !== -1;
      }();

      if (!selectedCmdIsVisualSearch) {
        return message_default.a.error('Image names can only be added to the target box if a vision related command is selected');
      }

      _this.props.updateSelectedCommand({ target: filePath });
    }, _this.exportAllVisions = function () {
      var zip = new jszip_min_default.a();
      var visionStorage = Object(storage["getStorageManager"])().getVisionStorage();

      visionStorage.list().then(function (visions) {
        if (visions.length === 0) {
          return message_default.a.error('No vision to export');
        }

        var ps = visions.map(function (ss) {
          return visionStorage.read(ss.fullPath, 'ArrayBuffer').then(function (buffer) {
            zip.file(ss.name, buffer, { binary: true });
          });
        });

        return Promise.all(ps).then(function () {
          zip.generateAsync({ type: 'blob' }).then(function (blob) {
            file_saver_default.a.saveAs(blob, 'vision-images-export.zip');
          });
        });
      });
    }, _this.downloadScreenshot = function (name, fullPath) {
      return Object(storage["getStorageManager"])().getScreenshotStorage().read(fullPath, 'ArrayBuffer').then(function (buffer) {
        file_saver_default.a.saveAs(new Blob([new Uint8Array(buffer)]), name);
      });
    }, _this.toggleBottom = function () {
      _this.props.updateConfig({
        showBottomArea: !_this.props.config.showBottomArea
      });
    }, _this.logLinkPatterns = [[/Error #101/i, 'https://ui.vision/x/idehelp?help=error101'], [/Error #120/i, 'https://ui.vision/x/idehelp?help=error120'], [/Error #121/i, 'https://ui.vision/x/idehelp?help=error121']], _temp), bottom_possibleConstructorReturn(_this, _ret);
  }

  bottom_createClass(DashboardBottom, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      Object(storage["getStorageManager"])().on(storage["StorageManagerEvent"].StrategyTypeChanged, function (type) {
        _this2.forceUpdate();
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _this3 = this;

      if (nextProps.logs.length !== this.props.logs.length) {
        var $logContent = document.querySelector('.log-content');

        if (!$logContent) {
          return;
        }

        // Note: set scroll top to a number large enough so that it will scroll to bottom
        // setTimeout 100ms to ensure content has been rendered before scroll
        setTimeout(function () {
          var $last = $logContent.children[$logContent.children.length - 1];

          if ($last) {
            $last.scrollIntoView();
          }
        }, 100);
      }

      if (nextProps.visions.length > this.props.visions.length) {
        var diff = nextProps.visions.filter(function (item) {
          return !_this3.props.visions.find(function (v) {
            return v.name === item.name;
          });
        });

        if (diff.length > 1) {
          diff.sort(function (a, b) {
            return a.createTime > b.createTime;
          });
        }

        var toFocus = diff[0];

        setTimeout(function () {
          var $dom = document.getElementById(toFocus.name);
          if (!$dom) return;
          $dom.scrollIntoView({ block: 'center', behavior: 'smooth' });
        }, 100);
      }
    }
  }, {
    key: 'logStyle',
    value: function logStyle(log) {
      if (log.options && log.options.color) {
        return { color: log.options.color };
      }

      if (log.options && log.options.ignored) {
        return { color: 'orange' };
      }
    }
  }, {
    key: 'prefixHardDisk',
    value: function prefixHardDisk(str) {
      var isXFileMode = Object(storage["getStorageManager"])().isXFileMode();
      if (!isXFileMode) return str;

      return react_default.a.createElement(
        'div',
        {
          style: {
            display: 'inline-block'
          }
        },
        react_default.a.createElement('img', {
          src: './img/hard-drive.svg',
          style: {
            position: 'relative',
            top: '3px',
            marginRight: '5px',
            height: '15px'
          }
        }),
        react_default.a.createElement(
          'span',
          null,
          str
        )
      );
    }
  }, {
    key: 'shouldUseFileSaverForDownloadingScreenshot',
    value: function shouldUseFileSaverForDownloadingScreenshot() {
      if (web_extension_default.a.isFirefox()) {
        return true;
      }

      return Object(storage["getStorageManager"])().isXFileMode();
    }
  }, {
    key: 'shouldRenderLogStack',
    value: function shouldRenderLogStack(log) {
      if (log.stack.length <= 1) {
        return false;
      }

      switch (log.type) {
        case 'error':
        case 'warning':
          return true;

        case 'status':
          return (/^Running/.test(log.text)
          );

        default:
          return false;
      }
    }
  }, {
    key: 'renderCSVModal',
    value: function renderCSVModal() {
      var _this4 = this;

      return react_default.a.createElement(
        modal_default.a,
        {
          title: 'Preview - ' + this.state.csvFile,
          visible: this.state.showCSVModal,
          onCancel: function onCancel() {
            return _this4.setState({ showCSVModal: false, csvText: '', csvFile: '' });
          },
          className: 'csv-preview-modal',
          footer: null
        },
        react_default.a.createElement(input_default.a.TextArea, {
          style: { width: '100%' },
          value: this.state.csvText,
          readOnly: true,
          rows: 10
        })
      );
    }
  }, {
    key: 'renderCSVTable',
    value: function renderCSVTable() {
      var _this5 = this;

      if (!this.props.shouldLoadResources) {
        return react_default.a.createElement(resource_not_loaded["ResourceNotLoaded"], {
          name: 'CSV list',
          from: this.props.from,
          showList: function showList() {
            _this5.props.setFrom(reducers_state["RunBy"].Manual);
          }
        });
      }

      if (this.state.activeTabForLogScreenshot !== 'CSV') {
        return null;
      }

      if (this.props.isPlaying && this.props.csvs.length > config_default.a.performanceLimit.fileCount) {
        return react_default.a.createElement(
          'div',
          { className: 'hidden-during-replay' },
          messages_default.a.contentHidden
        );
      }

      return react_default.a.createElement(csv_list["CsvList"], {
        list: this.props.csvs,
        viewCSV: this.viewCSV,
        removeCSV: this.removeCSV,
        downloadCSV: this.downloadCSV
      });
    }
  }, {
    key: 'renderVisionSection',
    value: function renderVisionSection() {
      var _this6 = this;

      if (!this.props.shouldLoadResources) {
        return react_default.a.createElement(
          'div',
          { className: 'vision-content' },
          react_default.a.createElement(resource_not_loaded["ResourceNotLoaded"], {
            name: 'Image list',
            from: this.props.from,
            showList: function showList() {
              _this6.props.setFrom(reducers_state["RunBy"].Manual);
            }
          })
        );
      }

      return react_default.a.createElement(
        'div',
        { className: 'vision-content' },
        react_default.a.createElement(
          'div',
          { className: 'vision-top-actions' },
          react_default.a.createElement(
            'div',
            { className: 'main-actions' },
            react_default.a.createElement(
              'div',
              { className: 'main-actions-left' },
              react_default.a.createElement(
                'span',
                {
                  className: 'load-image-button ant-btn ant-btn-primary'
                },
                react_default.a.createElement(
                  'label',
                  { htmlFor: 'select_image_files' },
                  'Load Image'
                ),
                react_default.a.createElement('input', {
                  multiple: true,
                  type: 'file',
                  accept: 'image/*',
                  id: 'select_image_files',
                  onChange: this.onImageFileChange,
                  ref: function ref(_ref3) {
                    _this6.imageFileInput = _ref3;
                  },
                  style: { display: 'none' }
                })
              ),
              react_default.a.createElement(
                button_default.a,
                {
                  onClick: this.exportAllVisions
                },
                'Export All'
              )
            ),
            react_default.a.createElement(search_box, {
              style: { flex: 0.8 },
              inputProps: {
                placeholder: 'search image',
                value: this.state.searchImageText,
                onChange: function onChange(e) {
                  return _this6.setState({ searchImageText: e.target.value });
                }
              }
            })
          ),
          react_default.a.createElement(
            'a',
            { className: 'more-info', target: '_blank', href: 'https://ui.vision/x/idehelp?help=visual' },
            'More Info'
          )
        ),
        this.renderVisionTable()
      );
    }
  }, {
    key: 'renderVisionTable',
    value: function renderVisionTable() {
      if (this.state.activeTabForLogScreenshot !== 'Vision') {
        return null;
      }

      if (this.props.isPlaying && this.props.visions.length > config_default.a.performanceLimit.fileCount) {
        return react_default.a.createElement(
          'div',
          { className: 'hidden-during-replay' },
          messages_default.a.contentHidden
        );
      }

      if (!this.$dom) {
        return null;
      }

      return react_default.a.createElement(vision_list["VisionList"], {
        visions: this.props.visions,
        intersectRoot: this.$dom,
        query: this.state.searchImageText,
        isNameValid: this.isVisionNameValid,
        renameVision: this.renameVision,
        viewVision: this.viewVision,
        duplicateVision: this.duplicateVision,
        deleteVision: this.deleteVision,
        copyNameToTarget: this.addVisionNameToTargetBox
      });
    }
  }, {
    key: 'renderScreenshots',
    value: function renderScreenshots() {
      if (this.state.activeTabForLogScreenshot !== 'Screenshots') {
        return null;
      }

      if (!this.$dom) {
        return null;
      }

      return react_default.a.createElement(screenshot_list["ScreenshotList"], {
        screenshots: this.props.screenshots,
        intersectRoot: this.$dom,
        downloadScreenshot: this.downloadScreenshot
      });
    }
  }, {
    key: 'renderVariableTable',
    value: function renderVariableTable() {
      if (this.state.activeTabForLogScreenshot !== 'Variables') {
        return null;
      }

      var columns = [{ title: 'Name', dataIndex: 'key', key: 'key', width: '40%' }, { title: 'Value', dataIndex: 'value', key: 'value', render: function render(val) {
          return JSON.stringify(val) || 'undefined';
        } }];
      var _props$config = this.props.config,
          showCommonInternalVariables = _props$config.showCommonInternalVariables,
          showAdvancedInternalVariables = _props$config.showAdvancedInternalVariables;

      var filter = createVarsFilter({
        withCommonInternal: showCommonInternalVariables,
        withAdvancedInternal: showAdvancedInternalVariables
      });
      var variables = this.props.variables.filter(function (variable) {
        return filter(variable.key);
      });

      var tableConfig = {
        columns: columns,
        dataSource: variables,
        pagination: false,
        bordered: true,
        size: 'middle',
        rowKey: 'key',
        onRowClick: function onRowClick(record, index, e) {
          // Do nothing
        },
        rowClassName: function rowClassName(record, index) {
          var vars = getVarsInstance();
          if (!vars) return '';
          return vars.isReadOnly(record.key) ? 'read-only' : '';
        }
      };

      return react_default.a.createElement(table_default.a, tableConfig);
    }
  }, {
    key: 'renderLogStack',
    value: function renderLogStack(log) {
      var _this7 = this;

      // Don't care about the top element in stack
      var stack = log.stack.slice(0, -1).reverse();

      if (stack.length === 0) {
        return null;
      }

      return react_default.a.createElement(
        'div',
        { style: { marginLeft: '80px' } },
        stack.map(function (item, i) {
          return react_default.a.createElement(
            'div',
            { key: i },
            'At ',
            react_default.a.createElement(
              'a',
              {
                href: '#',
                onClick: function onClick(e) {
                  e.preventDefault();

                  if (typeof item.commandIndex === 'number' && item.macroId) {
                    _this7.props.gotoLineInMacro(item.macroId, item.commandIndex);
                  }
                }
              },
              'Line ',
              item.commandIndex + 1,
              ' in ',
              item.macroName
            )
          );
        })
      );
    }
  }, {
    key: 'appendLinkIfPatternMatched',
    value: function appendLinkIfPatternMatched(text) {
      var linksToAdd = [];

      this.logLinkPatterns.forEach(function (item) {
        var _item = bottom_slicedToArray(item, 3),
            patternReg = _item[0],
            link = _item[1],
            _item$ = _item[2],
            anchorText = _item$ === undefined ? '(more info)' : _item$;

        if (patternReg.test(text)) {
          linksToAdd.push(react_default.a.createElement(
            'a',
            { href: link, 'class': 'info', target: '_blank', style: { marginLeft: '8px' } },
            anchorText
          ));
        }
      });

      if (linksToAdd.length === 0) {
        return text;
      }

      return react_default.a.createElement(
        'span',
        null,
        react_default.a.createElement(
          'span',
          null,
          text
        ),
        linksToAdd
      );
    }
  }, {
    key: 'renderLogText',
    value: function renderLogText(log) {
      var _this8 = this;

      if (typeof log.text === 'function') {
        return log.text({ renderText: this.renderLogText.bind(this) });
      }

      if (['error', 'warning'].indexOf(log.type) === -1) {
        return log.text;
      }

      var content = function () {
        if (/XClick\/XMove\/XType \d+ commands limit reached/.test(log.text) || /OCR conversion limit reached/.test(log.text) || /PROXY \d+ commands? limit reached/.test(log.text)) {
          var licenceType = function () {
            if (Object(services_license["getLicenseService"])().hasNoLicense()) {
              return 'PRO';
            }

            if (Object(services_license["getLicenseService"])().isPersonalLicense()) {
              return 'PRO2 or Enterprise';
            }

            return null;
          }();

          if (!licenceType) return log.text;

          return react_default.a.createElement(
            'span',
            null,
            react_default.a.createElement(
              'span',
              null,
              log.text
            ),
            react_default.a.createElement(
              'a',
              {
                href: '#',
                style: { marginLeft: '10px' },
                onClick: function onClick(e) {
                  e.preventDefault();
                  _this8.props.updateUI({ showSettings: true, settingsTab: 'register' });
                }
              },
              'Get a ',
              licenceType,
              ' license key to remove this limit'
            )
          );
        }

        if (/(XModule|xFile) is not installed yet/.test(log.text)) {
          return react_default.a.createElement(
            'span',
            null,
            react_default.a.createElement(
              'span',
              null,
              log.text
            ),
            react_default.a.createElement(
              'a',
              {
                href: '#',
                style: { marginLeft: '10px' },
                onClick: function onClick(e) {
                  e.preventDefault();
                  _this8.props.updateUI({ showSettings: true, settingsTab: 'xmodules' });
                }
              },
              'Install now'
            )
          );
        }

        if (/OCR feature disabled/.test(log.text)) {
          return react_default.a.createElement(
            'span',
            null,
            react_default.a.createElement(
              'span',
              null,
              'OCR feature disabled. Please enable it in the '
            ),
            react_default.a.createElement(
              'a',
              {
                href: '#',
                onClick: function onClick(e) {
                  e.preventDefault();
                  _this8.props.updateUI({ showSettings: true, settingsTab: 'ocr' });
                }
              },
              'OCR Settings'
            )
          );
        }

        return _this8.appendLinkIfPatternMatched(log.text);
      }();

      var stack = log.stack || [];
      var source = stack[stack.length - 1];

      if (!source) {
        return content;
      }

      return react_default.a.createElement(
        'span',
        null,
        react_default.a.createElement(
          'a',
          {
            href: '#',
            onClick: function onClick(e) {
              e.preventDefault();

              if (typeof source.commandIndex === 'number' && source.macroId) {
                _this8.props.gotoLineInMacro(source.macroId, source.commandIndex);
              }
            }
          },
          react_default.a.createElement(
            'span',
            null,
            'Line ',
            source.commandIndex + 1
          ),
          !source.isSubroutine ? null : react_default.a.createElement(
            'span',
            null,
            ' (Sub: ',
            source.macroName,
            ')'
          )
        ),
        react_default.a.createElement(
          'span',
          null,
          ': '
        ),
        content
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _this9 = this;

      var activeTabForLogScreenshot = this.state.activeTabForLogScreenshot;

      var filters = {
        'All': function All() {
          return true;
        },
        'Echo': function Echo(item) {
          return item.type === 'echo' || item.type === 'error' && (!item.options || !item.options.ignored);
        },
        'Echo_And_Status': function Echo_And_Status(item) {
          return item.type === 'echo' || item.type === 'error' && (!item.options || !item.options.ignored) || item.type === 'status';
        },
        // 'Info':   (item) => item.type === 'info' || item.type === 'echo' || item.type === 'reflect' || item.type === 'status',
        'Error': function Error(item) {
          return item.type === 'error' || item.type === 'report';
        },
        'None': function None() {
          return false;
        }
      };
      var logFilter = this.props.config.logFilter || 'All';
      var logs = this.props.logs.filter(filters[logFilter] || function () {
        return true;
      });

      return react_default.a.createElement(
        'div',
        {
          className: Object(utils["cn"])('logs-screenshots', { fold: !this.props.config.showBottomArea }),
          ref: function ref(el) {
            _this9.$dom = el;
          },
          style: { height: this.getBottomMinHeight() }
        },
        this.renderCSVModal(),
        react_default.a.createElement('div', {
          className: Object(utils["cn"])('resize-handler', { focused: this.state.drag.isDragging }),
          draggable: 'true',
          onDragStart: this.onResizeDragStart,
          onDragEnd: this.onResizeDragEnd,
          onMouseDown: function onMouseDown() {
            return _this9.setState(Object(utils["setIn"])(['drag', 'isDragging'], true, _this9.state));
          }
        }),
        react_default.a.createElement(
          tabs_default.a,
          {
            type: 'card',
            onChange: function onChange(key) {
              _this9.setState({ activeTabForLogScreenshot: key });

              if (key === 'Screenshots') {
                _this9.props.listScreenshots();
              }
            }
          },
          react_default.a.createElement(
            tabs_default.a.TabPane,
            { tab: 'Logs', key: 'Logs' },
            react_default.a.createElement(
              'ul',
              { className: 'log-content' },
              logs.map(function (log, i) {
                return react_default.a.createElement(
                  'li',
                  { className: log.type, key: log.id, style: _this9.logStyle(log) },
                  react_default.a.createElement(
                    'span',
                    { className: 'log-type' },
                    Object(macro_log["renderLogType"])(log)
                  ),
                  react_default.a.createElement(
                    'pre',
                    { className: 'log-detail' },
                    _this9.renderLogText(log)
                  ),
                  _this9.shouldRenderLogStack(log) ? _this9.renderLogStack(log) : null
                );
              })
            )
          ),
          react_default.a.createElement(
            tabs_default.a.TabPane,
            { tab: 'Variables', key: 'Variables' },
            react_default.a.createElement(
              'div',
              { className: 'variable-content' },
              react_default.a.createElement(
                'div',
                { className: 'variable-options' },
                react_default.a.createElement(
                  checkbox_default.a,
                  {
                    onChange: function onChange(e) {
                      return _this9.props.updateConfig({ showCommonInternalVariables: e.target.checked });
                    },
                    checked: this.props.config.showCommonInternalVariables
                  },
                  'Show most common ',
                  react_default.a.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?help=internalvars', target: '_blank' },
                    'internal variables'
                  )
                ),
                react_default.a.createElement(
                  checkbox_default.a,
                  {
                    onChange: function onChange(e) {
                      return _this9.props.updateConfig({ showAdvancedInternalVariables: e.target.checked });
                    },
                    checked: this.props.config.showAdvancedInternalVariables
                  },
                  'Show advanced ',
                  react_default.a.createElement(
                    'a',
                    { href: 'https://ui.vision/x/idehelp?help=internalvars', target: '_blank' },
                    'internal variables'
                  )
                )
              ),
              this.renderVariableTable()
            )
          ),
          react_default.a.createElement(
            tabs_default.a.TabPane,
            { tab: this.prefixHardDisk('Screenshots'), key: 'Screenshots' },
            this.renderScreenshots()
          ),
          react_default.a.createElement(
            tabs_default.a.TabPane,
            { tab: this.prefixHardDisk('CSV'), key: 'CSV' },
            react_default.a.createElement(
              'div',
              { className: 'csv-content' },
              this.renderCSVTable()
            )
          ),
          react_default.a.createElement(
            tabs_default.a.TabPane,
            { tab: this.prefixHardDisk('Visual'), key: 'Vision' },
            this.renderVisionSection()
          )
        ),
        react_default.a.createElement(
          'div',
          { className: 'ls-toolbox' },
          activeTabForLogScreenshot === 'Logs' ? [react_default.a.createElement(
            select_default.a,
            {
              value: this.props.config.logFilter,
              onChange: function onChange(value) {
                _this9.props.updateConfig({ logFilter: value });
              },
              style: { width: '60px' },
              dropdownMatchSelectWidth: false,
              size: 'small'
            },
            react_default.a.createElement(
              select_default.a.Option,
              { value: 'All' },
              'All'
            ),
            react_default.a.createElement(
              select_default.a.Option,
              { value: 'Echo' },
              'Echo'
            ),
            react_default.a.createElement(
              select_default.a.Option,
              { value: 'Echo_And_Status' },
              'Echo & Status'
            ),
            react_default.a.createElement(
              select_default.a.Option,
              { value: 'Error' },
              'Error & Reports'
            ),
            react_default.a.createElement(
              select_default.a.Option,
              { value: 'None' },
              'No log'
            )
          ), react_default.a.createElement(
            button_default.a,
            {
              size: 'small',
              onClick: this.props.clearLogs
            },
            'Clear'
          )] : null,
          activeTabForLogScreenshot === 'Screenshots' ? react_default.a.createElement(
            button_default.a,
            {
              size: 'small',
              onClick: this.props.clearScreenshots
            },
            'Clear'
          ) : null,
          activeTabForLogScreenshot === 'CSV' && this.props.shouldLoadResources ? react_default.a.createElement(
            button_default.a,
            {
              size: 'small',
              onClick: function onClick() {
                if (Object(storage["getStorageManager"])().isXFileMode()) {
                  modal_default.a.info({
                    title: 'In hard-drive mode, there is no need to import CSV files.',
                    content: 'To view the latest /datasource folder content, press the "Refresh" icon next to the word "Storage mode" on the left.'
                  });
                } else {
                  _this9.fileInput.click();
                }
              }
            },
            'Import CSV',
            react_default.a.createElement('input', {
              multiple: true,
              type: 'file',
              accept: '.csv',
              onChange: this.onFileChange,
              style: { display: 'none' },
              ref: function ref(_ref4) {
                _this9.fileInput = _ref4;
              }
            })
          ) : null,
          react_default.a.createElement(
            button_default.a,
            {
              size: 'small',
              onClick: this.toggleBottom
            },
            react_default.a.createElement(icon_default.a, { type: this.props.config.showBottomArea ? 'down' : 'up' })
          )
        )
      );
    }
  }]);

  return DashboardBottom;
}(react_default.a.Component);

/* harmony default export */ var bottom = (Object(react_redux_es["b" /* connect */])(function (state) {
  return {
    hasSelectedCommand: state.editor.editing && state.editor.editing.meta && state.editor.editing.meta.selectedIndex !== -1,
    selectedCommand: Object(recomputed["editorSelectedCommand"])(state),
    shouldLoadResources: Object(recomputed["getShouldLoadResources"])(state),
    isPlaying: Object(recomputed["isPlaying"])(state),
    status: state.status,
    from: state.from,
    logs: state.logs,
    screenshots: state.screenshots,
    variables: state.variables,
    csvs: state.csvs,
    visions: state.visions,
    config: state.config
  };
}, function (dispatch) {
  return Object(redux_es["b" /* bindActionCreators */])(bottom_extends({}, actions, simple_actions["Actions"]), dispatch);
})(bottom_DashboardBottom));
// CONCATENATED MODULE: ./src/containers/dashboard/index.js
var dashboard_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var dashboard_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function dashboard_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function dashboard_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function dashboard_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }











var dashboard_Dashboard = function (_React$Component) {
  dashboard_inherits(Dashboard, _React$Component);

  function Dashboard() {
    dashboard_classCallCheck(this, Dashboard);

    return dashboard_possibleConstructorReturn(this, (Dashboard.__proto__ || Object.getPrototypeOf(Dashboard)).apply(this, arguments));
  }

  dashboard_createClass(Dashboard, [{
    key: 'render',
    value: function render() {
      var isWindows = /windows/i.test(window.navigator.userAgent);

      return react_default.a.createElement(
        'div',
        { className: 'dashboard' },
        react_default.a.createElement(editor, null),
        react_default.a.createElement(bottom, null),
        react_default.a.createElement(
          'div',
          { className: 'online-help' },
          react_default.a.createElement(
            'div',
            { style: { visibility: isWindows ? 'visible' : 'hidden' } },
            react_default.a.createElement('a', { href: 'https://ui.vision/x/idehelp?help=visual', target: '_blank' })
          ),
          react_default.a.createElement(
            'div',
            null,
            'UI.Vision RPA:',
            react_default.a.createElement(
              'a',
              { href: 'https://ui.vision/x/idehelp?help=forum', target: '_blank' },
              ' User Forum'
            ),
            ' -',
            react_default.a.createElement(
              'a',
              { href: 'https://ui.vision/x/idehelp?help=docs', target: '_blank' },
              ' Online Help'
            )
          )
        )
      );
    }
  }]);

  return Dashboard;
}(react_default.a.Component);

/* harmony default export */ var containers_dashboard = (Object(react_redux_es["b" /* connect */])(function (state) {
  return {};
}, function (dispatch) {
  return Object(redux_es["b" /* bindActionCreators */])(dashboard_extends({}, actions), dispatch);
})(dashboard_Dashboard));
// EXTERNAL MODULE: ./node_modules/antd/dist/antd.css
var antd = __webpack_require__(386);

// EXTERNAL MODULE: ./src/app.scss
var app = __webpack_require__(1062);

// CONCATENATED MODULE: ./src/app.js









var app_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var app_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function app_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function app_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function app_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



















var app_App = function (_Component) {
  app_inherits(App, _Component);

  function App() {
    var _ref;

    var _temp, _this, _ret;

    app_classCallCheck(this, App);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = app_possibleConstructorReturn(this, (_ref = App.__proto__ || Object.getPrototypeOf(App)).call.apply(_ref, [this].concat(args))), _this), _this.hideBackupAlert = function () {
      _this.props.updateConfig({
        lastBackupActionTime: new Date() * 1
      });
      _this.$app.classList.remove('with-alert');
    }, _this.onClickBackup = function () {
      _this.props.runBackup();
      _this.hideBackupAlert();
    }, _this.onClickNoBackup = function () {
      _this.hideBackupAlert();
    }, _this.onClickMainArea = function () {
      _this.props.updateUI({ focusArea: reducers_state["FocusArea"].Unknown });
    }, _this.getPlayer = function (name) {
      if (name) return Object(common_player["b" /* getPlayer */])({ name: name });

      switch (_this.props.player.mode) {
        case constant["PLAYER_MODE"].TEST_CASE:
          return Object(common_player["b" /* getPlayer */])({ name: 'testCase' });

        case constant["PLAYER_MODE"].TEST_SUITE:
          return Object(common_player["b" /* getPlayer */])({ name: 'testSuite' });
      }
    }, _temp), app_possibleConstructorReturn(_this, _ret);
  }

  app_createClass(App, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      var run = function run() {
        ipc_cs["default"].ask('PANEL_TIME_FOR_BACKUP', {}).then(function (isTime) {
          if (!isTime) return;
          _this2.$app.classList.add('with-alert');
        });
      };

      // Note: check whether it's time for backup every 5 minutes
      this.timer = setInterval(run, 5 * 60000);
      run();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearInterval(this.timer);
    }
  }, {
    key: 'renderPreinstallModal',
    value: function renderPreinstallModal() {
      var _this3 = this;

      if (!this.props.ui.newPreinstallVersion) return null;

      return react_default.a.createElement(
        modal_default.a,
        {
          className: 'preinstall-modal',
          visible: true,
          title: 'New demo macros available',
          okText: 'Yes, overwrite',
          cancelText: 'Skip',
          onOk: function onOk() {
            _this3.props.updateUI({ newPreinstallVersion: false });

            return _this3.props.preinstall(true).then(function () {
              message_default.a.success('demo macros updated');
            }).catch(function (e) {
              message_default.a.error(e.message);
            });
          },
          onCancel: function onCancel() {
            _this3.props.updateUI({ newPreinstallVersion: false });
            _this3.props.preinstall(false);
          }
        },
        react_default.a.createElement(
          'p',
          { style: { fontSize: '14px' } },
          'Do you want to overwrite the demo macros with their latest versions?'
        )
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      if (this.props.noDisplay) {
        return react_default.a.createElement(
          'div',
          { className: 'app no-display' },
          react_default.a.createElement(
            'div',
            { className: 'content' },
            react_default.a.createElement(
              'div',
              { className: 'status' },
              'UI.Vision is in "No Display" mode now'
            ),
            react_default.a.createElement(
              button_default.a.Group,
              { className: 'simple-actions' },
              react_default.a.createElement(
                button_default.a,
                { size: 'large', onClick: function onClick() {
                    return _this4.getPlayer().stop();
                  } },
                react_default.a.createElement(
                  'span',
                  null,
                  'Stop'
                )
              ),
              react_default.a.createElement(
                button_default.a,
                { size: 'large', onClick: function onClick() {
                    return _this4.getPlayer('testCase').pause();
                  } },
                react_default.a.createElement(
                  'span',
                  null,
                  'Pause'
                )
              )
            )
          )
        );
      }

      return react_default.a.createElement(
        'div',
        { className: 'app with-sidebar', ref: function ref(el) {
            _this4.$app = el;
          } },
        react_default.a.createElement(
          'div',
          { className: 'backup-alert' },
          react_default.a.createElement(
            'span',
            null,
            'Do you want to run the automated backup?'
          ),
          react_default.a.createElement(
            'span',
            { className: 'backup-actions' },
            react_default.a.createElement(
              button_default.a,
              { type: 'primary', onClick: this.onClickBackup },
              'Yes'
            ),
            react_default.a.createElement(
              button_default.a,
              { onClick: this.onClickNoBackup },
              'No'
            )
          )
        ),
        react_default.a.createElement(
          'div',
          { className: 'app-inner' },
          react_default.a.createElement(containers_sidebar, null),
          react_default.a.createElement(
            'section',
            {
              className: 'content',
              onClickCapture: this.onClickMainArea
            },
            react_default.a.createElement(components_header, null),
            react_default.a.createElement(containers_dashboard, null)
          )
        ),
        this.renderPreinstallModal()
      );
    }
  }]);

  return App;
}(react["Component"]);

/* harmony default export */ var src_app = (Object(react_redux_es["b" /* connect */])(function (state) {
  return {
    ui: state.ui,
    player: state.player,
    noDisplay: Object(recomputed["isNoDisplay"])(state)
  };
}, function (dispatch) {
  return Object(redux_es["b" /* bindActionCreators */])(app_extends({}, actions), dispatch);
})(app_App));
// EXTERNAL MODULE: ./node_modules/redux-thunk/lib/index.js
var redux_thunk_lib = __webpack_require__(649);
var redux_thunk_lib_default = /*#__PURE__*/__webpack_require__.n(redux_thunk_lib);

// CONCATENATED MODULE: ./src/redux/promise_middleware.js
var promise_middleware_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var promise_middleware_slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

// Note: if a `promise` field and a `types` provied, this middleware will dispatch
// 3 actions REQUEST, SUCCESS, FAILURE based on the status of the promise it returns
function promiseMiddleWare() {
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;

    return function (next) {
      return function (action) {
        var promise = action.promise,
            types = action.types,
            rest = _objectWithoutProperties(action, ["promise", "types"]);

        if (!promise) {
          return next(action);
        }

        var _types = promise_middleware_slicedToArray(types, 3),
            REQUEST = _types[0],
            SUCCESS = _types[1],
            FAILURE = _types[2];

        next(promise_middleware_extends({}, rest, { type: REQUEST }));
        return promise().then(function (data) {
          return next(promise_middleware_extends({}, rest, { data: data, type: SUCCESS }));
        }, function (error) {
          return next(promise_middleware_extends({}, rest, { err: error, type: FAILURE }));
        });
      };
    };
  };
};
// CONCATENATED MODULE: ./src/redux/post_logic_middleware.js
function post_logic_middleware_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

// Note: if `post` field provided, it will call `post`
// after the action dispatched and state updated
function postLogicMiddleWare(extra) {
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        var post = action.post,
            rest = post_logic_middleware_objectWithoutProperties(action, ['post']);

        if (post && typeof post === 'function') {
          setTimeout(function () {
            post({ dispatch: dispatch, getState: getState }, action, extra);
          }, 0);
        } else if (Array.isArray(post)) {
          post.forEach(function (fn) {
            setTimeout(function () {
              fn({ dispatch: dispatch, getState: getState }, action, extra);
            }, 0);
          });
        }

        return next(action);
      };
    };
  };
}
// EXTERNAL MODULE: ./node_modules/url-parse/index.js
var url_parse = __webpack_require__(104);

// EXTERNAL MODULE: ./node_modules/lodash.isequal/index.js
var lodash_isequal = __webpack_require__(650);
var lodash_isequal_default = /*#__PURE__*/__webpack_require__.n(lodash_isequal);

// EXTERNAL MODULE: ./src/actions/action_types.js
var action_types = __webpack_require__(21);

// EXTERNAL MODULE: ./src/models/test_case_model.js
var test_case_model = __webpack_require__(114);

// CONCATENATED MODULE: ./src/reducers/index.js
var reducers_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function reducers_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function reducers_toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function reducers_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }














// Note: for update the `hasUnsaved` status in editing.meta
var reducers_updateHasUnSaved = function updateHasUnSaved(state) {
  var _state$editor$editing = state.editor.editing,
      meta = _state$editor$editing.meta,
      data = reducers_objectWithoutProperties(_state$editor$editing, ['meta']);

  var id = meta.src && meta.src.id;
  if (!id) return state;

  var currentMacro = state.editor.currentMacro;
  var normalizedEditing = Object(test_case_model["c" /* normalizeTestCase */])({ data: data });
  var hasUnsaved = !lodash_isequal_default()(currentMacro && currentMacro.data, normalizedEditing.data);

  return Object(utils["setIn"])(['editor', 'editing', 'meta', 'hasUnsaved'], hasUnsaved, state);
};

var updateBreakpointIndices = function updateBreakpointIndices(indices, action, actionIndex) {
  var handleSingleAction = function handleSingleAction(indices, action, actionIndex) {
    switch (action) {
      case 'add':
        {
          var result = indices.slice();

          for (var i = 0, len = indices.length; i < len; i++) {
            if (result[i] >= actionIndex) {
              result[i] += 1;
            }
          }

          return result;
        }

      case 'delete':
        {
          var _result = indices.slice();

          for (var _i = indices.length - 1; _i >= 0; _i--) {
            if (_result[_i] > actionIndex) {
              _result[_i] -= 1;
            } else if (_result[_i] === actionIndex) {
              _result.splice(_i, 1);
            }
          }

          return _result;
        }

      default:
        throw new Error('updateBreakpointIndices: unknown action, \'' + action + '\'');
    }
  };

  if (typeof actionIndex === 'number') {
    return handleSingleAction(indices, action, actionIndex);
  }

  if (Array.isArray(actionIndex)) {
    // Note: sort action indices as desc.  Bigger indice will be handled earlier, so that it won't affect others
    var actionIndices = actionIndex.slice();
    actionIndices.sort(function (a, b) {
      return b - a;
    });

    return actionIndices.reduce(function (indices, actionIndex) {
      return handleSingleAction(indices, action, actionIndex);
    }, indices);
  }

  throw new Error('updateBreakpointIndices: actionIndex should be either number or an array of number');
};

var resetEditingSource = Object(utils["partial"])(function (macro, state) {
  log_default()('resetEditingSource', macro);
  var str = Object(convert_utils["toJSONString"])(macro, {
    ignoreTargetOptions: Object(recomputed["getShouldSaveAlternativeLocators"])(state)
  });
  return Object(utils["setIn"])(['editor', 'editingSource'], {
    original: str,
    pure: str,
    current: str,
    error: null
  }, state);
});

var reducers_setEditingSourceCurrent = function setEditingSourceCurrent(state) {
  var macro = {
    name: state.editor.editing.meta.src ? state.editor.editing.meta.src.name : 'Untitled',
    commands: state.editor.editing.commands
  };
  log_default()('setEditingSourceCurrent', macro);

  var str = Object(convert_utils["toJSONString"])(macro, {
    ignoreTargetOptions: Object(recomputed["getShouldSaveAlternativeLocators"])(state)
  });
  return Object(utils["updateIn"])(['editor', 'editingSource'], function (editingSource) {
    return reducers_extends({}, editingSource, { pure: str, current: str });
  }, state);
};

var reducers_saveEditingSourceCurrent = function saveEditingSourceCurrent(state) {
  var current = state.editor.editingSource.current;

  return Object(utils["updateIn"])(['editor', 'editingSource'], function (editingSource) {
    return reducers_extends({}, editingSource, { pure: current, original: current });
  }, state);
};

var reducers_setEditingSourceOriginalAndPure = function setEditingSourceOriginalAndPure(macro, state) {
  var str = Object(convert_utils["toJSONString"])(macro, {
    ignoreTargetOptions: Object(recomputed["getShouldSaveAlternativeLocators"])(state)
  });
  return Object(utils["updateIn"])(['editor', 'editingSource'], function (editingSource) {
    return reducers_extends({}, editingSource, { pure: str, original: str });
  }, state);
};

function reducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : reducers_state["initialState"];
  var action = arguments[1];

  switch (action.type) {
    case action_types["b" /* types */].START_RECORDING_SUCCESS:
      return reducers_extends({}, state, {
        status: constant["APP_STATUS"].RECORDER,
        recorderStatus: constant["APP_STATUS"].PENDING,
        player: reducers_extends({}, state.player, {
          nextCommandIndex: null
        })
      });
    case action_types["b" /* types */].STOP_RECORDING_SUCCESS:
      return reducers_extends({}, state, {
        status: constant["APP_STATUS"].NORMAL,
        recorderStatus: constant["RECORDER_STATUS"].STOPPED
      });
    case action_types["b" /* types */].START_INSPECTING_SUCCESS:
      return reducers_extends({}, state, {
        status: constant["APP_STATUS"].INSPECTOR,
        inspectorStatus: constant["INSPECTOR_STATUS"].PENDING
      });
    case action_types["b" /* types */].STOP_INSPECTING_SUCCESS:
    case action_types["b" /* types */].DONE_INSPECTING:
      return reducers_extends({}, state, {
        status: constant["APP_STATUS"].NORMAL,
        recorderStatus: constant["INSPECTOR_STATUS"].STOPPED
      });

    case action_types["b" /* types */].START_PLAYING:
      return reducers_extends({}, state, {
        status: constant["APP_STATUS"].PLAYER
      });

    case action_types["b" /* types */].STOP_PLAYING:
      return reducers_extends({}, state, {
        status: constant["APP_STATUS"].NORMAL
      });

    case action_types["b" /* types */].APPEND_COMMAND:
      return Object(utils["compose"])(reducers_setEditingSourceCurrent, reducers_updateHasUnSaved, Object(utils["updateIn"])(['editor', 'editing', 'commands'], function (commands) {
        return [].concat(reducers_toConsumableArray(commands), [action.data.command]);
      }))(state);

    case action_types["b" /* types */].DUPLICATE_COMMAND:
      return Object(utils["compose"])(reducers_setEditingSourceCurrent, reducers_updateHasUnSaved, Object(utils["setIn"])(['editor', 'editing', 'meta', 'selectedIndex'], action.data.index + 1), Object(utils["updateIn"])(['editor', 'editing', 'commands'], function (commands) {
        var index = action.data.index;

        var newCommands = commands.slice();
        newCommands.splice(index + 1, 0, commands[index]);
        return newCommands;
      }), Object(ts_utils["safeUpdateIn"])(['editor', 'macrosExtra', Object(recomputed["getCurrentMacroId"])(state), 'breakpointIndices'], function (indices) {
        return updateBreakpointIndices(indices || [], 'add', action.data.index + 1);
      }))(state);

    case action_types["b" /* types */].INSERT_COMMAND:
      return Object(utils["compose"])(reducers_setEditingSourceCurrent, reducers_updateHasUnSaved, Object(utils["setIn"])(['editor', 'editing', 'meta', 'selectedIndex'], action.data.index), Object(utils["updateIn"])(['editor', 'editing', 'meta', 'indexToInsertRecorded'], function (recordIndex) {
        if (recordIndex === undefined || recordIndex === null || recordIndex < 0) {
          return recordIndex;
        }
        return recordIndex + (action.data.index <= recordIndex ? 1 : 0);
      }), Object(utils["updateIn"])(['editor', 'editing', 'commands'], function (commands) {
        var _action$data = action.data,
            index = _action$data.index,
            command = _action$data.command;

        var newCommands = commands.slice();
        newCommands.splice(index, 0, command);
        return newCommands;
      }), Object(ts_utils["safeUpdateIn"])(['editor', 'macrosExtra', Object(recomputed["getCurrentMacroId"])(state), 'breakpointIndices'], function (indices) {
        return updateBreakpointIndices(indices || [], 'add', action.data.index);
      }))(state);

    case action_types["b" /* types */].UPDATE_COMMAND:
      return Object(utils["compose"])(reducers_setEditingSourceCurrent, reducers_updateHasUnSaved, Object(utils["updateIn"])(['editor', 'editing', 'commands', action.data.index], function (cmdObj) {
        return reducers_extends({}, cmdObj, action.data.command);
      }))(state);

    case action_types["b" /* types */].REMOVE_COMMAND:
      return Object(utils["compose"])(reducers_setEditingSourceCurrent, reducers_updateHasUnSaved, function (state) {
        var _state$editor$editing2 = state.editor.editing,
            commands = _state$editor$editing2.commands,
            meta = _state$editor$editing2.meta;

        var isSelectedIndexStillValid = meta.selectedIndex >= 0 && meta.selectedIndex < commands.length;

        if (isSelectedIndexStillValid) {
          return state;
        }

        var startDistance = action.data.index;
        var endDistance = commands.length - action.data.index - 1;
        var nextSelectedIndex = startDistance < endDistance ? 0 : commands.length - 1;

        return Object(utils["setIn"])(['editor', 'editing', 'meta', 'selectedIndex'], nextSelectedIndex, state);
      }, Object(utils["updateIn"])(['editor', 'editing', 'commands'], function (commands) {
        var index = action.data.index;

        var newCommands = commands.slice();
        newCommands.splice(index, 1);
        return newCommands;
      }), Object(ts_utils["safeUpdateIn"])(['editor', 'macrosExtra', Object(recomputed["getCurrentMacroId"])(state), 'breakpointIndices'], function (indices) {
        return updateBreakpointIndices(indices || [], 'delete', action.data.index);
      }))(state);

    case action_types["b" /* types */].SELECT_COMMAND:
      return Object(utils["compose"])(Object(utils["setIn"])(['editor', 'editing', 'meta', 'selectedIndex'], action.data.forceClick || state.editor.editing.meta.selectedIndex !== action.data.index ? action.data.index : -1),
      // Note: normalize commands whenever switching between commands in normal mode
      state.status === constant["APP_STATUS"].NORMAL ? Object(utils["updateIn"])(['editor', 'editing', 'commands'], function (cmds) {
        return cmds.map(test_case_model["b" /* normalizeCommand */]);
      }) : function (x) {
        return x;
      })(state);

    case action_types["b" /* types */].CUT_COMMAND:
      {
        var commands = action.data.indices.map(function (i) {
          return state.editor.editing.commands[i];
        });

        return Object(utils["compose"])(reducers_setEditingSourceCurrent, reducers_updateHasUnSaved, Object(utils["setIn"])(['editor', 'clipboard', 'commands'], commands), Object(utils["updateIn"])(['editor', 'editing', 'commands'], function (commands) {
          var newCommands = commands.slice();
          return newCommands.filter(function (c, i) {
            return action.data.indices.indexOf(i) === -1;
          });
        }), Object(ts_utils["safeUpdateIn"])(['editor', 'macrosExtra', Object(recomputed["getCurrentMacroId"])(state), 'breakpointIndices'], function (indices) {
          return updateBreakpointIndices(indices || [], 'delete', action.data.indices);
        }))(state);
      }

    case action_types["b" /* types */].COPY_COMMAND:
      {
        var _commands = action.data.indices.map(function (i) {
          return state.editor.editing.commands[i];
        });
        return Object(utils["setIn"])(['editor', 'clipboard', 'commands'], _commands, state);
      }

    case action_types["b" /* types */].PASTE_COMMAND:
      {
        var _commands2 = state.editor.clipboard.commands;


        return Object(utils["compose"])(reducers_setEditingSourceCurrent, reducers_updateHasUnSaved, Object(utils["updateIn"])(['editor', 'editing', 'commands'], function (cmds) {
          var newCmds = cmds.slice();
          newCmds.splice.apply(newCmds, [action.data.index + 1, 0].concat(reducers_toConsumableArray(_commands2)));
          return newCmds;
        }), Object(ts_utils["safeUpdateIn"])(['editor', 'macrosExtra', Object(recomputed["getCurrentMacroId"])(state), 'breakpointIndices'], function (indices) {
          return updateBreakpointIndices(indices || [], 'add', _commands2.map(function (_) {
            return action.data.index + 1;
          }));
        }))(state);
      }

    case simple_actions["ActionTypes"].moveCommands:
      {
        var _state$editor$editing3 = state.editor.editing.commands,
            _commands3 = _state$editor$editing3 === undefined ? [] : _state$editor$editing3;

        var _action$data2 = action.data,
            startIndex = _action$data2.startIndex,
            endIndex = _action$data2.endIndex;


        if (startIndex < 0 || startIndex >= _commands3.length) {
          throw new Error('startIndex is out of range');
        }

        if (endIndex < 0 || endIndex >= _commands3.length) {
          throw new Error('endIndex is out of range');
        }

        if (endIndex === startIndex) {
          throw new Error('startIndex and endIndex must be different');
        }

        var newCommands = [].concat(reducers_toConsumableArray(_commands3));

        newCommands.splice(startIndex, 1);
        newCommands.splice(endIndex, 0, _commands3[startIndex]);

        return Object(utils["compose"])(reducers_setEditingSourceCurrent, reducers_updateHasUnSaved, Object(utils["setIn"])(['editor', 'editing', 'commands'], newCommands), Object(utils["updateIn"])(['editor', 'editing', 'meta', 'selectedIndex'], function (selectedIndex) {
          switch (selectedIndex) {
            case startIndex:
              return endIndex;
            case endIndex:
              return startIndex;
            default:
              return selectedIndex;
          }
        }))(state);
      }

    case action_types["b" /* types */].NORMALIZE_COMMANDS:
      return Object(utils["updateIn"])(['editor', 'editing', 'commands'], function (cmds) {
        return cmds.map(test_case_model["b" /* normalizeCommand */]);
      }, state);

    case action_types["b" /* types */].UPDATE_SELECTED_COMMAND:
      if (state.editor.editing.meta.selectedIndex === -1) {
        return state;
      }

      return Object(utils["compose"])(reducers_setEditingSourceCurrent, reducers_updateHasUnSaved, Object(utils["updateIn"])(['editor', 'editing', 'commands', state.editor.editing.meta.selectedIndex], function (cmdObj) {
        return Object(test_case_model["b" /* normalizeCommand */])(reducers_extends({}, cmdObj, action.data));
      }))(state);

    case action_types["b" /* types */].SAVE_EDITING_AS_EXISTED:
      return Object(utils["compose"])(Object(utils["setIn"])(['editor', 'editing', 'meta', 'hasUnsaved'], false), reducers_saveEditingSourceCurrent)(state);

    case action_types["b" /* types */].SAVE_EDITING_AS_NEW:
      return Object(utils["compose"])(Object(utils["updateIn"])(['editor', 'editing', 'meta'], function (meta) {
        return reducers_extends({}, meta, {
          hasUnsaved: false,
          src: Object(utils["pick"])(['id', 'name'], action.data)
        });
      }), reducers_saveEditingSourceCurrent)(state);

    case action_types["b" /* types */].SET_TEST_CASES:
      {
        return Object(utils["compose"])(function (state) {
          var src = state.editor.editing.meta.src;

          if (!src) return state;

          var tc = state.editor.testCases.find(function (tc) {
            return tc.id === src.id;
          });
          if (!tc) return state;

          return reducers_setEditingSourceOriginalAndPure({
            name: tc.name,
            commands: tc.data.commands
          }, state);
        }, Object(utils["setIn"])(['editor', 'testCases'], action.data))(state);
      }

    case action_types["b" /* types */].SET_TEST_SUITES:
      return Object(utils["setIn"])(['editor', 'testSuites'], action.data, state);

    case simple_actions["ActionTypes"].updateTestSuite:
      {
        var _action$data3 = action.data,
            id = _action$data3.id,
            updated = _action$data3.updated;

        var index = state.editor.testSuites.findIndex(function (ts) {
          return ts.id === id;
        });

        if (index === -1) return state;
        return Object(utils["setIn"])(['editor', 'testSuites', index], updated, state);
      }

    case action_types["b" /* types */].UPDATE_TEST_SUITE_STATUS:
      {
        var _action$data4 = action.data,
            _id = _action$data4.id,
            extra = _action$data4.extra;

        if (!_id) return state;

        return Object(utils["updateIn"])(['editor', 'testSuitesExtra'], function (data) {
          return reducers_extends({}, data, reducers_defineProperty({}, _id, extra));
        }, state);
      }

    case action_types["b" /* types */].SET_EDITING:
      log_default()('REDUCER SET_EDITING', action.data);

      if (!action.data) return state;
      return Object(utils["compose"])(reducers_setEditingSourceCurrent, reducers_updateHasUnSaved, Object(utils["setIn"])(['editor', 'editing'], action.data))(state);

    case action_types["b" /* types */].EDIT_TEST_CASE:
      {
        var _ref = state.editor.editing.meta.src || {},
            _id2 = _ref.id;

        if (!action.data.macro) return state;

        var macro = action.data.macro;

        return Object(utils["compose"])(Object(utils["setIn"])(['editor', 'editing'], reducers_extends({}, macro.data, {
          meta: {
            selectedIndex: -1,
            hasUnsaved: false,
            src: Object(utils["pick"])(['id', 'name'], macro)
          }
        })), Object(utils["updateIn"])(['player'], function (player) {
          return reducers_extends({}, player, {
            status: constant["PLAYER_STATUS"].STOPPED,
            stopReason: null,
            nextCommandIndex: null
          });
        }), resetEditingSource({
          name: macro.name,
          commands: macro.data.commands
        }), reducers_updateHasUnSaved)(state);
      }

    case action_types["b" /* types */].SET_ONE_MACRO_EXTRA:
      {
        var _action$data5 = action.data,
            _id3 = _action$data5.id,
            _extra = _action$data5.extra;


        if (!_id3) return state;

        return Object(ts_utils["safeSetIn"])(['editor', 'macrosExtra', _id3], _extra, state);
      }

    case action_types["b" /* types */].UPDATE_ONE_MACRO_EXTRA:
      {
        var _action$data6 = action.data,
            _id4 = _action$data6.id,
            _extra2 = _action$data6.extra;


        if (!_id4) return state;

        return Object(ts_utils["safeUpdateIn"])(['editor', 'macrosExtra', _id4], function (data) {
          return reducers_extends({}, data, _extra2);
        }, state);
      }

    case simple_actions["ActionTypes"].renameTestCase:
      return Object(utils["setIn"])(['editor', 'editing', 'meta', 'src', 'name'], action.data, state);

    case action_types["b" /* types */].REMOVE_TEST_CASE:
      {
        if (!action.data.isCurrent) return state;

        var _id5 = state.editor.editing.meta.src.id;
        var selectedIndex = state.editor.editing.meta.selectedIndex;

        var candidates = state.editor.testCases.filter(function (tc) {
          return tc.id !== _id5;
        });
        var lastIndex = state.editor.testCases.findIndex(function (tc) {
          return tc.id === _id5;
        });
        var editing = void 0;

        if (candidates.length === 0) {
          editing = reducers_extends({}, reducers_state["newTestCaseEditing"]);
        } else {
          var _index = lastIndex === -1 ? 0 : lastIndex < candidates.length ? lastIndex : lastIndex - 1;
          var tc = candidates[_index];

          editing = reducers_extends({}, tc.data, {
            meta: {
              src: Object(utils["pick"])(['id', 'name'], tc),
              hasUnsaved: false,
              selectedIndex: _index
            }
          });
        }

        return Object(utils["setIn"])(['editor', 'editing'], editing, state);
      }

    case action_types["b" /* types */].EDIT_NEW_TEST_CASE:
      {
        return Object(utils["compose"])(Object(utils["setIn"])(['editor', 'editing'], reducers_extends({}, reducers_state["newTestCaseEditing"])), Object(utils["updateIn"])(['player'], function (player) {
          return reducers_extends({}, player, {
            nextCommandIndex: null
          });
        }), resetEditingSource({
          name: 'Untitled',
          commands: []
        }))(state);
      }

    case action_types["b" /* types */].SET_MACROS_EXTRA:
      {
        return Object(utils["setIn"])(['editor', 'macrosExtra'], action.data, state);
      }

    case action_types["b" /* types */].SET_TEST_SUITES_EXTRA:
      {
        return Object(utils["setIn"])(['editor', 'testSuitesExtra'], action.data, state);
      }

    case simple_actions["ActionTypes"].setMacroFolderStructure:
      {
        return Object(utils["setIn"])(['editor', 'macroFolderStructure'], action.data, state);
      }

    case simple_actions["ActionTypes"].setTestSuiteFolderStructure:
      {
        return Object(utils["setIn"])(['editor', 'testSuiteFolderStructure'], action.data, state);
      }

    case action_types["b" /* types */].SET_PLAYER_STATE:
      return Object(utils["compose"])(Object(utils["updateIn"])(['player'], function (playerState) {
        return reducers_extends({}, playerState, action.data);
      }), Object(utils["updateIn"])(['noDisplayInPlay'], function (noDisplayInPlay) {
        // Reset noDisplay to false when macro stops playing
        return action.data.status === constant["PLAYER_STATUS"].STOPPED ? false : noDisplayInPlay;
      }))(state);

    case action_types["b" /* types */].ADD_LOGS:
      return reducers_extends({}, state, {
        logs: [].concat(reducers_toConsumableArray(state.logs), reducers_toConsumableArray(action.data)).slice(-500)
      });

    case action_types["b" /* types */].CLEAR_LOGS:
      return reducers_extends({}, state, {
        logs: []
      });

    case action_types["b" /* types */].ADD_SCREENSHOT:
      return reducers_extends({}, state, {
        screenshots: [].concat(reducers_toConsumableArray(state.screenshots), [action.data])
      });

    case action_types["b" /* types */].CLEAR_SCREENSHOTS:
      return reducers_extends({}, state, {
        screenshots: []
      });

    case action_types["b" /* types */].UPDATE_CONFIG:
      return Object(utils["updateIn"])(['config'], function (cfg) {
        return reducers_extends({}, cfg, action.data);
      }, state);

    case action_types["b" /* types */].SET_CSV_LIST:
      return reducers_extends({}, state, {
        csvs: action.data
      });

    case action_types["b" /* types */].SET_SCREENSHOT_LIST:
      return reducers_extends({}, state, {
        screenshots: action.data
      });

    case action_types["b" /* types */].SET_VISION_LIST:
      return reducers_extends({}, state, {
        visions: action.data
      });

    case action_types["b" /* types */].SET_VARIABLE_LIST:
      return reducers_extends({}, state, {
        variables: action.data
      });

    case action_types["b" /* types */].UPDATE_UI:
      {
        return Object(utils["updateIn"])(['ui'], function (ui) {
          return reducers_extends({}, ui, action.data);
        }, state);
      }

    case action_types["b" /* types */].SET_EDITOR_ACTIVE_TAB:
      {
        return Object(utils["setIn"])(['editor', 'activeTab'], action.data, state);
      }

    case action_types["b" /* types */].SET_SOURCE_ERROR:
      {
        return Object(utils["setIn"])(['editor', 'editingSource', 'error'], action.data, state);
      }

    case action_types["b" /* types */].SET_SOURCE_CURRENT:
      {
        return Object(utils["setIn"])(['editor', 'editingSource', 'current'], action.data, state);
      }

    case action_types["b" /* types */].UPDATE_PROXY:
      {
        return reducers_extends({}, state, {
          proxy: action.data
        });
      }

    case simple_actions["ActionTypes"].setIsDraggingCommand:
      {
        return Object(utils["setIn"])(['editor', 'isDraggingCommand'], action.data, state);
      }

    case simple_actions["ActionTypes"].setCurrentMacro:
      {
        return Object(utils["setIn"])(['editor', 'currentMacro'], action.data, state);
      }

    case simple_actions["ActionTypes"].setIsLoadingMacros:
      {
        return Object(utils["setIn"])(['isLoadingMacros'], action.data, state);
      }

    case simple_actions["ActionTypes"].setFrom:
      {
        return Object(utils["setIn"])(['from'], action.data, state);
      }

    case simple_actions["ActionTypes"].setNoDisplayInPlay:
      {
        return Object(utils["setIn"])(['noDisplayInPlay'], action.data, state);
      }

    case simple_actions["ActionTypes"].setMacroQuery:
      {
        return Object(utils["setIn"])(['macroQuery'], action.data, state);
      }

    case simple_actions["ActionTypes"].setIndexToInsertRecorded:
      {
        return Object(utils["setIn"])(['editor', 'editing', 'meta', 'indexToInsertRecorded'], action.data, state);
      }

    case simple_actions["ActionTypes"].toggleRecorderSkipOpen:
      {
        return Object(utils["updateIn"])(['recorder', 'skipOpen'], function (skipOpen) {
          return action.data !== undefined ? action.data : !skipOpen;
        }, state);
      }

    default:
      return state;
  }
}
// CONCATENATED MODULE: ./src/redux/index.js







var createStore = Object(redux_es["a" /* applyMiddleware */])(redux_thunk_lib_default.a, promiseMiddleWare(), postLogicMiddleWare())(redux_es["c" /* createStore */]);


// EXTERNAL MODULE: ./src/services/timeout/cs_timeout.ts
var cs_timeout = __webpack_require__(118);

// EXTERNAL MODULE: ./src/models/test_suite_model.js
var test_suite_model = __webpack_require__(390);

// EXTERNAL MODULE: ./src/common/storage/index.js + 1 modules
var common_storage = __webpack_require__(36);

// EXTERNAL MODULE: ./src/common/download_man.js
var download_man = __webpack_require__(119);

// EXTERNAL MODULE: ./src/services/kv_data/test_suite_extra_data.ts
var test_suite_extra_data = __webpack_require__(389);

// EXTERNAL MODULE: ./src/services/migration/jobs/2019_04_01_macro_suite_storage.ts
var _2019_04_01_macro_suite_storage = __webpack_require__(325);

// EXTERNAL MODULE: ./src/services/migration/index.ts
var migration = __webpack_require__(361);

// EXTERNAL MODULE: ./src/services/migration/types.ts
var migration_types = __webpack_require__(185);

// EXTERNAL MODULE: ./src/services/log/index.ts
var services_log = __webpack_require__(324);

// CONCATENATED MODULE: ./src/index.js













var src_slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var src_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function src_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function src_toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* global PREINSTALL_CSV_LIST PREINSTALL_VISION_LIST */
















































Object(cs_timeout["polyfillTimeoutFunctions"])(ipc_cs["default"]);

var src_store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());

// FIXME: better not passing store via `window` object
window['store'] = src_store;

var rootEl = document.getElementById('root');
var src_render = function render(Component) {
  return react_dom_default.a.render(react_default.a.createElement(
    DndProvider["a" /* DndProvider */],
    { backend: esm["a" /* default */] },
    react_default.a.createElement(
      locale_provider_default.a,
      { locale: en_US_default.a },
      react_default.a.createElement(
        react_redux_es["a" /* Provider */],
        { store: src_store },
        react_default.a.createElement(
          es["a" /* HashRouter */],
          null,
          react_default.a.createElement(src_app, null)
        )
      )
    )
  ), rootEl);
};

var timestampCache = {};
var DURATION = 2000;

// Note: listen to any db changes and restore all data from db to redux store
// All test cases are stored in indexeddb (dexie)
var src_bindMacroAndTestSuites = function bindMacroAndTestSuites() {
  var curStorageMode = Object(storage["getStorageManager"])().getCurrentStrategyType();
  var macroStorage = Object(storage["getStorageManager"])().getMacroStorage();
  var suiteStorage = Object(storage["getStorageManager"])().getTestSuiteStorage();
  var onError = function onError(errorList) {
    errorList.filter(function (item) {
      return item.fileName !== '__Untitled__';
    }).forEach(function (errorItem) {
      var key = errorItem.fullFilePath;

      if (!timestampCache[key] || new Date() * 1 - timestampCache[key] > DURATION) {
        timestampCache[key] = new Date() * 1;
        src_store.dispatch(Object(actions["addLog"])('warning', errorItem.error.message));
      }
    });
  };

  var restoreTestCases = function restoreTestCases() {
    src_store.dispatch(simple_actions["Actions"].setIsLoadingMacros(true));

    var pMacrosExtra = Object(macro_extra_data["getMacroExtraKeyValueData"])().getAll().then(function (data) {
      log_default()('restoreMacrosExtra', data);

      src_store.dispatch(Object(actions["setMacrosExtra"])(data));
    });

    var pFolderStructure = function () {
      if (!Object(recomputed["getShouldLoadResources"])(src_store.getState())) {
        return Promise.resolve();
      }

      return macroStorage.listR().then(function (entryNodes) {
        log_default()('restoreMacroFolderStructure', entryNodes);

        src_store.dispatch(simple_actions["Actions"].setMacroFolderStructure(entryNodes));
      });
    }();

    return Promise.all([pMacrosExtra, pFolderStructure]).finally(function () {
      return src_store.dispatch(simple_actions["Actions"].setIsLoadingMacros(false));
    });
  };

  var restoreTestSuites = function restoreTestSuites() {
    if (!Object(recomputed["getShouldLoadResources"])(src_store.getState())) {
      return Promise.resolve();
    }

    return Object(ts_utils["until"])('macros', function () {
      var macroFolderStructure = src_store.getState().editor.macroFolderStructure;


      return {
        pass: macroFolderStructure.length >= 0,
        result: true
      };
    }).then(function () {
      var pTestSuites = suiteStorage.readR('/', 'Text', onError).then(function (items) {
        return items.map(function (item) {
          return Object(test_suite_model["normalizeTestSuite"])(item.content);
        });
      }).then(function (tss) {
        tss.sort(function (a, b) {
          var aname = a.name.toLowerCase();
          var bname = b.name.toLowerCase();

          if (aname < bname) return -1;
          if (aname > bname) return 1;
          if (aname === bname) {
            return b.updateTime - a.updateTime;
          }
        });

        log_default()('restoreTestSuites - suiteStorage - tss', tss);

        src_store.dispatch(Object(actions["setTestSuites"])(tss));
      });

      var pTestSuitesExtra = Object(test_suite_extra_data["getTestSuiteExtraKeyValueData"])().getAll().then(function (data) {
        log_default()('restoreTestSuitesExtra', data);

        src_store.dispatch(Object(actions["setTestSuitesExtra"])(data));
      });

      var pFolderStructure = suiteStorage.listR().then(function (entryNodes) {
        log_default()('restoreTestSuiteFolderStructure', entryNodes);

        src_store.dispatch(simple_actions["Actions"].setTestSuiteFolderStructure(entryNodes));
      });

      return Promise.all([pTestSuites, pTestSuitesExtra, pFolderStructure]);
    });
  }

  // FIXME: need to unbind previous listeners when bindMacroAndTestSuites is called for more than once
  ;[flat_storage["FlatStorageEvent"].ListChanged, flat_storage["FlatStorageEvent"].FilesChanged].forEach(function (eventName) {
    macroStorage.off(eventName);
    macroStorage.on(eventName, function () {
      if (curStorageMode !== Object(storage["getStorageManager"])().getCurrentStrategyType()) return;
      log_default()('macroStorage - eventName', eventName);
      setTimeout(restoreTestCases, 50);
    });
  });[flat_storage["FlatStorageEvent"].ListChanged, flat_storage["FlatStorageEvent"].FilesChanged].forEach(function (eventName) {
    suiteStorage.off(eventName);
    suiteStorage.on(eventName, function () {
      if (curStorageMode !== Object(storage["getStorageManager"])().getCurrentStrategyType()) return;
      log_default()('suiteStorage - eventName', eventName);
      setTimeout(restoreTestSuites, 50);
    });
  });

  return Object(ts_utils["flow"])(Object(ts_utils["guardVoidPromise"])(restoreTestCases), Object(ts_utils["guardVoidPromise"])(restoreTestSuites));
};

// Note: editing is stored in localstorage
var src_restoreEditing = function restoreEditing() {
  return common_storage["default"].get('editing').then(function (editing) {
    if (!editing) return;

    var finalEditing = editing;

    if (editing.baseUrl) {
      finalEditing = src_extends({}, editing);
      finalEditing.commands = finalEditing.commands.map(Object(test_case_model["a" /* commandWithoutBaseUrl */])(editing.baseUrl));
      delete finalEditing.baseUrl;
    }

    src_store.dispatch(Object(actions["setEditing"])(finalEditing));
  });
};

var src_restoreConfig = function restoreConfig() {
  return common_storage["default"].get('config').then(function (config) {
    var cfg = src_extends({
      showSidebar: true,
      showBottomArea: true,
      playScrollElementsIntoView: true,
      playHighlightElements: true,
      playCommandInterval: 0.3,
      // selenium related
      saveAlternativeLocators: true,
      recordNotification: true,
      recordClickType: 'click',
      showTestCaseTab: true,
      logFilter: 'All',
      onErrorInLoop: 'continue_next_loop',
      // Run macros from outside
      allowRunFromBookmark: true,
      allowRunFromFileSchema: true,
      allowRunFromHttpSchema: true,
      // timeout in seconds
      timeoutPageLoad: 60,
      timeoutElement: 10,
      timeoutMacro: 0,
      timeoutDownload: 60,
      // backup relative
      lastBackupActionTime: new Date() * 1,
      enableAutoBackup: true,
      autoBackupInterval: 7,
      autoBackupTestCases: true,
      autoBackupTestSuites: true,
      autoBackupScreenshots: true,
      autoBackupCSVFiles: true,
      autoBackupVisionImages: true,
      // security relative
      shouldEncryptPassword: 'no',
      masterPassword: '',
      // variable relative
      showCommonInternalVariables: true,
      showAdvancedInternalVariables: false,
      // xmodules related
      storageMode: storage["StorageStrategyType"].Browser,
      xmodulesStatus: 'unregistered',
      // orc related
      ocrEngine: 1,
      ocrMode: 'disabled',
      ocrLanguage: 'eng',
      ocrOfflineURL: '',
      ocrOfflineAPIKey: '',
      // vision related
      cvScope: 'browser',
      defaultVisionSearchConfidence: 0.6,
      useDesktopScreenCapture: true,
      waitBeforeDesktopScreenCapture: false,
      secondsBeforeDesktopScreenCapture: 3,
      // proxy related,
      defaultProxy: '',
      defaultProxyAuth: '',
      turnOffProxyAfterReplay: true
    }, config);
    src_store.dispatch(Object(actions["updateConfig"])(cfg));
    return cfg;
  });
};

var src_restoreCSV = function restoreCSV() {
  if (!Object(recomputed["getShouldLoadResources"])(src_store.getState())) {
    return Promise.resolve();
  }

  // Note: just try to init storage. Eg. For browser fs, it will try to create root folder
  Object(storage["getStorageManager"])().getCSVStorage();
  return src_store.dispatch(Object(actions["listCSV"])());
};

var src_restoreScreenshots = function restoreScreenshots() {
  Object(storage["getStorageManager"])().getScreenshotStorage();
  return src_store.dispatch(Object(actions["listScreenshots"])());
};

var src_restoreVisions = function restoreVisions() {
  if (!Object(recomputed["getShouldLoadResources"])(src_store.getState())) {
    return Promise.resolve();
  }

  Object(storage["getStorageManager"])().getVisionStorage();
  return src_store.dispatch(Object(actions["listVisions"])());
};

var src_downloadTextFile = function downloadTextFile(text, fileName) {
  var blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
  file_saver_default.a.saveAs(blob, fileName);
};

var src_prepareBeforeRun = function prepareBeforeRun(options) {
  if (options.savelog) {
    src_store.dispatch(Object(actions["clearLogs"])());
  }
};

var src_genPlayerPlayCallback = function genPlayerPlayCallback(_ref) {
  var options = _ref.options;

  // Only run this callback once, we've added it to two places
  // 1. Player callback
  // 2. Promise finally of the entire macro run
  var alreadyRun = false;

  return function (err, reason) {
    if (alreadyRun) {
      return;
    }

    alreadyRun = true;

    var pSaveLog = Object(utils["delay"])(function () {}, 1000);

    if (options.savelog) {
      var isFullPath = /\\|\//.test(options.savelog);
      var logs = src_store.getState().logs;
      var errorLog = logs.find(function (log) {
        return log.type === 'error' && !(log.options && log.options.ignored);
      });
      var error = err || errorLog && { message: errorLog.text };
      var logTitle = error ? 'Status=Error: ' + error.message : 'Status=OK';
      var logContent = logs.map(function (log) {
        return Object(macro_log["renderLog"])(log, false);
      });
      var text = [logTitle, '###'].concat(src_toConsumableArray(logContent)).join('\n');

      if (!isFullPath || !Object(storage["getStorageManager"])().isXFileMode()) {
        pSaveLog = Object(utils["delay"])(function () {}, 500).then(function () {
          src_downloadTextFile(text, decodeURIComponent(options.savelog));
          // Note: We have to wait until savelog download completes if there is any
          return Object(download_man["a" /* getDownloadMan */])().prepareDownload(options.savelog);
        });
      } else {
        pSaveLog = Object(services_log["getLogService"])().logTo(options.savelog, text);
      }
    }

    var closeBrowser = Object(ts_utils["parseBoolLike"])(options.closeBrowser, false);
    var closeRPA = Object(ts_utils["parseBoolLike"])(options.closeRPA !== undefined ? options.closeRPA : options.closeKantu, true);

    if (closeBrowser && reason !== common_player["a" /* Player */].C.END_REASON.MANUAL) {
      // Close all tabs If close option is set
      pSaveLog.catch(function (e) {
        log_default.a.warn('Save log error: ', e.message);
      }).then(function () {
        return ipc_cs["default"].ask('PANEL_CLOSE_ALL_WINDOWS', {});
      });
    }

    // Note: it's better to keep kantu open if it's opened manually before
    if (!err && reason === common_player["a" /* Player */].C.END_REASON.COMPLETE && closeRPA && !closeBrowser) {
      // Close kantu panel
      setTimeout(function () {
        window.close();
      }, 1000);
    }
  };
};

var genOverrideScope = function genOverrideScope(_ref2) {
  var options = _ref2.options;

  return Object.keys(options || {}).reduce(function (prev, key) {
    var m = key.match(/^cmd_var(1|2|3)$/i);
    if (!m) return prev;

    prev['!CMD_VAR' + m[1]] = options[key];
    return prev;
  }, {});
};

var validParams = ['direct', 'closeBrowser', 'closeKantu', 'closeRPA', 'continueInLastUsedTab', 'nodisplay', 'folder', 'savelog', 'storage', 'macro', 'testsuite', 'storageMode', 'loadmacrotree', 'cmd_var1', 'cmd_var2', 'cmd_var3', 'cmd_var4', 'cmd_var5', 'cmd_var6', 'cmd_var7', 'cmd_var8', 'cmd_var9', 'cmd_var10'];

var fuzzyObj = new fuzzyset_js_default.a(validParams);

var src_initFromCommandLineArgs = function initFromCommandLineArgs(args) {
  var loadMacroTree = Object(ts_utils["parseBoolLike"])(args.loadmacrotree);
  var noDisplay = Object(ts_utils["parseBoolLike"])(args.nodisplay, false);

  if (loadMacroTree) {
    src_store.dispatch(simple_actions["Actions"].setFrom(reducers_state["RunBy"].Manual));
  }

  if (noDisplay) {
    src_store.dispatch(simple_actions["Actions"].setNoDisplayInPlay(true));
  }
};

var src_guardCommandLineArgs = function guardCommandLineArgs(args, storageMode) {
  // Check params
  var keys = Object.keys(args);
  var checkName = function checkName(pattern, str) {
    if (typeof pattern === 'string') {
      return pattern === str;
    } else {
      return pattern.test(str);
    }
  };
  var checkValue = function checkValue(name, value) {
    switch (name) {
      case 'continueInLastUsedTab':
      case 'closeKantu':
      case 'closeRPA':
      case 'closeBrowser':
      case 'direct':
      case 'loadmacrotree':
      case 'nodisplay':
        if (/^0|1|true|false$/i.test(value)) {
          return true;
        } else {
          throw new Error('"' + name + '" should be 0, 1, true or false, but now it\'s ' + value);
        }

      case 'storage':
        if (['browser', 'xfile'].indexOf(value) !== -1) {
          return true;
        } else {
          throw new Error('"' + name + '" should be either browser or xfile, but now it\'s ' + value);
        }

      default:
        return true;
    }
  };

  keys.forEach(function (key) {
    if (key.trim().length === 0) {
      return;
    }

    var isValid = validParams.find(function (name) {
      return checkName(name, key);
    });

    if (!isValid) {
      var match = fuzzyObj.get(key);
      var guess = !match || !match[0] || !match[0][1] ? '' : ', do you mean "' + match[0][1] + '"?';
      src_store.dispatch(Object(actions["addLog"])('warning', 'Unknown command line parameter: "' + key + '"' + guess));
    }

    try {
      checkValue(key, args[key]);
    } catch (e) {
      src_store.dispatch(Object(actions["addLog"])('warning', 'Invalid value for cmd line arg: ' + e.message));
    }
  });
};

var src_bindIpcEvent = function bindIpcEvent() {
  var prepareByOptions = function prepareByOptions() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var lowerCaseOptions = Object.keys(options).reduce(function (prev, key) {
      prev[key.toLowerCase()] = options[key];
      return prev;
    }, {});

    if (Object(ts_utils["parseBoolLike"])(lowerCaseOptions.continueinlastusedtab, false)) {
      return ipc_cs["default"].ask('PANEL_CLOSE_CURRENT_TAB_AND_SWITCH_TO_LAST_PLAYED');
    } else {
      return Promise.resolve();
    }
  };

  ipc_cs["default"].onAsk(function (cmd, args) {
    log_default()(cmd, args);

    switch (cmd) {
      case 'PROXY_UPDATE':
        {
          src_store.dispatch(Object(actions["updateProxy"])(args.proxy));
          return true;
        }

      case 'OPEN_SETTINGS':
        src_store.dispatch(Object(actions["updateUI"])({ showSettings: true }));
        return true;

      case 'INSPECT_RESULT':
        src_store.dispatch(Object(actions["doneInspecting"])());
        src_store.dispatch(Object(actions["updateSelectedCommand"])({
          target: args.locatorInfo.target,
          targetOptions: args.locatorInfo.targetOptions
        }));
        return true;

      case 'RECORD_ADD_COMMAND':
        log_default()('got add command', cmd, args);
        var state = src_store.getState();
        var commandCount = Object(recomputed["editorCommandCount"])(state);
        var recordIndex = Object(recomputed["getIndexToInsertRecorded"])(state);
        var shouldSkip = state.recorder.skipOpen && args.cmd === 'open';

        src_store.dispatch(simple_actions["Actions"].toggleRecorderSkipOpen(false));

        if (shouldSkip) {
          return false;
        }

        if (recordIndex > 0 && recordIndex <= commandCount) {
          src_store.dispatch(Object(actions["insertCommand"])(args, recordIndex, true));
        } else {
          src_store.dispatch(Object(actions["appendCommand"])(args, true));
        }

        return true;

      case 'TIMEOUT_STATUS':
        if (src_store.getState().status !== constant["APP_STATUS"].PLAYER) return false;
        if (args.playUID && !Object(common_player["b" /* getPlayer */])().checkPlayUID(args.playUID)) return false;

        src_store.dispatch(Object(actions["setTimeoutStatus"])(args));
        return true;

      case 'RUN_TEST_CASE':
        {
          if (src_store.getState().status !== constant["APP_STATUS"].NORMAL) {
            message_default.a.error('can only run macros when it is not recording or playing');
            return false;
          }

          var testCase = args.testCase,
              options = args.options;


          src_guardCommandLineArgs(options);
          src_initFromCommandLineArgs(options);

          var storageMan = Object(storage["getStorageManager"])();
          var storageMode = testCase.storageMode || storageMan.getCurrentStrategyType();

          storageMan.isStrategyTypeAvailable(storageMode).catch(function (e) {
            message_default.a.error(e.message);
            throw e;
          }).then(function () {
            var needChange = storageMan.setCurrentStrategyType(storageMode);
            src_store.dispatch(Object(actions["updateConfig"])({ storageMode: storageMode }));
            return needChange ? Object(utils["delay"])(function () {
              return reloadResources.onLastReloadFinished();
            }, 100) : undefined;
          }).then(function () {
            return prepareByOptions(options);
          }).then(function () {
            var state = src_store.getState();
            var shouldLoadResources = Object(recomputed["getShouldLoadResources"])(state);

            if (!shouldLoadResources) {
              return Promise.resolve(true);
            }

            return new Promise(function (resolve) {
              resolve(reloadResources.onLastReloadFinished ? reloadResources.onLastReloadFinished() : null);
            }).then(function () {
              return Object(ts_utils["until"])('macros ready', function () {
                var state = src_store.getState();
                var macroNodes = Object(recomputed["getMacroFileNodeList"])(state);

                return {
                  pass: macroNodes && macroNodes.length > 0,
                  result: true
                };
              }, 1000, 20 * 1000);
            });
          }).then(function () {
            // Note: for backward compatibility, still use `name` field (which makes sense in flat fs mode) to store `path`
            // after we migrate to standard folder mode
            var state = src_store.getState();
            var shouldLoadResources = Object(recomputed["getShouldLoadResources"])(state);
            var macroPath = testCase.name;

            if (shouldLoadResources) {
              var found = Object(recomputed["findMacroNodeWithCaseInsensitiveRelativePath"])(state, testCase.name);

              if (!found) {
                throw new Error('Can\'t find macro with name "' + testCase.name + '"');
              }

              macroPath = found.fullPath;
            } else if (lib_path["default"].isAbsolute(macroPath) && Object(storage["getStorageManager"])().isXFileMode()) {
              var msg = ['Absolute path locations like "' + macroPath + '" are not supported yet. ', 'Macro location must be relative to macro root folder (currently "' + Object(xfile["getXFile"])().getCachedConfig().rootDir + '")'].join('');

              throw new Error(msg);
            }

            var errorMsg = 'No macro found with path \'' + macroPath + '\'';

            return storageMan.getMacroStorage().read(macroPath, 'Text').then(function (macro) {
              if (!macro) {
                message_default.a.error(errorMsg);
                throw new Error(errorMsg);
              }

              return macro;
            }, function (e) {
              if (/File size cannot be determined.|A requested file or directory could not be found/.test(e.message)) {
                throw new Error(errorMsg);
              } else {
                return Promise.reject(e);
              }
            }).then(function (tc) {
              var openTc = tc.data.commands.find(function (item) {
                return item.cmd.toLowerCase() === 'open';
              });

              src_prepareBeforeRun(options);

              var callback = src_genPlayerPlayCallback({ options: options });

              src_store.dispatch(Object(actions["editTestCase"])(tc.id));
              src_store.dispatch(Object(actions["playerPlay"])({
                macroId: tc && tc.id,
                title: macroPath,
                extra: {
                  id: tc && tc.id
                },
                mode: common_player["a" /* Player */].C.MODE.STRAIGHT,
                startIndex: 0,
                startUrl: openTc ? openTc.target : null,
                resources: tc.data.commands,
                postDelay: state.player.playInterval * 1000,
                overrideScope: genOverrideScope({ options: options }),
                callback: callback
              })).finally(callback);

              src_store.dispatch(Object(actions["updateUI"])({ sidebarTab: 'macros' }));
            });
          }).catch(function (e) {
            src_store.dispatch(Object(actions["addLog"])('error', e.message));
          });

          return true;
        }

      case 'RUN_TEST_SUITE':
        {
          if (src_store.getState().status !== constant["APP_STATUS"].NORMAL) {
            message_default.a.error('can only run test suites when it is not recording or playing');
            return false;
          }

          var testSuite = args.testSuite,
              _options = args.options;


          src_guardCommandLineArgs(_options);
          src_initFromCommandLineArgs(_options);

          var _storageMode = testSuite.storageMode || storage["StorageStrategyType"].Browser;
          var _storageMan = Object(storage["getStorageManager"])();

          _storageMan.isStrategyTypeAvailable(_storageMode).catch(function (e) {
            message_default.a.error(e.message);
            throw e;
          }).then(function () {
            var needChange = _storageMan.setCurrentStrategyType(_storageMode);
            return needChange ? Object(utils["delay"])(function () {}, 1000) : undefined;
          }).then(function () {
            return prepareByOptions(_options);
          }).then(function () {
            var state = src_store.getState();
            var shouldLoadResources = Object(recomputed["getShouldLoadResources"])(state);

            if (testSuite.macroFolder && testSuite.macroFolder.length > 0) {
              var pMacroNodes = function () {
                if (shouldLoadResources) {
                  return Object(ts_utils["until"])('macros ready', function () {
                    var state = src_store.getState();
                    var macroNodes = Object(recomputed["getMacroFileNodeList"])(state);

                    return {
                      pass: macroNodes && macroNodes.length > 0,
                      result: macroNodes
                    };
                  }, 1000, 20 * 1000).then(function () {
                    var folder = Object(recomputed["findMacroFolderWithCaseInsensitiveRelativePath"])(src_store.getState(), testSuite.macroFolder);
                    return folder && folder.children || [];
                  });
                }

                return _storageMan.getMacroStorage().listR(testSuite.macroFolder).then(function (nodes) {
                  return nodes.filter(function (node) {
                    return node.isFile;
                  });
                });
              }();

              return pMacroNodes.then(function (foundNodes) {
                var macroStorage = _storageMan.getMacroStorage();
                var dirPath = macroStorage.dirPath(testSuite.macroFolder.replace(/\\/g, '/'));
                var path = macroStorage.getPathLib();
                var folderName = path.basename(dirPath);

                if (foundNodes.length === 0) {
                  throw new Error('No folder found for ' + testSuite.macroFolder + ', or no macro found in it');
                }

                src_prepareBeforeRun(_options);

                Object(common_player["b" /* getPlayer */])({ name: 'testSuite' }).play({
                  title: folderName,
                  mode: Object(common_player["b" /* getPlayer */])().C.MODE.STRAIGHT,
                  startIndex: 0,
                  resources: foundNodes.map(function (item) {
                    return {
                      id: item.fullPath,
                      loops: 1
                    };
                  }),
                  extra: {
                    id: dirPath,
                    name: folderName
                  },
                  public: {
                    scope: genOverrideScope({ options: _options })
                  },
                  callback: src_genPlayerPlayCallback({ options: _options })
                });
              });
            }

            if (testSuite.name && testSuite.name.length > 0) {
              var pTestSuite = function () {
                if (shouldLoadResources) {
                  return Object(ts_utils["until"])('testSuites ready', function () {
                    var state = src_store.getState();
                    var testSuites = state.editor.testSuites;


                    return {
                      pass: testSuites && testSuites.length > 0,
                      result: true
                    };
                  }).then(function () {
                    var state = src_store.getState();
                    return Object(actions["findSameNameTestSuite"])(testSuite.name, state.editor.testSuites);
                  });
                }

                return _storageMan.getTestSuiteStorage().read(testSuite.name, 'Text');
              }();

              return pTestSuite.then(function (ts) {
                if (!ts) {
                  message_default.a.error('no macro found with name \'' + testSuite.name + '\'');
                  return false;
                }

                src_prepareBeforeRun(_options);

                Object(common_player["b" /* getPlayer */])({ name: 'testSuite' }).play({
                  title: ts.name,
                  extra: {
                    id: ts.id,
                    name: ts.name
                  },
                  mode: Object(common_player["b" /* getPlayer */])().C.MODE.STRAIGHT,
                  startIndex: 0,
                  resources: ts.cases.map(function (item) {
                    return {
                      id: item.testCaseId,
                      loops: item.loops
                    };
                  }),
                  public: {
                    scope: genOverrideScope({ options: _options })
                  },
                  callback: src_genPlayerPlayCallback({ options: _options })
                });

                return src_store.dispatch(Object(actions["updateUI"])({ sidebarTab: 'test_suites' }));
              });
            }
          }).catch(function (e) {
            src_store.dispatch(Object(actions["addLog"])('error', e.message));
          });

          return true;
        }

      case 'IMPORT_AND_RUN':
        {
          var _options2 = args.options;

          var _testCase = void 0;

          if (args.html) {
            try {
              _testCase = Object(convert_utils["fromHtml"])(args.html);
            } catch (e) {
              message_default.a.error('Failed to parse html', 1.5);
              return false;
            }
          }

          if (args.json) {
            try {
              var jsonStr = typeof args.json === 'string' ? args.json : JSON.stringify(args.json);
              _testCase = Object(convert_utils["fromJSONString"])(jsonStr);
            } catch (e) {
              message_default.a.error('Failed to parse json', 1.5);
              return false;
            }
          }

          if (!_testCase) {
            message_default.a.error('Nothing to import');
            return false;
          }

          src_guardCommandLineArgs(_options2);

          var _storageMode2 = args.storageMode || storage["StorageStrategyType"].Browser;
          var _storageMan2 = Object(storage["getStorageManager"])();

          return _storageMan2.isStrategyTypeAvailable(_storageMode2).catch(function (e) {
            message_default.a.error(e.message);
            throw e;
          }).then(function () {
            var needChange = _storageMan2.setCurrentStrategyType(_storageMode2);
            return needChange ? Object(utils["delay"])(function () {}, 1000) : undefined;
          }).then(function () {
            return prepareByOptions(_options2);
          }).then(function () {
            var state = src_store.getState();
            var shouldLoadResources = Object(recomputed["getShouldLoadResources"])(state);

            if (!shouldLoadResources) {
              return Promise.resolve(true);
            }

            return new Promise(function (resolve) {
              resolve(reloadResources.onLastReloadFinished ? reloadResources.onLastReloadFinished() : null);
            }).then(function () {
              return Object(ts_utils["until"])('macros ready', function () {
                var state = src_store.getState();
                var macroNodes = Object(recomputed["getMacroFileNodeList"])(state);

                return {
                  pass: macroNodes && macroNodes.length > 0,
                  result: true
                };
              }, 1000, 20 * 1000);
            });
          }).then(function () {
            return src_store.dispatch(Object(actions["upsertTestCase"])(_testCase)).then(function () {
              return src_store.dispatch(Object(actions["editTestCase"])(_testCase.name));
            }).then(function (macro) {
              var state = src_store.getState();
              var openTc = macro.data.commands.find(function (command) {
                return command.cmd.toLowerCase() === 'open';
              });

              src_store.dispatch(Object(actions["playerPlay"])({
                macroId: macro.id,
                title: macro.name,
                extra: {
                  id: macro.id
                },
                mode: common_player["a" /* Player */].C.MODE.STRAIGHT,
                startIndex: 0,
                startUrl: openTc ? openTc.target : null,
                resources: macro.data.commands,
                postDelay: state.player.playInterval * 1000,
                overrideScope: genOverrideScope({ options: _options2 }),
                callback: src_genPlayerPlayCallback({ options: _options2 })
              }));
              return true;
            }).catch(function (e) {
              log_default.a.error(e.stack);
              throw e;
            });
          });
        }

      case 'ADD_VISION_IMAGE':
        {
          var dataUrl = args.dataUrl,
              _args$requireRename = args.requireRename,
              requireRename = _args$requireRename === undefined ? false : _args$requireRename;

          var fileName = Object(utils["randomName"])() + '_dpi_' + Object(utils["getScreenDpi"])() + '.png';

          return Object(storage["getStorageManager"])().getVisionStorage().write(fileName, Object(utils["dataURItoBlob"])(dataUrl)).then(src_restoreVisions).then(function () {
            if (!requireRename) return { fileName: fileName };

            return src_store.dispatch(Object(actions["renameVisionImage"])(fileName)).then(function (fileName) {
              src_restoreVisions();
              return { fileName: fileName };
            });
          });
        }

      case 'RESTORE_SCREENSHOTS':
        {
          src_restoreScreenshots();
          return true;
        }

      case 'UPDATE_ACTIVE_TAB':
        {
          src_updatePageTitle(args);
          return true;
        }

      case 'ADD_LOG':
        {
          if (!args) return false;
          if (args.info) src_store.dispatch(Object(actions["addLog"])('info', args.info, args.options));
          if (args.warning) src_store.dispatch(Object(actions["addLog"])('warning', args.warning));
          if (args.error) src_store.dispatch(Object(actions["addLog"])('error', args.error));

          return true;
        }
    }
  });
};

var src_bindWindowEvents = function bindWindowEvents() {
  // reset status to normal when panel closed
  window.addEventListener('beforeunload', function () {
    ipc_cs["default"].ask('PANEL_STOP_RECORDING', {});
    ipc_cs["default"].ask('PANEL_STOP_PLAYING', {});
  });

  window.addEventListener('resize', function () {
    var size = {
      width: window.outerWidth,
      height: window.outerHeight
    };
    var state = src_store.getState();
    src_store.dispatch(Object(actions["updateConfig"])({
      size: src_extends({}, state.config.size, src_defineProperty({}, state.config.showSidebar ? 'with_sidebar' : 'standard', size))
    }));
  });

  window.addEventListener('message', function (e) {
    switch (e.data && e.data.type) {
      case 'RELOAD_VISIONS':
        return src_store.dispatch(Object(actions["listVisions"])());
    }
  });
};

var src_bindVariableChange = function bindVariableChange() {
  // Note: bind to onChange in next tick, to make sure vars instance is already initialized
  // so that `bindVariableChange` could be executed before `initPlayer`
  setTimeout(function () {
    getVarsInstance().onChange(function (_ref3) {
      var vars = _ref3.vars;

      var variables = Object.keys(vars).map(function (key) {
        return { key: key, value: vars[key] };
      });
      src_store.dispatch(Object(actions["setVariables"])(variables));
    });
  }, 0);
};

var src_initSaveTestCase = function initSaveTestCase() {
  Object(save_test_case["default"])(src_store);
};

var src_updatePageTitle = function updatePageTitle(args) {
  // Note: Firefox includes page url in title, there could be not enough space for tab title
  if (web_extension_default.a.isFirefox()) return true;
  var origTitle = document.title.replace(/ - .*$/, '');
  document.title = origTitle + ' - (Tab: ' + args.title + ')';
};

function tryPreinstall() {
  return common_storage["default"].get('preinstall_info').then(function (info) {
    var status = function () {
      if (!info) return 'fresh';

      var _info$askedVersions = info.askedVersions,
          askedVersions = _info$askedVersions === undefined ? [] : _info$askedVersions;

      if (askedVersions.indexOf(config_default.a.preinstall.version) === -1) return 'new_version_available';

      return 'up_to_date';
    }();

    switch (status) {
      case 'fresh':
        return src_store.dispatch(Object(actions["preinstall"])());

      case 'new_version_available':
        return src_store.dispatch(Object(actions["updateUI"])({ newPreinstallVersion: true }));

      case 'up_to_date':
      default:
        return false;
    }
  });
}

function reloadResources() {
  var p = src_bindMacroAndTestSuites().then(function () {
    return Object(ts_utils["flow"])(Object(ts_utils["guardVoidPromise"])(src_restoreCSV), Object(ts_utils["guardVoidPromise"])(src_restoreVisions), Object(ts_utils["guardVoidPromise"])(src_restoreScreenshots), Object(ts_utils["guardVoidPromise"])(function () {
      return src_store.dispatch(Object(actions["resetEditingIfNeeded"])());
    }));
  });

  reloadResources.onLastReloadFinished = function (callback) {
    return callback ? p.then(callback) : p;
  };
  return p;
}

function checkXFileVersion() {
  return Object(xfile["getXFile"])().getVersion().then(function (versionInfo) {
    if (!versionInfo.version) {
      return;
    }

    if (semver_default.a.lt(versionInfo.version, config_default.a.xfile.minVersionToReadBigFile)) {
      var msg = 'Can not read/save screenshot on hard-drive. Please upgrade FileAccess XModule to latest version (>= ' + config_default.a.xfile.minVersionToReadBigFile + ').';

      message_default.a.warn(msg);
      src_store.dispatch(Object(actions["addLog"])('warning', msg));
    }
  });
}

function bindStorageModeChanged() {
  var first = true;

  Object(storage["getStorageManager"])().on(storage["StorageManagerEvent"].StrategyTypeChanged, function (type) {
    if (first) {
      first = false;
      return;
    }

    try {
      var p = function () {
        if (type === storage["StorageStrategyType"].XFile) {
          return checkXFileVersion();
        }

        return Promise.resolve();
      }();

      p.then(reloadResources).then(function () {
        src_store.dispatch(simple_actions["Actions"].selectInitialMacro(type));
      });
    } catch (e) {
      log_default.a.warn(e);
    }
  });

  Object(storage["getStorageManager"])().on(storage["StorageManagerEvent"].RootDirChanged, function (type) {
    reloadResources();
  });

  Object(storage["getStorageManager"])().on(storage["StorageManagerEvent"].ForceReload, function (type) {
    reloadResources();
  });
}

function remedyMigrationIfNeeded() {
  var todo = [];
  var shouldRemedyMacroFsMigration = Object(_2019_04_01_macro_suite_storage["getMigrateMacroTestSuiteToBrowserFileSystem"])().shouldMigrate() && !Object(migration["getKantuMigrationService"])().isMigrated(migration_types["MigrationJobType"].MigrateMacroTestSuiteToBrowserFileSystem);

  if (shouldRemedyMacroFsMigration || config_default.a.forceMigrationRemedy) {
    alert('Kantu introduced an internal storage migration in this version. It isn\'t supposed to disturb you, but looks like there is some unexpected error: \n\n=> Solution: After you click OK Kantu is going to download your macros and test suites from the old storage into a ZIP file. You can then manually import the macros back into the new Kantu version.\n\nIf you see this dialog, please also inform us at team@a9t9.com or in the user forum about the issue.');
    todo.push(function () {
      return Object(_2019_04_01_macro_suite_storage["getMigrateMacroTestSuiteToBrowserFileSystem"])().remedy();
    });
  }

  return ts_utils["flow"].apply(undefined, todo);
}

function initFromQuery() {
  var queries = Object(utils["parseQuery"])(window.location.search);

  src_store.dispatch(simple_actions["Actions"].setFrom(queries.from || reducers_state["RunBy"].Manual));

  if (queries.settings) {
    src_store.dispatch(Object(actions["updateUI"])({
      showSettings: true
    }));
  }
}

function initProxyState() {
  ipc_cs["default"].ask('PANEL_GET_PROXY').then(function (proxy) {
    src_store.dispatch(Object(actions["updateProxy"])(proxy));
  });
}

function init() {
  initFromQuery();
  src_bindIpcEvent();
  src_bindWindowEvents();
  src_bindVariableChange();
  bindStorageModeChanged();
  init_player_initPlayer(src_store);
  src_restoreEditing();
  src_restoreConfig();
  src_initSaveTestCase();
  initProxyState();

  tryPreinstall().catch(function (e) {
    log_default.a.warn('Error in preinstall', e);
  }).then(function () {
    reloadResources();
  });

  setTimeout(function () {
    remedyMigrationIfNeeded();
  }, 1000);

  ipc_cs["default"].ask('I_AM_PANEL', {});

  document.title = document.title + ' ' + web_extension_default.a.runtime.getManifest().version;

  ipc_cs["default"].ask('PANEL_CURRENT_PLAY_TAB_INFO').then(src_updatePageTitle);

  src_render(src_app);
}

Promise.all([src_restoreConfig(), Object(xfile["getXFile"])().getConfig(), Object(services_license["getLicenseService"])().getLatestInfo()]).then(function (_ref4) {
  var _ref5 = src_slicedToArray(_ref4, 2),
      config = _ref5[0],
      xFileConfig = _ref5[1];

  // Note: This is the first call of getStorageManager
  // and it must passed in `getMacros` to make test suite work
  Object(storage["getStorageManager"])(config.storageMode, {
    getConfig: function getConfig() {
      return src_store.getState().config;
    },
    getMacros: function getMacros() {
      return Object(recomputed["getMacroFileNodeList"])(src_store.getState());
    },
    getMaxMacroCount: function getMaxMacroCount(strategyType) {
      var count = function () {
        switch (strategyType) {
          case storage["StorageStrategyType"].XFile:
            return Object(services_license["getLicenseService"])().getMaxXFileMacros();

          case storage["StorageStrategyType"].Browser:
          default:
            return Infinity;
        }
      }();

      return Promise.resolve(count);
    }
  });

  init();
}, init);

/***/ }),

/***/ 112:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var OCRExitCode;
(function (OCRExitCode) {
    OCRExitCode[OCRExitCode["AllParsed"] = 1] = "AllParsed";
    OCRExitCode[OCRExitCode["PartiallyParsed"] = 2] = "PartiallyParsed";
    OCRExitCode[OCRExitCode["Failed"] = 3] = "Failed";
    OCRExitCode[OCRExitCode["Fatal"] = 4] = "Fatal";
})(OCRExitCode = exports.OCRExitCode || (exports.OCRExitCode = {}));
var FileParseExitCode;
(function (FileParseExitCode) {
    FileParseExitCode[FileParseExitCode["FileNotFound"] = 0] = "FileNotFound";
    FileParseExitCode[FileParseExitCode["Success"] = 1] = "Success";
    FileParseExitCode[FileParseExitCode["ParseError"] = -10] = "ParseError";
    FileParseExitCode[FileParseExitCode["Timeout"] = -20] = "Timeout";
    FileParseExitCode[FileParseExitCode["ValidationError"] = -30] = "ValidationError";
    FileParseExitCode[FileParseExitCode["UnknownError"] = -99] = "UnknownError";
})(FileParseExitCode = exports.FileParseExitCode || (exports.FileParseExitCode = {}));
var OcrHighlightType;
(function (OcrHighlightType) {
    OcrHighlightType[OcrHighlightType["Identified"] = 0] = "Identified";
    OcrHighlightType[OcrHighlightType["Matched"] = 1] = "Matched";
    OcrHighlightType[OcrHighlightType["TopMatched"] = 2] = "TopMatched";
})(OcrHighlightType = exports.OcrHighlightType || (exports.OcrHighlightType = {}));


/***/ }),

/***/ 114:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return normalizeCommand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return normalizeTestCase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return commandWithoutBaseUrl; });
/* unused harmony export eliminateBaseUrl */
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _common_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var _common_ts_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_common_ts_utils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92);
/* harmony import */ var _common_command__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
/* harmony import */ var _common_command__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_common_command__WEBPACK_IMPORTED_MODULE_3__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };






var model = {
  table: _db__WEBPACK_IMPORTED_MODULE_2__["default"].testCases,
  list: function list() {
    return _db__WEBPACK_IMPORTED_MODULE_2__["default"].testCases.toArray();
  },
  insert: function insert(data) {
    if (!data.name) {
      throw new Error('Model TestCase - insert: missing name');
    }

    if (!data.data) {
      throw new Error('Model TestCase - insert: missing data');
    }

    data.updateTime = new Date() * 1;
    data.id = Object(_common_utils__WEBPACK_IMPORTED_MODULE_0__["uid"])();
    return _db__WEBPACK_IMPORTED_MODULE_2__["default"].testCases.add(normalizeTestCase(data));
  },
  bulkInsert: function bulkInsert(tcs) {
    var list = tcs.map(function (data) {
      if (!data.name) {
        throw new Error('Model TestCase - insert: missing name');
      }

      if (!data.data) {
        throw new Error('Model TestCase - insert: missing data');
      }

      data.updateTime = new Date() * 1;
      data.id = Object(_common_utils__WEBPACK_IMPORTED_MODULE_0__["uid"])();

      return normalizeTestCase(data);
    });

    return _db__WEBPACK_IMPORTED_MODULE_2__["default"].testCases.bulkAdd(list);
  },
  update: function update(id, data) {
    return _db__WEBPACK_IMPORTED_MODULE_2__["default"].testCases.update(id, normalizeTestCase(data));
  },
  remove: function remove(id) {
    return _db__WEBPACK_IMPORTED_MODULE_2__["default"].testCases.delete(id);
  }
};

/* unused harmony default export */ var _unused_webpack_default_export = (model);

var normalizeCommand = function normalizeCommand(command) {
  var result = Object(_common_ts_utils__WEBPACK_IMPORTED_MODULE_1__["pickIfExist"])(['cmd', 'target', 'value', 'targetOptions', 'description'], command);

  if (!Object(_common_command__WEBPACK_IMPORTED_MODULE_3__["doesCommandSupportTargetOptions"])(result.cmd)) {
    delete result.targetOptions;
  }

  return result;
};

var normalizeTestCase = function normalizeTestCase(testCase) {
  var intermediate = Object(_common_utils__WEBPACK_IMPORTED_MODULE_0__["compose"])(Object(_common_utils__WEBPACK_IMPORTED_MODULE_0__["on"])('data'), Object(_common_utils__WEBPACK_IMPORTED_MODULE_0__["on"])('commands'), _common_utils__WEBPACK_IMPORTED_MODULE_0__["map"])(normalizeCommand)(testCase);

  return Object(_common_ts_utils__WEBPACK_IMPORTED_MODULE_1__["pickIfExist"])(['id', 'data', 'name', 'path'], intermediate);
};

var commandWithoutBaseUrl = function commandWithoutBaseUrl(baseUrl) {
  return function (command) {
    if (command.cmd !== 'open') return command;

    return _extends({}, command, {
      target: (baseUrl + '/' + command.target).replace(/\/+/g, '/')
    });
  };
};

var eliminateBaseUrl = function eliminateBaseUrl(testCase) {
  if (!testCase.baseUrl) return testCase;
  return Object(_common_utils__WEBPACK_IMPORTED_MODULE_0__["compose"])(Object(_common_utils__WEBPACK_IMPORTED_MODULE_0__["on"])('data'), Object(_common_utils__WEBPACK_IMPORTED_MODULE_0__["on"])('commands'), _common_utils__WEBPACK_IMPORTED_MODULE_0__["map"])(commandWithoutBaseUrl(testCase.baseUrl))(testCase);
};

/***/ }),

/***/ 115:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = __webpack_require__(402);
const stack_1 = __webpack_require__(976);
const macro_1 = __webpack_require__(191);
const ts_utils_1 = __webpack_require__(12);
const registry_1 = __webpack_require__(184);
class CallStack extends stack_1.Stack {
    constructor(options) {
        super();
        this.opts = options;
        this.registry = registry_1.createListenerRegistry();
    }
    on(eventName, listener) {
        this.registry.add(eventName, listener);
        return () => this.registry.remove(eventName, listener);
    }
    off() {
        this.registry.destroy();
    }
    call(resource, runningStatus) {
        if (!this.isEmpty()) {
            this.updatePeek((element) => {
                return {
                    id: element.id,
                    resource: element.resource,
                    runningStatus: Object.assign(Object.assign({}, this.opts.updateRunningStatusForCaller(element.runningStatus, element.resource)), { status: macro_1.MacroStatus.Calling })
                };
            });
        }
        this.push({
            resource,
            id: ts_utils_1.uid(),
            runningStatus: runningStatus || this.opts.getInitialRunningStatus(resource)
        });
        this.registry.fire(types_1.CallStackEvent.BeforeRun, this.callStackSnapshot());
        return this.runPeek();
    }
    runPeek(isResume = false) {
        return this.opts.prepareContext(this.peek(), this.getFrameStatus(this.peek(), isResume))
            .then(() => {
            const item = this.peek();
            return this.opts.run(item, this.getFrameStatus(item, isResume))
                .then(() => {
                const snapshot = this.callStackSnapshot();
                const latestFrameId = this.opts.getLatestFrameIdFromSnapshot(snapshot);
                // FIXME: There is a kind of design error here. This callback after runPeek could be run twice
                // for a single macro.
                //
                // For exmaple, Run A => A calls B => B returns to A => A continues
                // 1) Run A: runPeek is called for A for first time
                // 2) A calls B: runPeek is called for B for first time
                // 3) B returns to A: The call to runPeek below is run, so runPeek is called for A for second time
                //
                // As a temporary fix, I have to check if snapshot's last element is the same as the one being run
                if (latestFrameId !== item.id) {
                    return;
                }
                this.registry.fire(types_1.CallStackEvent.AfterReturn, snapshot);
                this.pop();
                if (this.isEmpty()) {
                    return;
                }
                this.updatePeekAfterResume();
                this.registry.fire(types_1.CallStackEvent.BeforeResume, this.callStackSnapshot());
                return this.runPeek(true);
            });
        });
    }
    updatePeek(updater) {
        this.guardNotEmpty();
        const index = this.getCount() - 1;
        this.list[index] = updater(this.list[index]);
    }
    getFrameStatus(element, isResume) {
        return {
            isResume,
            isBottom: this.getCount() === 1,
            frameId: element.id
        };
    }
    updatePeekAfterResume() {
        this.updatePeek((element) => {
            return element;
        });
    }
    callStackSnapshot() {
        return this.list.map((item) => item.resource);
    }
}
exports.CallStack = CallStack;
class MacroCallStack extends CallStack {
    isAtBottom() {
        return this.getCount() === 1;
    }
    callStackSnapshot() {
        return this.list.map((item) => ({
            id: item.resource.id,
            name: item.resource.name,
            frameId: item.id
        }));
    }
    updatePeekAfterResume() {
        this.updatePeek((element) => {
            const curIndex = element.runningStatus.nextIndex;
            const nextIndex = curIndex + 1;
            const commandResults = [...element.runningStatus.commandResults];
            commandResults[curIndex] = macro_1.CommandRunningStatus.Success;
            return {
                id: element.id,
                resource: element.resource,
                runningStatus: {
                    nextIndex,
                    commandResults,
                    status: macro_1.MacroStatus.Running,
                    playerState: Object.assign(Object.assign({}, element.runningStatus.playerState), { nextIndex, doneIndices: [
                            ...element.runningStatus.playerState.doneIndices,
                            curIndex
                        ] }),
                    interpreterState: element.runningStatus.interpreterState
                }
            };
        });
    }
}
exports.MacroCallStack = MacroCallStack;
exports.getMacroCallStack = ts_utils_1.singletonGetter((callStackOptions) => {
    if (!callStackOptions) {
        throw new Error('macro call stack options is required');
    }
    return new MacroCallStack(callStackOptions);
});
function createMacroCallStack(options) {
    return exports.getMacroCallStack({
        getInitialRunningStatus: (macro) => ({
            nextIndex: 0,
            status: macro_1.MacroStatus.Running,
            commandResults: [],
            playerState: {},
            interpreterState: {}
        }),
        getLatestFrameIdFromSnapshot: (snapshot) => {
            const last = snapshot[snapshot.length - 1];
            return last ? last.frameId : null;
        },
        updateRunningStatusForCaller: (runningStatus, macro) => {
            return options.getCurrentMacroRunningStatus();
        },
        prepareContext: (resourceAndStatus, frameStatus) => {
            const macro = resourceAndStatus.resource;
            const status = resourceAndStatus.runningStatus;
            return ts_utils_1.withPromise(() => options.updateSelectedMacro(macro, status, frameStatus))
                .then(() => ts_utils_1.withPromise(() => options.restorePlayerState(macro, status, frameStatus)));
        },
        run: (resourceAndStatus, frameStatus) => {
            // Steps
            // * Update selected macro
            // * Restore commandResults
            // * Restore tcPlayer state
            // * Start to play
            const macro = resourceAndStatus.resource;
            const status = resourceAndStatus.runningStatus;
            return ts_utils_1.withPromise(() => options.playMacro(macro, status, frameStatus));
        }
    });
}
exports.createMacroCallStack = createMacroCallStack;


/***/ }),

/***/ 118:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const log_1 = __importDefault(__webpack_require__(11));
const oldSetTimeout = window.setTimeout;
const oldClearTimeout = window.clearTimeout;
const oldSetInterval = window.setInterval;
const oldClearInterval = window.clearInterval;
function uid() {
    return Math.floor(Math.random() * 1e8);
}
function polyfillTimeoutFunctions(csIpc) {
    const timeoutRecords = {};
    function createSetTimeoutViaBackground(identity) {
        const id = identity !== null && identity !== void 0 ? identity : uid();
        return function setTimeoutViaBackground(fn, timeout = 0, ...args) {
            timeoutRecords[id] = true;
            csIpc.ask('TIMEOUT', { id, timeout }).then((identity) => {
                if (!timeoutRecords[identity]) {
                    return;
                }
                fn(...args);
            })
                .catch((e) => {
                log_1.default.error('Error in setTimeout', e.stack);
            });
            return id;
        };
    }
    function clearTimeoutViaBackground(id) {
        delete timeoutRecords[id];
    }
    // Call both native setTimeout and setTimeoutViaBackground
    // and take the first one resolved
    function smartSetTimeout(fn, timeout = 0, ...args) {
        let done = false;
        const wrappedFn = (...args) => {
            if (done) {
                return null;
            }
            done = true;
            return fn(...args);
        };
        const id = oldSetTimeout(wrappedFn, timeout, ...args);
        createSetTimeoutViaBackground(id)(wrappedFn, timeout, ...args);
        return id;
    }
    const intervalRecords = {};
    function smartSetInterval(fn, timeout = 0, ...args) {
        const id = uid();
        const wrappedFn = () => {
            if (!intervalRecords[id]) {
                return;
            }
            smartSetTimeout(wrappedFn, timeout);
            fn(...args);
        };
        intervalRecords[id] = true;
        smartSetTimeout(wrappedFn, timeout);
        return id;
    }
    function clearIntervalViaBackground(id) {
        delete intervalRecords[id];
    }
    const runBoth = (f1, f2) => {
        return (...args) => {
            f1(...args);
            f2(...args);
        };
    };
    window.setTimeout = smartSetTimeout;
    window.clearTimeout = runBoth(clearTimeoutViaBackground, oldClearTimeout);
    window.setInterval = smartSetInterval;
    window.clearInterval = clearIntervalViaBackground;
}
exports.polyfillTimeoutFunctions = polyfillTimeoutFunctions;


/***/ }),

/***/ 119:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DownloadMan */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getDownloadMan; });
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_web_extension__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_log__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }





var DownloadMan = function () {
  function DownloadMan() {
    var _this = this;

    _classCallCheck(this, DownloadMan);

    this.activeDownloads = [];
    this.eventsBound = false;

    this.filterActiveDownloads = function (predicate) {
      _this.activeDownloads = _this.activeDownloads.filter(predicate);

      if (_this.activeDownloads.length === 0) {
        _this.unbindEvents();
      }
    };

    this.createdListener = function (downloadItem) {
      if (!_this.isActive()) return;
      _log__WEBPACK_IMPORTED_MODULE_1___default()('download on created', downloadItem);

      var item = _this.activeDownloads.find(function (item) {
        return !item.id;
      });
      if (!item) return;

      // Note: 3 things to do on download created
      // 1. record download id
      // 2. Start timer for timeout
      // 3. Start interval timer for count down message
      _extends(item, _extends({
        id: downloadItem.id
      }, !item.wait && item.timeout > 0 ? {} : {
        timeoutTimer: setTimeout(function () {
          item.reject(new Error('download timeout ' + item.timeout / 1000 + 's'));
          _this.filterActiveDownloads(function (d) {
            return item.uid !== d.uid;
          });
        }, item.timeout),

        countDownTimer: setInterval(function () {
          if (!_this.countDownHandler) return;

          var _item$past = item.past,
              past = _item$past === undefined ? 0 : _item$past;

          var newPast = past + 1000;

          _this.countDownHandler({
            total: item.timeout,
            past: newPast
          });
          _extends(item, { past: newPast });
        }, 1000)
      }));
    };

    this.changedListener = function (downloadDelta) {
      if (!_this.isActive()) return;
      _log__WEBPACK_IMPORTED_MODULE_1___default()('download on changed', downloadDelta);

      var item = _this.findById(downloadDelta.id);
      if (!item) return;

      if (downloadDelta.state) {
        var fn = function fn() {};
        var done = false;

        switch (downloadDelta.state.current) {
          case 'complete':
            fn = function fn() {
              return item.resolve(true);
            };
            done = true;

            if (_this.completeHandler) {
              _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.downloads.search({ id: item.id }).then(function (_ref) {
                var _ref2 = _slicedToArray(_ref, 1),
                    downloadItem = _ref2[0];

                if (downloadItem) {
                  _this.completeHandler(downloadItem);
                }
              });
            }
            break;

          case 'interrupted':
            fn = function fn() {
              return item.reject(new Error('download interrupted'));
            };
            done = true;
            break;
        }

        // Remove this download item from our todo list if it's done
        if (done) {
          clearTimeout(item.timeoutTimer);
          clearInterval(item.countDownTimer);
          _this.filterActiveDownloads(function (item) {
            return item.id !== downloadDelta.id;
          });
        }

        // resolve or reject that promise object
        fn();
      }
    };

    this.determineFileNameListener = function (downloadItem, suggest) {
      if (!_this.isActive()) return;

      _log__WEBPACK_IMPORTED_MODULE_1___default()('download on determine', downloadItem);

      var item = _this.findById(downloadItem.id);
      if (!item) return;

      var tmpName = item.fileName.trim();
      var fileName = tmpName === '' || tmpName === '*' ? null : tmpName;

      if (fileName) {
        return suggest({
          filename: fileName,
          conflictAction: 'uniquify'
        });
      }
    };
  }

  _createClass(DownloadMan, [{
    key: 'isActive',


    /*
     * Private methods
     */

    value: function isActive() {
      return this.activeDownloads.length > 0;
    }
  }, {
    key: 'findById',
    value: function findById(id) {
      return this.activeDownloads.find(function (item) {
        return item.id === id;
      });
    }
  }, {
    key: 'bindEvents',
    value: function bindEvents() {
      if (this.eventsBound) return;

      _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.downloads.onCreated.addListener(this.createdListener);
      _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.downloads.onChanged.addListener(this.changedListener);

      // Note: only chrome supports api `chrome.downloads.onDeterminingFilename`
      if (_web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.downloads.onDeterminingFilename) {
        _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.downloads.onDeterminingFilename.addListener(this.determineFileNameListener);
      }

      this.eventsBound = true;
    }
  }, {
    key: 'unbindEvents',
    value: function unbindEvents() {
      if (!this.eventsBound) return;

      if (_web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.downloads.onCreated.removeListener) {
        _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.downloads.onCreated.removeListener(this.createdListener);
      }

      if (_web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.downloads.onChanged.removeListener) {
        _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.downloads.onChanged.removeListener(this.changedListener);
      }

      if (_web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.downloads.onDeterminingFilename && _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.downloads.onDeterminingFilename.removeListener) {
        _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.downloads.onDeterminingFilename.removeListener(this.determineFileNameListener);
      }

      this.eventsBound = false;
    }

    /*
     * Public methods
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.activeDownloads.forEach(function (item) {
        if (item.timeoutTimer) clearTimeout(item.timeoutTimer);
        if (item.countDownTimer) clearInterval(item.countDownTimer);
      });
      this.activeDownloads = [];
      this.unbindEvents();
    }
  }, {
    key: 'prepareDownload',
    value: function prepareDownload(fileName) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var downloadToCreate = this.activeDownloads.find(function (item) {
        return !item.id;
      });
      if (downloadToCreate) throw new Error('only one not-created download allowed at a time');

      this.bindEvents();

      var opts = _extends({
        timeoutForStart: 10000,
        timeout: 60000,
        wait: false
      }, options);

      var promise = new Promise(function (resolve, reject) {
        var uid = Math.floor(Math.random() * 1000) + new Date() * 1;

        // Note: we need to cache promise object, so have to wait for next tick
        setTimeout(function () {
          _this2.activeDownloads.push({
            uid: uid,
            resolve: resolve,
            reject: reject,
            fileName: fileName,
            promise: promise,
            timeoutForStart: opts.timeoutForStart,
            timeout: opts.timeout,
            wait: opts.wait
          });
        }, 0);
      });

      return promise;
    }
  }, {
    key: 'waitForDownloadIfAny',
    value: function waitForDownloadIfAny() {
      var _this3 = this;

      var downloadToCreate = this.activeDownloads.find(function (item) {
        return !item.id;
      });
      if (downloadToCreate) {
        return Object(_utils__WEBPACK_IMPORTED_MODULE_2__["until"])('download start', function () {
          return {
            pass: !!downloadToCreate.id,
            result: true
          };
        }, 50, downloadToCreate.timeoutForStart).then(function () {
          return _this3.waitForDownloadIfAny();
        });
      }

      // Note: check if id exists, because it means this download item is created
      var downloadToComplete = this.activeDownloads.find(function (item) {
        return item.wait && item.id;
      });
      if (!downloadToComplete) return Promise.resolve(true);
      return downloadToComplete.promise.then(function () {
        return _this3.waitForDownloadIfAny();
      });
    }
  }, {
    key: 'onCountDown',
    value: function onCountDown(fn) {
      this.countDownHandler = fn;
    }
  }, {
    key: 'onDownloadComplete',
    value: function onDownloadComplete(fn) {
      this.completeHandler = fn;
    }
  }, {
    key: 'hasPendingDownload',
    value: function hasPendingDownload() {
      var downloadToCreate = this.activeDownloads.find(function (item) {
        return !item.id;
      });
      return !!downloadToCreate;
    }
  }]);

  return DownloadMan;
}();

var getDownloadMan = function () {
  var instance = void 0;

  return function () {
    if (!instance) {
      instance = new DownloadMan();
    }

    return instance;
  };
}();

/***/ }),

/***/ 121:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const standard_storage_1 = __webpack_require__(89);
const filesystem_1 = __importDefault(__webpack_require__(107));
const path_1 = __webpack_require__(27);
const utils_1 = __webpack_require__(4);
const dom_utils_1 = __webpack_require__(22);
const web_extension_1 = __importDefault(__webpack_require__(10));
const ts_utils_1 = __webpack_require__(12);
class BrowserFileSystemStandardStorage extends standard_storage_1.StandardStorage {
    constructor(opts) {
        super({
            encode: opts.encode,
            decode: opts.decode
        });
        this.transformFileName = (path) => path;
        const { extensions, shouldKeepExt, transformFileName, baseDir = 'share' } = opts;
        if (!baseDir || baseDir === '/') {
            throw new Error(`Invalid baseDir, ${baseDir}`);
        }
        if (transformFileName) {
            this.transformFileName = transformFileName;
        }
        this.baseDir = baseDir;
        this.extensions = extensions;
        this.shouldKeepExt = shouldKeepExt;
        // Note: create the folder in which we will store files
        filesystem_1.default.getDirectory(baseDir, true);
    }
    getLink(filePath) {
        if (!dom_utils_1.isFirefox()) {
            const tmp = web_extension_1.default.extension.getURL('temporary');
            const link = `filesystem:${tmp}/${this.filePath(filePath)}`;
            return Promise.resolve(link + '?' + new Date().getTime());
        }
        else {
            // Note: Except for Chrome, the filesystem API we use is a polyfill from idb.filesystem.js
            // idb.filesystem.js works great but the only problem is that you can't use 'filesystem:' schema to retrieve that file
            // so here, we have to convert the file to data url
            return this.read(filePath, 'DataURL');
        }
    }
    read(filePath, type) {
        const fullPath = this.filePath(filePath);
        const relativePath = path_1.posix.relative(this.dirPath('/'), fullPath);
        return filesystem_1.default.readFile(fullPath, type)
            .then(intermediate => this.decode(intermediate, relativePath, type), error => {
            if (error.message.indexOf("A requested file or directory could not be found") !== -1) {
                throw new Error(`File not found: ${filePath}`);
            }
            return Promise.reject(error);
        });
    }
    stat(entryPath, isDir) {
        const name = path_1.posix.basename(entryPath);
        const dir = path_1.posix.dirname(entryPath);
        const fullPath = isDir ? this.dirPath(entryPath) : this.filePath(entryPath);
        const relativePath = path_1.posix.relative(this.dirPath('/'), fullPath);
        return filesystem_1.default.existsStat(fullPath)
            .then(({ isFile, isDirectory }) => {
            // Note: idb.filesystem.js (we use it as polyfill for firefox) doesn't support getMetadata on folder yet
            // so we simply set size/lastModified to empty value for now.
            if (!isFile) {
                return {
                    dir,
                    name,
                    fullPath,
                    relativePath,
                    isFile,
                    isDirectory,
                    size: 0,
                    lastModified: new Date(0)
                };
            }
            return filesystem_1.default.getMetadata(fullPath, isDirectory)
                .then((meta) => {
                return {
                    dir,
                    name,
                    fullPath,
                    relativePath,
                    isFile,
                    isDirectory,
                    size: meta.size,
                    lastModified: meta.modificationTime
                };
            });
        });
    }
    __list(directoryPath = '/', brief = false) {
        // TODO: Ignore brief param for browser fs for now
        const convertName = (entryName, isDirectory) => {
            return this.shouldKeepExt || isDirectory ? entryName : this.removeExt(entryName);
        };
        return this.ensureBaseDir()
            .then(() => filesystem_1.default.list(this.dirPath(directoryPath)))
            .then(fileEntries => {
            const ps = fileEntries.map(fileEntry => {
                return this.stat(fileEntry.fullPath, fileEntry.isDirectory)
                    .then((stat) => (Object.assign(Object.assign({}, stat), { name: this.transformFileName(convertName(stat.name, fileEntry.isDirectory)) })));
            });
            return Promise.all(ps)
                .then(list => {
                list.sort((a, b) => {
                    if (a.name < b.name)
                        return -1;
                    if (a.name > b.name)
                        return 1;
                    return 0;
                });
                this.totalCount = list.length;
                this.displayedCount = list.length;
                return list;
            });
        });
    }
    __write(filePath, content) {
        return this.ensureBaseDir()
            .then(() => this.remove(filePath))
            .catch(() => { })
            .then(() => this.encode(content, filePath))
            .then((encodedContent) => filesystem_1.default.writeFile(this.filePath(filePath, true), encodedContent))
            .then(() => { });
    }
    __overwrite(filePath, content) {
        return this.__write(filePath, content);
    }
    __removeFile(filePath) {
        return filesystem_1.default.removeFile(this.filePath(filePath));
    }
    __removeEmptyDirectory(directoryPath) {
        return filesystem_1.default.rmdir(this.dirPath(directoryPath));
    }
    __moveFile(filePath, newPath) {
        return filesystem_1.default.moveFile(this.filePath(filePath), this.filePath(newPath, true))
            .then(() => { });
    }
    __copyFile(filePath, newPath) {
        return filesystem_1.default.copyFile(this.filePath(filePath), this.filePath(newPath, true))
            .then(() => { });
    }
    __createDirectory(directoryPath) {
        return filesystem_1.default.getDirectory(this.dirPath(directoryPath, true), true)
            .then(() => { });
    }
    dirPath(dir, shouldSanitize = false) {
        const path = this.getPathLib();
        const absPath = (() => {
            if (this.isStartWithBaseDir(dir)) {
                return dir;
            }
            else {
                return path.join('/', this.baseDir, dir);
            }
        })();
        const dirName = path.dirname(absPath);
        const baseName = path.basename(absPath);
        const sanitized = shouldSanitize ? utils_1.sanitizeFileName(baseName) : baseName;
        return path.join(dirName, sanitized);
    }
    isWin32Path() {
        return false;
    }
    filePath(filePath, shouldSanitize = false) {
        const dirName = path_1.posix.dirname(filePath);
        const baseName = path_1.posix.basename(filePath);
        const sanitized = shouldSanitize ? utils_1.sanitizeFileName(baseName) : baseName;
        const existingExt = path_1.posix.extname(baseName);
        const ext = this.extensions[0];
        const finalFileName = existingExt && existingExt.substr(1).toLowerCase() === ext.toLowerCase() ? sanitized : (sanitized + '.' + ext);
        if (this.isStartWithBaseDir(dirName)) {
            return path_1.posix.join(dirName, this.transformFileName(finalFileName));
        }
        else {
            return path_1.posix.join('/', this.baseDir, dirName, this.transformFileName(finalFileName));
        }
    }
    isStartWithBaseDir(str) {
        return str.indexOf('/' + this.baseDir) === 0;
    }
    ensureBaseDir() {
        return filesystem_1.default.ensureDirectory(this.baseDir)
            .then(() => { });
    }
    removeExt(fileNameWithExt) {
        const name = path_1.posix.basename(fileNameWithExt);
        const ext = path_1.posix.extname(fileNameWithExt);
        const i = name.lastIndexOf(ext);
        return name.substring(0, i);
    }
}
exports.BrowserFileSystemStandardStorage = BrowserFileSystemStandardStorage;
exports.getBrowserFileSystemStandardStorage = ts_utils_1.singletonGetterByKey((opts) => {
    return (opts && opts.baseDir) || 'share';
}, (opts) => {
    return new BrowserFileSystemStandardStorage(opts);
});


/***/ }),

/***/ 122:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ts_utils_1 = __webpack_require__(12);
// reference: https://nodejs.org/api/errors.html#errors_common_system_errors
exports.EACCES = ts_utils_1.errorClassFactory('EACCES');
exports.EEXIST = ts_utils_1.errorClassFactory('EEXIST');
exports.EISDIR = ts_utils_1.errorClassFactory('EISDIR');
exports.EMFILE = ts_utils_1.errorClassFactory('EMFILE');
exports.ENOENT = ts_utils_1.errorClassFactory('ENOENT');
exports.ENOTDIR = ts_utils_1.errorClassFactory('ENOTDIR');
exports.ENOTEMPTY = ts_utils_1.errorClassFactory('ENOTEMPTY');


/***/ }),

/***/ 123:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(__webpack_require__(27));
const standard_storage_1 = __webpack_require__(89);
const utils_1 = __webpack_require__(4);
const filesystem_1 = __webpack_require__(60);
const native_filesystem_storage_1 = __webpack_require__(128);
const ts_utils_1 = __webpack_require__(12);
class NativeFileSystemStandardStorage extends standard_storage_1.StandardStorage {
    constructor(opts) {
        super({
            encode: opts.encode,
            decode: opts.decode,
            listFilter: opts.listFilter
        });
        const { baseDir, rootDir, extensions, shouldKeepExt = false, allowAbsoluteFilePath = false } = opts;
        if (!baseDir || baseDir === '/') {
            throw new Error(`Invalid baseDir, ${baseDir}`);
        }
        this.rootDir = rootDir;
        this.baseDir = baseDir;
        this.extensions = extensions;
        this.shouldKeepExt = shouldKeepExt;
        this.allowAbsoluteFilePath = allowAbsoluteFilePath;
        this.fs = filesystem_1.getNativeFileSystemAPI();
    }
    getLink(fileName) {
        return this.read(fileName, 'DataURL');
    }
    read(filePath, type) {
        const fullPath = this.filePath(filePath);
        const relativePath = path_1.default.relative(this.dirPath('/'), fullPath);
        const onResolve = (res) => {
            if (res.errorCode !== 0 /* Succeeded */) {
                throw new native_filesystem_storage_1.ErrorWithCode(`${filePath}: ` + native_filesystem_storage_1.getErrorMessageForCode(res.errorCode), res.errorCode);
            }
            const rawContent = res.content;
            const intermediate = (() => {
                switch (type) {
                    case 'Text':
                    case 'DataURL':
                        return rawContent;
                    case 'ArrayBuffer':
                        return utils_1.dataURItoArrayBuffer(rawContent);
                    case 'BinaryString':
                        return utils_1.arrayBufferToString(utils_1.dataURItoArrayBuffer(rawContent));
                }
            })();
            return this.decode(intermediate, relativePath, type);
        };
        switch (type) {
            case 'Text':
                return this.fs.readAllTextCompat({
                    path: fullPath
                })
                    .then(onResolve);
            default:
                return this.fs.readAllBytesCompat({
                    path: fullPath
                })
                    .then(onResolve);
        }
    }
    stat(entryPath, isDirectory) {
        const dir = path_1.default.dirname(entryPath);
        const name = path_1.default.basename(entryPath);
        const fullPath = isDirectory ? this.dirPath(entryPath) : this.filePath(entryPath);
        const relativePath = path_1.default.relative(this.dirPath('/'), fullPath);
        const noEntry = {
            dir,
            name,
            fullPath,
            relativePath,
            isFile: false,
            isDirectory: false,
            lastModified: new Date(0),
            size: 0
        };
        const pExists = isDirectory ? this.fs.directoryExists({ path: fullPath })
            : this.fs.fileExists({ path: fullPath });
        return pExists.then(exists => {
            if (!exists) {
                return noEntry;
            }
            return this.fs.getFileSystemEntryInfo({ path: fullPath })
                .then((info) => {
                return {
                    dir,
                    name,
                    fullPath,
                    relativePath,
                    isFile: !info.isDirectory,
                    isDirectory: info.isDirectory,
                    lastModified: new Date(info.lastWriteTime),
                    size: info.length
                };
            }, (e) => {
                return noEntry;
            });
        });
    }
    __list(directoryPath = '/', brief = false) {
        return this.ensureBaseDir()
            .then(() => {
            return this.fs.getEntries({
                brief,
                path: this.dirPath(directoryPath),
                extensions: this.extensions,
            })
                .then(data => {
                const entries = data.entries;
                const errorCode = data.errorCode;
                if (errorCode !== 0 /* Succeeded */) {
                    throw new native_filesystem_storage_1.ErrorWithCode(native_filesystem_storage_1.getErrorMessageForCode(errorCode) + `: ${directoryPath}`, errorCode);
                }
                const convertName = (entryName, isDirectory) => {
                    return this.shouldKeepExt || isDirectory ? entryName : this.removeExt(entryName);
                };
                const convert = (entry) => {
                    const dir = this.dirPath(directoryPath);
                    const name = convertName(entry.name, entry.isDirectory);
                    const fullPath = path_1.default.join(dir, entry.name);
                    const relativePath = path_1.default.relative(this.dirPath('/'), fullPath);
                    return {
                        dir,
                        name,
                        fullPath,
                        relativePath,
                        isFile: !entry.isDirectory,
                        isDirectory: entry.isDirectory,
                        lastModified: new Date(entry.lastWriteTime),
                        size: entry.length
                    };
                };
                return entries.map(convert);
            });
        });
    }
    __write(filePath, content) {
        return this.ensureBaseDir()
            .then(() => this.encode(content, filePath))
            .then(encodedContent => {
            return this.fs.writeAllBytes({
                content: encodedContent,
                path: this.filePath(filePath, true),
            })
                .then(result => {
                if (!result) {
                    throw new Error(`Failed to write to '${filePath}'`);
                }
            });
        });
    }
    __overwrite(filePath, content) {
        return this.write(filePath, content);
    }
    __removeFile(filePath) {
        return this.ensureBaseDir()
            .then(() => {
            return this.fs.deleteFile({
                path: this.filePath(filePath)
            })
                .then(() => { });
        });
    }
    __removeEmptyDirectory(directoryPath) {
        return this.ensureBaseDir()
            .then(() => {
            return this.fs.removeDirectory({ path: this.dirPath(directoryPath) })
                .then(() => { });
        });
    }
    __moveFile(filePath, newPath) {
        return this.ensureBaseDir()
            .then(() => {
            return this.fs.moveFile({
                sourcePath: this.filePath(filePath),
                targetPath: this.filePath(newPath, true)
            })
                .then(() => { });
        });
    }
    __copyFile(filePath, newPath) {
        return this.ensureBaseDir()
            .then(() => {
            return this.fs.copyFile({
                sourcePath: this.filePath(filePath),
                targetPath: this.filePath(newPath, true)
            })
                .then(() => { });
        });
    }
    __createDirectory(directoryPath) {
        return this.ensureBaseDir()
            .then(() => {
            return this.fs.createDirectory({
                path: this.dirPath(directoryPath, true)
            })
                .then(() => { });
        });
    }
    dirPath(dir, shouldSanitize = false) {
        const path = this.getPathLib();
        const absPath = (() => {
            if (this.isStartWithBaseDir(dir)) {
                return path.normalize(dir);
            }
            else {
                return path.normalize(path.join(this.rootDir, this.baseDir, dir));
            }
        })();
        const dirName = path.dirname(absPath);
        const baseName = path.basename(absPath);
        const sanitized = shouldSanitize ? utils_1.sanitizeFileName(baseName) : baseName;
        return path.join(dirName, sanitized);
    }
    filePath(filePath, shouldSanitize = false) {
        const dirName = path_1.default.dirname(filePath);
        const baseName = path_1.default.basename(filePath);
        const sanitized = shouldSanitize ? utils_1.sanitizeFileName(baseName) : baseName;
        const existingExt = path_1.default.extname(baseName);
        const ext = this.extensions[0];
        const finalFileName = existingExt && existingExt.substr(1).toLowerCase() === ext.toLowerCase() ? sanitized : (sanitized + '.' + ext);
        if (this.isStartWithBaseDir(dirName)) {
            return path_1.default.normalize(path_1.default.join(dirName, finalFileName));
        }
        else if (this.allowAbsoluteFilePath && this.isAbsoluteUrl(filePath)) {
            return path_1.default.normalize(path_1.default.join(dirName, finalFileName));
        }
        else {
            return path_1.default.normalize(path_1.default.join(this.rootDir, this.baseDir, dirName, finalFileName));
        }
    }
    isWin32Path() {
        return /^([A-Z]:\\|\/\/|\\\\)/i.test(this.rootDir);
    }
    isAbsoluteUrl(str) {
        const path = this.getPathLib();
        return path.isAbsolute(str);
    }
    isStartWithBaseDir(str) {
        return str.indexOf(this.rootDir) === 0;
    }
    removeExt(fileNameWithExt) {
        const name = path_1.default.basename(fileNameWithExt);
        const ext = path_1.default.extname(fileNameWithExt);
        const i = name.lastIndexOf(ext);
        return name.substring(0, i);
    }
    ensureBaseDir() {
        const fs = this.fs;
        const dir = path_1.default.normalize(path_1.default.join(this.rootDir, this.baseDir));
        return fs.directoryExists({
            path: dir
        })
            .then(existed => {
            if (existed)
                return existed;
            return fs.createDirectory({
                path: dir
            });
        })
            .then(() => { });
    }
}
exports.NativeFileSystemStandardStorage = NativeFileSystemStandardStorage;
exports.getNativeFileSystemStandardStorage = ts_utils_1.singletonGetterByKey((opts) => {
    return path_1.default.join(opts.rootDir, opts.baseDir);
}, (opts) => {
    return new NativeFileSystemStandardStorage(opts);
});


/***/ }),

/***/ 124:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Non-external method types which the user can use via UI.
 */
exports.PublicMethodTypes = [
    1 /* GetFileSystemEntries */,
    2 /* GetDirectories */,
    3 /* GetFiles */,
    4 /* DirectoryExists */,
    5 /* FileExists */,
    8 /* CreateDirectory */,
    9 /* RemoveDirectory */,
    10 /* CopyFile */,
    11 /* MoveFile */,
    12 /* DeleteFile */,
    13 /* ReadAllText */,
    14 /* WriteAllText */,
    15 /* AppendAllText */,
    16 /* ReadAllBytes */,
    17 /* WriteAllBytes */,
    18 /* AppendAllBytes */
];
exports.MethodTypeFriendlyNames = [
    "GetVersion",
    "GetFileSystemEntries",
    "GetDirectories",
    "GetFiles",
    "GetFileSystemEntryInfo",
    "GetSpecialFolderPath",
    "DirectoryExists",
    "FileExists",
    "CreateDirectory",
    "RemoveDirectory",
    "CopyFile",
    "MoveFile",
    "DeleteFile",
    "ReadAllText",
    "WriteAllText",
    "AppendAllText",
    "ReadAllBytes",
    "WriteAllBytes",
    "AppendAllBytes",
    "GetMaxFileRange",
    "GetFileSize",
    "ReadFileRange",
    "RunProcess"
];
exports.MethodTypeInvocationNames = [
    "get_version",
    "get_file_system_entries",
    "get_directories",
    "get_files",
    "get_file_system_entry_info",
    "get_special_folder_path",
    "directory_exists",
    "file_exists",
    "create_directory",
    "remove_directory",
    "copy_file",
    "move_file",
    "delete_file",
    "read_all_text",
    "write_all_text",
    "append_all_text",
    "read_all_bytes",
    "write_all_bytes",
    "append_all_bytes",
    "get_max_file_range",
    "get_file_size",
    "read_file_range",
    "run_process"
];


/***/ }),

/***/ 125:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const native_host_1 = __webpack_require__(97);
class KantuFileAccessHost extends native_host_1.NativeMessagingHost {
    constructor() {
        super(KantuFileAccessHost.HOST_NAME);
    }
}
exports.KantuFileAccessHost = KantuFileAccessHost;
KantuFileAccessHost.HOST_NAME = "com.a9t9.kantu.file_access";


/***/ }),

/***/ 126:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Adapted from: http://www.json.org/JSON_checker/utf8_decode.c
Object.defineProperty(exports, "__esModule", { value: true });
class Utf8Decoder {
    constructor(input) {
        this.input = input;
        this.position = 0;
    }
    /**
     * Gets the next byte.
     * @returns UTF8_END if there are no more bytes, next byte otherwise.
     */
    getNextByte() {
        if (this.position >= this.input.length) {
            return Utf8Decoder.END;
        }
        const c = this.input[this.position] & 0xff;
        ++this.position;
        return c;
    }
    /**
     *  Gets the 6-bit payload of the next continuation byte.
     * @returns Contination byte if it's valid, UTF8_ERROR otherwise.
     */
    getNextContinuationByte() {
        const c = this.getNextByte();
        return (c & 0xc0) == 0x80 ? c & 0x3f : Utf8Decoder.ERROR;
    }
    /**
     * Decodes next codepoint.
     * @returns `Utf8Decoder.END` for end of stream, next codepoint if it's valid, `Utf8Decoder.ERROR` otherwise.
     */
    decodeNext() {
        if (this.position >= this.input.length) {
            return this.position === this.input.length
                ? Utf8Decoder.END
                : Utf8Decoder.ERROR;
        }
        const c = this.getNextByte();
        // Zero continuation (0 to 127)
        if ((c & 0x80) == 0) {
            return c;
        }
        // One continuation (128 to 2047)
        if ((c & 0xe0) == 0xc0) {
            const c1 = this.getNextContinuationByte();
            if (c1 >= 0) {
                const r = ((c & 0x1f) << 6) | c1;
                if (r >= 128) {
                    return r;
                }
            }
            // Two continuations (2048 to 55295 and 57344 to 65535)
        }
        else if ((c & 0xf0) == 0xe0) {
            const c1 = this.getNextContinuationByte();
            const c2 = this.getNextContinuationByte();
            if ((c1 | c2) >= 0) {
                const r = ((c & 0x0f) << 12) | (c1 << 6) | c2;
                if (r >= 2048 && (r < 55296 || r > 57343)) {
                    return r;
                }
            }
            // Three continuations (65536 to 1114111)
        }
        else if ((c & 0xf8) == 0xf0) {
            const c1 = this.getNextContinuationByte();
            const c2 = this.getNextContinuationByte();
            const c3 = this.getNextContinuationByte();
            if ((c1 | c2 | c3) >= 0) {
                const r = ((c & 0x07) << 18) | (c1 << 12) | (c2 << 6) | c3;
                if (r >= 65536 && r <= 1114111) {
                    return r;
                }
            }
        }
        return Utf8Decoder.ERROR;
    }
}
Utf8Decoder.REPLACEMENT_CHARACTER = "\uFFFD";
Utf8Decoder.END = -1;
Utf8Decoder.ERROR = -2;
var utf8;
(function (utf8) {
    function isValid(input) {
        const decoder = new Utf8Decoder(input);
        while (true) {
            const cp = decoder.decodeNext();
            switch (cp) {
                case Utf8Decoder.END:
                    return true;
                case Utf8Decoder.ERROR:
                    return false;
                default:
                // ignore
            }
        }
    }
    utf8.isValid = isValid;
    function decode(input) {
        const decoder = new Utf8Decoder(input);
        let output = "";
        while (true) {
            const cp = decoder.decodeNext();
            if (cp === Utf8Decoder.END) {
                break;
            }
            output +=
                cp !== Utf8Decoder.ERROR
                    ? String.fromCodePoint(cp)
                    : Utf8Decoder.REPLACEMENT_CHARACTER;
        }
        return output;
    }
    utf8.decode = decode;
})(utf8 = exports.utf8 || (exports.utf8 = {}));


/***/ }),

/***/ 127:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var base64;
(function (base64) {
    // prettier-ignore
    const encodingTable = new Uint8Array([
        65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
        97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,
        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47
    ]);
    // prettier-ignore
    const decodingTable = new Uint8Array([
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
        -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
        -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    ]);
    const paddingChar = 61;
    function calculateEncodedLength(length) {
        let result = Math.trunc(length / 3) * 4;
        result += length % 3 != 0 ? 4 : 0;
        return result;
    }
    function readWord(input, i, maxLength) {
        if (maxLength > 4) {
            throw new Error("maxLength should be in range [0, 4].");
        }
        const t = new Uint8Array(4);
        for (let k = 0; k < maxLength; ++k) {
            const c = input.charCodeAt(i + k);
            const b = decodingTable[c];
            if (b === 0xff) {
                return undefined;
            }
            t[k] = b;
        }
        return ((t[0] << (3 * 6)) +
            (t[1] << (2 * 6)) +
            (t[2] << (1 * 6)) +
            (t[3] << (0 * 6)));
    }
    function writeWord(output, i, triple) {
        output[i + 0] = (triple >> 16) & 0xff;
        output[i + 1] = (triple >> 8) & 0xff;
        output[i + 2] = triple & 0xff;
    }
    function encode(input) {
        const inLen = input.length;
        const outLen = calculateEncodedLength(inLen);
        const lengthMod3 = inLen % 3;
        const calcLength = inLen - lengthMod3;
        const output = new Uint8Array(outLen);
        let i;
        let j = 0;
        for (i = 0; i < calcLength; i += 3) {
            output[j + 0] = encodingTable[(input[i] & 0xfc) >> 2];
            output[j + 1] =
                encodingTable[((input[i] & 0x03) << 4) | ((input[i + 1] & 0xf0) >> 4)];
            output[j + 2] =
                encodingTable[((input[i + 1] & 0x0f) << 2) | ((input[i + 2] & 0xc0) >> 6)];
            output[j + 3] = encodingTable[input[i + 2] & 0x3f];
            j += 4;
        }
        i = calcLength;
        switch (lengthMod3) {
            case 2: // One character padding needed
                output[j + 0] = encodingTable[(input[i] & 0xfc) >> 2];
                output[j + 1] =
                    encodingTable[((input[i] & 0x03) << 4) | ((input[i + 1] & 0xf0) >> 4)];
                output[j + 2] = encodingTable[(input[i + 1] & 0x0f) << 2];
                output[j + 3] = paddingChar;
                j += 4;
                break;
            case 1: // Two character padding needed
                output[j + 0] = encodingTable[(input[i] & 0xfc) >> 2];
                output[j + 1] = encodingTable[(input[i] & 0x03) << 4];
                output[j + 2] = paddingChar;
                output[j + 3] = paddingChar;
                j += 4;
                break;
        }
        const decoder = new TextDecoder("ascii");
        return decoder.decode(output);
    }
    base64.encode = encode;
    function decode(input) {
        const inLen = input.length;
        if (inLen % 4 != 0) {
            return undefined;
        }
        let padding = 0;
        if (inLen > 0 && input.charCodeAt(inLen - 1) == paddingChar) {
            ++padding;
            if (inLen > 1 && input.charCodeAt(inLen - 2) == paddingChar) {
                ++padding;
            }
        }
        const encodedLen = inLen - padding;
        const completeLen = encodedLen & ~3;
        const outLen = (6 * inLen) / 8 - padding;
        const output = new Uint8Array(outLen);
        let triple;
        let i = 0;
        let j = 0;
        while (i < completeLen) {
            triple = readWord(input, i, 4);
            if (typeof triple === "undefined") {
                return undefined;
            }
            writeWord(output, j, triple);
            i += 4;
            j += 3;
        }
        if (padding > 0) {
            triple = readWord(input, i, 4 - padding);
            if (typeof triple === "undefined") {
                return undefined;
            }
            switch (padding) {
                case 1:
                    output[j + 0] = (triple >> 16) & 0xff;
                    output[j + 1] = (triple >> 8) & 0xff;
                    break;
                case 2:
                    output[j + 0] = (triple >> 16) & 0xff;
                    break;
            }
        }
        return output;
    }
    base64.decode = decode;
})(base64 = exports.base64 || (exports.base64 = {}));


/***/ }),

/***/ 128:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const storage_1 = __webpack_require__(76);
const filesystem_1 = __webpack_require__(60);
const path_1 = __importDefault(__webpack_require__(27));
const utils_1 = __webpack_require__(4);
const ts_utils_1 = __webpack_require__(12);
class NativeFileSystemFlatStorage extends storage_1.FlatStorage {
    constructor(opts) {
        super({
            encode: opts.encode,
            decode: opts.decode
        });
        this.listFilter = (list) => list;
        this.displayedCount = 0;
        this.totalCount = 0;
        const { baseDir, rootDir, extensions, shouldKeepExt = false, listFilter } = opts;
        if (!baseDir || baseDir === '/') {
            throw new Error(`Invalid baseDir, ${baseDir}`);
        }
        this.rootDir = rootDir;
        this.baseDir = baseDir;
        this.extensions = extensions;
        this.shouldKeepExt = shouldKeepExt;
        if (listFilter) {
            this.listFilter = listFilter;
        }
        this.fs = filesystem_1.getNativeFileSystemAPI();
    }
    getDisplayCount() {
        return this.displayedCount;
    }
    getTotalCount() {
        return this.totalCount;
    }
    readAll(readFileType = 'Text', onErrorFiles) {
        return this.list()
            .then(items => {
            return Promise.all(items.map(item => {
                return this.read(item.fileName, readFileType)
                    .then(content => ({
                    content,
                    fileName: item.fileName
                }))
                    // Note: Whenever there is error in reading file,
                    // return null
                    .catch(e => ({
                    fileName: item.fileName,
                    fullFilePath: this.filePath(item.fileName),
                    error: new Error(`Error in parsing ${this.filePath(item.fileName)}:\n${e.message}`)
                }));
            }))
                .then(list => {
                const errorFiles = list.filter(item => item.error);
                if (onErrorFiles)
                    onErrorFiles(errorFiles);
                return list.filter((item) => item.content);
            });
        });
    }
    getLink(fileName) {
        return this.read(fileName, 'DataURL');
    }
    __list() {
        return this.ensureDir()
            .then(() => {
            return this.fs.getEntries({
                path: path_1.default.join(this.rootDir, this.baseDir),
                extensions: this.extensions
            })
                .then(data => {
                const entries = data.entries;
                const errorCode = data.errorCode;
                if (errorCode !== 0 /* Succeeded */) {
                    throw new ErrorWithCode(getErrorMessageForCode(errorCode), errorCode);
                }
                const convertName = (entryName) => this.shouldKeepExt ? entryName : this.removeExt(entryName);
                const convert = (entry) => {
                    return {
                        dir: this.baseDir,
                        fileName: convertName(entry.name),
                        lastModified: new Date(entry.lastWriteTime),
                        size: storage_1.readableSize(entry.length)
                    };
                };
                const allList = entries.map(convert);
                return Promise.resolve(this.listFilter(allList))
                    .then(displayList => {
                    this.totalCount = allList.length;
                    this.displayedCount = displayList.length;
                    return displayList;
                });
            });
        });
    }
    exists(fileName) {
        return this.fs.fileExists({
            path: this.filePath(fileName)
        });
    }
    read(fileName, type) {
        const onResolve = (res) => {
            if (res.errorCode !== 0 /* Succeeded */) {
                throw new ErrorWithCode(`${fileName}: ` + getErrorMessageForCode(res.errorCode), res.errorCode);
            }
            const rawContent = res.content;
            const intermediate = (() => {
                switch (type) {
                    case 'Text':
                    case 'DataURL':
                        return rawContent;
                    case 'ArrayBuffer':
                        return utils_1.dataURItoArrayBuffer(rawContent);
                    case 'BinaryString':
                        return utils_1.arrayBufferToString(utils_1.dataURItoArrayBuffer(rawContent));
                }
            })();
            return this.decode(intermediate, fileName);
        };
        switch (type) {
            case 'Text':
                return this.fs.readAllTextCompat({
                    path: this.filePath(fileName)
                })
                    .then(onResolve);
            default:
                return this.fs.readAllBytesCompat({
                    path: this.filePath(fileName)
                })
                    .then(onResolve);
        }
    }
    __write(fileName, content) {
        return this.ensureDir()
            .then(() => this.encode(content, fileName))
            .then(encodedContent => {
            return this.fs.writeAllBytes({
                content: encodedContent,
                path: this.filePath(fileName, true),
            })
                .then(result => {
                if (!result) {
                    throw new Error(`Failed to write to '${fileName}'`);
                }
            });
        });
    }
    __overwrite(fileName, content) {
        return this.remove(fileName)
            .catch(() => { })
            .then(() => this.write(fileName, content));
    }
    __clear() {
        return this.list()
            .then(list => {
            const ps = list.map(file => {
                return this.remove(file.fileName);
            });
            return Promise.all(ps);
        })
            .then(() => { });
    }
    __remove(fileName) {
        return this.ensureDir()
            .then(() => {
            return this.fs.deleteFile({
                path: this.filePath(fileName)
            })
                .then(() => { });
        });
    }
    __rename(fileName, newName) {
        return this.ensureDir()
            .then(() => {
            return this.fs.moveFile({
                sourcePath: this.filePath(fileName),
                targetPath: this.filePath(newName, true)
            })
                .then(() => { });
        });
    }
    __copy(fileName, newName) {
        return this.ensureDir()
            .then(() => {
            return this.fs.copyFile({
                sourcePath: this.filePath(fileName),
                targetPath: this.filePath(newName, true)
            })
                .then(() => { });
        });
    }
    filePath(fileName, shouldSanitize = false) {
        const sanitized = shouldSanitize ? utils_1.sanitizeFileName(fileName) : fileName;
        const existingExt = path_1.default.extname(fileName);
        const ext = this.extensions[0];
        const finalFileName = existingExt && existingExt.substr(1).toLowerCase() === ext.toLowerCase() ? sanitized : (sanitized + '.' + ext);
        return path_1.default.join(this.rootDir, this.baseDir, finalFileName);
    }
    removeExt(fileNameWithExt) {
        const name = path_1.default.basename(fileNameWithExt);
        const ext = path_1.default.extname(fileNameWithExt);
        const i = name.lastIndexOf(ext);
        return name.substring(0, i);
    }
    ensureDir() {
        const fs = this.fs;
        const dir = path_1.default.join(this.rootDir, this.baseDir);
        return fs.directoryExists({
            path: dir
        })
            .then(existed => {
            if (existed)
                return existed;
            return fs.createDirectory({
                path: dir
            });
        })
            .then(() => { });
    }
}
exports.NativeFileSystemFlatStorage = NativeFileSystemFlatStorage;
exports.getNativeFileSystemFlatStorage = ts_utils_1.singletonGetterByKey((opts) => {
    return path_1.default.join(opts.rootDir, opts.baseDir);
}, (opts) => {
    return new NativeFileSystemFlatStorage(opts);
});
class ErrorWithCode extends Error {
    constructor(message, code) {
        super(message);
        this.name = 'ErrorWithCode';
        this.code = code;
        // Note: better to keep stack trace
        // reference: https://stackoverflow.com/a/32749533/1755633
        let captured = true;
        if (typeof Error.captureStackTrace === 'function') {
            try {
                Error.captureStackTrace(this, this.constructor);
            }
            catch (e) {
                captured = false;
            }
        }
        if (!captured) {
            this.stack = (new Error(message)).stack;
        }
    }
}
exports.ErrorWithCode = ErrorWithCode;
function getErrorMessageForCode(code) {
    switch (code) {
        case 0 /* Succeeded */:
            return 'Success';
        case 1 /* Failed */:
            return 'Failed to load';
        case 2 /* Truncated */:
            return 'File too large to load';
        default:
            return `Unknown error code: ${code}`;
    }
}
exports.getErrorMessageForCode = getErrorMessageForCode;


/***/ }),

/***/ 13:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const eventemitter3_1 = __importDefault(__webpack_require__(81));
const browser_filesystem_storage_1 = __webpack_require__(121);
const native_filesystem_storage_1 = __webpack_require__(123);
const ts_utils_1 = __webpack_require__(12);
const xfile_1 = __webpack_require__(32);
const convert_utils_1 = __webpack_require__(50);
const convert_suite_utils_1 = __webpack_require__(69);
const utils_1 = __webpack_require__(4);
const path_1 = __importDefault(__webpack_require__(27));
var StorageStrategyType;
(function (StorageStrategyType) {
    StorageStrategyType["Browser"] = "browser";
    StorageStrategyType["XFile"] = "xfile";
    StorageStrategyType["Nil"] = "nil";
})(StorageStrategyType = exports.StorageStrategyType || (exports.StorageStrategyType = {}));
var StorageTarget;
(function (StorageTarget) {
    StorageTarget[StorageTarget["Macro"] = 0] = "Macro";
    StorageTarget[StorageTarget["TestSuite"] = 1] = "TestSuite";
    StorageTarget[StorageTarget["CSV"] = 2] = "CSV";
    StorageTarget[StorageTarget["Screenshot"] = 3] = "Screenshot";
    StorageTarget[StorageTarget["Vision"] = 4] = "Vision";
})(StorageTarget = exports.StorageTarget || (exports.StorageTarget = {}));
var StorageManagerEvent;
(function (StorageManagerEvent) {
    StorageManagerEvent["StrategyTypeChanged"] = "StrategyTypeChanged";
    StorageManagerEvent["RootDirChanged"] = "RootDirChanged";
    StorageManagerEvent["ForceReload"] = "ForceReload";
})(StorageManagerEvent = exports.StorageManagerEvent || (exports.StorageManagerEvent = {}));
class StorageManager extends eventemitter3_1.default {
    constructor(strategyType, extraOptions) {
        super();
        this.strategyType = StorageStrategyType.Nil;
        this.getMacros = () => [];
        this.getMaxMacroCount = (s) => Promise.resolve(Infinity);
        this.setCurrentStrategyType(strategyType);
        if (extraOptions && extraOptions.getMacros) {
            this.getMacros = extraOptions.getMacros;
        }
        if (extraOptions && extraOptions.getMaxMacroCount) {
            this.getMaxMacroCount = extraOptions.getMaxMacroCount;
        }
        this.getConfig = extraOptions === null || extraOptions === void 0 ? void 0 : extraOptions.getConfig;
    }
    isXFileMode() {
        return this.strategyType === StorageStrategyType.XFile;
    }
    isBrowserMode() {
        return this.strategyType === StorageStrategyType.Browser;
    }
    getCurrentStrategyType() {
        return this.strategyType;
    }
    setCurrentStrategyType(type) {
        const needChange = type !== this.strategyType;
        if (needChange) {
            setTimeout(() => {
                this.emit(StorageManagerEvent.StrategyTypeChanged, type);
            }, 0);
            this.strategyType = type;
        }
        return needChange;
    }
    isStrategyTypeAvailable(type) {
        switch (type) {
            case StorageStrategyType.Browser:
                return Promise.resolve(true);
            case StorageStrategyType.XFile:
                return xfile_1.getXFile().sanityCheck();
            default:
                throw new Error(`type '${type}' is not supported`);
        }
    }
    getStorageForTarget(target, forceStrategytype) {
        switch (forceStrategytype || this.strategyType) {
            case StorageStrategyType.Browser: {
                switch (target) {
                    case StorageTarget.Macro: {
                        const storage = browser_filesystem_storage_1.getBrowserFileSystemStandardStorage({
                            baseDir: 'macros',
                            extensions: ['json'],
                            shouldKeepExt: false,
                            decode: (text, filePath) => {
                                const obj = convert_utils_1.fromJSONString(text, path_1.default.basename(filePath), { withStatus: true });
                                // Note: use filePath as id
                                return Object.assign(Object.assign({}, obj), { id: storage.filePath(filePath), path: storage.relativePath(filePath) });
                            },
                            encode: (data, fileName) => {
                                var _a, _b;
                                const str = convert_utils_1.toJSONString(Object.assign(Object.assign({}, data), { commands: data.data.commands }), {
                                    withStatus: true,
                                    ignoreTargetOptions: !!((_b = (_a = this.getConfig) === null || _a === void 0 ? void 0 : _a.call(this)) === null || _b === void 0 ? void 0 : _b.saveAlternativeLocators)
                                });
                                // Note: BrowserFileSystemStorage only supports writing file with Blob
                                // so have to convert it here in `encode`
                                return new Blob([str]);
                            }
                        });
                        window.newMacroStorage = storage;
                        return storage;
                    }
                    case StorageTarget.TestSuite: {
                        const storage = browser_filesystem_storage_1.getBrowserFileSystemStandardStorage({
                            baseDir: 'testsuites',
                            extensions: ['json'],
                            shouldKeepExt: false,
                            decode: (text, filePath) => {
                                console.log('test suite raw content', filePath, text, this.getMacros());
                                const obj = convert_suite_utils_1.parseTestSuite(text, { fileName: path_1.default.basename(filePath) });
                                // Note: use filePath as id
                                return Object.assign(Object.assign({}, obj), { id: storage.filePath(filePath), path: storage.relativePath(filePath) });
                            },
                            encode: (suite, fileName) => {
                                const str = convert_suite_utils_1.stringifyTestSuite(suite);
                                return new Blob([str]);
                            }
                        });
                        window.newTestSuiteStorage = storage;
                        return storage;
                    }
                    case StorageTarget.CSV:
                        return browser_filesystem_storage_1.getBrowserFileSystemStandardStorage({
                            baseDir: 'spreadsheets',
                            extensions: ['csv'],
                            shouldKeepExt: true,
                            transformFileName: (path) => {
                                return path.toLowerCase();
                            }
                        });
                    case StorageTarget.Screenshot:
                        return browser_filesystem_storage_1.getBrowserFileSystemStandardStorage({
                            baseDir: 'screenshots',
                            extensions: ['png'],
                            shouldKeepExt: true,
                            transformFileName: (path) => {
                                return path.toLowerCase();
                            }
                        });
                    case StorageTarget.Vision:
                        return browser_filesystem_storage_1.getBrowserFileSystemStandardStorage({
                            baseDir: 'visions',
                            extensions: ['png'],
                            shouldKeepExt: true,
                            transformFileName: (path) => {
                                return path.toLowerCase();
                            }
                        });
                }
            }
            case StorageStrategyType.XFile: {
                const { rootDir } = xfile_1.getXFile().getCachedConfig();
                switch (target) {
                    case StorageTarget.Macro: {
                        const storage = native_filesystem_storage_1.getNativeFileSystemStandardStorage({
                            rootDir,
                            baseDir: 'macros',
                            extensions: ['json'],
                            shouldKeepExt: false,
                            listFilter: (entryNodes) => {
                                return this.getMaxMacroCount(this.strategyType)
                                    .then(maxCount => {
                                    return ts_utils_1.forestSlice(maxCount, entryNodes);
                                });
                            },
                            decode: (text, filePath) => {
                                const obj = convert_utils_1.fromJSONString(text, path_1.default.basename(filePath), { withStatus: true });
                                // Note: use filePath as id
                                return Object.assign(Object.assign({}, obj), { id: storage.filePath(filePath), path: storage.relativePath(filePath) });
                            },
                            encode: (data, fileName) => {
                                const str = convert_utils_1.toJSONString(Object.assign(Object.assign({}, data), { commands: data.data.commands }), { withStatus: true });
                                // Note: NativeFileSystemStorage only supports writing file with DataURL
                                // so have to convert it here in `encode`
                                return utils_1.blobToDataURL(new Blob([str]));
                            }
                        });
                        return storage;
                    }
                    case StorageTarget.TestSuite: {
                        const storage = native_filesystem_storage_1.getNativeFileSystemStandardStorage({
                            rootDir,
                            baseDir: 'testsuites',
                            extensions: ['json'],
                            shouldKeepExt: false,
                            decode: (text, filePath) => {
                                const obj = convert_suite_utils_1.parseTestSuite(text, { fileName: path_1.default.basename(filePath) });
                                // Note: use filePath as id
                                return Object.assign(Object.assign({}, obj), { id: storage.filePath(filePath), path: storage.relativePath(filePath) });
                            },
                            encode: (suite, fileName) => {
                                const str = convert_suite_utils_1.stringifyTestSuite(suite);
                                return utils_1.blobToDataURL(new Blob([str]));
                            }
                        });
                        return storage;
                    }
                    case StorageTarget.CSV:
                        return native_filesystem_storage_1.getNativeFileSystemStandardStorage({
                            rootDir,
                            baseDir: 'datasources',
                            extensions: ['csv'],
                            shouldKeepExt: true,
                            allowAbsoluteFilePath: true,
                            encode: ((text, fileName) => {
                                return utils_1.blobToDataURL(new Blob([text]));
                            })
                        });
                    case StorageTarget.Vision:
                        return native_filesystem_storage_1.getNativeFileSystemStandardStorage({
                            rootDir,
                            baseDir: 'images',
                            extensions: ['png'],
                            shouldKeepExt: true,
                            decode: xFileDecodeImage,
                            encode: ((imageBlob, fileName) => {
                                return utils_1.blobToDataURL(imageBlob);
                            })
                        });
                    case StorageTarget.Screenshot:
                        return native_filesystem_storage_1.getNativeFileSystemStandardStorage({
                            rootDir,
                            baseDir: 'screenshots',
                            extensions: ['png'],
                            shouldKeepExt: true,
                            decode: xFileDecodeImage,
                            encode: ((imageBlob, fileName) => {
                                return utils_1.blobToDataURL(imageBlob);
                            })
                        });
                }
            }
            default:
                throw new Error(`Unsupported strategy type: '${this.strategyType}'`);
        }
    }
    getMacroStorage() {
        return this.getStorageForTarget(StorageTarget.Macro);
    }
    getTestSuiteStorage() {
        return this.getStorageForTarget(StorageTarget.TestSuite);
    }
    getCSVStorage() {
        return this.getStorageForTarget(StorageTarget.CSV);
    }
    getVisionStorage() {
        return this.getStorageForTarget(StorageTarget.Vision);
    }
    getScreenshotStorage() {
        return this.getStorageForTarget(StorageTarget.Screenshot);
    }
}
exports.StorageManager = StorageManager;
function xFileDecodeImage(data, fileName, readFileType) {
    if (readFileType !== 'DataURL') {
        return data;
    }
    if (data.substr(0, 11) === 'data:image') {
        return data;
    }
    return 'data:image/png;base64,' + data;
}
// Note: in panel window (`src/index.js`), `getStorageManager` is provided with `getMacros` in `extraOptions`
// While in `bg.js` or `csv_edtior.js`, `vision_editor.js`, `extraOptions` is omitted with no harm,
// because they don't read/write test suites
exports.getStorageManager = ts_utils_1.singletonGetter((strategyType, extraOptions) => {
    return new StorageManager(strategyType || StorageStrategyType.XFile, extraOptions);
});


/***/ }),

/***/ 136:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export aesEncrypt */
/* unused harmony export aesDecrypt */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return encrypt; });
/* unused harmony export decrypt */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return encryptIfNeeded; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return decryptIfNeeded; });
/* harmony import */ var pbkdf2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(193);
/* harmony import */ var pbkdf2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pbkdf2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(101);
/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(aes_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_web_extension__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36);





var RAW_PREFIX = '@_KANTU_@';
var DEPRECATED_CIPHER_PREFIX = '__KANTU_ENCRYPTED__';
var CIPHER_PREFIX = '__RPA_ENCRYPTED__';
var RAW_PREFIX_REG = new RegExp('^' + RAW_PREFIX);
var CIPHER_PREFIX_REG = new RegExp('^(' + CIPHER_PREFIX + '|' + DEPRECATED_CIPHER_PREFIX + ')');

var getEncryptConfig = function getEncryptConfig() {
  return _storage__WEBPACK_IMPORTED_MODULE_3__["default"].get('config').then(function (config) {
    return {
      shouldEncrypt: config.shouldEncryptPassword === 'master_password',
      masterPassword: config.masterPassword
    };
  });
};

var aesEncrypt = function aesEncrypt(text, password) {
  var key = pbkdf2__WEBPACK_IMPORTED_MODULE_0___default.a.pbkdf2Sync(password, 'salt', 1, 256 / 8, 'sha512');
  var engine = new aes_js__WEBPACK_IMPORTED_MODULE_1___default.a.ModeOfOperation.ctr(key);

  return aes_js__WEBPACK_IMPORTED_MODULE_1___default.a.utils.hex.fromBytes(engine.encrypt(aes_js__WEBPACK_IMPORTED_MODULE_1___default.a.utils.utf8.toBytes(text)));
};

var aesDecrypt = function aesDecrypt(text, password) {
  var key = pbkdf2__WEBPACK_IMPORTED_MODULE_0___default.a.pbkdf2Sync(password, 'salt', 1, 256 / 8, 'sha512');
  var engine = new aes_js__WEBPACK_IMPORTED_MODULE_1___default.a.ModeOfOperation.ctr(key);

  return aes_js__WEBPACK_IMPORTED_MODULE_1___default.a.utils.utf8.fromBytes(engine.decrypt(aes_js__WEBPACK_IMPORTED_MODULE_1___default.a.utils.hex.toBytes(text)));
};

var encrypt = function encrypt(text) {
  return getEncryptConfig().then(function (_ref) {
    var shouldEncrypt = _ref.shouldEncrypt,
        masterPassword = _ref.masterPassword;

    if (!shouldEncrypt) return text;
    return '' + CIPHER_PREFIX + aesEncrypt(RAW_PREFIX + text, masterPassword);
  });
};

var decrypt = function decrypt(text) {
  return getEncryptConfig().then(function (_ref2) {
    var shouldEncrypt = _ref2.shouldEncrypt,
        masterPassword = _ref2.masterPassword;

    if (!shouldEncrypt) return text;
    var raw = aesDecrypt(text.replace(CIPHER_PREFIX_REG, ''), masterPassword);
    if (raw.indexOf(RAW_PREFIX) !== 0) throw new Error('Wrong master password');
    return raw.replace(RAW_PREFIX_REG, '');
  }).catch(function (e) {
    throw new Error('password string invalid');
  });
};

var encryptIfNeeded = function encryptIfNeeded(text, dom) {
  if (dom && dom.tagName.toUpperCase() === 'INPUT' && dom.type === 'password') {
    return encrypt(text);
  }

  return Promise.resolve(text);
};

var decryptIfNeeded = function decryptIfNeeded(text, dom) {
  if (!CIPHER_PREFIX_REG.test(text)) {
    return Promise.resolve(text);
  }

  if (!dom || ['INPUT', 'TEXTAREA'].indexOf(dom.tagName.toUpperCase()) !== -1) {
    return decrypt(text);
  }

  return Promise.resolve(text);
};

/***/ }),

/***/ 137:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(0));
const prop_types_1 = __importDefault(__webpack_require__(1));
const react_dnd_1 = __webpack_require__(515);
const antd_1 = __webpack_require__(117);
const utils_1 = __webpack_require__(4);
const tree_1 = __webpack_require__(972);
const ts_utils_1 = __webpack_require__(12);
const path_1 = __webpack_require__(27);
__webpack_require__(973);
var FileNodeType;
(function (FileNodeType) {
    FileNodeType["File"] = "file";
    FileNodeType["Folder"] = "folder";
})(FileNodeType = exports.FileNodeType || (exports.FileNodeType = {}));
class InternalFileTree extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.onToggle = (data, paths) => {
            if (data.type !== FileNodeType.Folder) {
                return;
            }
            this.props.onToggle(data, paths);
        };
        this.subnodeComponent = (() => {
            const { DndFileNode, DndFolderNode } = dndComponentsFactory({
                move: (sourceId, targetId, isDirectory) => {
                    this.props.onMove(sourceId, targetId, isDirectory);
                }
            });
            return (data, paths) => {
                switch (data.type) {
                    case FileNodeType.File:
                        return DndFileNode;
                    case FileNodeType.Folder:
                        return DndFolderNode;
                }
            };
        })();
        this.renderFileIcon = (data) => {
            switch (data.type) {
                case FileNodeType.File:
                    return (react_1.default.createElement("img", { src: "./img/code.svg", className: "file-node-icon file-icon" }));
                case FileNodeType.Folder:
                    if (!data.folded) {
                        return (react_1.default.createElement("img", { src: "./img/folder_expanded.svg", className: "file-node-icon folder-icon expanded" }));
                    }
                    else {
                        return (react_1.default.createElement("img", { src: "./img/folder.svg", className: "file-node-icon folder-icon" }));
                    }
            }
        };
        this.renderFileItem = (data, paths) => {
            return (react_1.default.createElement("div", { className: "file-node-title" },
                react_1.default.createElement("span", null, data.name)));
        };
        this.renderFileItemExtra = (data, paths) => {
            return (react_1.default.createElement(antd_1.Icon, { type: "bars", className: "more-button", onClick: (e) => this.props.onContextMenu(data, paths, e) }));
        };
    }
    shouldComponentUpdate(nextProps) {
        return !ts_utils_1.isForestEqual((a, b) => {
            const result = a.entryPath === b.entryPath &&
                a.folded === b.folded &&
                a.type === b.type &&
                a.className === b.className;
            return result;
        }, this.props.nodes, nextProps.nodes);
    }
    render() {
        const { nodes } = this.props;
        const { connectDropTarget, highlighted } = this.props;
        return connectDropTarget(react_1.default.createElement("div", { className: utils_1.cn('file-root', { 'drag-over': highlighted }) }, nodes.map((data, i) => {
            const Node = this.subnodeComponent(data, [i]);
            return (react_1.default.createElement(Node, { key: data.id, data: data, paths: [i], commonClass: "file-node", renderIcon: this.renderFileIcon, renderItem: this.renderFileItem, renderItemExtra: this.renderFileItemExtra, subnodeComponent: this.subnodeComponent, onClick: this.props.onClick, onDoubleClick: this.props.onDoubleClick, onContextMenu: this.props.onContextMenu, onToggle: this.onToggle, foldOnClickTitle: true }));
        })));
    }
}
exports.InternalFileTree = InternalFileTree;
InternalFileTree.propTypes = {
    nodes: prop_types_1.default.array.isRequired,
    onMove: prop_types_1.default.func.isRequired,
    onClick: prop_types_1.default.func.isRequired,
    onDoubleClick: prop_types_1.default.func.isRequired,
    onContextMenu: prop_types_1.default.func.isRequired
};
exports.FileTree = react_dnd_1.DropTarget([FileNodeType.Folder, FileNodeType.File], {
    drop(props, monitor, component) {
        const folderId = props.rootPath;
        const srcItem = monitor.getItem();
        props.onMove(srcItem.id, folderId, srcItem.isDirectory);
    },
    canDrop(props, monitor) {
        const folderId = props.rootPath;
        const { id: entryId } = monitor.getItem();
        if (folderId === entryId) {
            return false;
        }
        if (folderId === path_1.posix.dirname(entryId)) {
            return false;
        }
        return monitor.isOver({ shallow: true });
    }
}, (connect, monitor) => ({
    connectDropTarget: connect.dropTarget(),
    highlighted: monitor.isOver({ shallow: true }) && monitor.canDrop()
}))(InternalFileTree);
function dndComponentsFactory(opts) {
    const applyDragSource = (itemType) => (comp) => {
        return react_dnd_1.DragSource(itemType, {
            beginDrag: (props) => {
                const result = ({
                    id: props.data.id,
                    isDirectory: props.data.type === FileNodeType.Folder
                });
                return result;
            },
        }, (connect, monitor) => ({
            connectDragSource: connect.dragSource(),
            isDragging: monitor.isDragging()
        }))(comp);
    };
    const applyDropTarget = (itemType) => (comp) => {
        return react_dnd_1.DropTarget(itemType, {
            drop(props, monitor, component) {
                const folderId = props.data.id;
                const srcItem = monitor.getItem();
                opts.move(srcItem.id, folderId, srcItem.isDirectory);
            },
            canDrop(props, monitor) {
                const folderId = props.data.id;
                const { id: entryId } = monitor.getItem();
                if (folderId === entryId) {
                    return false;
                }
                if (folderId === path_1.posix.dirname(entryId)) {
                    return false;
                }
                return monitor.isOver({ shallow: true });
            }
        }, (connect, monitor) => ({
            connectDropTarget: connect.dropTarget(),
            highlighted: monitor.isOver({ shallow: true }) && monitor.canDrop()
        }))(comp);
    };
    const DndFileNode = applyDragSource(FileNodeType.File)(function InternalFileNode(props) {
        return (react_1.default.createElement(tree_1.TreeNode, Object.assign({}, props, { decorate: ts_utils_1.compose(props.connectDragSource, track) })));
    });
    const DndFolderNode = ts_utils_1.compose(applyDragSource(FileNodeType.Folder), applyDropTarget([FileNodeType.Folder, FileNodeType.File]))(function InternalFolderNode(props) {
        return (react_1.default.createElement(tree_1.TreeNode, Object.assign({}, props, { decorate: ts_utils_1.compose(props.connectDragSource, props.connectDropTarget, track), data: ts_utils_1.safeUpdateIn(['className'], (oldClassName = '') => utils_1.cn(oldClassName, { 'drag-over': props.highlighted }), props.data) })));
    });
    const track = (x) => {
        return x;
    };
    return { DndFolderNode, DndFileNode };
}


/***/ }),

/***/ 146:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = __webpack_require__(157);
const listener_api_proxy_1 = __webpack_require__(357);
const settings_api_proxy_1 = __webpack_require__(504);
const pac_api_proxy_1 = __webpack_require__(505);
const http_auth_1 = __webpack_require__(506);
const messages_1 = __importDefault(__webpack_require__(159));
const allAvailableProxyManagers = [
    new listener_api_proxy_1.ProxyManagerViaListenerAPI(),
    new pac_api_proxy_1.ProxyManagerViaPacAPI(),
    new settings_api_proxy_1.ProxyManagerViaSettingsAPI()
];
const proxyHttpAuth = new http_auth_1.ProxyHttpAuth({
    getAuth: (host, port) => {
        return getProxyManager().getAuth(host, port);
    }
});
function getProxyManager() {
    for (let i = 0, len = allAvailableProxyManagers.length; i < len; i++) {
        if (allAvailableProxyManagers[i].isSupported()) {
            return allAvailableProxyManagers[i];
        }
    }
    throw new Error('Unable to use proxy');
}
exports.getProxyManager = getProxyManager;
function setProxy(proxy) {
    return new Promise((resolve, reject) => {
        const proxyManager = getProxyManager();
        // Default to not incognito mode
        proxyManager.isControllable(false)
            .then((controllable) => {
            if (!controllable) {
                throw new Error(messages_1.default.proxy.notControllable);
            }
            proxyHttpAuth.bind();
            if (!proxy) {
                return proxyManager.reset();
            }
            return proxyManager.setProxy(proxy);
        })
            .then(resolve, reject);
    });
}
exports.setProxy = setProxy;
function parseProxyUrl(proxyUrl, usernameAndPassword) {
    const url = new URL(proxyUrl);
    // URL has problem parsing non-standard url like socks4://0.0.0.0
    // hostname will be empty string, so we have to replace protocol with http
    const httpUrl = new URL(proxyUrl.replace(/\s*socks[45]/i, 'http'));
    const host = httpUrl.hostname;
    const type = (() => {
        switch (url.protocol) {
            case 'http:':
                return types_1.ProxyScheme.Http;
            case 'https:':
                return types_1.ProxyScheme.Https;
            case 'socks4:':
                return types_1.ProxyScheme.Socks4;
            case 'socks5:':
                return types_1.ProxyScheme.Socks5;
            default:
                throw new Error('Invalid proxy protocol');
        }
    })();
    const port = (() => {
        if (httpUrl.port) {
            return httpUrl.port;
        }
        switch (type) {
            case types_1.ProxyScheme.Http:
                return '80';
            case types_1.ProxyScheme.Https:
                return '443';
            case types_1.ProxyScheme.Socks4:
            case types_1.ProxyScheme.Socks5:
                return '1080';
        }
    })();
    if (!host || !host.length) {
        throw new Error('No host found in proxy');
    }
    if (!port || isNaN(parseInt(port, 10))) {
        throw new Error('No valid port found in proxy');
    }
    const { username, password } = (() => {
        if (!usernameAndPassword || !usernameAndPassword.length) {
            return {};
        }
        const index = usernameAndPassword.indexOf(',');
        if (index === -1) {
            return { username: usernameAndPassword };
        }
        return {
            username: usernameAndPassword.substr(0, index),
            password: usernameAndPassword.substr(index + 1)
        };
    })();
    return {
        type,
        host,
        port,
        username,
        password
    };
}
exports.parseProxyUrl = parseProxyUrl;


/***/ }),

/***/ 153:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const storage_1 = __importDefault(__webpack_require__(36));
const ts_utils_1 = __webpack_require__(12);
function parseKey(key) {
    return key.split('::').filter(s => s.length > 0);
}
exports.parseKey = parseKey;
class KeyValueData {
    constructor() {
        this.withOneLock = ts_utils_1.concurrent(1)((run) => {
            return new Promise((resolve, reject) => {
                try {
                    Promise.resolve(run()).then(resolve, reject);
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    }
    get(key) {
        const [mainKey, subKeys] = this.getMainKeyAndSubKeys(key);
        return storage_1.default.get(mainKey)
            .then((data = {}) => {
            const result = ts_utils_1.getIn(subKeys, data);
            return result;
        });
    }
    set(key, value) {
        return this.withOneLock(() => {
            const [mainKey, subKeys] = this.getMainKeyAndSubKeys(key);
            return storage_1.default.get(mainKey)
                .then((data = {}) => {
                const updated = ts_utils_1.safeSetIn(subKeys, value, data);
                return storage_1.default.set(mainKey, updated)
                    .then(() => ts_utils_1.getIn(subKeys, updated));
            });
        });
    }
    update(key, updater) {
        return this.withOneLock(() => {
            const [mainKey, subKeys] = this.getMainKeyAndSubKeys(key);
            return storage_1.default.get(mainKey)
                .then((data = {}) => {
                const updated = ts_utils_1.safeUpdateIn(subKeys, updater, data);
                return storage_1.default.set(mainKey, updated)
                    .then(() => ts_utils_1.getIn(subKeys, updated));
            });
        });
    }
    getMainKeyAndSubKeys(key) {
        const keys = parseKey(key);
        const mainKey = keys[0];
        const subKeys = keys.slice(1);
        return [mainKey, subKeys];
    }
}
exports.KeyValueData = KeyValueData;


/***/ }),

/***/ 157:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ProxyScheme;
(function (ProxyScheme) {
    ProxyScheme["Http"] = "http";
    ProxyScheme["Https"] = "https";
    ProxyScheme["Socks4"] = "socks4";
    ProxyScheme["Socks5"] = "socks5";
})(ProxyScheme = exports.ProxyScheme || (exports.ProxyScheme = {}));
var FirefoxProxyType;
(function (FirefoxProxyType) {
    FirefoxProxyType["Direct"] = "direct";
    FirefoxProxyType["Http"] = "http";
    FirefoxProxyType["Https"] = "https";
    FirefoxProxyType["Socks4"] = "socks4";
    FirefoxProxyType["Socks5"] = "socks";
})(FirefoxProxyType = exports.FirefoxProxyType || (exports.FirefoxProxyType = {}));


/***/ }),

/***/ 159:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    proxy: {
        notControllable: 'The proxy settings are controlled by other app(s) or extension(s). Please disable or uninstall the apps or extensions in conflict'
    },
    contentHidden: 'Content is hidden during replay'
};


/***/ }),

/***/ 16:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "findSameNameMacro", function() { return /* binding */ findSameNameMacro; });
__webpack_require__.d(__webpack_exports__, "findSamePathMacro", function() { return /* binding */ findSamePathMacro; });
__webpack_require__.d(__webpack_exports__, "findMacrosInFolder", function() { return /* binding */ findMacrosInFolder; });
__webpack_require__.d(__webpack_exports__, "findSameNameTestSuite", function() { return /* binding */ findSameNameTestSuite; });
__webpack_require__.d(__webpack_exports__, "setRoute", function() { return /* binding */ setRoute; });
__webpack_require__.d(__webpack_exports__, "startRecording", function() { return /* binding */ startRecording; });
__webpack_require__.d(__webpack_exports__, "stopRecording", function() { return /* binding */ stopRecording; });
__webpack_require__.d(__webpack_exports__, "startInspecting", function() { return /* binding */ startInspecting; });
__webpack_require__.d(__webpack_exports__, "stopInspecting", function() { return /* binding */ stopInspecting; });
__webpack_require__.d(__webpack_exports__, "startPlaying", function() { return /* binding */ startPlaying; });
__webpack_require__.d(__webpack_exports__, "stopPlaying", function() { return /* binding */ stopPlaying; });
__webpack_require__.d(__webpack_exports__, "doneInspecting", function() { return /* binding */ doneInspecting; });
__webpack_require__.d(__webpack_exports__, "increaseRecordedCount", function() { return /* binding */ increaseRecordedCount; });
__webpack_require__.d(__webpack_exports__, "appendCommand", function() { return /* binding */ appendCommand; });
__webpack_require__.d(__webpack_exports__, "duplicateCommand", function() { return /* binding */ duplicateCommand; });
__webpack_require__.d(__webpack_exports__, "insertCommand", function() { return /* binding */ insertCommand; });
__webpack_require__.d(__webpack_exports__, "updateCommand", function() { return /* binding */ updateCommand; });
__webpack_require__.d(__webpack_exports__, "removeCommand", function() { return /* binding */ removeCommand; });
__webpack_require__.d(__webpack_exports__, "selectCommand", function() { return /* binding */ selectCommand; });
__webpack_require__.d(__webpack_exports__, "cutCommand", function() { return /* binding */ cutCommand; });
__webpack_require__.d(__webpack_exports__, "copyCommand", function() { return /* binding */ copyCommand; });
__webpack_require__.d(__webpack_exports__, "pasteCommand", function() { return /* binding */ pasteCommand; });
__webpack_require__.d(__webpack_exports__, "normalizeCommands", function() { return /* binding */ normalizeCommands; });
__webpack_require__.d(__webpack_exports__, "updateSelectedCommand", function() { return /* binding */ updateSelectedCommand; });
__webpack_require__.d(__webpack_exports__, "toggleComment", function() { return /* binding */ toggleComment; });
__webpack_require__.d(__webpack_exports__, "toggleCommentOnSelectedCommand", function() { return /* binding */ toggleCommentOnSelectedCommand; });
__webpack_require__.d(__webpack_exports__, "setSourceError", function() { return /* binding */ setSourceError; });
__webpack_require__.d(__webpack_exports__, "setSourceCurrent", function() { return /* binding */ setSourceCurrent; });
__webpack_require__.d(__webpack_exports__, "saveSourceCodeToEditing", function() { return /* binding */ saveSourceCodeToEditing; });
__webpack_require__.d(__webpack_exports__, "saveEditingAsExisted", function() { return /* binding */ saveEditingAsExisted; });
__webpack_require__.d(__webpack_exports__, "saveEditingAsNew", function() { return /* binding */ saveEditingAsNew; });
__webpack_require__.d(__webpack_exports__, "setTestCases", function() { return /* binding */ setTestCases; });
__webpack_require__.d(__webpack_exports__, "resetEditing", function() { return /* binding */ resetEditing; });
__webpack_require__.d(__webpack_exports__, "resetEditingIfNeeded", function() { return /* binding */ resetEditingIfNeeded; });
__webpack_require__.d(__webpack_exports__, "setEditing", function() { return /* binding */ setEditing; });
__webpack_require__.d(__webpack_exports__, "editTestCase", function() { return /* binding */ editTestCase; });
__webpack_require__.d(__webpack_exports__, "editNewTestCase", function() { return /* binding */ editNewTestCase; });
__webpack_require__.d(__webpack_exports__, "upsertTestCase", function() { return /* binding */ upsertTestCase; });
__webpack_require__.d(__webpack_exports__, "addTestCases", function() { return /* binding */ addTestCases; });
__webpack_require__.d(__webpack_exports__, "removeTestCase", function() { return /* binding */ removeTestCase; });
__webpack_require__.d(__webpack_exports__, "removeCurrentTestCase", function() { return /* binding */ removeCurrentTestCase; });
__webpack_require__.d(__webpack_exports__, "setPlayerState", function() { return /* binding */ setPlayerState; });
__webpack_require__.d(__webpack_exports__, "setTimeoutStatus", function() { return /* binding */ setTimeoutStatus; });
__webpack_require__.d(__webpack_exports__, "addPlayerWarningCommandIndex", function() { return /* binding */ addPlayerWarningCommandIndex; });
__webpack_require__.d(__webpack_exports__, "addPlayerErrorCommandIndex", function() { return /* binding */ addPlayerErrorCommandIndex; });
__webpack_require__.d(__webpack_exports__, "addLog", function() { return /* binding */ addLog; });
__webpack_require__.d(__webpack_exports__, "clearLogs", function() { return /* binding */ clearLogs; });
__webpack_require__.d(__webpack_exports__, "addScreenshot", function() { return /* binding */ addScreenshot; });
__webpack_require__.d(__webpack_exports__, "clearScreenshots", function() { return /* binding */ clearScreenshots; });
__webpack_require__.d(__webpack_exports__, "addVision", function() { return /* binding */ addVision; });
__webpack_require__.d(__webpack_exports__, "clearVisions", function() { return /* binding */ clearVisions; });
__webpack_require__.d(__webpack_exports__, "updateConfig", function() { return /* binding */ updateConfig; });
__webpack_require__.d(__webpack_exports__, "setMacrosExtra", function() { return /* binding */ setMacrosExtra; });
__webpack_require__.d(__webpack_exports__, "setTestSuitesExtra", function() { return /* binding */ setTestSuitesExtra; });
__webpack_require__.d(__webpack_exports__, "updateMacroExtra", function() { return /* binding */ updateMacroExtra; });
__webpack_require__.d(__webpack_exports__, "updateMacroPlayStatus", function() { return /* binding */ updateMacroPlayStatus; });
__webpack_require__.d(__webpack_exports__, "updateMacroBreakpoints", function() { return /* binding */ updateMacroBreakpoints; });
__webpack_require__.d(__webpack_exports__, "updateMacroDoneCommandsIndices", function() { return /* binding */ updateMacroDoneCommandsIndices; });
__webpack_require__.d(__webpack_exports__, "updateMacroErrorCommandsIndices", function() { return /* binding */ updateMacroErrorCommandsIndices; });
__webpack_require__.d(__webpack_exports__, "updateMacroWarningCommandsIndices", function() { return /* binding */ updateMacroWarningCommandsIndices; });
__webpack_require__.d(__webpack_exports__, "updateProxy", function() { return /* binding */ updateProxy; });
__webpack_require__.d(__webpack_exports__, "commonPlayerState", function() { return /* binding */ commonPlayerState; });
__webpack_require__.d(__webpack_exports__, "playerPlay", function() { return /* binding */ playerPlay; });
__webpack_require__.d(__webpack_exports__, "listCSV", function() { return /* binding */ listCSV; });
__webpack_require__.d(__webpack_exports__, "listScreenshots", function() { return /* binding */ listScreenshots; });
__webpack_require__.d(__webpack_exports__, "listVisions", function() { return /* binding */ listVisions; });
__webpack_require__.d(__webpack_exports__, "renameVisionImage", function() { return /* binding */ renameVisionImage; });
__webpack_require__.d(__webpack_exports__, "setTestSuites", function() { return /* binding */ setTestSuites; });
__webpack_require__.d(__webpack_exports__, "addTestSuite", function() { return /* binding */ addTestSuite; });
__webpack_require__.d(__webpack_exports__, "addTestSuites", function() { return /* binding */ addTestSuites; });
__webpack_require__.d(__webpack_exports__, "removeTestSuite", function() { return /* binding */ removeTestSuite; });
__webpack_require__.d(__webpack_exports__, "setPlayerMode", function() { return /* binding */ setPlayerMode; });
__webpack_require__.d(__webpack_exports__, "runBackup", function() { return /* binding */ runBackup; });
__webpack_require__.d(__webpack_exports__, "setVariables", function() { return /* binding */ setVariables; });
__webpack_require__.d(__webpack_exports__, "updateUI", function() { return /* binding */ updateUI; });
__webpack_require__.d(__webpack_exports__, "addBreakpoint", function() { return /* binding */ addBreakpoint; });
__webpack_require__.d(__webpack_exports__, "removeBreakpoint", function() { return /* binding */ removeBreakpoint; });
__webpack_require__.d(__webpack_exports__, "setEditorActiveTab", function() { return /* binding */ setEditorActiveTab; });
__webpack_require__.d(__webpack_exports__, "preinstall", function() { return /* binding */ preinstall; });

// EXTERNAL MODULE: ./node_modules/antd/lib/message/index.js
var message = __webpack_require__(15);
var message_default = /*#__PURE__*/__webpack_require__.n(message);

// EXTERNAL MODULE: ./src/actions/action_types.js
var action_types = __webpack_require__(21);

// EXTERNAL MODULE: ./src/common/utils.js
var utils = __webpack_require__(4);

// EXTERNAL MODULE: ./src/common/ipc/ipc_cs.js
var ipc_cs = __webpack_require__(20);

// EXTERNAL MODULE: ./src/common/storage/index.js + 1 modules
var common_storage = __webpack_require__(36);

// EXTERNAL MODULE: ./src/services/storage/index.ts
var services_storage = __webpack_require__(13);

// EXTERNAL MODULE: ./src/models/test_case_model.js
var test_case_model = __webpack_require__(114);

// EXTERNAL MODULE: ./src/common/player.js
var player = __webpack_require__(28);

// EXTERNAL MODULE: ./src/services/backup/backup.ts
var backup = __webpack_require__(358);

// EXTERNAL MODULE: ./src/common/log.ts
var log = __webpack_require__(11);
var log_default = /*#__PURE__*/__webpack_require__.n(log);

// EXTERNAL MODULE: ./src/common/convert_utils.js
var convert_utils = __webpack_require__(50);

// EXTERNAL MODULE: ./src/common/convert_suite_utils.js
var convert_suite_utils = __webpack_require__(69);

// EXTERNAL MODULE: ./src/config/index.ts
var src_config = __webpack_require__(34);
var config_default = /*#__PURE__*/__webpack_require__.n(src_config);

// CONCATENATED MODULE: ./src/config/preinstall_macros.js
/* harmony default export */ var preinstall_macros = ({
  "Core/DemoAutofill": {
    "CreationDate": "2020-05-28",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "store",
      "Target": "15",
      "Value": "!TIMEOUT_WAIT"
    }, {
      "Command": "store",
      "Target": "60",
      "Value": "!TIMEOUT_PAGELOAD"
    }, {
      "Command": "open",
      "Target": "https://docs.google.com/forms/d/1cbI5dMRs0-t_IwNzPm6T3lAG_nPgsnJZEA-FEYVARxg/",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"UI.Vision IDE\")]",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//*[text()[contains(.,'Web Testing')]]",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"Form Autofilling\")]",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//*[text()[contains(.,\"General Web Automation\")]]",
      "Value": ""
    }, {
      "Command": "pause",
      "Target": "500",
      "Value": ""
    }, {
      "Command": "captureScreenshot",
      "Target": "AutoFill1stPage${!LOOP}",
      "Value": ""
    }, {
      "Command": "clickAndWait",
      "Target": "xpath=//*[@id=\"mG61Hd\"]/div/div/div[3]/div/div/div/span/span",
      "Value": "",
      "Targets": ["xpath=//*[@id=\"mG61Hd\"]/div/div/div[3]/div/div/div/span/span", "xpath=//*[@id=\"mG61Hd\"]/div[2]/div/div[3]/div/div/div/span/span"]
    }, {
      "Command": "type",
      "Target": "xpath=//input[@type='text']",
      "Value": "This is a single line test..."
    }, {
      "Command": "type",
      "Target": "xpath=//textarea",
      "Value": "...and this a multiline test:\nLine2\nLine3"
    }, {
      "Command": "captureScreenshot",
      "Target": "AutoFill2ndPage${!LOOP}",
      "Value": ""
    }, {
      "Command": "pause",
      "Target": "1000",
      "Value": ""
    }, {
      "Command": "clickAndWait",
      "Target": "xpath=//*[@id=\"mG61Hd\"]/div/div/div[3]/div[1]/div[1]/div[2]/span/span",
      "Value": ""
    }, {
      "Command": "captureScreenshot",
      "Target": "AutoFill3rdPage${!LOOP}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "DemoAutofill macro completed (shown as notification because of #shownotification in the 3rd column)",
      "Value": "#shownotification"
    }, {
      "Command": "comment",
      "Target": "Open form filling tutorial page",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/rpa/docs/selenium-ide/form-filling",
      "Value": ""
    }, {
      "Command": "assertTitle",
      "Target": "*Form Filling*",
      "Value": ""
    }]
  },
  "Core/DemoDragDrop": {
    "CreationDate": "2017-10-18",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/demo/webtest/dragdrop/",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Reduce replay speed so we can better see what is going on...",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "medium",
      "Value": "!replayspeed"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=one",
      "Value": "id=bin"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=two",
      "Value": "id=bin"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=three",
      "Value": "id=bin"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=four",
      "Value": "id=bin"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=five",
      "Value": "id=bin"
    }]
  },
  "Core/DemoDownload": {
    "CreationDate": "2018-11-23",
    "Commands": [{
      "Command": "store",
      "Target": "60",
      "Value": "!timeout_download"
    }, {
      "Command": "store",
      "Target": "10",
      "Value": "!timeout_wait"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var d=new Date(); return d.getFullYear() + '-' +((d.getMonth()+1))+'-' +d.getDate();",
      "Value": "todaydate"
    }, {
      "Command": "echo",
      "Target": "Today is ${todaydate}",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/filedownload",
      "Value": ""
    }, {
      "Command": "onDownload",
      "Target": "DownloadTest1_${todaydate}.exe",
      "Value": "true"
    }, {
      "Command": "store",
      "Target": "${!runtime}",
      "Value": "starttime"
    }, {
      "Command": "click",
      "Target": "linkText=XModules for Windows",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "File name on disk is ${!LAST_DOWNLOADED_FILE_NAME}",
      "Value": "blue"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return parseFloat(${!runtime})-parseFloat(${starttime})",
      "Value": "downloadtime"
    }, {
      "Command": "echo",
      "Target": "Download1 (Windows version) took ${downloadtime} seconds",
      "Value": "blue"
    }, {
      "Command": "onDownload",
      "Target": "DownloadTest2_${todaydate}.exe",
      "Value": "true"
    }, {
      "Command": "store",
      "Target": "${!runtime}",
      "Value": "starttime"
    }, {
      "Command": "click",
      "Target": "partialLinkText=for macOS",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "File name on disk is ${!LAST_DOWNLOADED_FILE_NAME}",
      "Value": "green"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return parseFloat(${!runtime})-parseFloat(${starttime})",
      "Value": "downloadtime"
    }, {
      "Command": "echo",
      "Target": "Download2 (Mac) took ${downloadtime} seconds",
      "Value": "green"
    }, {
      "Command": "echo",
      "Target": "All done...",
      "Value": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=OnDownload command",
      "Value": ""
    }]
  },
  "Core/DemoExtract": {
    "CreationDate": "2018-05-28",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/executescript",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Current page URL = ${!URL}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Current loop value = ${!LOOP}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "This macro shows various methods to extract and save data from a website",
      "Value": ""
    }, {
      "Command": "storeAttribute",
      "Target": "css=img.responsive-img@src",
      "Value": "mylink"
    }, {
      "Command": "echo",
      "Target": "href=${mylink}",
      "Value": ""
    }, {
      "Command": "storeAttribute",
      "Target": "css=img.responsive-img@alt",
      "Value": "myalttext"
    }, {
      "Command": "echo",
      "Target": "alt text = ${myalttext}",
      "Value": ""
    }, {
      "Command": "storeAttribute",
      "Target": "//input[@id='sometext']@size",
      "Value": "boxsize"
    }, {
      "Command": "echo",
      "Target": "input box size =${boxsize}",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "This box is ${boxsize} chars wide"
    }, {
      "Command": "executeScript",
      "Target": "document.title = ${boxsize};",
      "Value": ""
    }, {
      "Command": "assertTitle",
      "Target": "70",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[3]",
      "Value": ""
    }, {
      "Command": "storeText",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[3]",
      "Value": "myheader"
    }, {
      "Command": "echo",
      "Target": "header = ${myheader}",
      "Value": ""
    }, {
      "Command": "storeTitle",
      "Target": "",
      "Value": "mytitle"
    }, {
      "Command": "echo",
      "Target": "page title = ${mytitle}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "page title = ${mytitle}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "page title = ${mytitle}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "page title = ${mytitle}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Now test some extraction with storeValue",
      "Value": ""
    }, {
      "Command": "storeValue",
      "Target": "id=sometext",
      "Value": "mytext"
    }, {
      "Command": "select",
      "Target": "id=tesla",
      "Value": "label=Model Y"
    }, {
      "Command": "storeValue",
      "Target": "id=tesla",
      "Value": "mytesla"
    }, {
      "Command": "echo",
      "Target": "The text box contains [${mytext}] and the select box has the value [${mytesla}] selected",
      "Value": ""
    }, {
      "Command": "verifyValue",
      "Target": "id=tesla",
      "Value": "y"
    }, {
      "Command": "storeChecked",
      "Target": "name=vehicle",
      "Value": "hasbike"
    }, {
      "Command": "storeChecked",
      "Target": "xpath=(//input[@name='vehicle'])[2]",
      "Value": "hascar"
    }, {
      "Command": "storeChecked",
      "Target": "xpath=(//input[@name='vehicle'])[3]",
      "Value": "hasboat"
    }, {
      "Command": "echo",
      "Target": "User has bike:${hasbike}, car:${hascar}, boat:${hasboat}",
      "Value": "green"
    }, {
      "Command": "comment",
      "Target": "Search and extract directly from the page SOURCE",
      "Value": "y"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=[\\$\\\\](\\d+(?:\\.\\d{1,2})?)",
      "Value": "match1"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=[\\$\\\\](\\d+(?:\\.\\d{1,2})?)@2",
      "Value": "match2"
    }, {
      "Command": "comment",
      "Target": "You can also extract without regex with the * symbol",
      "Value": "match2b"
    }, {
      "Command": "sourceExtract",
      "Target": "$*<",
      "Value": "match2b"
    }, {
      "Command": "echo",
      "Target": "Coffee costs ${match1} and tea ${match2}",
      "Value": "blue"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=_width: (\\d+)",
      "Value": "match1"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=_width: (\\d+)@1,1",
      "Value": "match1group1"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=_width: (\\d+)@2",
      "Value": "match2"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=_width: (\\d+)@2,1",
      "Value": "match2group1"
    }, {
      "Command": "echo",
      "Target": "match1 = [${MATCH1}] (group1 = [${match1group1}]) match2 =  [${MATCH2}]  (group1 = [${MATCH2GROUP1}])",
      "Value": "blue"
    }, {
      "Command": "comment",
      "Target": "Extract Google Analytics ID",
      "Value": ""
    }, {
      "Command": "sourceExtract",
      "Target": "UA-*,",
      "Value": "ga_option1"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=UA-[0-9]+-[0-9]+",
      "Value": "ga_option2"
    }, {
      "Command": "echo",
      "Target": "Google Analytics ID = ${ga_option2}",
      "Value": "pink"
    }, {
      "Command": "comment",
      "Target": "Some assertion test for QA",
      "Value": ""
    }, {
      "Command": "if_v2",
      "Target": "${match2group1} != 22",
      "Value": ""
    }, {
      "Command": "throwError",
      "Target": "Regex Extraction failed for Match2(1):  ${match2group1}",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Last but not least, taking a screenshot is another way to extract data",
      "Value": ""
    }, {
      "Command": "captureScreenshot",
      "Target": "myscreenshot_${mytitle}",
      "Value": ""
    }, {
      "Command": "storeImage",
      "Target": "//*[@id=\"page-header\"]/div/div/h1",
      "Value": "pagetitle.png"
    }, {
      "Command": "comment",
      "Target": "Export images to download folder",
      "Value": ""
    }, {
      "Command": "localStorageExport",
      "Target": "myscreenshot_${mytitle}.png",
      "Value": ""
    }, {
      "Command": "localStorageExport",
      "Target": "pagetitle.png",
      "Value": ""
    }]
  },
  "Core/DemoFrames": {
    "CreationDate": "2020-05-27",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/demo/webtest/frames/",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Reduce replay speed so we can better see what is going on...",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "medium",
      "Value": "!replayspeed"
    }, {
      "Command": "selectFrame",
      "Target": "index=0",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "name=mytext1",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "name=mytext1",
      "Value": "Frame1 (index=0)"
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=1",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "name=mytext2",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "name=mytext2",
      "Value": "Frame2 (index=1)"
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=2",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "name=mytext3",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "name=mytext3",
      "Value": "Frame3 (index=2)"
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=3",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "name=mytext4",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "name=mytext4",
      "Value": "Frame4 (index=3)"
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=4",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "name=mytext5",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "name=mytext5",
      "Value": "Frame5 (index=4)"
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=2",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "name=mytext3",
      "Value": "now testing iframe inside this frame"
    }, {
      "Command": "selectFrame",
      "Target": "index=0",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"UI.Vision IDE\")]",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "css=input.quantumWizTextinputSimpleinputInput.exportInput",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "css=input.quantumWizTextinputSimpleinputInput.exportInput",
      "Value": "iframe in frame: works!"
    }, {
      "Command": "clickAndWait",
      "Target": "xpath=//div[3]/div/div/div/span",
      "Value": "",
      "Targets": ["xpath=//*[@id=\"mG61Hd\"]/div[2]/div/div[3]/div/div/div/span", "xpath=//div[3]/div/div/div/span"]
    }, {
      "Command": "type",
      "Target": "name=entry.1572386418",
      "Value": "Form Filling Test Done!"
    }, {
      "Command": "click",
      "Target": "xpath=//*[@id=\"mG61Hd\"]/div/div/div[3]/div[1]/div[1]/div[2]/span/span",
      "Value": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=2",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "name=mytext3",
      "Value": "Test completed!"
    }]
  },

  "Core/DemoTakeScreenshots": {
    "CreationDate": "2018-1-25",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/blog/",
      "Value": ""
    }, {
      "Command": "captureEntirePageScreenshot",
      "Target": "rpablog",
      "Value": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=read more@POS=1",
      "Value": ""
    }, {
      "Command": "captureEntirePageScreenshot",
      "Target": "article1",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/blog/",
      "Value": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=read more@POS=2",
      "Value": ""
    }, {
      "Command": "captureEntirePageScreenshot",
      "Target": "article2",
      "Value": ""
    }, {
      "Command": "captureScreenshot",
      "Target": "article2_just_viewport",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "take screenshot of an _element_ with storeImage",
      "Value": ""
    }, {
      "Command": "storeImage",
      "Target": "partialLinkText=Blog",
      "Value": "blogtitle"
    }]
  },
  "Core/DemoIfElse": {
    "CreationDate": "2018-4-28",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/executeScript",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "How to use gotoIf and label(s) for flow control. For a while/endWhile demo, see the DemoSaveCSV macro.",
      "Value": ""
    }, {
      "Command": "executeScript",
      "Target": "return (new Date().getHours())",
      "Value": "mytime"
    }, {
      "Command": "echo",
      "Target": "mytime = ${mytime}",
      "Value": ""
    }, {
      "Command": "if_v2",
      "Target": "${mytime}  > 16",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Good afternoon!",
      "Value": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Good morning!",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "storeAttribute",
      "Target": "//input[@id='sometext-WRONG-ID-TEST']@size",
      "Value": "boxsize"
    }, {
      "Command": "if_v2",
      "Target": "${boxsize} == \"#LNF\"",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "The xpath was not found. In this case the variable gets filled with #LNF (Locator Not Found).",
      "Value": "blue"
    }, {
      "Command": "storeAttribute",
      "Target": "//input[@id='sometext']@size",
      "Value": "boxsize"
    }, {
      "Command": "echo",
      "Target": "With correct Xpath ID we get: Boxsize = ${boxsize}",
      "Value": "green"
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "gotoIf_v2",
      "Target": "${boxsize} > 70",
      "Value": "BOX-TOO-BIG"
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "This box is ${boxsize} chars wide"
    }, {
      "Command": "executeScript",
      "Target": "document.title = ${boxsize};",
      "Value": ""
    }, {
      "Command": "gotoLabel",
      "Target": "END",
      "Value": ""
    }, {
      "Command": "label",
      "Target": "BOX-TOO-BIG",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Input box too big. This is just a test of gotoIf",
      "Value": ""
    }, {
      "Command": "executeScript",
      "Target": "document.title = \"Just a gotoIf test. This line should not be reached unless you edit the macro\"",
      "Value": ""
    }, {
      "Command": "label",
      "Target": "END",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "test case completed",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "",
      "Value": ""
    }, {
      "Command": "onError",
      "Target": "#goto",
      "Value": "fixerror"
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "this line works"
    }, {
      "Command": "type",
      "Target": "id=sometextXXXXX",
      "Value": "this line has the wrong ID..."
    }, {
      "Command": "echo",
      "Target": "this line is never reached, because of the error above",
      "Value": "blue"
    }, {
      "Command": "gotoLabel",
      "Target": "end-part2",
      "Value": ""
    }, {
      "Command": "label",
      "Target": "fixerror",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "here we can have code that handles the error..",
      "Value": "green"
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "Fix Error Section: This command works."
    }, {
      "Command": "label",
      "Target": "end-part2",
      "Value": ""
    }]
  },
  "Core/DemoIframe": {
    "CreationDate": "2020-8-8",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/demo/iframes",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//*[@id=\"content\"]/div[2]/div/p[1]",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[1]",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "First iframe: Embedded Google Doc",
      "Value": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=0",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"UI.Vision IDE\")]",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"Web Testing\")]",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"Form Autofilling\")]",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"General Web Automation\")]",
      "Value": ""
    }, {
      "Command": "clickAndWait",
      "Target": "css=span.quantumWizButtonPaperbuttonLabel.exportLabel",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "xpath=//input[@type='text']",
      "Value": "This is the iframe web automation test."
    }, {
      "Command": "click",
      "Target": "xpath=//div[3]/div/div/div/span/span",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "xpath=//div[2]/span/span",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Back to main page (top frame)",
      "Value": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": ""
    }]
  },
  "Core/DemoImplicitWaiting": {
    "CreationDate": "2019-8-5",
    "Commands": [{
      "Command": "comment",
      "Target": "waitForElementVisible is not part of implicit waiting",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/waitforelementvisible",
      "Value": ""
    }, {
      "Command": "waitForElementVisible",
      "Target": "css=#div1 > h1",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "css=#div1 > h1",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "20",
      "Value": "!timeout_wait"
    }, {
      "Command": "waitForElementVisible",
      "Target": "css=#div2 > h1",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "css=#div2 > h1",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Implicit waiting: Wait for elements to be loaded  or <timeout_wait> is reached",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/webtest/implicitwaiting/",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "15",
      "Value": "!TIMEOUT_WAIT"
    }, {
      "Command": "assertText",
      "Target": "/html/body/header/center/p[2]",
      "Value": "Use the select box to start the timer..."
    }, {
      "Command": "select",
      "Target": "id=minutesSelect",
      "Value": "label=5 Seconds"
    }, {
      "Command": "echo",
      "Target": "The next element (target) is not available yet... UI.Vision RPA waits for it up to ${!TIMEOUT_WAIT} seconds to appear.",
      "Value": "blue"
    }, {
      "Command": "click",
      "Target": "/html/body/header/center/img",
      "Value": ""
    }]
  },
  "Core/DemoCsvReadWithLoop": {
    "CreationDate": "2019-03-23",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "comment",
      "Target": "The file ReadCSVTestData.csv is pre-installed with UI.Vision RPA.",
      "Value": ""
    }, {
      "Command": "csvRead",
      "Target": "ReadCSVTestData.csv",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Call subroutine for the actual form filling",
      "Value": ""
    }, {
      "Command": "run",
      "Target": "Sub/Sub_DemoCsvRead_FillForm",
      "Value": ""
    }]
  },
  "Core/DemoCsvReadWithWhile": {
    "CreationDate": "2018-1-25",
    "Commands": [{
      "Command": "store",
      "Target": "180",
      "Value": "!timeout_macro"
    }, {
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "comment",
      "Target": "The file ReadCSVTestData.csv is pre-installed with UI.Vision RPA.",
      "Value": ""
    }, {
      "Command": "csvRead",
      "Target": "ReadCSVTestData.csv",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Status = ${!csvReadStatus}, line = ${!csvReadLineNumber}",
      "Value": ""
    }, {
      "Command": "while_v2",
      "Target": "${!csvReadStatus} == \"OK\"",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "status = ${!csvReadStatus}, line = ${!csvReadLineNumber}",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Call subroutine for the actual form filling",
      "Value": ""
    }, {
      "Command": "run",
      "Target": "Sub/Sub_DemoCsvRead_FillForm",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number(${!csvReadLineNumber})+1",
      "Value": "!csvReadLineNumber"
    }, {
      "Command": "store",
      "Target": "true",
      "Value": "!errorIgnore"
    }, {
      "Command": "echo",
      "Target": "Reading CSV line No.  ${!csvReadLineNumber} ",
      "Value": "!errorIgnore"
    }, {
      "Command": "csvRead",
      "Target": "ReadCSVTestData.csv",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "false",
      "Value": "!errorIgnore"
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }]
  },
  "Core/DemoCsvReadArray": {
    "CreationDate": "2020-03-23",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "comment",
      "Target": "Create an array and save the content to a CSV file",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var arr = []; for(var x = 0; x < 5; x++){arr[x] = []; for(var y = 0; y < 3; y++){arr[x][y] = (x+1)*(y+1);}}; return arr",
      "Value": "array1"
    }, {
      "Command": "comment",
      "Target": "Manually set two array values ",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var newArr = ${array1}; newArr[0][2] = 'Hello World'; return newArr",
      "Value": "array1"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var newArr = ${array1}; newArr[2][1] = 'This is how you set an array value'; return newArr",
      "Value": "array1"
    }, {
      "Command": "csvSaveArray",
      "Target": "array1",
      "Value": "data_from_array.csv"
    }, {
      "Command": "comment",
      "Target": "Read the array again from csv file",
      "Value": ""
    }, {
      "Command": "csvReadArray",
      "Target": "data_from_array.csv",
      "Value": "myCSV"
    }, {
      "Command": "echo",
      "Target": "Number of rows = ${!CsvReadMaxRow}",
      "Value": "green"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${mycsv[0]}.length;",
      "Value": "col"
    }, {
      "Command": "echo",
      "Target": "Number of columns = ${col}",
      "Value": "pink"
    }, {
      "Command": "comment",
      "Target": "loop over all CSV values",
      "Value": ""
    }, {
      "Command": "forEach",
      "Target": "myCSV",
      "Value": "row"
    }, {
      "Command": "echo",
      "Target": "col1=${row[0]}, col2=${row[1]}, col3=${row[2]}",
      "Value": "brown"
    }, {
      "Command": "forEach",
      "Target": "row",
      "Value": "elem"
    }, {
      "Command": "echo",
      "Target": "Element=${elem}",
      "Value": "blue"
    }, {
      "Command": "end",
      "Target": "row",
      "Value": "elem"
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Another way to loop over the array content",
      "Value": ""
    }, {
      "Command": "times",
      "Target": "${!CsvReadMaxRow}",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Substract 1 from !times, as the array index starts with 0",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!times} - 1;",
      "Value": "i"
    }, {
      "Command": "echo",
      "Target": "Row ${i}, 3rd Element => ${myCSV[${i}][2]}",
      "Value": "blue"
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }]
  },

  "Core/DemoCsvSave": {
    "CreationDate": "2018-06-01",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/csvsave",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var d = new Date(); m = d.getFullYear()+\"-\"+(d.getMonth()+1)+\"-\"+ d.getDate()+\" \"+ d.getHours()+\":\" + d.getMinutes() + \":\" + d.getSeconds(); return m",
      "Value": "timestamp"
    }, {
      "Command": "store",
      "Target": "${timestamp}",
      "Value": "!csvLine"
    }, {
      "Command": "echo",
      "Target": "First column in the CSV is time (${timestamp})",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Set i = 1 as we start the extraction with the 2nd table cell.",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "1",
      "Value": "i"
    }, {
      "Command": "while_v2",
      "Target": "(${i} < 8)",
      "Value": ""
    }, {
      "Command": "executeScript",
      "Target": "return Number (${i}) + 1",
      "Value": "i"
    }, {
      "Command": "echo",
      "Target": "Current value of i = ${i}",
      "Value": "i"
    }, {
      "Command": "storeText",
      "Target": "//*[@id=\"gcw_mainFNGP5XSu6\"]/div[2]/table/tbody/tr[2]/td[${i}]/a",
      "Value": "c2"
    }, {
      "Command": "store",
      "Target": "${c2}",
      "Value": "!csvLine"
    }, {
      "Command": "echo",
      "Target": "Extracted Value for i=${i} is exchange rate = ${c2}",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "${!csvLine}",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Append content of !csvLine to CSV file (or create file if none exists)",
      "Value": ""
    }, {
      "Command": "csvSave",
      "Target": "CurrencyConverterData",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "If needed, you can download (save) the CSV data from the CSV tab to the the download folder",
      "Value": ""
    }, {
      "Command": "localStorageExport",
      "Target": "currencyconverterdata.csv",
      "Value": ""
    }]
  },
  "XModules/DemoPDFTest_with_OCR": {
    "CreationDate": "2019-01-18",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "if_v2",
      "Target": "${!browser} ==\"firefox\"",
      "Value": ""
    }, {
      "Command": "throwError",
      "Target": "This macro works only in Chrome and Edge - Firefox does not support automating PDF documents yet.",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "http://download.ui.vision/demo/pdf-test.pdf",
      "Value": ""
    }, {
      "Command": "setWindowSize",
      "Target": "800x700",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Check that PDF is loaded OK",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Option 1: Check with image search",
      "Value": ""
    }, {
      "Command": "visualAssert",
      "Target": "pdftest_salesquote.png@0.35",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Option 2: Check with text search  search",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "ENG",
      "Value": "!ocrlanguage"
    }, {
      "Command": "OCRSearch",
      "Target": "sales quote",
      "Value": "matches"
    }, {
      "Command": "echo",
      "Target": "Number of matches: ${matches}",
      "Value": "green"
    }, {
      "Command": "if_v2",
      "Target": "${matches} == \"0\"",
      "Value": ""
    }, {
      "Command": "throwError",
      "Target": "Something wrong, I can not find the text <sales quote>",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Now extract the quote number and check that it is the correct one",
      "Value": ""
    }, {
      "Command": "OCRExtractRelative",
      "Target": "getquotenumber_dpi_96_relative.png@0.30",
      "Value": "q"
    }, {
      "Command": "echo",
      "Target": "Extracted text in pink area: >${q}<",
      "Value": "blue"
    }, {
      "Command": "executeScript",
      "Target": "return ${q}.replace(/( |\\n|\\r)/gm, \"\")",
      "Value": "q"
    }, {
      "Command": "echo",
      "Target": "Remove space(s) and line break(s): Quote Number: >${q}<",
      "Value": "green"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var string = ${q}, substring = \"135\";  b= string.includes(substring); return b;",
      "Value": "textfound"
    }, {
      "Command": "if_v2",
      "Target": "${textfound} == true",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Quote number OK",
      "Value": "green"
    }, {
      "Command": "else",
      "Target": "",
      "Value": ""
    }, {
      "Command": "throwError",
      "Target": "Wrong quote number",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "The X... commands require the RealUser XModule to be installed",
      "Value": ""
    }, {
      "Command": "pause",
      "Target": "500",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Click on the document to give it the focus. For this, we click on the word \"SALES QUOTE\".",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "ocr=sales quote",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Scroll down to next page",
      "Value": ""
    }, {
      "Command": "if_v2",
      "Target": "${!os}==\"mac\"",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Page scroll in macOS is CMD key + Down",
      "Value": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_CMD+KEY_DOWN}",
      "Value": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Page scroll in Windows and Linux is PAGE DOWN key",
      "Value": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_PAGE_DOWN}${KEY_PAGE_DOWN}",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Find link image and click it",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Wait 0.5 seconds for the PDF to complete scrolling. Otherwise if the Xclick image is found while the PDF still scrolls, the click goes to the wrong location.",
      "Value": ""
    }, {
      "Command": "pause",
      "Target": "500",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "ocr=website",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Check the right page is loaded (here: check logo is there)",
      "Value": ""
    }, {
      "Command": "assertElementPresent",
      "Target": "//*[@id=\"logo\"]/img",
      "Value": ""
    }]
  },
  "Core/DemoExecuteScript": {
    "CreationDate": "2020-8-1",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/executescript",
      "Value": ""
    }, {
      "Command": "assertText",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[1]",
      "Value": "Input box to display some results"
    }, {
      "Command": "verifyText",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[1]",
      "Value": "Input box to display some results"
    }, {
      "Command": "verifyTitle",
      "Target": "Selenium IDE executeScript Demo Page",
      "Value": ""
    }, {
      "Command": "assertTitle",
      "Target": "Selenium IDE executeScript Demo Page",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "executeScript can run Javascript... and store the result in a variable (optional)",
      "Value": ""
    }, {
      "Command": "executeScript",
      "Target": "function randomString(length, chars) {\n    var result = '';\n    for (var i = length; i > 0; --i) result += chars[Math.round(Math.random() * (chars.length - 1))];\n    return result;\n}\n\n//The executeScript script(s) can have multiple lines!\n\n//Demo: Here we generate a random key \nvar s = randomString(8, '0123456789ABCDE') + \"<= Random String\";\n\n//Set the page title to the random key \ndocument.title = s;\n\nreturn s;\n",
      "Value": "s"
    }, {
      "Command": "assertTitle",
      "Target": "${s}",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Use sourceSearch to assert we have the right Google Analytics Code",
      "Value": ""
    }, {
      "Command": "sourceSearch",
      "Target": "UA-86195842-1",
      "Value": "matches"
    }, {
      "Command": "if_v2",
      "Target": "${matches} == 0",
      "Value": ""
    }, {
      "Command": "throwError",
      "Target": "Google Analytics ID is wrong!",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "First some basic calculations with STORE",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "15",
      "Value": "AAA"
    }, {
      "Command": "store",
      "Target": "10",
      "Value": "BBB"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return (Number (${AAA}) - Number (${BBB}) )",
      "Value": "CCC"
    }, {
      "Command": "echo",
      "Target": "${CCC}",
      "Value": ""
    }, {
      "Command": "executeScript",
      "Target": "document.title = ${CCC};",
      "Value": ""
    }, {
      "Command": "assertTitle",
      "Target": "5",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "SELenium IDe",
      "Value": "AAA"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${AAA}.toUpperCase()",
      "Value": "CCC"
    }, {
      "Command": "echo",
      "Target": "${CCC}",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "${CCC}"
    }, {
      "Command": "echo",
      "Target": "Generate TODAYs date in in YYYY-MM-DD format ",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Create today's date in the YYYY-MM-DD format",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var d = new Date(); \nvar m = ((d.getMonth()+1)<10)?'0'+(d.getMonth()+1):(d.getMonth()+1);\nvar d2 = (d.getDate() <10)?'0'+d.getDate():d.getDate(); \nvar date_today = d.getFullYear()+\"-\"+m+\"-\"+d2; \nreturn date_today",
      "Value": "mydate"
    }, {
      "Command": "echo",
      "Target": "Today is ${mydate}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Pick a random item from a list, useful for data-driven testing",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return new Array ('cat','dog','fish','dog','deer','frog','whale','dog','seal','horse','elephant')",
      "Value": "names"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${names}.length",
      "Value": "len"
    }, {
      "Command": "echo",
      "Target": "array length = ${len}",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Math.floor(Math.random()*${len})",
      "Value": "num"
    }, {
      "Command": "echo",
      "Target": "num=${num}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "The next command picks the random item",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${names}[${num}]",
      "Value": "myrandomname"
    }, {
      "Command": "store",
      "Target": "Today is ${mydate}, and we draw a ${myrandomname}",
      "Value": "output"
    }, {
      "Command": "echo",
      "Target": "To is ${mydate}, and we draw a ${myrandomname}",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "${output}"
    }, {
      "Command": "if_v2",
      "Target": "parseFloat(${!runtime}) > 20",
      "Value": ""
    }, {
      "Command": "throwError",
      "Target": "Runtime too slow (${!runtime} seconds), test failed",
      "Value": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Runtime Ok, test passed!",
      "Value": "green"
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "With @POS you click on the (in this case) 3rd link with the same name. Great for looping over a list of links with the same name.",
      "Value": "green"
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=This link@POS=3",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Demo: Create array and then loop over it with forEach",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var arr = [\"Hello\",\"World\", \"2020\"]; \nreturn arr;",
      "Value": "myarray"
    }, {
      "Command": "forEach",
      "Target": "myarray",
      "Value": "elem"
    }, {
      "Command": "echo",
      "Target": "${elem}",
      "Value": "blue"
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }]
  },
  "Core/DemoTabs": {
    "CreationDate": "2017-10-15",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/demo/tabs",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "linkText=Open new web page in new browser tab",
      "Value": ""
    }, {
      "Command": "selectWindow",
      "Target": "tab=1",
      "Value": ""
    }, {
      "Command": "assertTitle",
      "Target": "*1* TAB1",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "id=sometext1",
      "Value": "this is tab 1"
    }, {
      "Command": "click",
      "Target": "linkText=Open yet another web page in a new browser tab",
      "Value": ""
    }, {
      "Command": "selectWindow",
      "Target": "tab=2",
      "Value": ""
    }, {
      "Command": "assertTitle",
      "Target": "*2* TAB2",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "id=sometext2",
      "Value": "And this is tab 2!"
    }, {
      "Command": "selectWindow",
      "Target": "tab=1",
      "Value": ""
    }, {
      "Command": "assertTitle",
      "Target": "*1* TAB1",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "id=sometext1",
      "Value": "Now back in tab 1 - test done!"
    }, {
      "Command": "comment",
      "Target": "We can also open new tabs",
      "Value": ""
    }, {
      "Command": "selectWindow",
      "Target": "tab=open",
      "Value": "https://ui.vision"
    }, {
      "Command": "selectWindow",
      "Target": "tab=open",
      "Value": "https://ocr.space"
    }, {
      "Command": "type",
      "Target": "id=imageUrl",
      "Value": "UI.Vision RPA Tab Test done"
    }]
  },
  "Core/DemoVisualUITest": {
    "CreationDate": "2018-6-26",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/",
      "Value": ""
    }, {
      "Command": "setWindowSize",
      "Target": "1024x768",
      "Value": ""
    }, {
      "Command": "visualVerify",
      "Target": "uitest_logo_wide_dpi_96.png@0.70",
      "Value": ""
    }, {
      "Command": "visualAssert",
      "Target": "uitest_download_dpi_96.png@0.70",
      "Value": ""
    }, {
      "Command": "visualVerify",
      "Target": "uitest_share_dpi_96.png@0.70",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Resize to iPhone6 screen size",
      "Value": ""
    }, {
      "Command": "setWindowSize",
      "Target": "375x768",
      "Value": ""
    }, {
      "Command": "visualVerify",
      "Target": "uitest_logo_mobile_dpi_96.png",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Missing menu is critical, so we use ASSERT (instead of just VERIFY)",
      "Value": ""
    }, {
      "Command": "visualAssert",
      "Target": "uitest_hamburger_dpi_96.png",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Check that Share buttons do not show",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "At this point, page is surely loaded => reduce wait for (normally missing) image",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "2",
      "Value": "!timeout_wait"
    }, {
      "Command": "visualSearch",
      "Target": "uitest_share_dpi_96.png@0.70",
      "Value": "count"
    }, {
      "Command": "if_v2",
      "Target": "${count} > 0",
      "Value": ""
    }, {
      "Command": "throwError",
      "Target": "Share buttons should NOT show on mobile phones",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Restore default wait (not really needed here, since macro stops now anyway)",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "10",
      "Value": "!timeout_wait"
    }, {
      "Command": "comment",
      "Target": "Done, enlarge browser again",
      "Value": ""
    }, {
      "Command": "setWindowSize",
      "Target": "1024x768",
      "Value": ""
    }]
  },
  "XModules/DemoXType": {
    "CreationDate": "2019-01-28",
    "Commands": [{
      "Command": "store",
      "Target": "medium",
      "Value": "!replayspeed"
    }, {
      "Command": "comment",
      "Target": "Make sure the browser is in the foreground, so it receives the XTYPE keystrokes",
      "Value": ""
    }, {
      "Command": "bringBrowserToForeground",
      "Target": "",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/xtype",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "To save the page, open the browser save dialog with a shortcut",
      "Value": ""
    }, {
      "Command": "if_v2",
      "Target": "${!os}==\"mac\"",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Save web page in macOS is CMD+S",
      "Value": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_CMD+KEY_S}",
      "Value": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Save web page in Windows and Linux is CTRL+S",
      "Value": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_CTRL+KEY_S}",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Generate today's date and time ",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var d= new Date(); var m=((d.getMonth()+1)<10)?'0'+(d.getMonth()+1):(d.getMonth()+1); m = d.getFullYear()+\"-\"+m+\"-\"+d.getDate(); return m",
      "Value": "mydate"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return new Date().getHours()+\"-\" + new Date().getMinutes() + \"-\" + new Date().getSeconds()",
      "Value": "mytime"
    }, {
      "Command": "echo",
      "Target": "Today is ${mydate}, and the time is ${mytime}",
      "Value": "blue"
    }, {
      "Command": "comment",
      "Target": "Wait for the dialog to appear before sending the next keystrokes",
      "Value": ""
    }, {
      "Command": "pause",
      "Target": "2000",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Send the new file name to the dialog and press ENTER",
      "Value": "blue"
    }, {
      "Command": "XType",
      "Target": "Page_saved_by_UiVision_${mydate}_${mytime}",
      "Value": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_ENTER}",
      "Value": ""
    }]
  },

  "XModules/DemoXRun": {
    "CreationDate": "2019-09-16",
    "Commands": [{
      "Command": "echo",
      "Target": "This demo macro uses hard-coded paths for the default calculator app. But the correct path depends on your operating system version and language. So the default path in this macro might be wrong and needs to be adjusted.",
      "Value": "blue"
    }, {
      "Command": "if_v2",
      "Target": "${!os}==\"mac\"",
      "Value": ""
    }, {
      "Command": "XRun",
      "Target": "/Applications/Calculator.app/Contents/MacOS/Calculator",
      "Value": ""
    }, {
      "Command": "elseif",
      "Target": "${!os}==\"linux\"",
      "Value": ""
    }, {
      "Command": "XRun",
      "Target": "/snap/bin/gnome-calculator",
      "Value": ""
    }, {
      "Command": "elseif",
      "Target": "${!os}==\"windows\"",
      "Value": ""
    }, {
      "Command": "XRun",
      "Target": "C:\\Windows\\System32\\calc.exe",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "You find the example PowerShell script for this demo in the UI.Vision docs for \"XRunAndWait\"",
      "Value": "-executionpolicy bypass -File  c:\\test\\test1.ps1  c:\\test\\test.txt Hello"
    }, {
      "Command": "comment",
      "Target": "XRunAndWait // Powershell.exe ",
      "Value": "-executionpolicy bypass -File  c:\\test\\test1.ps1  c:\\test\\test.txt Hello"
    }, {
      "Command": "comment",
      "Target": "echo // Exitcode = ${!xrun_exitcode}  (Note: The exit code is only captured if you use XRunAndWait)",
      "Value": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "This should never happen",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Calculator app launched ",
      "Value": ""
    }]
  },

  "XModules/DemoXClick": {
    "CreationDate": "2021-02-01",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/draw",
      "Value": ""
    }, {
      "Command": "bringBrowserToForeground",
      "Target": "",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "linkText=this link",
      "Value": ""
    }, {
      "Command": "pause",
      "Target": "1000",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Check we are on the right page",
      "Value": ""
    }, {
      "Command": "visualAssert",
      "Target": "draw_plus1_dpi_96.png",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Click the plus icon to start a new drawing",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "draw_plus1_dpi_96.png",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "draw_create1_dpi_96.png",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "We use a relative click, since the pencil icon can change shape",
      "Value": ""
    }, {
      "Command": "XClickRelative",
      "Target": "draw_select_pencil1_dpi_96.png",
      "Value": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_ESC}",
      "Value": ""
    }, {
      "Command": "XClickRelative",
      "Target": "draw_start1_dpi_96.png",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Starting point: x=${!imagex} y=${!imagey}",
      "Value": "green"
    }, {
      "Command": "store",
      "Target": "${!imagex}",
      "Value": "x"
    }, {
      "Command": "store",
      "Target": "${!imagey}",
      "Value": "y"
    }, {
      "Command": "comment",
      "Target": "Draw top line --->",
      "Value": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#down"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${x}) +100",
      "Value": "x"
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#move"
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#up"
    }, {
      "Command": "comment",
      "Target": "Draw right line down",
      "Value": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#down"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${y}) +100",
      "Value": "y"
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#move"
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#up"
    }, {
      "Command": "comment",
      "Target": "Draw bottom line <---",
      "Value": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#down"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${x}) - 100",
      "Value": "x"
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#move"
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#up"
    }, {
      "Command": "comment",
      "Target": "Draw left line up",
      "Value": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#down"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${y}) - 100",
      "Value": "y"
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#move"
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#up"
    }, {
      "Command": "comment",
      "Target": "visualVerify // draw_compare_dpi_96.png",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Add some text...",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "draw_text1_dpi_96.png",
      "Value": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_ESC}",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Now click on the canvas. This is the place where the text starts.",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${y}) +180",
      "Value": "y"
    }, {
      "Command": "XClick",
      "Target": "${x},${y}",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Send keystrokes",
      "Value": ""
    }, {
      "Command": "XType",
      "Target": "Demo completed.",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Click once more on the canvas to close text menu",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${y}) - 150",
      "Value": "y"
    }, {
      "Command": "XClick",
      "Target": "${x},${y}",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Confirm that the text is shown. @0.5 overwrites the global confidence level.",
      "Value": ""
    }, {
      "Command": "visualAssert",
      "Target": "draw_checkresult1_dpi_96.png@0.4",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "DemoXClick completed",
      "Value": "#shownotification"
    }]
  },

  "XModules/DemoXMove": {
    "CreationDate": "2021-05-17",
    "Commands": [{
      "Command": "comment",
      "Target": "This demo shows *two* methods to select an image from a list of matches",
      "Value": "",
      "Description": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/draw",
      "Value": "",
      "Description": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=this external website",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Move 2nd range slider using #POS method",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "slider_handle_dpi_96.png@0.75#2",
      "Value": "#down",
      "Description": "Press slider handle down"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var x = ${!imagex}; return x+200",
      "Value": "xnew",
      "Description": "Calcuate new X position. "
    }, {
      "Command": "XMove",
      "Target": "${xnew}, ${!imagey}",
      "Value": "#up",
      "Description": "Move slider handle and release left mouse button"
    }, {
      "Command": "comment",
      "Target": "Move 3rd slider with AREALIMIT method",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "xpath=//ion-list[3]/ion-item/div/div/ion-range",
      "Value": "#down",
      "Description": "CLICK is not needed. We used it just to find the XPath for use with visionLimitSearchArea below."
    }, {
      "Command": "pause",
      "Target": "2000",
      "Value": "",
      "Description": ""
    }, {
      "Command": "visionLimitSearchArea",
      "Target": "element: xpath=//ion-list[3]/ion-item/div/div/ion-range",
      "Value": "",
      "Description": "Restrict computer vision image search to the HTML tag area"
    }, {
      "Command": "XMove",
      "Target": "slider_handle_dpi_96.png@0.6",
      "Value": "#down",
      "Description": "We do not need to add \"#1\" because in the new (limited) area there is only one slider handle, so the BEST MATCH option (=without #) is most reliable"
    }, {
      "Command": "XMoveRelative",
      "Target": "slider_red_dpi_96.png@0.6",
      "Value": "#up",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Confirm slider is in the right position.",
      "Value": "",
      "Description": ""
    }, {
      "Command": "storeText",
      "Target": "xpath=//ion-list[3]/ion-list-header/div/ion-badge",
      "Value": "warmth",
      "Description": "Extract slider position"
    }, {
      "Command": "echo",
      "Target": "Slider WARMTH value is: ${warmth}",
      "Value": "red",
      "Description": ""
    }, {
      "Command": "assert",
      "Target": "warmth",
      "Value": "2000",
      "Description": "Show error if slider has not the expected value"
    }]
  },

  "XModules_Desktop/DemoXDesktopAutomation": {
    "CreationDate": "2020-02-13",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "echo",
      "Target": "Running DESKTOP image search now",
      "Value": "#shownotification"
    }, {
      "Command": "XDesktopAutomation",
      "Target": "true",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Limit the search area for better performance",
      "Value": ""
    }, {
      "Command": "run",
      "Target": "Sub/Sub_XDesktopAutomation_Area",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Log button can be greyed out - try both options",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "true",
      "Value": "!errorignore"
    }, {
      "Command": "comment",
      "Target": "Log button can have white or grey background",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_logstab_white_dpi_96.png@0.5",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "false",
      "Value": "!errorignore"
    }, {
      "Command": "if_v2",
      "Target": "${!statusOK} == false",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_logstab_grey_dpi_96.png@0.5",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "true",
      "Value": "!statusOK"
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Press Clear button",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_clearbutton_dpi_96.png@0.5",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Log cleared by macro (clear button pressed)",
      "Value": "blue"
    }, {
      "Command": "comment",
      "Target": "Now search and open other tabs",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_vartab_dpi_96.png@0.5",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_scrtab_dpi_96.png@0.4",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_vitab_dpi_96.png@0.4",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Check that the correct tab is selected",
      "Value": ""
    }, {
      "Command": "visualAssert",
      "Target": "desktop_checktab_dpi_96.png@0.55",
      "Value": ""
    }]
  },
  "XModules_Desktop/DemoXDesktopAutomation_OCR": {
    "CreationDate": "2020-05-15",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "comment",
      "Target": "For more information please see https://ui.vision/x/desktop-automation#ocr",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Running DESKTOP image search now",
      "Value": "#shownotification"
    }, {
      "Command": "XDesktopAutomation",
      "Target": "true",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Limit the search area for better performance",
      "Value": ""
    }, {
      "Command": "run",
      "Target": "Sub/Sub_XDesktopAutomation_Area",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "eng",
      "Value": "!OCRlanguage"
    }, {
      "Command": "store",
      "Target": "1",
      "Value": "!OCRengine"
    }, {
      "Command": "comment",
      "Target": "Instead of the word \"Logs\" we look only for (L)\"ogs\". There is no need for this. It is done to demo and test the substring search.",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "ocr=ogs@pos=1",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "ocr=Clear@pos=1",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "\"Clear\" button pressed by macro. The button was found at ${!OCRX}, ${!OCRY})",
      "Value": "blue"
    }, {
      "Command": "XClick",
      "Target": "ocr=Screenshots@pos=1",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Now we use the second OCR Engine. Both work fine here. So this switch is just for test and demo purposes.",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "2",
      "Value": "!OCREngine"
    }, {
      "Command": "XClick",
      "Target": "ocr=Visual@pos=1",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Check the right tab is selected",
      "Value": ""
    }, {
      "Command": "visualAssert",
      "Target": "desktop_checktab_dpi_96.png@0.55",
      "Value": ""
    }]
  },
  "XModules_Desktop/Sub/Sub_XDesktopAutomation_Area": {
    "CreationDate": "2021-04-29",
    "Commands": [{
      "Command": "comment",
      "Target": "SUBROUTINE used by DemoXDesktopAutomation and DemoXDesktopAutomation_OCR",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "It uses two anchor images to define the new search area",
      "Value": "",
      "Description": ""
    }, {
      "Command": "visualAssert",
      "Target": "desktop_area_topleft3_dpi_96.png@0.4",
      "Value": "",
      "Description": "Find image to calculate the top left x/y for visionLimitSearchArea "
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!imagex}-${!imagewidth}/1.5",
      "Value": "x1",
      "Description": "New limited area top left corner = bottom left corner of the anchor image. We use image x/y and image width/height to calculate this value. For X we use /1.5 instead of /2 in the formular below to make the area a bit wider."
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!imagey}+${!imageheight}/2",
      "Value": "y1",
      "Description": ""
    }, {
      "Command": "visualAssert",
      "Target": "desktop_area_bottomright_dpi_96.png",
      "Value": "",
      "Description": "Find image to calculate the bottom right x/y for visionLimitSearchArea."
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!imagex}+${!imagewidth}/2",
      "Value": "x2",
      "Description": "New Search Area bottom right corner = top right corner of the anchor image."
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!imagey}-${!imageheight}/2",
      "Value": "y2",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "x1=${x1}, y1=${y1}, x2=${x2}, y2=${y2}",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "visionLimitSearchArea",
      "Target": "area=${x1},${y1},${x2},${y2}",
      "Value": "",
      "Description": ""
    }]
  },
  "Core/Sub/Sub_DemoCsvRead_FillForm": {
    "CreationDate": "2020-08-08",
    "Commands": [{
      "Command": "comment",
      "Target": "Subroutine used by DemoCsvReadWithLoop and DemoCsvReadWithWhile",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Inside subroutine: Status = ${!csvReadStatus}, Line = ${!csvReadLineNumber}",
      "Value": "green"
    }, {
      "Command": "open",
      "Target": "https://docs.google.com/forms/d/e/1FAIpQLScGWVjexH2FNzJqPACzuzBLlTWMJHgLUHjxehtU-2cJxtu6VQ/viewform",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "xpath=//input[@type='text']",
      "Value": "${!COL1}_${!csvReadLineNumber}"
    }, {
      "Command": "type",
      "Target": "xpath=//div[3]/div/div/div[2]/div/div/div/div/input",
      "Value": "${!COL2}"
    }, {
      "Command": "type",
      "Target": "xpath=//div[4]/div/div/div[2]/div/div/div/div/input",
      "Value": "${!COL3}"
    }, {
      "Command": "clickAndWait",
      "Target": "xpath=//span/span",
      "Value": ""
    }]
  }
});
// CONCATENATED MODULE: ./src/config/preinstall_suites.js
/* harmony default export */ var preinstall_suites = ([{
  "creationDate": "2019-05-21",
  "name": "Old_Style_Testsuites_(Deprecated)",
  "fold": true,
  "macros": [{
    "macro": "Demo/Core/DemoAutofill.json",
    "loops": 1
  }, {
    "macro": "Demo/Core/DemoFrames.json",
    "loops": 1
  }]
}]);
// EXTERNAL MODULE: ./src/services/kv_data/macro_extra_data.ts
var macro_extra_data = __webpack_require__(105);

// EXTERNAL MODULE: ./src/services/kv_data/test_suite_extra_data.ts
var test_suite_extra_data = __webpack_require__(389);

// EXTERNAL MODULE: ./src/models/test_suite_model.js
var test_suite_model = __webpack_require__(390);

// EXTERNAL MODULE: ./src/recomputed/index.ts
var recomputed = __webpack_require__(23);

// EXTERNAL MODULE: ./src/components/prompt.tsx
var components_prompt = __webpack_require__(187);

// EXTERNAL MODULE: ./src/common/command.ts
var common_command = __webpack_require__(43);

// EXTERNAL MODULE: ./src/services/player/call_stack/call_stack.ts
var call_stack = __webpack_require__(115);

// EXTERNAL MODULE: ./src/services/player/macro.ts
var player_macro = __webpack_require__(191);

// EXTERNAL MODULE: ./src/components/save_test_case.js
var save_test_case = __webpack_require__(99);

// EXTERNAL MODULE: ./src/common/lib/path/index.js
var lib_path = __webpack_require__(27);

// EXTERNAL MODULE: ./src/common/ts_utils.ts
var ts_utils = __webpack_require__(12);

// EXTERNAL MODULE: ./src/common/macro_log.ts
var macro_log = __webpack_require__(161);

// EXTERNAL MODULE: ./src/services/log/index.ts
var services_log = __webpack_require__(324);

// EXTERNAL MODULE: ./src/services/kv_data/misc_data.ts
var misc_data = __webpack_require__(365);

// CONCATENATED MODULE: ./src/actions/index.js






var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

 /* global PREINSTALL_CSV_LIST PREINSTALL_VISION_LIST */





























var recordedCount = 0;

var actions_saveEditing = function saveEditing(_ref) {
  var dispatch = _ref.dispatch,
      getState = _ref.getState;

  var state = getState();
  var _state$editor = state.editor,
      editing = _state$editor.editing,
      isDraggingCommand = _state$editor.isDraggingCommand;


  if (isDraggingCommand) {
    return;
  }

  common_storage["default"].set('editing', editing);
};

var actions_saveMacroExtra = function saveMacroExtra(id) {
  return function (_ref2) {
    var dispatch = _ref2.dispatch,
        getState = _ref2.getState;

    var state = getState();

    if (state.editor.isDraggingCommand) {
      return;
    }

    var macroId = id || Object(recomputed["getCurrentMacroId"])(state);
    var updated = state.editor.macrosExtra[macroId] || {};

    return Object(macro_extra_data["getMacroExtraKeyValueData"])().update(macroId, function (data) {
      return _extends({}, data, updated);
    });
  };
};

var actions_saveWholeMacrosExtra = function saveWholeMacrosExtra(_ref3) {
  var dispatch = _ref3.dispatch,
      getState = _ref3.getState;

  var state = getState();
  var macrosExtra = Object(recomputed["getMacrosExtra"])(state);

  return Object(macro_extra_data["getMacroExtraKeyValueData"])().set('', macrosExtra);
};

var saveConfig = function () {
  var lastSize = {};

  return function (_ref4) {
    var dispatch = _ref4.dispatch,
        getState = _ref4.getState;

    var _getState = getState(),
        config = _getState.config;

    config = config || {};

    var savedSize = config.size ? config.size[config.showSidebar ? 'with_sidebar' : 'standard'] : null;
    var finalSize = savedSize || (config.showSidebar ? {
      width: 860,
      height: 775
    } : {
      width: 520,
      height: 775
    });

    if (finalSize.width !== lastSize.width || finalSize.height !== lastSize.height) {
      common_storage["default"].get('config').then(function (oldConfig) {
        if ((oldConfig && oldConfig.showSidebar) === config.showSidebar) return;

        if (finalSize.width !== window.outerWidth || finalSize.height !== window.outerHeight) {
          ipc_cs["default"].ask('PANEL_RESIZE_WINDOW', { size: finalSize });
        }
      });
    }

    common_storage["default"].set('config', config);
    lastSize = finalSize;
  };
}();

var toLower = function toLower(str) {
  return (str || '').toLowerCase();
};

function findSameNameMacro(name, macros) {
  return macros.find(function (tc) {
    return toLower(tc.name) === toLower(name);
  });
}

function findSamePathMacro(path, macroNodes) {
  var converPath = function converPath(str) {
    return toLower(str).replace(/.json$/, '');
  };
  return macroNodes.find(function (node) {
    return converPath(node.relativePath) === converPath(path);
  });
}

function findMacrosInFolder(folderPath, macroNodes) {
  var lowerFolderPath = toLower(folderPath);

  return macroNodes.filter(function (macroNode) {
    var lowerMacroFullPath = toLower(macroNode.fullPath);

    if (lowerMacroFullPath.indexOf(lowerFolderPath) !== 0) {
      return false;
    }

    var parts = lowerMacroFullPath.substr(lowerFolderPath.length).split(/\/|\\/g);

    if (parts.length !== 2 || parts[0] !== '') {
      return false;
    }

    return true;
  });
}

function findSameNameTestSuite(name, testSuites) {
  return testSuites.find(function (ts) {
    return toLower(ts.name) === toLower(name);
  });
}

function setRoute(data) {
  return {
    type: action_types["b" /* types */].SET_ROUTE,
    data: data
  };
}

function startRecording() {
  recordedCount = 0;

  return {
    types: Object(action_types["a" /* type3 */])('START_RECORDING'),
    promise: function promise() {
      setTimeout(function () {
        ipc_cs["default"].ask('PANEL_TRY_TO_RECORD_OPEN_COMMAND');
      });

      return ipc_cs["default"].ask('PANEL_START_RECORDING', {});
    }
  };
}

function stopRecording() {
  return {
    types: Object(action_types["a" /* type3 */])('STOP_RECORDING'),
    promise: function promise() {
      return ipc_cs["default"].ask('PANEL_STOP_RECORDING', {});
    }
  };
}

function startInspecting() {
  return {
    types: Object(action_types["a" /* type3 */])('START_INSPECTING'),
    promise: function promise() {
      return ipc_cs["default"].ask('PANEL_START_INSPECTING', {});
    }
  };
}

function stopInspecting() {
  return {
    types: Object(action_types["a" /* type3 */])('STOP_INSPECTING'),
    promise: function promise() {
      return ipc_cs["default"].ask('PANEL_STOP_INSPECTING', {});
    }
  };
}

function startPlaying() {
  return {
    type: action_types["b" /* types */].START_PLAYING,
    data: null
  };
}

function stopPlaying() {
  return {
    type: action_types["b" /* types */].STOP_PLAYING,
    data: null
  };
}

function doneInspecting() {
  return {
    type: action_types["b" /* types */].DONE_INSPECTING,
    data: {}
  };
}

function increaseRecordedCount() {
  recordedCount += 1;
  // Note: show in badge the recorded count
  ipc_cs["default"].ask('PANEL_UPDATE_BADGE', {
    type: 'record',
    text: '' + recordedCount
  });
}

function appendCommand(cmdObj) {
  var fromRecord = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (fromRecord) {
    increaseRecordedCount();
  }

  return {
    type: action_types["b" /* types */].APPEND_COMMAND,
    data: { command: Object(test_case_model["b" /* normalizeCommand */])(cmdObj) },
    post: [actions_saveEditing, actions_saveMacroExtra()]
  };
}

function duplicateCommand(index) {
  return {
    type: action_types["b" /* types */].DUPLICATE_COMMAND,
    data: { index: index },
    post: [actions_saveEditing, actions_saveMacroExtra()]
  };
}

function insertCommand(cmdObj, index) {
  var fromRecord = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (fromRecord) {
    increaseRecordedCount();
  }

  return {
    type: action_types["b" /* types */].INSERT_COMMAND,
    data: {
      index: index,
      command: Object(test_case_model["b" /* normalizeCommand */])(cmdObj)
    },
    post: [actions_saveEditing, actions_saveMacroExtra()]
  };
}

function updateCommand(cmdObj, index) {
  return {
    type: action_types["b" /* types */].UPDATE_COMMAND,
    data: {
      command: Object(test_case_model["b" /* normalizeCommand */])(cmdObj),
      index: index
    },
    post: actions_saveEditing
  };
}

function removeCommand(index) {
  return {
    type: action_types["b" /* types */].REMOVE_COMMAND,
    data: { index: index },
    post: [actions_saveEditing, actions_saveMacroExtra()]
  };
}

function selectCommand(index, forceClick) {
  return {
    type: action_types["b" /* types */].SELECT_COMMAND,
    data: { index: index, forceClick: forceClick },
    post: actions_saveEditing
  };
}

function cutCommand(index) {
  return {
    type: action_types["b" /* types */].CUT_COMMAND,
    data: { indices: [index] },
    post: [actions_saveEditing, actions_saveMacroExtra()]
  };
}

function copyCommand(index) {
  return {
    type: action_types["b" /* types */].COPY_COMMAND,
    data: { indices: [index] }
  };
}

function pasteCommand(index) {
  return {
    type: action_types["b" /* types */].PASTE_COMMAND,
    data: { index: index },
    post: [actions_saveEditing, actions_saveMacroExtra()]
  };
}

function normalizeCommands() {
  return {
    type: action_types["b" /* types */].NORMALIZE_COMMANDS,
    data: {},
    post: actions_saveEditing
  };
}

function updateSelectedCommand(obj) {
  return {
    type: action_types["b" /* types */].UPDATE_SELECTED_COMMAND,
    data: obj,
    post: actions_saveEditing
  };
}

function toggleComment(commandIndex) {
  return function (dispatch, getState) {
    var state = getState();
    var commands = state.editor.editing.commands;
    var command = commands[commandIndex];

    if (!command || !command.cmd || !command.cmd.length) {
      return;
    }

    // Note: for commented out command, its data looks like:
    // {
    //   cmd:     'comment',
    //   target:  'originalCmd // originalTarget
    //   value:   not touched
    // }
    if (command.cmd === 'comment') {
      var separator = ' // ';
      var index = command.target.indexOf(separator);
      if (index === -1) return;

      var cmd = command.target.substr(0, index);
      if (!Object(common_command["isValidCmd"])(cmd)) return;

      var target = command.target.substr(index + separator.length);

      return dispatch(updateCommand(_extends({}, command, {
        cmd: cmd,
        target: target
      }), commandIndex));
    } else {
      return dispatch(updateCommand(_extends({}, command, {
        cmd: 'comment',
        target: command.cmd + ' // ' + (command.target || '')
      }), commandIndex));
    }
  };
}

function toggleCommentOnSelectedCommand() {
  return function (dispatch, getState) {
    var state = getState();
    var index = state.editor.editing.meta.selectedIndex;

    dispatch(toggleComment(index));
  };
}

function setSourceError(error) {
  return {
    type: action_types["b" /* types */].SET_SOURCE_ERROR,
    data: error
  };
}

function setSourceCurrent(str) {
  return {
    type: action_types["b" /* types */].SET_SOURCE_CURRENT,
    data: str
  };
}

function saveSourceCodeToEditing(str) {
  return function (dispatch, getState) {
    var _getState$editor = getState().editor,
        editing = _getState$editor.editing,
        editingSource = _getState$editor.editingSource;

    if (editingSource.pure === editing.current) return;

    log_default()('ACTION, saveSourceCodeToEditing', str);

    try {
      var obj = Object(convert_utils["fromJSONString"])(str, 'untitled');

      dispatch(setEditing(_extends({}, obj.data, {
        meta: editing.meta
      })));

      dispatch(setSourceError(null));
    } catch (e) {
      message_default.a.error('There are errors in the source');
      dispatch(setSourceError(e.message));
    }
  };
}

// In the form of redux-thunnk, it saves current editing test case to local storage
function saveEditingAsExisted() {
  return function (dispatch, getState) {
    var state = getState();
    var src = state.editor.editing.meta.src;
    var macroId = src.id;
    var data = Object(utils["pick"])(['commands'], state.editor.editing);
    var macroStorage = Object(services_storage["getStorageManager"])().getMacroStorage();

    if (!macroId) {
      throw new Error('Can\'t find macro with path \'' + macroId + '\'');
    }

    // Make sure, only 'cmd', 'value', 'target' are saved in storage
    data.commands = data.commands.map(test_case_model["b" /* normalizeCommand */]);

    if (Object(recomputed["hasUnsavedMacro"])(state)) {
      // Reset test case status
      dispatch(updateMacroPlayStatus(macroId, null));
    }

    return macroStorage.read(macroId, 'Text').then(function (macro) {
      var updatedMacro = _extends({}, macro, { data: data });

      dispatch({
        type: 'setCurrentMacro',
        data: updatedMacro
      });

      return macroStorage.write(macroId, updatedMacro);
    }).then(function () {
      dispatch({
        type: action_types["b" /* types */].SAVE_EDITING_AS_EXISTED,
        data: null,
        post: actions_saveEditing
      });
    });
  };
}

// In the form of redux-thunnk, it saves the current editing test case as a new named test case
function saveEditingAsNew(name) {
  return function (dispatch, getState) {
    var state = getState();
    var data = Object(utils["pick"])(['commands'], state.editor.editing);
    var sameName = findSameNameMacro(name, state.editor.testCases);

    if (sameName) {
      return Promise.reject(new Error('The macro name already exists!'));
    }

    var relativePath = '/' + name + '.json';
    var id = Object(services_storage["getStorageManager"])().getMacroStorage().filePath(relativePath);
    var newMacro = { id: id, name: name, data: data };

    return Object(services_storage["getStorageManager"])().getMacroStorage().write(relativePath, newMacro).then(function () {
      dispatch({
        type: 'setCurrentMacro',
        data: newMacro
      });

      return dispatch({
        type: action_types["b" /* types */].SAVE_EDITING_AS_NEW,
        data: {
          id: id,
          name: name
        },
        post: actions_saveEditing
      });
    });
  };
}

function setTestCases(testCases) {
  var tcs = testCases.slice();

  tcs.sort(function (a, b) {
    var nameA = a.name.toLowerCase();
    var nameB = b.name.toLowerCase();

    if (nameA < nameB) return -1;
    if (nameA === nameB) return 0;
    return 1;
  });

  return {
    type: action_types["b" /* types */].SET_TEST_CASES,
    data: tcs,
    post: function post(_ref5) {
      var dispatch = _ref5.dispatch,
          getState = _ref5.getState;

      var state = getState();
      var macroNodes = Object(recomputed["getMacroFileNodeList"])(state);
      var shouldSelectDefault = macroNodes.length > 0 && !state.editor.editing.meta.src && state.editor.editing.commands.length === 0;

      if (shouldSelectDefault) {
        dispatch(editTestCase(macroNodes[0].fullPath));
      }
    }
  };
}

function resetEditing() {
  return function (dispatch, getState) {
    var state = getState();
    var editing = state.editor.editing;

    var macroNodes = Object(recomputed["getMacroFileNodeList"])(state);

    // Leave it if it's a new macro
    if (editing.meta && !editing.meta.src) return;
    if (macroNodes.length === 0) {
      dispatch(editNewTestCase());
    } else {
      dispatch(editTestCase(macroNodes[0].fullPath));
    }
  };
}

function resetEditingIfNeeded() {
  return function (dispatch, getState) {
    var state = getState();
    var editing = state.editor.editing;

    var lastTcId = editing.meta.src && editing.meta.src.id;

    if (!lastTcId) return resetEditing()(dispatch, getState);
    dispatch(editTestCase(lastTcId));
  };
}

function setEditing(editing) {
  return {
    type: action_types["b" /* types */].SET_EDITING,
    data: editing
  };
}

function editTestCase(id) {
  return function (dispatch, getState) {
    return Object(services_storage["getStorageManager"])().getMacroStorage().read(id, 'Text').then(function (rawMacro) {
      var macro = Object(test_case_model["c" /* normalizeTestCase */])(rawMacro);

      dispatch({
        type: 'setCurrentMacro',
        data: macro
      });

      dispatch({
        type: action_types["b" /* types */].EDIT_TEST_CASE,
        data: {
          id: id,
          macro: macro
        },
        post: actions_saveEditing
      });

      // Save last edited macro id for each mode,
      // so that we can recover to it after switching mode
      var mode = Object(services_storage["getStorageManager"])().getCurrentStrategyType();
      var key = function () {
        switch (mode) {
          case services_storage["StorageStrategyType"].Browser:
            return misc_data["MiscKey"].BrowserModeLastMacroId;

          case services_storage["StorageStrategyType"].XFile:
            return misc_data["MiscKey"].XFileModeLastMacroId;

          default:
            throw new Error('Invalid mode: ' + mode);
        }
      }();

      Object(misc_data["getMiscData"])().set(key, id);

      return macro;
    });
  };
}

function editNewTestCase() {
  return {
    type: action_types["b" /* types */].EDIT_NEW_TEST_CASE,
    data: null,
    post: actions_saveEditing
  };
}

function upsertTestCase(tc) {
  return function (dispatch, getState) {
    return Object(services_storage["getStorageManager"])().getMacroStorage().write(tc.name, _extends({
      id: Object(utils["uid"])()
    }, tc));
  };
}

function addTestCases(_ref6) {
  var macros = _ref6.macros,
      _ref6$folder = _ref6.folder,
      folder = _ref6$folder === undefined ? '/' : _ref6$folder,
      _ref6$overwrite = _ref6.overwrite,
      overwrite = _ref6$overwrite === undefined ? false : _ref6$overwrite,
      _ref6$storageStrategy = _ref6.storageStrategyType,
      storageStrategyType = _ref6$storageStrategy === undefined ? null : _ref6$storageStrategy;

  return function (dispatch, getState) {
    var storage = Object(services_storage["getStorageManager"])().getStorageForTarget(services_storage["StorageTarget"].Macro, storageStrategyType || Object(services_storage["getStorageManager"])().getCurrentStrategyType());
    var state = getState();
    var dirToCompare = folder === '/' ? '' : storage.relativePath(folder, true);
    var allMacros = Object(recomputed["getMacroFileNodeList"])(state);
    var macroNodes = allMacros.filter(function (node) {
      var rawDir = storage.getPathLib().dirname(node.fullPath);
      var dir = storage.relativePath(rawDir, true);

      return dirToCompare === dir;
    });
    var failTcs = [];
    var validTcs = [];

    macros.forEach(function (macro) {
      var isValid = overwrite || !macroNodes.find(function (node) {
        return node.name === macro.name;
      });

      if (isValid) {
        validTcs.push(macro);
      } else {
        failTcs.push(macro);
      }
    });

    var passCount = validTcs.length;
    var failCount = macros.length - passCount;

    if (passCount === 0) {
      return Promise.resolve({ passCount: passCount, failCount: failCount, failTcs: failTcs });
    }

    var macrosToWrite = validTcs.map(function (tc) {
      return {
        filePath: lib_path["posix"].join(folder, tc.name + '.json'),
        content: _extends({}, tc, {
          id: Object(utils["uid"])(),
          udpateTime: new Date() * 1
        })
      };
    });

    return storage.ensureDirectory(folder).then(function () {
      return storage.bulkWrite(macrosToWrite);
    }).then(function () {
      return { passCount: passCount, failCount: failCount, failTcs: failTcs };
    });
  };
}

function removeTestCase(macroId) {
  return function (dispatch, getState) {
    var state = getState();
    var curId = state.editor.editing.meta.src && state.editor.editing.meta.src.id;
    var tss = state.editor.testSuites.filter(function (ts) {
      return ts.cases.find(function (m) {
        return m.testCaseId === macroId;
      });
    });

    if (tss.length > 0) {
      return Promise.reject(new Error('Can\'t delete this macro for now, it\'s currently used in following test suites: ' + tss.map(function (item) {
        return item.name;
      })));
    }

    // Reset test case status
    dispatch(updateMacroPlayStatus(macroId, null));

    return Object(services_storage["getStorageManager"])().getMacroStorage().remove(macroId).then(function () {
      dispatch({
        type: action_types["b" /* types */].REMOVE_TEST_CASE,
        data: {
          isCurrent: curId === macroId
        },
        post: actions_saveEditing
      });
    }).catch(function (e) {
      return log_default.a.error(e.stack);
    });
  };
}

function removeCurrentTestCase() {
  return function (dispatch, getState) {
    var state = getState();
    var id = state.editor.editing.meta.src.id;

    return removeTestCase(id)(dispatch, getState);
  };
}

function setPlayerState(obj) {
  return {
    type: action_types["b" /* types */].SET_PLAYER_STATE,
    data: obj
  };
}

function setTimeoutStatus(args) {
  return function (dispatch) {
    dispatch(setPlayerState({
      timeoutStatus: args
    }));

    // Note: show in badge the timeout left
    ipc_cs["default"].ask('PANEL_UPDATE_BADGE', {
      type: 'play',
      text: (args.total - args.past) / 1000 + 's'
    });
  };
}

function addPlayerWarningCommandIndex(index) {
  return function (dispatch, getState) {
    var state = getState();
    var macroId = Object(recomputed["getCurrentMacroId"])(state);
    var indices = Object(recomputed["getWarningCommandIndices"])(state);
    var warningCommandIndices = indices.indexOf(index) === -1 ? [].concat(_toConsumableArray(indices), [index]) : indices;
    dispatch(updateMacroExtra(macroId, { warningCommandIndices: warningCommandIndices }));
  };
}

function addPlayerErrorCommandIndex(index) {
  return function (dispatch, getState) {
    var state = getState();
    var macroId = Object(recomputed["getCurrentMacroId"])(state);
    var indices = Object(recomputed["getErrorCommandIndices"])(state);
    var errorCommandIndices = indices.indexOf(index) === -1 ? [].concat(_toConsumableArray(indices), [index]) : indices;
    dispatch(updateMacroExtra(macroId, { errorCommandIndices: errorCommandIndices }));
  };
}

function addLog(type, text) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return function (dispatch, getState) {
    var state = getState();
    var callStack = options.noStack ? [] : Object(call_stack["getMacroCallStack"])().toArray();
    var logItem = {
      type: type,
      text: text,
      options: options,
      id: Object(utils["uid"])(),
      createTime: new Date(),
      stack: callStack.map(function (item, i) {
        return {
          macroId: item.resource.id,
          macroName: item.resource.name,
          commandIndex: i === callStack.length - 1 ? state.player.nextCommandIndex : item.runningStatus.nextIndex,
          isSubroutine: i !== 0
        };
      })
    };

    if (state.config.logFilter !== 'None') {
      // Also write file to hard drive when it's in xfile mode
      setTimeout(function () {
        ipc_cs["default"].ask('PANEL_LOG', { log: Object(macro_log["renderLog"])(logItem, true) });
      }, 0);
    }

    return dispatch({
      type: action_types["b" /* types */].ADD_LOGS,
      data: [logItem]
    });
  };
}

function clearLogs() {
  return {
    type: action_types["b" /* types */].CLEAR_LOGS,
    data: null
  };
}

function addScreenshot(screenshot) {
  return {
    type: action_types["b" /* types */].ADD_SCREENSHOT,
    data: _extends({}, screenshot, {
      createTime: new Date()
    })
  };
}

function clearScreenshots() {
  return {
    type: action_types["b" /* types */].CLEAR_SCREENSHOTS,
    data: null,
    post: function post() {
      return Object(services_storage["getStorageManager"])().getScreenshotStorage().clear();
    }
  };
}

function addVision(vision) {
  return {
    type: action_types["b" /* types */].ADD_VISION,
    data: _extends({}, vision, {
      createTime: new Date()
    })
  };
}

function clearVisions() {
  return {
    type: action_types["b" /* types */].CLEAR_VISIONS,
    data: null,
    post: function post() {
      return Object(services_storage["getStorageManager"])().getVisionStorage().clear();
    }
  };
}

function updateConfig(data) {
  return {
    type: action_types["b" /* types */].UPDATE_CONFIG,
    data: data,
    post: saveConfig
  };
}

function setMacrosExtra(data) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var opts = _extends({
    shouldPersist: false
  }, options);

  return {
    type: action_types["b" /* types */].SET_MACROS_EXTRA,
    data: data || {},
    post: opts.shouldPersist ? actions_saveWholeMacrosExtra : function () {}
  };
}

function setTestSuitesExtra(data) {
  return {
    type: action_types["b" /* types */].SET_TEST_SUITES_EXTRA,
    data: data || {}
  };
}

function updateMacroExtra(id, extra) {
  // TODO: the key for extra info should be different,
  // something like storage mode + storage path + file name
  return {
    type: action_types["b" /* types */].UPDATE_ONE_MACRO_EXTRA,
    data: { id: id, extra: extra },
    post: actions_saveMacroExtra(id)
  };
}

function updateMacroPlayStatus(id, status) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, { status: status }));
  };
}

function updateMacroBreakpoints(id, breakpointIndices) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, { breakpointIndices: breakpointIndices }));
  };
}

function updateMacroDoneCommandsIndices(id, doneCommandIndices) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, { doneCommandIndices: doneCommandIndices }));
  };
}

function updateMacroErrorCommandsIndices(id, errorCommandIndices) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, { errorCommandIndices: errorCommandIndices }));
  };
}

function updateMacroWarningCommandsIndices(id, warningCommandIndices) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, { warningCommandIndices: warningCommandIndices }));
  };
}

function updateProxy(proxy) {
  return {
    type: action_types["b" /* types */].UPDATE_PROXY,
    data: proxy
  };
}

function commonPlayerState(state, options, macroId, macroName) {
  var config = state.config;

  var cfg = Object(utils["pick"])(['playHighlightElements', 'playScrollElementsIntoView'], config);
  var finalMacroName = function () {
    if (macroName) {
      return macroName;
    }

    if (!macroId) {
      return state.editor.editing.meta.src ? state.editor.editing.meta.src.name : 'Untitled';
    }

    var macro = Object(recomputed["getMacroFileNodeList"])(state).find(function (node) {
      return node.fullPath === macroId;
    });

    if (!macro) {
      throw new Error('can\'t find macro with id \'' + macroId + '\'');
    }

    return macro.name;
  }();
  var scope = _extends({
    '!MACRONAME': finalMacroName,
    '!TIMEOUT_PAGELOAD': parseFloat(config.timeoutPageLoad),
    '!TIMEOUT_WAIT': parseFloat(config.timeoutElement),
    '!TIMEOUT_MACRO': parseFloat(config.timeoutMacro),
    '!TIMEOUT_DOWNLOAD': parseFloat(config.timeoutDownload),
    '!OCRLANGUAGE': config.ocrLanguage,
    '!CVSCOPE': config.cvScope,
    '!REPLAYSPEED': {
      '0': 'FAST',
      '0.3': 'MEDIUM',
      '2': 'SLOW'
    }[options.postDelay / 1000] || 'MEDIUM'
  }, options.overrideScope || {});

  var breakpoints = macroId ? Object(recomputed["getBreakpointsByMacroId"])(state, macroId) : Object(recomputed["getBreakpoints"])(state);

  var opts = Object(utils["compose"])(Object(utils["on"])('resources'), utils["map"], Object(utils["on"])('extra'))(function () {
    var extra = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return _extends({}, extra, cfg, options.commandExtra || {});
  })(options);

  var playerState = _extends({
    title: finalMacroName
  }, opts, {
    public: _extends({}, opts.public || {}, {
      scope: scope
    }),
    breakpoints: [].concat(_toConsumableArray(breakpoints), _toConsumableArray(options.breakpoints || []))
  });

  return playerState;
}

function playerPlay(options) {
  // Filter out empty commands
  var opts = _extends({}, options, {
    resources: (options.resources || []).filter(function (res) {
      return res.cmd && res.cmd.length > 0;
    })
  });

  return function (dispatch, getState) {
    return Object(save_test_case["default"])().saveOrNot({
      getContent: function getContent(data) {
        return 'You must save macro before replay';
      },
      okText: 'Save',
      cancelText: 'Cancel',
      autoSaveExisting: true
    }).then(function (saved) {
      if (!saved) return;

      var state = getState();
      var playerState = commonPlayerState(state, opts, opts.macroId, opts.title);

      Object(call_stack["getMacroCallStack"])().clear();

      return Object(call_stack["getMacroCallStack"])().call({
        id: opts.macroId,
        name: playerState.title,
        commands: opts.resources
      }, {
        playerState: playerState,
        status: player_macro["MacroStatus"].Running,
        nextIndex: opts.startIndex,
        commandResults: []
      });
    });
  };
}

function listCSV() {
  return function (dispatch, getState) {
    var csvStorage = Object(services_storage["getStorageManager"])().getCSVStorage();

    csvStorage.list().then(function (list) {
      return Promise.all(list.map(function (item) {
        return {
          name: item.name,
          size: item.size,
          fullPath: item.fullPath,
          createTime: new Date(item.lastModified)
        };
      }));
    }).then(function (list) {
      dispatch({
        type: action_types["b" /* types */].SET_CSV_LIST,
        data: list
      });
    }).catch(function (e) {
      log_default.a.error('listCSV error', e);
      return Promise.reject(e);
    });
  };
}

function listScreenshots() {
  return function (dispatch, getState) {
    var man = Object(services_storage["getStorageManager"])().getScreenshotStorage();

    return man.list().then(function (list) {
      log_default()('listScreenshots', list);

      return list.map(function (item) {
        return {
          name: item.name,
          fullPath: item.fullPath,
          createTime: new Date(item.lastModified)
        };
      });
    }).then(function (list) {
      dispatch({
        type: action_types["b" /* types */].SET_SCREENSHOT_LIST,
        data: list
      });
    }).catch(function (e) {
      log_default.a.error('listScreenshots error', e);
      return Promise.reject(e);
    });
  };
}

function listVisions() {
  return function (dispatch, getState) {
    var visionStorage = Object(services_storage["getStorageManager"])().getVisionStorage();

    return visionStorage.list().then(function (list) {
      log_default()('listVisions', list);

      return list.map(function (item) {
        return {
          name: item.name,
          fullPath: item.fullPath,
          createTime: new Date(item.lastModified)
        };
      });
    }).then(function (list) {
      dispatch({
        type: action_types["b" /* types */].SET_VISION_LIST,
        data: list
      });
    }).catch(function (e) {
      log_default.a.error('listVisions error', e);
      return Promise.reject(e);
    });
  };
}

function renameVisionImage(fileName) {
  var shouldUpdateCommand = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  return function (dispatch, getState) {
    return Object(utils["withFileExtension"])(fileName, function (baseName, addExtName) {
      return Object(components_prompt["prompt"])({
        title: 'Image Name',
        message: 'Note: Please keep the \'_dpi_xx\' postfix',
        value: baseName,
        keepOpenOnError: true,
        selectionEnd: function () {
          var m = baseName.match(/_dpi_\d+/i);
          if (!m) return undefined;
          return m.index;
        }(),
        onOk: function onOk(finalBaseName) {
          // Note: a small timeout to prevent "select" button from accepting "enter" keypress
          var timeout = Object(utils["delay"])(function () {
            return true;
          }, 100);
          if (finalBaseName === baseName) return timeout;

          try {
            Object(utils["validateStandardName"])(finalBaseName, true);
          } catch (e) {
            message_default.a.error(e.message);
            throw e;
          }

          return Object(services_storage["getStorageManager"])().getVisionStorage().exists(addExtName(finalBaseName)).then(function (result) {
            if (result) {
              var msg = '\'' + addExtName(finalBaseName) + '\' already exists';
              message_default.a.error(msg);
              throw new Error(msg);
            }

            return Object(services_storage["getStorageManager"])().getVisionStorage().rename(fileName, addExtName(finalBaseName)).then(function () {
              return timeout;
            }).catch(function (e) {
              // Note: If there is error in renaming like duplicate names,
              // it should show error message and let users try again
              message_default.a.error(e.message);
              throw e;
            });
          });
        }
      }).then(function (finalFullName) {
        // If users click "Cancel" button, we should delete it #479
        // Have to give it private name, since withFileExtenion will try to add '.png'
        if (!finalFullName) {
          return Object(services_storage["getStorageManager"])().getVisionStorage().remove(addExtName(baseName)).then(function () {
            return dispatch(listVisions());
          }).then(function () {
            return '__kantu_deleted__';
          });
        }

        return finalFullName;
      });
    }).then(function (finalFullName) {
      // It means it's deleted (user clicks "cancel")
      if (/__kantu_deleted__/.test(finalFullName)) return;

      if (shouldUpdateCommand) {
        dispatch(updateSelectedCommand({ target: finalFullName }));
      }
      dispatch(listVisions());
      message_default.a.success('Saved vision as ' + finalFullName);
      return finalFullName;
    });
  };
}

function setTestSuites(tss) {
  return {
    type: action_types["b" /* types */].SET_TEST_SUITES,
    data: tss
  };
}

function addTestSuite(ts) {
  return function (dispatch, getState) {
    var state = getState();
    var existingtestSuites = Object(recomputed["getTestSuitesWithAllInfo"])(state);
    var hasDuplicateName = !!existingtestSuites.find(function (item) {
      return ts.name === item.name;
    });

    if (hasDuplicateName) {
      return Promise.reject(new Error('The test suite name \'' + ts.name + '\' already exists!'));
    }

    return Object(services_storage["getStorageManager"])().getTestSuiteStorage().write(ts.name, _extends({}, ts, {
      id: Object(utils["uid"])(),
      updateTime: new Date() * 1
    }));
  };
}

function addTestSuites(tss) {
  var storageStrategyType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  return function (dispatch, getState) {
    var state = getState();
    var existingtestSuites = Object(recomputed["getTestSuitesWithAllInfo"])(state);

    var validTss = tss.filter(function (ts) {
      return !existingtestSuites.find(function (item) {
        return item.name === ts.name;
      });
    });
    var passCount = validTss.length;
    var failCount = tss.length - passCount;

    if (passCount === 0) {
      return Promise.resolve({ passCount: passCount, failCount: failCount, failTss: [] });
    }

    var storage = Object(services_storage["getStorageManager"])().getStorageForTarget(services_storage["StorageTarget"].TestSuite, storageStrategyType || Object(services_storage["getStorageManager"])().getCurrentStrategyType());

    var testSuitesToWrite = validTss.map(function (ts) {
      return {
        filePath: ts.name,
        content: _extends({}, ts, {
          id: Object(utils["uid"])(),
          updateTime: new Date() * 1
        })
      };
    });

    return storage.ensureDir().then(function () {
      return storage.bulkWrite(testSuitesToWrite);
    }).then(function () {
      return { passCount: passCount, failCount: failCount, failTss: [] };
    });
  };
}

function removeTestSuite(id) {
  return function (dispatch, getState) {
    var state = getState();
    var ts = state.editor.testSuites.find(function (ts) {
      return ts.id === id;
    });

    if (!ts) throw new Error('can\'t find test suite with id \'' + id + '\'');

    // Reset test suite status
    dispatch({
      type: action_types["b" /* types */].UPDATE_TEST_SUITE_STATUS,
      data: {
        id: id,
        extra: {
          fold: false,
          playStatus: {}
        }
      }
    });

    return Object(services_storage["getStorageManager"])().getTestSuiteStorage().remove(ts.name);
  };
}

function setPlayerMode(mode) {
  return {
    type: action_types["b" /* types */].SET_PLAYER_STATE,
    data: { mode: mode }
  };
}

function runBackup() {
  return function (dispatch, getState) {
    var state = getState();
    var config = state.config,
        editor = state.editor;
    var autoBackupTestCases = config.autoBackupTestCases,
        autoBackupTestSuites = config.autoBackupTestSuites,
        autoBackupScreenshots = config.autoBackupScreenshots,
        autoBackupCSVFiles = config.autoBackupCSVFiles,
        autoBackupVisionImages = config.autoBackupVisionImages;


    var sm = Object(services_storage["getStorageManager"])();

    return Promise.all([sm.getCSVStorage().list(), sm.getScreenshotStorage().list(), sm.getVisionStorage().list()]).then(function (_ref7) {
      var _ref8 = _slicedToArray(_ref7, 3),
          csvs = _ref8[0],
          screenshots = _ref8[1],
          visions = _ref8[2];

      return Object(backup["backup"])({
        csvs: csvs,
        screenshots: screenshots,
        visions: visions,
        macroNodes: Object(recomputed["getMacroFileNodeList"])(state),
        testSuites: editor.testSuites,
        backup: {
          testCase: autoBackupTestCases,
          testSuite: autoBackupTestSuites,
          screenshot: autoBackupScreenshots,
          csv: autoBackupCSVFiles,
          vision: autoBackupVisionImages
        }
      });
    }).catch(function (e) {
      log_default.a.error(e.stack);
    });
  };
}

function setVariables(variables) {
  variables.sort(function (a, b) {
    if (a.key < b.key) return -1;
    if (a.key > b.key) return 1;
    return 0;
  });

  return {
    type: action_types["b" /* types */].SET_VARIABLE_LIST,
    data: variables
  };
}

function updateUI(data) {
  return {
    type: action_types["b" /* types */].UPDATE_UI,
    data: data
  };
}

function addBreakpoint(macroId, commandIndex) {
  return function (dispatch, getState) {
    var state = getState();
    var extra = state.editor.macrosExtra[macroId] || {};
    var indices = extra.breakpointIndices || [];
    var newIndices = indices.indexOf(commandIndex) === -1 ? [].concat(_toConsumableArray(indices), [commandIndex]) : indices;

    dispatch(updateMacroBreakpoints(macroId, newIndices));
  };
}

function removeBreakpoint(macroId, commandIndex) {
  return function (dispatch, getState) {
    var state = getState();
    var extra = state.editor.macrosExtra[macroId] || {};
    var indices = extra.breakpointIndices || [];
    var newIndices = indices.filter(function (index) {
      return index !== commandIndex;
    });

    dispatch(updateMacroBreakpoints(macroId, newIndices));
  };
}

function setEditorActiveTab(tab) {
  return {
    type: action_types["b" /* types */].SET_EDITOR_ACTIVE_TAB,
    data: tab
  };
}

function preinstall() {
  var yesInstall = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

  return function (dispatch, getState) {
    var markThisVersion = function markThisVersion() {
      return common_storage["default"].get('preinstall_info').then(function () {
        var info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var prevVersions = info.askedVersions || [];
        var thisVersion = config_default.a.preinstall.version;
        var hasThisOne = prevVersions.indexOf(thisVersion) !== -1;

        if (hasThisOne) return true;

        return common_storage["default"].set('preinstall_info', _extends({}, info, {
          askedVersions: [].concat(_toConsumableArray(prevVersions), [thisVersion])
        }));
      });
    };

    if (!yesInstall) return markThisVersion();

    log_default()('PREINSTALL_CSV_LIST', ["preinstall/csv/readcsvtestdata.csv"]);
    log_default()('PREINSTALL_VISION_LIST', ["preinstall/vision/canvas_3dots_verify_dpi_96.png","preinstall/vision/canvas_hydepark_dpi_96.png","preinstall/vision/canvas_hydepark_extract_dpi_96_relative.png","preinstall/vision/canvas_hydepark_verify_dpi_96.png","preinstall/vision/canvas_wyoming_dpi_96.png","preinstall/vision/canvas_wyoming_verify_dpi_96.png","preinstall/vision/democv_checkoverlay.png","preinstall/vision/democv_ocrdone.png","preinstall/vision/democv_share.png","preinstall/vision/democv_startocr.png","preinstall/vision/desktop_area_bottomright_dpi_96.png","preinstall/vision/desktop_area_topleft3_dpi_96.png","preinstall/vision/desktop_checktab_dpi_96.png","preinstall/vision/desktop_clearbutton_dpi_96.png","preinstall/vision/desktop_logstab_grey_dpi_96.png","preinstall/vision/desktop_logstab_white_dpi_96.png","preinstall/vision/desktop_scrtab_dpi_96.png","preinstall/vision/desktop_searcharea_dpi_96_relative.png","preinstall/vision/desktop_vartab_dpi_96.png","preinstall/vision/desktop_vitab_dpi_96.png","preinstall/vision/draw_checkresult1_dpi_96.png","preinstall/vision/draw_create1_dpi_96.png","preinstall/vision/draw_plus1_dpi_96.png","preinstall/vision/draw_select_pencil1_dpi_96.png","preinstall/vision/draw_start1_dpi_96.png","preinstall/vision/draw_text1_dpi_96.png","preinstall/vision/getquotenumber_dpi_96_relative.png","preinstall/vision/pdftest_salesquote.png","preinstall/vision/slider_handle_dpi_96.png","preinstall/vision/slider_red_dpi_96.png","preinstall/vision/uitest_download_dpi_96.png","preinstall/vision/uitest_hamburger_dpi_96.png","preinstall/vision/uitest_logo_mobile_dpi_96.png","preinstall/vision/uitest_logo_wide_dpi_96.png","preinstall/vision/uitest_share_dpi_96.png","preinstall/vision/youtube_play_button.png","preinstall/vision/youtube_video_content_verify.png"]);

    var installMacrosAndSuites = function installMacrosAndSuites() {
      if (!preinstall_macros || !Object.keys(preinstall_macros).length) return Promise.resolve();

      var installMacros = function installMacros() {
        var macroStorage = Object(services_storage["getStorageManager"])().getMacroStorage();
        var path = macroStorage.getPathLib();
        var folders = Object.keys(preinstall_macros).map(function (relativePath) {
          return path.join(config_default.a.preinstall.macroFolder, path.dirname(relativePath));
        });
        var uniqueFolders = ts_utils["uniqueStrings"].apply(undefined, _toConsumableArray(folders));

        return ts_utils["flow"].apply(undefined, _toConsumableArray(uniqueFolders.map(function (dirPath) {
          return function () {
            return macroStorage.ensureDirectory(dirPath);
          };
        }))).then(function () {
          return Promise.all(Object.keys(preinstall_macros).map(function (relativePath) {
            var macroName = path.basename(relativePath);
            var filePath = macroStorage.filePath(path.join(config_default.a.preinstall.macroFolder, relativePath));
            var str = JSON.stringify(preinstall_macros[relativePath]);
            var macro = Object(convert_utils["fromJSONString"])(str, macroName);

            return macroStorage.write(filePath, macro);
          }));
        });
      };

      var installTestSuites = function installTestSuites() {
        var tss = preinstall_suites.map(function (ts) {
          return Object(convert_suite_utils["parseTestSuite"])(JSON.stringify(ts));
        });
        dispatch(addTestSuites(tss, services_storage["StorageStrategyType"].Browser));
      };

      return Object(ts_utils["flow"])(installMacros, installTestSuites);
    };

    // Preinstall csv
    var installCsvs = function installCsvs() {
      var list = ["preinstall/csv/readcsvtestdata.csv"];
      if (list.length === 0) return Promise.resolve();

      // Note: preinstalled resources all go into browser mode
      var csvStorage = Object(services_storage["getStorageManager"])().getStorageForTarget(services_storage["StorageTarget"].CSV, services_storage["StorageStrategyType"].Browser);

      return csvStorage.ensureDir().then(function () {
        var ps = list.map(function (url) {
          var parts = url.split('/');
          var fileName = parts[parts.length - 1];

          return Object(utils["loadCsv"])(url).then(function (text) {
            return csvStorage.write(fileName, new Blob([text]));
          });
        });

        return Promise.resolve(ps)
        // Note: delay needed for Firefox and slow Chrome
        .then(function () {
          return Object(utils["delay"])(function () {}, 3000);
        }).then(function () {
          dispatch(listCSV());
        });
      });
    };

    // Preinstall vision images
    var installVisionImages = function installVisionImages() {
      var list = ["preinstall/vision/canvas_3dots_verify_dpi_96.png","preinstall/vision/canvas_hydepark_dpi_96.png","preinstall/vision/canvas_hydepark_extract_dpi_96_relative.png","preinstall/vision/canvas_hydepark_verify_dpi_96.png","preinstall/vision/canvas_wyoming_dpi_96.png","preinstall/vision/canvas_wyoming_verify_dpi_96.png","preinstall/vision/democv_checkoverlay.png","preinstall/vision/democv_ocrdone.png","preinstall/vision/democv_share.png","preinstall/vision/democv_startocr.png","preinstall/vision/desktop_area_bottomright_dpi_96.png","preinstall/vision/desktop_area_topleft3_dpi_96.png","preinstall/vision/desktop_checktab_dpi_96.png","preinstall/vision/desktop_clearbutton_dpi_96.png","preinstall/vision/desktop_logstab_grey_dpi_96.png","preinstall/vision/desktop_logstab_white_dpi_96.png","preinstall/vision/desktop_scrtab_dpi_96.png","preinstall/vision/desktop_searcharea_dpi_96_relative.png","preinstall/vision/desktop_vartab_dpi_96.png","preinstall/vision/desktop_vitab_dpi_96.png","preinstall/vision/draw_checkresult1_dpi_96.png","preinstall/vision/draw_create1_dpi_96.png","preinstall/vision/draw_plus1_dpi_96.png","preinstall/vision/draw_select_pencil1_dpi_96.png","preinstall/vision/draw_start1_dpi_96.png","preinstall/vision/draw_text1_dpi_96.png","preinstall/vision/getquotenumber_dpi_96_relative.png","preinstall/vision/pdftest_salesquote.png","preinstall/vision/slider_handle_dpi_96.png","preinstall/vision/slider_red_dpi_96.png","preinstall/vision/uitest_download_dpi_96.png","preinstall/vision/uitest_hamburger_dpi_96.png","preinstall/vision/uitest_logo_mobile_dpi_96.png","preinstall/vision/uitest_logo_wide_dpi_96.png","preinstall/vision/uitest_share_dpi_96.png","preinstall/vision/youtube_play_button.png","preinstall/vision/youtube_video_content_verify.png"];
      if (list.length === 0) return Promise.resolve();

      // Note: preinstalled resources all go into browser mode
      var visionStorage = Object(services_storage["getStorageManager"])().getStorageForTarget(services_storage["StorageTarget"].Vision, services_storage["StorageStrategyType"].Browser);

      return visionStorage.ensureDir().then(function () {
        var ps = list.map(function (url) {
          var parts = url.split('/');
          var fileName = parts[parts.length - 1];

          return Object(utils["loadImage"])(url).then(function (blob) {
            return visionStorage.write(fileName, blob);
          });
        });

        return Promise.resolve(ps)
        // Note: delay needed for Firefox and slow Chrome
        .then(function () {
          return Object(utils["delay"])(function () {}, 3000);
        }).then(function () {
          dispatch(listVisions());
        });
      });
    };

    return Promise.all([installMacrosAndSuites(), installCsvs(), installVisionImages()]).then(markThisVersion);
  };
}

/***/ }),

/***/ 161:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.renderLogType = (log) => {
    switch (log.type) {
        case 'reflect':
            return '[info]';
        case 'error':
            return (log.options && log.options.ignored) ? '[error][ignored]' : '[error]';
        default:
            return `[${log.type}]`;
    }
};
exports.renderLog = (log, withTimestamp = false) => {
    const prefix = withTimestamp ? (log.createTime.toISOString() + ' - ') : '';
    return prefix + exports.renderLogType(log) + ' ' + log.text;
};


/***/ }),

/***/ 17:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const mk = (list) => list.reduce((prev, key) => {
    prev[key] = key;
    return prev;
}, {});
exports.APP_STATUS = mk([
    'NORMAL',
    'INSPECTOR',
    'RECORDER',
    'PLAYER'
]);
exports.INSPECTOR_STATUS = mk([
    'PENDING',
    'INSPECTING',
    'STOPPED'
]);
exports.RECORDER_STATUS = mk([
    'PENDING',
    'RECORDING',
    'STOPPED'
]);
exports.PLAYER_STATUS = mk([
    'PLAYING',
    'PAUSED',
    'STOPPED'
]);
exports.PLAYER_MODE = mk([
    'TEST_CASE',
    'TEST_SUITE'
]);
exports.CONTENT_SCRIPT_STATUS = mk([
    'NORMAL',
    'RECORDING',
    'INSPECTING',
    'PLAYING'
]);
exports.TEST_CASE_STATUS = mk([
    'NORMAL',
    'SUCCESS',
    'ERROR',
    'ERROR_IN_SUB'
]);
exports.LAST_SCREENSHOT_FILE_NAME = '__lastscreenshot';
exports.LAST_DESKTOP_SCREENSHOT_FILE_NAME = '__last_desktop_screenshot';
exports.UNTITLED_ID = '__untitled__';


/***/ }),

/***/ 181:
/***/ (function(module, exports) {


function removeFromArray(array, item) {
  var index = array.indexOf(item);

  if (index >= 0) {
    array.splice(index, 1);
  }
}

var DataTransfer = function DataTransfer() {
  this.dataByFormat = {};

  this.dropEffect = 'none';
  this.effectAllowed = 'all';
  this.files = [];
  this.types = [];
};

DataTransfer.prototype.clearData = function (dataFormat) {
  if (dataFormat) {
    delete this.dataByFormat[dataFormat];
    removeFromArray(this.types, dataFormat);
  } else {
    this.dataByFormat = {};
    this.types = [];
  }
};

DataTransfer.prototype.getData = function (dataFormat) {
  return this.dataByFormat[dataFormat];
};

DataTransfer.prototype.setData = function (dataFormat, data) {
  this.dataByFormat[dataFormat] = data;

  if (this.types.indexOf(dataFormat) < 0) {
    this.types.push(dataFormat);
  }

  return true;
};

DataTransfer.prototype.setDragImage = function () {
  // don't do anything (the stub just makes sure there is no error thrown if someone tries to call the method)
};

module.exports = function () {
  // Note: in Firefox, window.DataTransfer exists, but it can't be used as constructor
  // In Firefox, `new window.DataTransfer()` throws errors like 'TypeError: Illegal constructor'
  if (window.DataTransfer) {
    try {
      var tmp = new window.DataTransfer();
      return window.DataTransfer;
    } catch (e) {}
  }

  return DataTransfer;
}();

/***/ }),

/***/ 182:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const registry_1 = __webpack_require__(184);
class BaseProxyManager {
    constructor() {
        this.proxy = null;
        this.registry = registry_1.createListenerRegistry();
    }
    getProxy() {
        return Promise.resolve(this.proxy);
    }
    getAuth(host, port) {
        if (!this.proxy || !this.proxy.username) {
            return null;
        }
        // port could be number, so must convert it to string before compare
        if (this.proxy.host === host && this.proxy.port === '' + port) {
            return {
                username: this.proxy.username,
                password: this.proxy.password
            };
        }
        return null;
    }
    onChange(listener) {
        this.registry.add('change', listener);
        return () => { this.registry.remove('change', listener); };
    }
}
exports.BaseProxyManager = BaseProxyManager;


/***/ }),

/***/ 184:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Registry {
    constructor({ process, onZero, onOne }) {
        this.cache = {};
        this.process = process;
        this.onZero = onZero || (() => { });
        this.onOne = onOne || (() => { });
    }
    add(id, obj) {
        this.cache[id] = this.cache[id] || [];
        this.cache[id].push(obj);
        if (this.cache[id].length === 1) {
            try {
                this.onOne(id);
            }
            catch (e) {
                // tslint:disable-next-line
                console.error('in onOne, ' + e.message);
            }
        }
        return true;
    }
    remove(id, obj) {
        if (!this.cache[id]) {
            return false;
        }
        this.cache[id] = this.cache[id].filter((item) => item !== obj);
        if (this.cache[id].length === 0) {
            try {
                this.onZero(id);
            }
            catch (e) {
                // tslint:disable-next-line
                console.error('in onZero, ' + e.message);
            }
        }
        return true;
    }
    removeAllWithData(obj) {
        Object.keys(this.cache).forEach((id) => {
            for (let i = this.cache[id].length - 1; i >= 0; i--) {
                if (this.cache[id][i] === obj) {
                    this.remove(id, this.cache[id][i]);
                }
            }
        });
    }
    fire(id, data) {
        if (!this.cache[id]) {
            return false;
        }
        this.cache[id].forEach((item) => {
            try {
                this.process(item, data, id);
            }
            catch (e) {
                // tslint:disable-next-line
                console.error('in process, ' + e.message);
            }
        });
        return true;
    }
    has(id) {
        return this.cache[id] && this.cache[id].length > 0;
    }
    keys() {
        return Object.keys(this.cache).filter((key) => this.cache[key] && this.cache[key].length > 0);
    }
    destroy() {
        Object.keys(this.cache).forEach((id) => {
            try {
                this.onZero(id);
            }
            catch (e) {
                // tslint:disable-next-line
                console.error('in onZero, ' + e.message);
            }
        });
        this.cache = {};
    }
}
exports.Registry = Registry;
function createListenerRegistry() {
    return new Registry({
        process: (fn, data, id) => {
            fn(data);
        }
    });
}
exports.createListenerRegistry = createListenerRegistry;


/***/ }),

/***/ 185:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MigrationJobType;
(function (MigrationJobType) {
    MigrationJobType["MigrateMacroTestSuiteToBrowserFileSystem"] = "20190401_macro_test_suite_to_browser_fs";
})(MigrationJobType = exports.MigrationJobType || (exports.MigrationJobType = {}));
var MigrationResult;
(function (MigrationResult) {
    MigrationResult[MigrationResult["AlreadyMigrated"] = 0] = "AlreadyMigrated";
    MigrationResult[MigrationResult["NotQualified"] = 1] = "NotQualified";
    MigrationResult[MigrationResult["Success"] = 2] = "Success";
    MigrationResult[MigrationResult["Error"] = 3] = "Error";
    MigrationResult[MigrationResult["JobUnknown"] = 4] = "JobUnknown";
})(MigrationResult = exports.MigrationResult || (exports.MigrationResult = {}));


/***/ }),

/***/ 187:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(0));
const react_dom_1 = __importDefault(__webpack_require__(18));
const prop_types_1 = __importDefault(__webpack_require__(1));
const antd_1 = __webpack_require__(117);
class Prompt extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.state = {
            value: '',
            visible: true
        };
        this.onOk = () => {
            return this.props.onOk(this.state.value)
                .then(() => this.hide());
        };
        this.onCancel = () => {
            return this.props.onCancel()
                .then(() => this.hide());
        };
    }
    componentDidMount() {
        this.setState({ value: this.props.value });
        setTimeout(() => this.focus(), 100);
    }
    componentWillReceiveProps(newProps) {
        if (newProps.value !== this.props.value) {
            this.setState({ value: newProps.value });
            setTimeout(() => this.focus(), 100);
        }
    }
    focus() {
        const input = this.input;
        if (input && input.refs && input.refs.input) {
            const $input = input.refs.input;
            $input.focus();
            if (this.props.inputType === 'text') {
                $input.selectionStart = this.props.selectionStart !== undefined ? this.props.selectionStart : 0;
                $input.selectionEnd = this.props.selectionEnd !== undefined ? this.props.selectionEnd : $input.value.length;
            }
        }
    }
    hide() {
        this.setState({ visible: false });
    }
    render() {
        return (react_1.default.createElement(antd_1.Modal, { ref: ref => { this.modal = ref; }, visible: this.state.visible, align: 'left', title: this.props.title, width: this.props.width, closable: this.props.closable, maskClosable: this.props.closable, okText: this.props.okText, cancelText: this.props.cancelText, onOk: this.onOk, onCancel: this.onCancel },
            this.props.message && this.props.message.length ? (react_1.default.createElement("pre", { style: {
                    fontFamily: 'inherit',
                    marginBottom: '10px',
                    whiteSpace: 'pre-wrap'
                } }, this.props.message)) : null,
            this.props.noInput ? null : (react_1.default.createElement(antd_1.Input, { defaultValue: "", ref: ref => this.input = ref, type: this.props.inputType, autosize: false, placeholder: this.props.placeholder, value: this.state.value, onChange: e => this.setState({ value: e.target.value }), onKeyDown: e => {
                    if (e.keyCode === 13)
                        this.onOk();
                } }))));
    }
}
exports.Prompt = Prompt;
Prompt.propTypes = {
    onOk: prop_types_1.default.func.isRequired,
    onCancel: prop_types_1.default.func.isRequired,
    title: prop_types_1.default.string,
    width: prop_types_1.default.number,
    message: prop_types_1.default.string,
    value: prop_types_1.default.string,
    noInput: prop_types_1.default.bool,
    inputType: prop_types_1.default.string,
    selectionStart: prop_types_1.default.number,
    selectionEnd: prop_types_1.default.number,
    placeholder: prop_types_1.default.string,
    okText: prop_types_1.default.string,
    cancelText: prop_types_1.default.string,
    keepOpenOnError: prop_types_1.default.bool
};
Prompt.defaultProps = {
    width: 350,
    title: 'Please input',
    message: '',
    value: '',
    placeholder: '',
    selectionStart: 0,
    selectionEnd: 0,
    noInput: false,
    closable: true,
    inputType: 'text',
    okText: 'Confirm',
    cancelText: 'Cancel',
    keepOpenOnError: false
};
function prompt(props) {
    return new Promise((resolve, reject) => {
        const wrappedProps = Object.assign(Object.assign({}, props), { onOk: (str) => {
                const go = () => {
                    resolve(str);
                    destroy();
                    return Promise.resolve(true);
                };
                return new Promise(resolve => {
                    resolve(props.onOk ? props.onOk(str) : true);
                })
                    .then(go, (e) => {
                    if (props.keepOpenOnError) {
                        return Promise.reject(e);
                    }
                    reject(e);
                    return true;
                });
            }, onCancel: () => {
                const go = () => {
                    resolve(null);
                    destroy();
                    return Promise.resolve(true);
                };
                return new Promise(resolve => {
                    resolve(props.onCancel ? props.onCancel() : true);
                })
                    .then(go, (e) => {
                    if (props.keepOpenOnError) {
                        return Promise.reject(e);
                    }
                    reject(e);
                    return true;
                });
            } });
        const $root = document.createElement('div');
        const $el = document.createElement('div');
        const destroy = () => setTimeout(() => {
            $root.remove();
        }, 1000);
        document.body.appendChild($root);
        $root.appendChild($el);
        react_dom_1.default.render(react_1.default.createElement(Prompt, Object.assign({}, wrappedProps)), $el);
    });
}
exports.prompt = prompt;


/***/ }),

/***/ 191:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CommandRunningStatus;
(function (CommandRunningStatus) {
    CommandRunningStatus[CommandRunningStatus["Pending"] = 0] = "Pending";
    CommandRunningStatus[CommandRunningStatus["Success"] = 1] = "Success";
    CommandRunningStatus[CommandRunningStatus["Failure"] = 2] = "Failure";
    CommandRunningStatus[CommandRunningStatus["Warning"] = 3] = "Warning";
})(CommandRunningStatus = exports.CommandRunningStatus || (exports.CommandRunningStatus = {}));
var MacroStatus;
(function (MacroStatus) {
    MacroStatus[MacroStatus["Idle"] = 0] = "Idle";
    MacroStatus[MacroStatus["Running"] = 1] = "Running";
    MacroStatus[MacroStatus["Calling"] = 2] = "Calling";
    MacroStatus[MacroStatus["Finished"] = 3] = "Finished";
    MacroStatus[MacroStatus["Error"] = 4] = "Error";
})(MacroStatus = exports.MacroStatus || (exports.MacroStatus = {}));
function getCommandResults(data) {
    const { doneIndices, errorIndices, warningIndices, count } = data;
    const result = [];
    for (let i = 0; i < count; i++) {
        if (doneIndices.indexOf(i) !== -1) {
            result.push(CommandRunningStatus.Success);
        }
        else if (errorIndices.indexOf(i) !== -1) {
            result.push(CommandRunningStatus.Failure);
        }
        else if (warningIndices.indexOf(i) !== -1) {
            result.push(CommandRunningStatus.Warning);
        }
        else {
            result.push(CommandRunningStatus.Pending);
        }
    }
    return result;
}
exports.getCommandResults = getCommandResults;
function getDoneErrorIndices(commandResults) {
    const doneIndices = [];
    const errorIndices = [];
    const warningIndices = [];
    commandResults.forEach((r, i) => {
        switch (r) {
            case CommandRunningStatus.Failure:
                return errorIndices.push(i);
            case CommandRunningStatus.Warning:
                return warningIndices.push(i);
            case CommandRunningStatus.Success:
                return doneIndices.push(i);
        }
    });
    return {
        doneIndices,
        errorIndices,
        warningIndices,
        count: commandResults.length
    };
}
exports.getDoneErrorIndices = getDoneErrorIndices;


/***/ }),

/***/ 195:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(0));
const antd_1 = __webpack_require__(117);
const state_1 = __webpack_require__(62);
function ResourceNotLoaded(props) {
    return (react_1.default.createElement("div", { className: "list-not-loaded" },
        react_1.default.createElement("p", null,
            "Started by ",
            state_1.stringForRunBy(props.from),
            "."),
        react_1.default.createElement("p", null,
            props.name,
            " not loaded."),
        react_1.default.createElement(antd_1.Button, { type: "primary", onClick: props.showList }, "Load now")));
}
exports.ResourceNotLoaded = ResourceNotLoaded;


/***/ }),

/***/ 197:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(153);
const ts_utils_1 = __webpack_require__(12);
const config_1 = __importDefault(__webpack_require__(34));
class OcrServerKeyValueData extends common_1.KeyValueData {
    getAll() {
        return super.get("").then(data => data || {});
    }
    getMainKeyAndSubKeys(key) {
        const [mainKey, subKeys] = super.getMainKeyAndSubKeys(key);
        return [
            OcrServerKeyValueData.STORAGE_KEY,
            [mainKey].concat(subKeys).filter(x => x && x.length)
        ];
    }
}
exports.OcrServerKeyValueData = OcrServerKeyValueData;
OcrServerKeyValueData.STORAGE_KEY = 'ocr_server_data';
exports.getOcrServerKeyValueData = ts_utils_1.singletonGetter(() => new OcrServerKeyValueData());
class OcrEndpointPicker {
    constructor(options) {
        this.servers = options.servers;
        this.resetTime = options.resetTime;
        this.lastId = null;
    }
    all() {
        return Promise.resolve(this.servers);
    }
    isAllDown() {
        return this.validServers()
            .then(({ servers }) => {
            return servers.length === 0;
        });
    }
    randomPick() {
        return this.validServers()
            .then(({ servers, serverInfos }) => {
            return servers[randomIndex(servers.length)];
        });
    }
    bestPick() {
        return this.validServers()
            .then(({ servers, serverInfos }) => {
            const getTime = (server) => {
                return serverInfos[server.id] ? serverInfos[server.id].lastTotalMilliseconds : 0;
            };
            return servers.reduce((prev, server) => {
                if (!prev)
                    return server;
                // Note: These two lines are used to avoid using the same endpoint on two consecutive runs
                // That's not what we want at this comment, so comment it out
                //
                // if (prev.id === this.lastId)    return server
                // if (server.id === this.lastId)  return prev
                const timeA = getTime(prev);
                const timeB = getTime(server);
                switch (Math.sign(timeA - timeB)) {
                    case 0: return Math.random() > 0.5 ? prev : server;
                    case 1: return server;
                    case -1:
                    default: return prev;
                }
            });
        });
    }
    reset() {
        // Note: reset server sanity to null when all servers are down,
        // so that it will check all servers again on next request
        return ts_utils_1.flow(...this.servers.map(server => {
            return () => exports.getOcrServerKeyValueData().set(server.id, null);
        }))
            .then(() => { });
    }
    use(id) {
        const found = this.servers.find(item => item.id === id);
        if (!found)
            throw new Error(`No server found with id '${id}'`);
        this.lastId = id;
    }
    report(id, sanityInfo) {
        return exports.getOcrServerKeyValueData().set(id, sanityInfo)
            .then(() => true);
    }
    validServers() {
        return exports.getOcrServerKeyValueData().getAll()
            .then(serverInfos => {
            const now = new Date().getTime();
            const servers = this.servers.filter(server => {
                const info = serverInfos[server.id];
                if (!info)
                    return true;
                if (now - info.lastResponseTimestamp > this.resetTime)
                    return true;
                if (info.lastError)
                    return false;
                return info.lastTotalMilliseconds <= config_1.default.ocr.apiHealthyResponseTime;
            });
            if (servers.length === 0) {
                throw new Error('All OCR servers are down');
            }
            return {
                servers,
                serverInfos
            };
        });
    }
}
exports.OcrEndpointPicker = OcrEndpointPicker;
function randomIndex(count) {
    return Math.round(Math.random() * count);
}
exports.randomIndex = randomIndex;
exports.getOcrEndpointPicker = ts_utils_1.singletonGetter(() => {
    return new OcrEndpointPicker({
        servers: config_1.default.ocr.apiList,
        resetTime: config_1.default.ocr.resetTime
    });
});


/***/ }),

/***/ 20:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ipc_bg_cs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93);


var throwNotTop = function throwNotTop() {
  throw new Error('You are not a top window, not allowed to initialize/use csIpc');
};

// Note: csIpc is only available to top window
var ipc = window.top === window ? Object(_ipc_bg_cs__WEBPACK_IMPORTED_MODULE_0__["csInit"])() : {
  ask: throwNotTop,
  send: throwNotTop,
  onAsk: throwNotTop,
  destroy: throwNotTop

  // Note: one ipc singleton per content script
};/* harmony default export */ __webpack_exports__["default"] = (ipc);

/***/ }),

/***/ 21:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export make3 */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return type3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return types; });
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

// Generate three action types, used in actions that return promises
var make3 = function make3(name) {
  return [name + '_REQUEST', name + '_SUCCESS', name + '_FAIL'];
};

var type3 = function type3(name) {
  return make3(name).map(function (key) {
    return types[key];
  });
};

var promiseTypes = ['START_RECORDING', 'STOP_RECORDING', 'START_INSPECTING', 'STOP_INSPECTING'].reduce(function (prev, cur) {
  make3(cur).forEach(function (key) {
    prev[key] = key;
  });

  return prev;
}, {});

var simpleTypes = ['SET_ROUTE', 'SET_EDITOR_ACTIVE_TAB', 'DONE_INSPECTING', 'UPDATE_BASE_URL', 'APPEND_COMMAND', 'DUPLICATE_COMMAND', 'INSERT_COMMAND', 'UPDATE_COMMAND', 'REMOVE_COMMAND', 'SELECT_COMMAND', 'CUT_COMMAND', 'COPY_COMMAND', 'PASTE_COMMAND', 'NORMALIZE_COMMANDS', 'UPDATE_SELECTED_COMMAND', 'SAVE_EDITING_AS_EXISTED', 'SAVE_EDITING_AS_NEW', 'SET_TEST_CASES', 'SET_EDITING', 'EDIT_TEST_CASE', 'EDIT_NEW_TEST_CASE', 'ADD_TEST_CASES', 'RENAME_TEST_CASE', 'REMOVE_TEST_CASE', 'UPDATE_TEST_SUITE_STATUS', 'UPDATE_ONE_MACRO_EXTRA', 'SET_ONE_MACRO_EXTRA', 'SET_MACROS_EXTRA', 'SET_TEST_SUITES_EXTRA', 'SET_PLAYER_STATE', 'SET_PLAYER_MODE', 'SET_TEST_SUITES', 'UPDATE_TEST_SUITE', 'ADD_LOGS', 'CLEAR_LOGS', 'ADD_SCREENSHOT', 'CLEAR_SCREENSHOTS', 'ADD_VISION', 'CLEAR_VISIONS', 'START_PLAYING', 'STOP_PLAYING', 'SET_CSV_LIST', 'SET_SCREENSHOT_LIST', 'SET_VISION_LIST', 'SET_VARIABLE_LIST', 'SET_SOURCE_ERROR', 'SET_SOURCE_CURRENT', 'UPDATE_CONFIG', 'UPDATE_UI', 'UPDATE_PROXY'].reduce(function (prev, cur) {
  prev[cur] = cur;
  return prev;
}, {});

var types = _extends({}, simpleTypes, promiseTypes);

/***/ }),

/***/ 22:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = __webpack_require__(4);
exports.getStyle = function (dom) {
    if (!dom)
        throw new Error('getStyle: dom does not exist');
    return getComputedStyle(dom);
};
exports.setStyle = function (dom, style) {
    if (!dom)
        throw new Error('setStyle: dom does not exist');
    for (var i = 0, keys = Object.keys(style), len = keys.length; i < len; i++) {
        dom.style[keys[i]] = style[keys[i]];
    }
    return dom;
};
exports.pixel = function (num) {
    if ((num + '').indexOf('px') !== -1)
        return num;
    return (num || 0) + 'px';
};
exports.bindDrag = (options) => {
    const { onDragStart, onDragEnd, onDrag, $el, preventGlobalClick = true, doc = document } = options;
    let isDragging = false;
    let startPos = { x: 0, y: 0 };
    const onMouseDown = (e) => {
        isDragging = true;
        startPos = { x: e.screenX, y: e.screenY };
        onDragStart(e);
    };
    const onMouseUp = (e) => {
        if (!isDragging)
            return;
        isDragging = false;
        const dx = e.screenX - startPos.x;
        const dy = e.screenY - startPos.y;
        onDragEnd(e, { dx, dy });
    };
    const onMouseMove = (e) => {
        if (!isDragging)
            return;
        const dx = e.screenX - startPos.x;
        const dy = e.screenY - startPos.y;
        onDrag(e, { dx, dy });
        e.preventDefault();
        e.stopPropagation();
    };
    const onClick = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };
    if (preventGlobalClick) {
        doc.addEventListener('click', onClick, true);
    }
    doc.addEventListener('mousemove', onMouseMove, true);
    doc.addEventListener('mouseup', onMouseUp, true);
    $el.addEventListener('mousedown', onMouseDown, true);
    return () => {
        doc.removeEventListener('click', onClick, true);
        doc.removeEventListener('mousemove', onMouseMove, true);
        doc.removeEventListener('mouseup', onMouseUp, true);
        $el.removeEventListener('mousedown', onMouseDown, true);
    };
};
exports.bindContentEditableChange = (options) => {
    const { onChange, doc = document } = options;
    let currentCE = null;
    let oldContent = null;
    const onFocus = (e) => {
        if (!e.target || e.target.contentEditable !== 'true')
            return;
        currentCE = e.target;
        oldContent = currentCE.innerHTML;
    };
    const onBlur = (e) => {
        if (e.target !== currentCE) {
            // Do nothing
        }
        else if (currentCE && currentCE.innerHTML !== oldContent) {
            onChange(e);
        }
        currentCE = null;
        oldContent = null;
    };
    doc.addEventListener('focus', onFocus, true);
    doc.addEventListener('blur', onBlur, true);
    return () => {
        doc.removeEventListener('focus', onFocus, true);
        doc.removeEventListener('blur', onBlur, true);
    };
};
exports.scrollLeft = function (document) {
    return document.documentElement.scrollLeft;
};
exports.scrollTop = function (document) {
    return document.documentElement.scrollTop;
};
exports.domText = ($dom) => {
    const it = $dom.innerText ? $dom.innerText.trim() : '';
    const tc = $dom.textContent;
    const pos = tc.toUpperCase().indexOf(it.toUpperCase());
    return pos === -1 ? it : tc.substr(pos, it.length);
};
exports.isVisible = function (el) {
    if (el === window.document)
        return true;
    if (!el)
        return true;
    const style = window.getComputedStyle(el);
    if (style.display === 'none' || style.opacity === '0' || style.visibility === 'hidden')
        return false;
    return exports.isVisible(el.parentNode);
};
exports.cssSelector = function (dom) {
    if (!dom)
        return '';
    if (dom.nodeType !== 1)
        return '';
    if (dom.tagName === 'BODY')
        return 'body';
    if (dom.id)
        return '#' + dom.id;
    var classes = dom.className.split(/\s+/g)
        .filter(function (item) {
        return item && item.length;
    });
    var children = Array.from(dom.parentNode ? dom.parentNode.childNodes : [])
        .filter(function ($el) {
        return $el.nodeType === 1;
    });
    var sameTag = children.filter(function ($el) {
        return $el.tagName === dom.tagName;
    });
    var sameClass = children.filter(function ($el) {
        var cs = $el.className.split(/\s+/g);
        return utils_1.and(...classes.map(function (c) {
            return cs.indexOf(c) !== -1;
        }));
    });
    var extra = '';
    if (sameTag.length === 1) {
        extra = '';
    }
    else if (classes.length && sameClass.length === 1) {
        extra = '.' + classes.join('.');
    }
    else {
        extra = ':nth-child(' + (1 + children.findIndex(function (item) { return item === dom; })) + ')';
    }
    var me = dom.tagName.toLowerCase() + extra;
    // Note: browser will add an extra 'tbody' when tr directly in table, which will cause an wrong selector,
    // so the hack is to remove all tbody here
    var ret = exports.cssSelector(dom.parentNode) + ' > ' + me;
    return ret;
    // return ret.replace(/\s*>\s*tbody\s*>?/g, ' ')
};
exports.isPositionFixed = ($dom) => {
    if (!$dom || $dom === document.documentElement || $dom === document.body)
        return false;
    return getComputedStyle($dom)['position'] === 'fixed' || exports.isPositionFixed($dom.parentNode);
};
exports.offset = function (dom) {
    if (!dom)
        return { left: 0, top: 0 };
    var rect = dom.getBoundingClientRect();
    return {
        left: rect.left + window.scrollX,
        top: rect.top + window.scrollY
    };
};
function accurateOffset(dom) {
    if (!dom)
        return { left: 0, top: 0 };
    const doc = dom.ownerDocument;
    if (!doc || dom === doc.documentElement)
        return { left: 0, top: 0 };
    const parentOffset = accurateOffset(dom.offsetParent);
    return {
        left: parentOffset.left + dom.offsetLeft,
        top: parentOffset.top + dom.offsetTop
    };
}
exports.accurateOffset = accurateOffset;
function preloadImage(url) {
    return new Promise((resolve, reject) => {
        const $img = new Image();
        $img.onload = () => {
            resolve({
                $img,
                width: $img.width,
                height: $img.height
            });
        };
        $img.onerror = (e) => {
            reject(e);
        };
        $img.src = url;
    });
}
exports.preloadImage = preloadImage;
function isFirefox() {
    return /Firefox/.test(window.navigator.userAgent);
}
exports.isFirefox = isFirefox;
function svgNodetoString(svgNode) {
    return svgNode.outerHTML;
}
exports.svgNodetoString = svgNodetoString;
function svgToBase64(str) {
    return 'data:image/svg+xml;base64,' + window.btoa(str);
}
exports.svgToBase64 = svgToBase64;
function canvasFromSVG(str) {
    return new Promise((resolve, reject) => {
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        const img = document.createElement('img');
        const b64 = svgToBase64(str);
        const mw = str.match(/<svg[\s\S]*?width="(.*?)"/m);
        const mh = str.match(/<svg[\s\S]*?height="(.*?)"/m);
        const w = parseInt(mw[1], 10);
        const h = parseInt(mh[1], 10);
        img.src = b64;
        img.onload = function () {
            c.width = w;
            c.height = h;
            ctx.drawImage(img, 0, 0, w, h);
            resolve(c);
        };
        img.onerror = function (e) {
            reject(e);
        };
    });
}
exports.canvasFromSVG = canvasFromSVG;
function imageBlobFromSVG(str, mimeType = 'image/png', quality) {
    return canvasFromSVG(str)
        .then(canvas => {
        const p = new Promise((resolve, reject) => {
            try {
                canvas.toBlob(resolve, mimeType, quality);
            }
            catch (e) {
                reject(e);
            }
        });
        return p;
    });
}
exports.imageBlobFromSVG = imageBlobFromSVG;
function imageDataFromUrl(url) {
    return preloadImage(url)
        .then(({ $img, width, height }) => {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        context.drawImage($img, 0, 0, width, height);
        return context.getImageData(0, 0, width, height);
    });
}
exports.imageDataFromUrl = imageDataFromUrl;
function subImage(imageUrl, rect) {
    return new Promise((resolve, reject) => {
        const $img = new Image();
        $img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = rect.width;
            canvas.height = rect.height;
            const context = canvas.getContext('2d');
            context.drawImage($img, 0, 0, $img.width, $img.height, -1 * rect.x, -1 * rect.y, $img.width, $img.height);
            resolve(canvas.toDataURL());
        };
        $img.src = imageUrl;
    });
}
exports.subImage = subImage;
function rgbToHex(r, g, b) {
    if (r > 255 || g > 255 || b > 255) {
        throw 'Invalid color component';
    }
    return ((r << 16) | (g << 8) | b).toString(16);
}
exports.rgbToHex = rgbToHex;
function getPixel(params) {
    const { x, y, dataUrl } = params;
    return new Promise((resolve, reject) => {
        const $img = new Image();
        $img.onload = () => {
            const imgWidth = $img.width;
            const imgHeight = $img.height;
            if (x < 0 || y < 0 || x > imgWidth || y > imgHeight) {
                return reject(new Error(`${x}, ${y} is out of screenshot bound 0, 0 ~ ${imgWidth}, ${imgHeight}`));
            }
            const canvas = document.createElement('canvas');
            canvas.width = x + 5;
            canvas.height = y + 5;
            const context = canvas.getContext('2d');
            context.drawImage($img, 0, 0, x + 5, y + 5, 0, 0, x + 5, y + 5);
            let hex;
            try {
                const p = context.getImageData(x, y, 1, 1).data;
                hex = '#' + ('000000' + rgbToHex(p[0], p[1], p[2])).slice(-6);
                resolve(hex);
            }
            catch (e) {
                reject(new Error(`Failed to get pixel color` + ((e === null || e === void 0 ? void 0 : e.message) ? `: ${e.message}.` : '.')));
            }
        };
        $img.src = dataUrl;
    });
}
exports.getPixel = getPixel;
function scaleRect(rect, scale) {
    return {
        x: scale * rect.x,
        y: scale * rect.y,
        width: scale * rect.width,
        height: scale * rect.height,
    };
}
exports.scaleRect = scaleRect;
function isEditable(el) {
    if (el.contentEditable === 'true') {
        return true;
    }
    const tag = (el.tagName || '').toLowerCase();
    if (['input', 'textarea'].indexOf(tag) === -1) {
        return false;
    }
    const disabled = el.disabled;
    const readOnly = el.readOnly;
    return !disabled && !readOnly;
}
exports.isEditable = isEditable;
function hasAncestor(el, checkAncestor) {
    let node = el;
    while (node) {
        if (checkAncestor(node)) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}
exports.hasAncestor = hasAncestor;
function getAncestor(el, checkAncestor) {
    let node = el;
    while (node) {
        if (checkAncestor(node)) {
            return node;
        }
        node = node.parentNode;
    }
    return null;
}
exports.getAncestor = getAncestor;


/***/ }),

/***/ 23:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const reselect_1 = __webpack_require__(731);
const constant_1 = __webpack_require__(17);
const macro_extra_data_1 = __webpack_require__(105);
const tree_file_1 = __webpack_require__(137);
const ts_utils_1 = __webpack_require__(12);
const state_1 = __webpack_require__(62);
exports.getTestSuitesWithAllInfo = reselect_1.createSelector([
    (state) => state.editor.testSuites,
    (state) => state.editor.testSuitesExtra
], (testSuites, testSuitesExtra) => {
    const getKey = (ts) => ts.id;
    return testSuites.map(ts => {
        const key = getKey(ts);
        const extra = testSuitesExtra[key || ''];
        return Object.assign(Object.assign({}, ts), (extra || {}));
    });
});
exports.getCurrentMacroId = reselect_1.createSelector([
    (state) => state.editor.editing.meta.src
], (src) => {
    return src ? src.id : constant_1.UNTITLED_ID;
});
exports.getBreakpoints = reselect_1.createSelector([
    (state) => state.editor.macrosExtra,
    exports.getCurrentMacroId
], (macrosExtra, macroId) => {
    const extra = macrosExtra[macroId] || {};
    return extra.breakpointIndices || [];
});
function getBreakpointsByMacroId(state, macroId) {
    const macrosExtra = state.editor.macrosExtra;
    const extra = macrosExtra[macroId] || {};
    return extra.breakpointIndices || [];
}
exports.getBreakpointsByMacroId = getBreakpointsByMacroId;
exports.getDoneCommandIndices = reselect_1.createSelector([
    (state) => state.editor.macrosExtra,
    exports.getCurrentMacroId
], (macrosExtra, macroId) => {
    const extra = macrosExtra[macroId] || {};
    return extra.doneCommandIndices || [];
});
exports.getWarningCommandIndices = reselect_1.createSelector([
    (state) => state.editor.macrosExtra,
    exports.getCurrentMacroId
], (macrosExtra, macroId) => {
    const extra = macrosExtra[macroId] || {};
    return extra.warningCommandIndices || [];
});
exports.getErrorCommandIndices = reselect_1.createSelector([
    (state) => state.editor.macrosExtra,
    exports.getCurrentMacroId
], (macrosExtra, macroId) => {
    const extra = macrosExtra[macroId] || {};
    return extra.errorCommandIndices || [];
});
exports.isFocusOnCommandTable = reselect_1.createSelector([(state) => state], (state) => state.ui.focusArea === state_1.FocusArea.CommandTable);
exports.isFocusOnSidebar = reselect_1.createSelector([(state) => state], (state) => state.ui.focusArea === state_1.FocusArea.Sidebar);
exports.getConfig = reselect_1.createSelector([(state) => state.config], ts_utils_1.id);
exports.getShouldSaveAlternativeLocators = reselect_1.createSelector([exports.getConfig], (config) => !!config.saveAlternativeLocators);
function hasUnsavedMacro(state) {
    const { editor } = state;
    const { editing, editingSource, activeTab } = editor;
    if (!editing.meta.src)
        return true;
    switch (activeTab) {
        case 'table_view': {
            const { hasUnsaved } = editing.meta || {};
            return hasUnsaved;
        }
        case 'source_view': {
            return editingSource.original !== editingSource.current;
        }
        default:
            throw new Error('Unknown activeTab');
    }
}
exports.hasUnsavedMacro = hasUnsavedMacro;
function findMacroNodeWithCaseInsensitiveField(state, field, value, isDirectory = false) {
    const nodes = isDirectory ? exports.getMacroFolderNodeList(state) : exports.getMacroFileNodeList(state);
    const transform = (path) => path.toLowerCase().replace(/\\/g, '/').replace(/\.json$/i, '');
    const toMatch = transform(value);
    return nodes.find(node => {
        if (isDirectory !== node.isDirectory) {
            return false;
        }
        return transform(node.fullPath) === toMatch || transform(node[field]) === toMatch;
    });
}
exports.findMacroNodeWithCaseInsensitiveField = findMacroNodeWithCaseInsensitiveField;
function findMacroNodeWithCaseInsensitiveFullPath(state, fullPath) {
    return findMacroNodeWithCaseInsensitiveField(state, 'fullPath', fullPath);
}
exports.findMacroNodeWithCaseInsensitiveFullPath = findMacroNodeWithCaseInsensitiveFullPath;
function findMacroNodeWithCaseInsensitiveRelativePath(state, relativePath) {
    return findMacroNodeWithCaseInsensitiveField(state, 'relativePath', relativePath);
}
exports.findMacroNodeWithCaseInsensitiveRelativePath = findMacroNodeWithCaseInsensitiveRelativePath;
function findMacroFolderWithCaseInsensitiveRelativePath(state, relativePath) {
    return findMacroNodeWithCaseInsensitiveField(state, 'relativePath', relativePath, true);
}
exports.findMacroFolderWithCaseInsensitiveRelativePath = findMacroFolderWithCaseInsensitiveRelativePath;
function editorSelectedCommand(state) {
    const { meta, commands } = state.editor.editing;
    if (!meta || meta.selectedIndex === -1)
        return null;
    return commands[meta.selectedIndex] || null;
}
exports.editorSelectedCommand = editorSelectedCommand;
function editorSelectedCommandIndex(state) {
    const { meta } = state.editor.editing;
    return meta ? meta.selectedIndex : null;
}
exports.editorSelectedCommandIndex = editorSelectedCommandIndex;
function editorCommandCount(state) {
    const { commands } = state.editor.editing;
    return commands.length;
}
exports.editorCommandCount = editorCommandCount;
function entryNodeToFileNodeData(entryNode, getClassName, getFolded) {
    return ts_utils_1.treeMap((entryData, paths) => {
        return {
            id: entryData.fullPath,
            type: entryData.isFile ? tree_file_1.FileNodeType.File : tree_file_1.FileNodeType.Folder,
            level: paths.length,
            selected: false,
            name: entryData.name,
            entryPath: entryData.fullPath,
            folded: getFolded(entryData),
            className: getClassName(entryData)
        };
    }, entryNode);
}
exports.entryNodeToFileNodeData = entryNodeToFileNodeData;
exports.getEditor = (state) => state.editor;
exports.getMacroFolderStructure = reselect_1.createSelector([exports.getEditor], (editor) => {
    return editor.macroFolderStructure;
});
exports.getMacrosExtra = reselect_1.createSelector([exports.getEditor], (editor) => {
    return editor.macrosExtra;
});
exports.getMacroFileNodeData = reselect_1.createSelector([
    exports.getMacroFolderStructure,
    exports.getMacrosExtra,
    exports.getCurrentMacroId,
    exports.isFocusOnSidebar,
], (macroFolderStructure, macrosExtra, macroId, sidebarFocused) => {
    const getClassName = (data) => {
        const klasses = [];
        const id = data.fullPath;
        const status = macrosExtra[id] && macrosExtra[id].status;
        klasses.push((() => {
            switch (status) {
                case macro_extra_data_1.MacroResultStatus.Success:
                    return 'success';
                case macro_extra_data_1.MacroResultStatus.Error:
                    return 'error';
                case macro_extra_data_1.MacroResultStatus.ErrorInSub:
                    return 'error-in-sub';
                default:
                    return 'normal';
            }
        })());
        if (macroId === id) {
            klasses.push('selected');
        }
        if (!sidebarFocused) {
            klasses.push('blur');
        }
        return klasses.join(' ');
    };
    const getFolded = (data) => {
        const id = data.fullPath;
        const folded = macrosExtra[id] && macrosExtra[id].folded || false;
        return folded;
    };
    return macroFolderStructure.map((node) => {
        return entryNodeToFileNodeData(node, getClassName, getFolded);
    });
});
exports.getFilteredMacroFileNodeData = reselect_1.createSelector([
    exports.getMacroFileNodeData,
    (state) => state.macroQuery
], (macroFileNodeData, searchText) => {
    const trimSearchText = searchText.trim().toLowerCase();
    const filteredFileNodeData = (() => {
        if (trimSearchText.length === 0) {
            return macroFileNodeData;
        }
        return macroFileNodeData.map((node) => {
            const filteredNode = ts_utils_1.treeFilter((data) => data.name.toLowerCase().indexOf(trimSearchText) !== -1, node);
            if (!filteredNode) {
                return null;
            }
            return ts_utils_1.treeMap((data) => (Object.assign(Object.assign({}, data), { folded: false })), filteredNode);
        })
            .filter(node => node);
    })();
    return filteredFileNodeData;
});
exports.getMacroFileNodeList = reselect_1.createSelector([exports.getMacroFolderStructure], (macroFolderStructure) => {
    const findAllMacros = (root) => {
        const result = [];
        ts_utils_1.traverseTree((node) => {
            if (node.isFile) {
                result.push(node);
            }
            return ts_utils_1.TraverseTreeResult.Normal;
        }, root);
        return result;
    };
    return ts_utils_1.flatten(macroFolderStructure.map(findAllMacros));
});
exports.getMacroFolderNodeList = reselect_1.createSelector([exports.getMacroFolderStructure], (macroFolderStructure) => {
    const findAllFolders = (root) => {
        const result = [];
        ts_utils_1.traverseTree((node) => {
            if (node.isDirectory) {
                result.push(node);
            }
            return ts_utils_1.TraverseTreeResult.Normal;
        }, root);
        return result;
    };
    return ts_utils_1.flatten(macroFolderStructure.map(findAllFolders));
});
exports.isMacroFolderNodeListEmpty = reselect_1.createSelector([exports.getMacroFolderNodeList], (entries) => {
    return entries.length === 0;
});
exports.getIndexToInsertRecorded = reselect_1.createSelector([
    (state) => state.editor.editing.meta.indexToInsertRecorded
], ts_utils_1.id);
exports.getStatus = reselect_1.createSelector([(state) => state.status], ts_utils_1.id);
exports.getShouldLoadResources = reselect_1.createSelector([(state) => state.from], (from) => from === state_1.RunBy.Manual);
exports.isPlaying = reselect_1.createSelector([exports.getStatus, ts_utils_1.id], (appStatus, state) => {
    return appStatus === constant_1.APP_STATUS.PLAYER && state.player.status === constant_1.PLAYER_STATUS.PLAYING;
});
exports.isNoDisplay = reselect_1.createSelector([exports.isPlaying, ts_utils_1.id], (isPlaying, state) => {
    return isPlaying && state.noDisplayInPlay;
});


/***/ }),

/***/ 27:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55);
/* harmony import */ var _node_modules_path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "win32", function() { return _node_modules_path__WEBPACK_IMPORTED_MODULE_0__["win32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "posix", function() { return _node_modules_path__WEBPACK_IMPORTED_MODULE_0__["posix"]; });



var isWindows = /windows/i.test(window.navigator.userAgent);
var path = isWindows ? _node_modules_path__WEBPACK_IMPORTED_MODULE_0__["win32"] : _node_modules_path__WEBPACK_IMPORTED_MODULE_0__["posix"];

/* harmony default export */ __webpack_exports__["default"] = (path);



/***/ }),

/***/ 28:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Player; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getPlayer; });
/* harmony import */ var event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(630);
/* harmony import */ var event_emitter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(event_emitter__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }




var MODE = {
  STRAIGHT: 'STRAIGHT',
  SINGLE: 'SINGLE',
  LOOP: 'LOOP'
};

var STATUS = {
  PLAYING: 'PLAYING',
  PAUSED: 'PAUSED',
  STOPPED: 'STOPPED',
  ERROR: 'ERROR'
};

var END_REASON = {
  COMPLETE: 'COMPLETE',
  ERROR: 'ERROR',
  MANUAL: 'MANUAL'
};

var isEmpty = function isEmpty(x) {
  return x === undefined || x === null;
};

var initialState = {
  startUrl: null,

  startIndex: null,
  endIndex: null,
  nextIndex: null,
  errorIndex: null,
  doneIndices: [],

  mode: MODE.STRAIGHT,
  resources: [],

  // preDelay: 0,
  // postDelay: 0,

  status: STATUS.STOPPED

  // Note: A generic player for consuming some kind of resources
  // It supports 3 modes: single, straight, loop.
  // Also for straight and loop, it can start or end at any valid index you want
  //
  // The main API of a player is
  // 1. constructor({ run: Function,  prepare: Function })
  // 2. play(config)
  // 3. pause()
  // 4. resume()
  // 5. stop()
  //
  // Events it emits
  // 1. START
  // 2. PREPARED
  // 3. TO_PLAY
  // 4. PLAYED_LIST
  // 5. PAUSED
  // 6. RESUMED
  // 7. END
  // 8. ERROR

};var Player = function () {
  function Player(opts, state) {
    _classCallCheck(this, Player);

    this.state = _extends({}, initialState);
    this.toResumePromises = {};

    if (!opts) {
      throw new Error('Player - constructor: must provide opts as 1st argument');
    }

    if (typeof opts.run !== 'function') {
      throw new Error('Player - constructor: must provide a run function');
    }

    if (typeof opts.prepare !== 'function') {
      throw new Error('Player - constructor: must provide a prepare function');
    }

    if (typeof opts.handleResult !== 'function') {
      throw new Error('Player - constructor: must provide a handleResult function');
    }

    this.__run = opts.run;
    this.__prepare = opts.prepare;
    this.__handle = opts.handleResult;

    this.__setState(state || {});
  }

  _createClass(Player, [{
    key: 'play',
    value: function play(config) {
      var _this = this;

      if (!config) {
        throw new Error('Player - play: config should not be empty');
      }

      if (!config.mode || Object.keys(MODE).indexOf(config.mode) === -1) {
        throw new Error('Player - play: must provide a valid mode, now it is ' + config.mode);
      }

      if (config.mode === MODE.LOOP && (!config.loopsStart || config.loopsStart < 0 || Math.floor(config.loopsStart) !== config.loopsStart || !config.loopsEnd || config.loopsEnd < config.loopsStart || Math.floor(config.loopsEnd) !== config.loopsEnd)) {
        throw new Error('Player - play: must provide a valid tuple of "loopsStart" and "loopsEnd" in loop mode, now it is ' + config.loopsStart + ', ' + config.loopsEnd);
      }

      if (config.resources.length !== 0) {
        if (isEmpty(config.startIndex) || config.startIndex < 0 || config.startIndex >= config.resources.length) {
          throw new Error('Player - play: startIndex out of range, now it is ' + config.startIndex + ', len: ' + config.resources.length);
        }
      }

      // Note: endIndex could be omitted
      if (!isEmpty(config.endIndex) && (config.endIndex < 0 || config.endIndex >= config.resources.length)) {
        throw new Error('Player - play: endIndex out of range, now it is ' + config.endIndex + ', len: ' + config.resources.length);
      }

      var nextIndex = config.nextIndex,
          startIndex = config.startIndex,
          startUrl = config.startUrl,
          resources = config.resources,
          title = config.title,
          extra = config.extra,
          doneIndices = config.doneIndices,
          noEndEvent = config.noEndEvent,
          token = config.token,
          isStep = config.isStep,
          loopsCursor = config.loopsCursor,
          loopsStart = config.loopsStart,
          loopsEnd = config.loopsEnd,
          isBackFromCalling = config.isBackFromCalling,
          needDelayAfterLoop = config.needDelayAfterLoop;

      var endIndex = config.endIndex || resources.length - 1;
      var basicState = {
        token: token,
        title: title,
        extra: extra,
        needDelayAfterLoop: needDelayAfterLoop,
        isBackFromCalling: isBackFromCalling,
        startUrl: startUrl,
        startIndex: startIndex,
        endIndex: endIndex,
        nextIndex: nextIndex !== undefined ? nextIndex : startIndex,
        errorIndex: null,
        doneIndices: doneIndices || [],
        mode: config.mode,
        loopsCursor: 1,
        loopsStart: 1,
        loopsEnd: 1,
        isStep: isStep || false,
        noEndEvent: noEndEvent || false,
        resources: config.resources,
        breakpoints: config.breakpoints || [],
        status: STATUS.PLAYING,
        public: config.public || {},
        callback: config.callback || function () {},
        lastPlayConfig: config,
        playUID: Math.random()
      };['preDelay', 'postDelay'].forEach(function (key) {
        if (isEmpty(config[key])) return;
        basicState[key] = config[key];
      });

      switch (config.mode) {
        case MODE.STRAIGHT:
          this.__setState(_extends({}, basicState));
          break;

        case MODE.SINGLE:
          this.__setState(_extends({}, basicState, {
            endIndex: startIndex
          }));
          break;

        case MODE.LOOP:
          this.__setState(_extends({}, basicState, {
            loopsStart: loopsStart,
            loopsEnd: loopsEnd,
            loopsCursor: loopsCursor !== undefined ? loopsCursor : loopsStart
          }));
          break;

        default:
          break;
      }

      this.emit('START', {
        title: title,
        loopsCursor: this.state.loopsCursor,
        doneIndices: this.state.doneIndices,
        extra: this.state.extra,
        isBackFromCalling: this.state.isBackFromCalling
      });

      return Promise.resolve().then(function () {
        return _this.__prepare(_this.state);
      }).then(function () {
        _this.emit('PREPARED', {
          title: title,
          loopsCursor: _this.state.loopsCursor,
          doneIndices: _this.state.doneIndices,
          extra: _this.state.extra,
          isBackFromCalling: _this.state.isBackFromCalling
        });
      }).then(function () {
        return _this.__go(_this.state.token || null);
      }, function (e) {
        return _this.__errLog(e, e.errorIndex);
      });
    }
  }, {
    key: 'pause',
    value: function pause() {
      var _this2 = this;

      this.__setState({
        status: STATUS.PAUSED
      });

      setTimeout(function () {
        _this2.emit('PAUSED', { extra: _this2.state.extra });
      }, 0);

      return this.__createPromiseWaitForResume(this.state.token);
    }
  }, {
    key: 'resume',
    value: function resume(isStep) {
      this.__setState({
        status: STATUS.PLAYING,
        isStep: !!isStep
      });

      this.emit('RESUMED', { extra: this.state.extra });
      // this.__go(null)

      var item = this.toResumePromises[this.state.token];

      if (item && item.resolve) {
        item.resolve();
      }
    }
  }, {
    key: 'stop',
    value: function stop(opts) {
      this.__end(END_REASON.MANUAL, opts);
    }
  }, {
    key: 'stopWithError',
    value: function stopWithError(error) {
      this.__errLog(error);
    }
  }, {
    key: 'jumpTo',
    value: function jumpTo(nextIndex) {
      var resources = this.state.resources;

      // Note: validate nextIndex by resources.length instead of startIndex and endIndex,
      // to make it possible for 'run from here' to jump to commands ahead of the start point

      if (nextIndex < 0 || nextIndex >= resources.length) {
        throw new Error('jumpTo: nextIndex out of range');
      }

      this.__setState({
        nextIndex: nextIndex
      });
    }
  }, {
    key: 'setPostDelay',
    value: function setPostDelay(n) {
      this.__setState({
        postDelay: n
      });
    }
  }, {
    key: 'getStatus',
    value: function getStatus() {
      return this.state.status;
    }
  }, {
    key: 'getState',
    value: function getState() {
      return _extends({}, this.state);
    }
  }, {
    key: 'setState',
    value: function setState(state) {
      return this.__setState(state);
    }
  }, {
    key: 'replayLastConfig',
    value: function replayLastConfig() {
      var config = this.state.lastPlayConfig;
      if (!config) throw new Error('No last play config available');

      return this.play(_extends({}, config, {
        nextIndex: config.startIndex
      }));
    }

    // Note: playUID changes on every `play` call
    // it's useful for features with timer to tell if it should continue to run

  }, {
    key: 'getPlayUID',
    value: function getPlayUID() {
      return this.state.playUID;
    }
  }, {
    key: 'checkPlayUID',
    value: function checkPlayUID(uid) {
      return this.state.playUID === uid;
    }
  }, {
    key: '__go',
    value: function __go(token) {
      var _this3 = this;

      // Note: in case it is returned from previous call

      if (token === undefined || token === null) {
        this.state.token = token = Math.random();
      } else if (token !== this.state.token) {
        return;
      }

      var guardToken = function guardToken(fn) {
        return function () {
          if (token !== _this3.state.token) {
            throw new Error('token expired');
          }
          return fn.apply(undefined, arguments);
        };
      };

      var _state = this.state,
          resources = _state.resources,
          nextIndex = _state.nextIndex,
          preDelay = _state.preDelay;

      var pre = preDelay > 0 ? this.__delay(function () {
        return undefined;
      }, preDelay) : Promise.resolve();

      // Note: the flow of this process:
      // 1. delay if `preDelay` set
      // 2. check `__shouldContinue`
      // 3. stop if the player is stopped or paused
      // 4. otherwise call `__run` to actually consume the current resource
      // 5. set the state to next by calling `__setNext`
      // 6. delay if `postDelay` set
      return pre.then(function () {
        return _this3.__shouldContinue();
      }).then(function (_ref) {
        var paused = _ref.paused,
            complete = _ref.complete;

        if (paused) {
          throw new Error('player: paused or stopped');
        }

        if (complete) {
          return;
        }

        var _state2 = _this3.state,
            resources = _state2.resources,
            nextIndex = _state2.nextIndex,
            startIndex = _state2.startIndex,
            loopsCursor = _state2.loopsCursor,
            loopsStart = _state2.loopsStart,
            loopsEnd = _state2.loopsEnd;

        // Note: when we're running loops

        if (nextIndex === startIndex) {
          var obj = {
            loopsCursor: loopsCursor,
            index: nextIndex,
            currentLoop: loopsCursor - loopsStart + 1,
            loops: loopsEnd - loopsStart + 1,
            resource: resources[nextIndex],
            extra: _this3.state.extra
          };

          _this3.emit('LOOP_START', obj);

          if (loopsCursor !== loopsStart) {
            _this3.emit('LOOP_RESTART', obj);
          }
        }

        _this3.emit('TO_PLAY', {
          index: nextIndex,
          currentLoop: loopsCursor - loopsStart + 1,
          loops: loopsEnd - loopsStart + 1,
          resource: resources[nextIndex],
          extra: _this3.state.extra
        });

        var possibleBreakpointPromise = function () {
          // Note: there will never be two breakpoints in straight. Use `lastBreakpoint` to tell whether we just hit a breakpoint
          // Also note that, 'TO_PLAY' events need to be fired before we pause.
          if (_this3.state.lastBreakpoint === undefined && _this3.state.breakpoints.indexOf(nextIndex) !== -1) {
            _this3.__setState({ lastBreakpoint: nextIndex });
            _this3.emit('BREAKPOINT', {
              index: nextIndex,
              currentLoop: loopsCursor - loopsStart + 1,
              loops: loopsEnd - loopsStart + 1,
              resource: resources[nextIndex],
              extra: _this3.state.extra
            });
            return _this3.pause();
          } else {
            _this3.__setState({ lastBreakpoint: undefined });
            return Promise.resolve();
          }
        }();

        // Note: Check whether token expired or not after each async operations
        // Also also in the final catch to prevent unnecessary invoke of __errLog
        return possibleBreakpointPromise.then(function () {
          return _this3.__run(resources[nextIndex], _this3.state);
        }).then(guardToken(function (res) {
          // Note: allow users to handle the result
          return _this3.__handle(res, resources[nextIndex], _this3.state).then(guardToken(function (nextIndex) {
            // Note: __handle has the chance to return a `nextIndex`, mostly when it's
            // from a flow logic. But still, it could be undefined for normal commands
            var oldLoopsCursor = _this3.state.loopsCursor;

            _this3.__setNext(nextIndex);
            _this3.emit('PLAYED_LIST', {
              indices: _this3.state.doneIndices,
              extra: _this3.state.extra
            });

            return oldLoopsCursor !== _this3.state.loopsCursor;
          })).then(function (isLoopsCursorChanged) {
            // __handle may change postDelay
            var _state3 = _this3.state,
                postDelay = _state3.postDelay,
                needDelayAfterLoop = _state3.needDelayAfterLoop;

            var delay = Math.max(postDelay, isLoopsCursorChanged && needDelayAfterLoop ? 10 : 0);
            return delay > 0 ? _this3.__delay(function () {
              return undefined;
            }, delay) : Promise.resolve();
          }).then(function () {
            if (_this3.state.isStep) return _this3.pause().then(function () {
              return _this3.__go(token);
            });
            return _this3.__go(token);
          });
        })).catch(guardToken(function (err) {
          return _this3.__errLog(err);
        }));
      });
    }
  }, {
    key: '__shouldContinue',
    value: function __shouldContinue() {
      var _state4 = this.state,
          status = _state4.status,
          mode = _state4.mode,
          nextIndex = _state4.nextIndex,
          startIndex = _state4.startIndex,
          endIndex = _state4.endIndex,
          token = _state4.token;

      var ret = void 0;

      if (status === STATUS.PAUSED || status === STATUS.STOPPED) {
        // Note: when it's paused, use a pending promise to holde the execution
        // so we can continue running after resume and resolve the promise
        var promiseItem = this.toResumePromises[this.state.token];
        return promiseItem ? promiseItem.promise.then(function () {
          return {};
        }) : { paused: true };
      }

      if (status === STATUS.PLAYING && nextIndex >= startIndex && nextIndex <= endIndex) {
        return Promise.resolve({ paused: false, complete: false });
      }

      // Note: make this function return promise, just in case
      // an async check is needed in future

      this.__end(END_REASON.COMPLETE);
      return Promise.resolve({ complete: true });
    }
  }, {
    key: '__createPromiseWaitForResume',
    value: function __createPromiseWaitForResume(token) {
      var _this4 = this;

      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          _this4.toResumePromises[token] = {
            resolve: resolve,
            reject: reject,
            promise: p
          };
        }, 10);
      });

      return p;
    }
  }, {
    key: '__createPromiseForStop',
    value: function __createPromiseForStop(token, stopReason) {
      var _this5 = this;

      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          _this5.toResumePromises[token] = {
            resolve: resolve,
            reject: reject,
            promise: p
          };

          reject(new Error('Stop reason: ' + stopReason));
        }, 10);
      });

      return p;
    }
  }, {
    key: '__end',
    value: function __end(reason, opts) {
      // Note: CANNOT end the player twice
      if (this.state.status === STATUS.STOPPED) return;

      if (Object.keys(END_REASON).indexOf(reason) === -1) {
        throw new Error('Player - __end: invalid reason, ' + reason);
      }

      var silent = opts && opts.silent;
      var noEndEvent = this.state.noEndEvent && reason === END_REASON.COMPLETE;

      if (!noEndEvent && !silent) {
        this.emit('END', { opts: opts, reason: reason, extra: this.state.extra });

        if (reason !== END_REASON.ERROR) {
          this.state.callback(null, reason);
        }
      }

      if (reason !== END_REASON.COMPLETE) {
        this.__createPromiseForStop(this.state.token, reason);
      }

      this.__setState({
        status: STATUS.STOPPED
      });
    }
  }, {
    key: '__errLog',
    value: function __errLog(err, errorIndex) {
      // Note: CANNOT log error if player is already stopped
      if (this.state.status === STATUS.STOPPED) {
        throw new Error(err);
      }

      this.emit('ERROR', {
        errorIndex: errorIndex !== undefined ? errorIndex : this.state.nextIndex,
        msg: err && err.message,
        extra: this.state.extra,
        restart: !!err.restart
      });
      this.state.callback(err, null);
      this.__end(END_REASON.ERROR);

      throw new Error(err);
    }
  }, {
    key: '__setNext',
    value: function __setNext(nextIndexPassed) {
      if (nextIndexPassed !== undefined && (nextIndexPassed < 0 || nextIndexPassed > this.state.resources.length)) {
        // Note: nextIndexPassed is allowed to be equal to resources.length
        // That means we run out of commands
        throw new Error('invalid nextIndexPassed ' + nextIndexPassed);
      }

      var _state5 = this.state,
          mode = _state5.mode,
          doneIndices = _state5.doneIndices,
          nextIndex = _state5.nextIndex,
          endIndex = _state5.endIndex,
          startIndex = _state5.startIndex,
          loopsCursor = _state5.loopsCursor,
          loopsEnd = _state5.loopsEnd;


      var nextIndexToSet = nextIndexPassed !== undefined ? nextIndexPassed : nextIndex + 1;

      var done = doneIndices.indexOf(nextIndex) === -1 ? [].concat(_toConsumableArray(doneIndices), [nextIndex]) : doneIndices;
      var lcur = loopsCursor;
      var next = null;

      if (mode === MODE.LOOP) {
        if (nextIndexToSet <= endIndex) {
          next = nextIndexToSet;
        } else if (loopsCursor >= loopsEnd) {
          next = nextIndexToSet;
        } else {
          lcur += 1;
          next = startIndex;
          done = [];
        }
      } else {
        next = nextIndexToSet;
      }

      this.__setState({
        loopsCursor: lcur,
        nextIndex: next,
        doneIndices: done
      });
    }
  }, {
    key: '__setState',
    value: function __setState(obj) {
      this.state = _extends({}, this.state, obj);
    }
  }, {
    key: '__delay',
    value: function __delay(fn, timeout) {
      var _this6 = this;

      var past = 0;
      var timer = setInterval(function () {
        past += 1000;
        _this6.emit('DELAY', {
          extra: _this6.state.extra,
          total: timeout,
          past: past
        });
      }, 1000);

      return Object(_utils__WEBPACK_IMPORTED_MODULE_1__["delay"])(fn, timeout).then(function (res) {
        if (timer) clearInterval(timer);
        return res;
      });
    }
  }]);

  return Player;
}();

event_emitter__WEBPACK_IMPORTED_MODULE_0___default()(Player.prototype);

Player.C = Player.prototype.C = {
  MODE: MODE,
  STATUS: STATUS,
  END_REASON: END_REASON
};

var playerPool = {};

// factory function to return a player singleton
var getPlayer = function getPlayer() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var state = arguments[1];

  var name = opts.name || 'testCase';
  delete opts.name;

  if (Object.keys(opts).length > 0) {
    playerPool[name] = new Player(opts, state);
  }

  if (!playerPool[name]) {
    throw new Error('player not initialized');
  }

  return playerPool[name];
};

/***/ }),

/***/ 30:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web_extension_1 = __importDefault(__webpack_require__(10));
const storage_1 = __importDefault(__webpack_require__(36));
const ts_utils_1 = __webpack_require__(12);
const service_1 = __webpack_require__(1005);
const actions_1 = __webpack_require__(16);
exports.getLicenseService = ts_utils_1.singletonGetter(() => {
    return new service_1.LicenseService({
        getVersion: () => {
            return Promise.resolve(web_extension_1.default.runtime.getManifest().version);
        },
        getLegacyXModuleStatus: () => {
            return window['store'].getState().config.xmodulesStatus;
        },
        setLegacyXModuleStatus: (status) => {
            return Promise.resolve(window['store'].dispatch(actions_1.updateConfig({ xmodulesStatus: status })));
        },
        save: (license) => {
            return storage_1.default.set(service_1.LicenseService.StorageKey, license).then(() => { });
        },
        read: () => {
            return storage_1.default.get(service_1.LicenseService.StorageKey).then(license => license !== null && license !== void 0 ? license : null);
        }
    });
});


/***/ }),

/***/ 32:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(90);
const filesystem_1 = __webpack_require__(60);
const ts_utils_1 = __webpack_require__(12);
const path_1 = __importDefault(__webpack_require__(27));
class XFile extends common_1.XModule {
    getName() {
        return common_1.XModuleTypes.XFile;
    }
    getAPI() {
        return filesystem_1.getNativeFileSystemAPI();
    }
    initConfig() {
        return this.getConfig()
            .then(config => {
            if (!config.rootDir) {
                const fsAPI = filesystem_1.getNativeFileSystemAPI();
                return fsAPI.getSpecialFolderPath({ folder: filesystem_1.SpecialFolder.UserDesktop })
                    .then(profilePath => {
                    const kantuDir = path_1.default.join(profilePath, 'uivision');
                    return fsAPI.ensureDir({ path: kantuDir })
                        .then(done => {
                        this.setConfig({
                            rootDir: done ? kantuDir : profilePath
                        });
                    });
                })
                    .catch(e => {
                    // Ignore host not found error, `initConfig` is supposed to be called on start
                    // But we can't guarantee that native fs module is already installed
                    if (!/Specified native messaging host not found/.test(e)) {
                        throw e;
                    }
                });
            }
        });
    }
    sanityCheck(simple) {
        return Promise.all([
            this.getConfig(),
            this.getAPI().getVersion()
                .then(() => this.getAPI(), () => this.getAPI().reconnect())
                .catch(e => {
                throw new Error('xFile is not installed yet');
            })
        ])
            .then(([config, api]) => {
            if (simple) {
                return true;
            }
            if (!config.rootDir) {
                throw new Error('rootDir is not set');
            }
            const checkDirectoryExists = () => {
                return api.directoryExists({ path: config.rootDir })
                    .then((existed) => {
                    if (!existed)
                        throw new Error(`Directory '${config.rootDir}' doesn't exist`);
                    return true;
                });
            };
            const checkDirectoryWritable = () => {
                const testDir = path_1.default.join(config.rootDir, '__kantu__' + Math.round(Math.random() * 100));
                return api.createDirectory({ path: testDir })
                    .then((created) => {
                    if (!created)
                        throw new Error();
                    return api.removeDirectory({ path: testDir });
                })
                    .then((deleted) => {
                    if (!deleted)
                        throw new Error();
                    return true;
                })
                    .catch((e) => {
                    throw new Error(`Directory '${config.rootDir}' is not writable`);
                });
            };
            return checkDirectoryExists()
                .then(checkDirectoryWritable);
        });
    }
    checkUpdate() {
        return Promise.reject(new Error('checkUpdate is not implemented yet'));
    }
    checkUpdateLink(modVersion, extVersion) {
        return `https://ui.vision/x/idehelp?help=xfileaccess_updatecheck&xversion=${modVersion}&kantuversion=${extVersion}`;
    }
    downloadLink() {
        return 'https://ui.vision/x/idehelp?help=xfileaccess_download';
    }
    infoLink() {
        return 'https://ui.vision/x/idehelp?help=xfileaccess';
    }
}
exports.XFile = XFile;
exports.getXFile = ts_utils_1.singletonGetter(() => {
    return new XFile();
});


/***/ }),

/***/ 324:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const filesystem_1 = __webpack_require__(60);
const xfile_1 = __webpack_require__(32);
const path_1 = __importDefault(__webpack_require__(27));
const log_1 = __importDefault(__webpack_require__(11));
const ts_utils_1 = __webpack_require__(12);
const storage_1 = __webpack_require__(13);
class LogService {
    constructor(params = {}) {
        this.pDirReady = Promise.resolve(false);
        this.logsDir = '';
        this.fileName = 'log.txt';
        this.waitForStorageManager = () => Promise.resolve(storage_1.getStorageManager());
        this.check();
        this.updateLogFileName();
        if (params.waitForStorageManager) {
            this.waitForStorageManager = params.waitForStorageManager;
        }
    }
    updateLogFileName() {
        const now = new Date();
        const dateStr = `${now.getFullYear()}${ts_utils_1.pad2digits(now.getMonth() + 1)}${ts_utils_1.pad2digits(now.getDate())}`;
        const timeStr = [now.getHours(), now.getMinutes(), now.getSeconds()].map(n => ts_utils_1.pad2digits(n)).join('');
        this.fileName = `log-${dateStr}-${timeStr}.txt`;
    }
    check() {
        this.pDirReady = xfile_1.getXFile().sanityCheck(true).then(isSane => {
            if (!isSane) {
                return false;
            }
            const { rootDir } = xfile_1.getXFile().getCachedConfig();
            if (!rootDir) {
                return false;
            }
            this.logsDir = path_1.default.join(rootDir, 'logs');
            return filesystem_1.getNativeFileSystemAPI().ensureDir({
                path: this.logsDir
            });
        });
        return this.pDirReady;
    }
    log(str) {
        return this.waitForStorageManager()
            .then(storageManager => {
            if (!storageManager.isXFileMode()) {
                return false;
            }
            return xfile_1.getXFile().sanityCheck(true)
                .then(() => this.pDirReady)
                .then((ready) => {
                if (!ready) {
                    return false;
                }
                return filesystem_1.getNativeFileSystemAPI().appendAllText({
                    path: path_1.default.join(this.logsDir, this.fileName),
                    content: ensureLineBreak(str)
                });
            }, (e) => {
                log_1.default.warn('Failed to log: ', e.message);
                return false;
            });
        });
    }
    logWithTime(str) {
        return this.log(`${new Date().toISOString()} - ${str}`);
    }
    logTo(filePath, str) {
        return this.waitForStorageManager()
            .then(storageManager => {
            if (!storageManager.isXFileMode()) {
                return false;
            }
            return xfile_1.getXFile().sanityCheck(true)
                .then((ready) => {
                if (!ready) {
                    return false;
                }
                const dirPath = path_1.default.dirname(filePath);
                return filesystem_1.getNativeFileSystemAPI().ensureDir({ path: dirPath })
                    .then((dirReady) => {
                    if (!dirReady) {
                        return false;
                    }
                    return filesystem_1.getNativeFileSystemAPI().appendAllText({
                        path: filePath,
                        content: ensureLineBreak(str)
                    });
                });
            }, (e) => {
                log_1.default.warn('Failed to log: ', e.message);
                return false;
            });
        });
    }
}
exports.LogService = LogService;
exports.getLogService = ts_utils_1.singletonGetter(() => new LogService());
function ensureLineBreak(str) {
    if (str.length === 0) {
        return str;
    }
    if (str.charAt(str.length - 1) !== '\n') {
        return str + '\n';
    }
    return str;
}


/***/ }),

/***/ 325:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = __webpack_require__(185);
const indexeddb_storage_1 = __webpack_require__(511);
const storage_1 = __webpack_require__(13);
const macro_extra_data_1 = __webpack_require__(105);
const filesystem_1 = __importDefault(__webpack_require__(107));
const backup_1 = __webpack_require__(358);
const ts_utils_1 = __webpack_require__(12);
class MigrateMacroTestSuiteToBrowserFileSystem {
    constructor() {
        this.oldMacros = [];
    }
    getMeta() {
        return {
            createdAt: new Date('2019-04-01').getTime(),
            goal: [
                `Migrate macros and test suites from indexedDB storage to Browser File System storage`,
                `In order to prepare for an easy support for deep folder structure`,
                `Note: the old indexedDB storage WILL NOT be cleared, just in case any user loses his data during migration`,
                `The real clean up could be done in future releases, in the form of another migration job`
            ].join('. ')
        };
    }
    getType() {
        return types_1.MigrationJobType.MigrateMacroTestSuiteToBrowserFileSystem;
    }
    previousVersionRange() {
        return '<=4.0.1';
    }
    shouldMigrate() {
        const oldMacroStorage = this.getOldMacroStorage();
        const oldTestSuiteStorage = this.getOldTestSuiteStorage();
        return Promise.all([
            oldMacroStorage.list().then((list) => list.length),
            oldTestSuiteStorage.list().then((list) => list.length)
        ])
            .then(([macroCount, testSuiteCount]) => {
            return macroCount > 0 || testSuiteCount > 0;
        });
    }
    migrate() {
        const migrateMacros = () => {
            return this.getOldMacroStorage().readAll()
                .then((fileObjs) => {
                console.log('this.getOldMacroStorage().readAll()', fileObjs);
                this.oldMacros = fileObjs.map((obj) => obj.content);
                return filesystem_1.default.ensureDirectory('/macros')
                    .then(() => this.getNewMacroStorage().bulkWrite(fileObjs));
            })
                .then(() => true);
        };
        const migrateTestSuites = () => {
            return this.getOldTestSuiteStorage().readAll()
                .then((fileObjs) => {
                console.log('this.getOldTestSuiteStorage().readAll()', fileObjs);
                return filesystem_1.default.ensureDirectory('/testsuites')
                    .then(() => this.getNewTestSuiteStorage().bulkWrite(fileObjs));
            })
                .then(() => true);
        };
        const migrateMacroExtra = () => {
            return macro_extra_data_1.getMacroExtraKeyValueData().getAll()
                .then((allMacroExtra) => {
                this.oldMacros.forEach(macro => {
                    const newId = this.getNewMacroStorage().filePath(macro.name);
                    const oldId = macro.id;
                    if (allMacroExtra[oldId]) {
                        allMacroExtra[newId] = allMacroExtra[oldId];
                    }
                });
                return macro_extra_data_1.getMacroExtraKeyValueData().set('', allMacroExtra);
            });
        };
        return migrateMacros()
            .then(() => migrateTestSuites())
            .then(() => migrateMacroExtra())
            .then(() => true);
    }
    remedy() {
        // Download the old macros and test suites in zip
        const readOldMacros = () => {
            return this.getOldMacroStorage().readAll()
                .then((fileObjs) => {
                this.oldMacros = fileObjs.map((obj) => obj.content);
                return this.oldMacros;
            });
        };
        const readOldTestSuites = () => {
            return this.getOldTestSuiteStorage().readAll()
                .then((fileObjs) => {
                return fileObjs.map((obj) => obj.content);
            });
        };
        return readOldMacros()
            .then(macros => {
            return readOldTestSuites()
                .then(testSuites => {
                return backup_1.backup({
                    backup: {
                        testCase: true,
                        testSuite: true
                    },
                    macroNodes: macros,
                    testSuites: testSuites
                });
            });
        });
    }
    getOldMacroStorage() {
        return indexeddb_storage_1.getIndexeddbFlatStorage({
            table: 'testCases'
        });
    }
    getOldTestSuiteStorage() {
        return indexeddb_storage_1.getIndexeddbFlatStorage({
            table: 'testSuites'
        });
    }
    getNewMacroStorage() {
        return this.getStorageManager().getStorageForTarget(storage_1.StorageTarget.Macro, storage_1.StorageStrategyType.Browser);
    }
    getNewTestSuiteStorage() {
        return this.getStorageManager().getStorageForTarget(storage_1.StorageTarget.TestSuite, storage_1.StorageStrategyType.Browser);
    }
    getStorageManager() {
        return new storage_1.StorageManager(storage_1.StorageStrategyType.Browser, {
            getMacros: () => this.oldMacros,
            getMaxMacroCount: () => Promise.resolve(Infinity)
        });
    }
}
exports.MigrateMacroTestSuiteToBrowserFileSystem = MigrateMacroTestSuiteToBrowserFileSystem;
exports.getMigrateMacroTestSuiteToBrowserFileSystem = ts_utils_1.singletonGetter(() => {
    return new MigrateMacroTestSuiteToBrowserFileSystem();
});


/***/ }),

/***/ 329:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const __languages = {
    ara: {
        "lang": "ara",
        "name": "Arabic",
        "short": "AR"
    },
    chs: {
        "lang": "chs",
        "name": "ChineseSimplified",
        "short": ""
    },
    cht: {
        "lang": "cht",
        "name": "ChineseTraditional",
        "short": ""
    },
    ce: {
        "lang": "ce",
        "name": "Czech",
        "short": "CS"
    },
    dan: {
        "lang": "dan",
        "name": "Danish",
        "short": "DA"
    },
    dut: {
        "lang": "dut",
        "name": "Dutch",
        "short": "NL"
    },
    eng: {
        "lang": "eng",
        "name": "English",
        "short": "EN"
    },
    fin: {
        "lang": "fin",
        "name": "Finnish",
        "short": "FI"
    },
    fre: {
        "lang": "fre",
        "name": "French",
        "short": "FR"
    },
    ger: {
        "lang": "ger",
        "name": "German",
        "short": "DE"
    },
    gre: {
        "lang": "gre",
        "name": "Greek",
        "short": "EL"
    },
    hun: {
        "lang": "hun",
        "name": "Hungarian",
        "short": "HU"
    },
    ita: {
        "lang": "ita",
        "name": "Italian",
        "short": "IT"
    },
    jpn: {
        "lang": "jpn",
        "name": "Japanese",
        "short": "JP"
    },
    kor: {
        "lang": "kor",
        "name": "Korean",
        "short": "KO"
    },
    nor: {
        "lang": "nor",
        "name": "Norwegian",
        "short": "NN"
    },
    pol: {
        "lang": "pol",
        "name": "Polish",
        "short": "PL"
    },
    por: {
        "lang": "por",
        "name": "Portuguese",
        "short": "PT"
    },
    rus: {
        "lang": "rus",
        "name": "Russian",
        "short": "RU"
    },
    spa: {
        "lang": "spa",
        "name": "Spanish",
        "short": "ES"
    },
    swe: {
        "lang": "swe",
        "name": "Swedish",
        "short": "SV"
    },
    tur: {
        "lang": "tur",
        "name": "Turkish",
        "short": "TR"
    }
};
exports.languages = __languages;
function isValidOCRLanguage(lang) {
    return typeof lang === 'string' && !!__languages[lang.toLowerCase()];
}
exports.isValidOCRLanguage = isValidOCRLanguage;


/***/ }),

/***/ 330:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const storage_1 = __importDefault(__webpack_require__(36));
const persistent_counter_1 = __webpack_require__(1029);
const ts_utils_1 = __webpack_require__(12);
const log_1 = __importDefault(__webpack_require__(11));
const STORAGE_KEY = 'OCR_CONVERSIONS_PER_DAY';
const today = () => {
    const d = new Date();
    return {
        year: d.getFullYear(),
        month: d.getMonth() + 1,
        date: d.getDate()
    };
};
const isSameDay = (a, b) => {
    return a.year === b.year &&
        a.month === b.month &&
        a.date === b.date;
};
exports.getOcrCommandCounter = ts_utils_1.singletonGetter((options) => {
    const read = () => {
        log_1.default('getOcrCommandCounter - read');
        return storage_1.default.get(STORAGE_KEY)
            .then((val) => {
            if (!val)
                return options.initial;
            if (!isSameDay(today(), val.day))
                return options.initial;
            return val.count;
        });
    };
    const write = (n) => {
        log_1.default('getOcrCommandCounter - write', n);
        return storage_1.default.set(STORAGE_KEY, {
            day: today(),
            count: n
        })
            .then(() => { });
    };
    return new persistent_counter_1.PersistentCounter(Object.assign(Object.assign({}, options), { read,
        write }));
});


/***/ }),

/***/ 34:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web_extension_1 = __importDefault(__webpack_require__(10));
const platform = web_extension_1.default.isFirefox() ? 'firefox' : 'chrome';
exports.default = {
    preinstall: {
        version: '5.8.8',
        macroFolder: '/Demo'
    },
    urlAfterUpgrade: 'https://ui.vision/x/idehelp?help=k_update',
    urlAfterInstall: 'https://ui.vision/x/idehelp?help=k_welcome',
    urlAfterUninstall: 'https://ui.vision/x/idehelp?help=k_why',
    performanceLimit: {
        fileCount: Infinity
    },
    xmodulesLimit: {
        unregistered: {
            ocrCommandCount: 100,
            xCommandCount: 25,
            xFileMacroCount: 10,
            proxyExecCount: 5,
            upgradeUrl: 'https://ui.vision/x/idehelp?help=k_xupgrade'
        },
        free: {
            ocrCommandCount: 250,
            xCommandCount: Infinity,
            xFileMacroCount: 20,
            proxyExecCount: 10,
            upgradeUrl: 'https://ui.vision/x/idehelp?help=k_xupgradepro'
        },
        pro: {
            ocrCommandCount: 500,
            xCommandCount: Infinity,
            xFileMacroCount: Infinity,
            proxyExecCount: Infinity,
            upgradeUrl: 'https://ui.vision/x/idehelp?help=k_xupgrade_contactsupport'
        }
    },
    xfile: {
        minVersionToReadBigFile: '1.0.10'
    },
    ocr: {
        apiList: [
            {
                "id": "1",
                "key": "kantu_only_53b8",
                "url": "https://apipro1.ocr.space/parse/image"
            },
            {
                "id": "2",
                "key": "kantu_only_53b8",
                "url": "https://apipro2.ocr.space/parse/image"
            },
            {
                "id": "3",
                "key": "kantu_only_53b8",
                "url": "https://apipro3.ocr.space/parse/image"
            }
        ],
        apiTimeout: 60 * 1000,
        singleApiTimeout: 30 * 1000,
        apiHealthyResponseTime: 20 * 1000,
        resetTime: 24 * 3600 * 1000
    },
    license: {
        api: {
            url: 'https://license1.ocr.space/api/status'
        }
    },
    icons: {
        normal: 'logo38.png',
        inverted: 'inverted_logo_38.png'
    },
    forceMigrationRemedy: false,
    iframePostMessageTimeout: 500,
    ui: {
        commandItemHeight: 35
    },
    commandRunner: {
        sendKeysMaxCharCount: 1000
    }
};


/***/ }),

/***/ 344:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MethodTypeInvocationNames = [
    'get_version',
    'get_desktop_dpi',
    'get_image_info',
    'capture_desktop',
    'search_image',
    'search_desktop',
    'get_max_file_range',
    'get_file_size',
    'read_file_range'
];


/***/ }),

/***/ 345:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const native_host_1 = __webpack_require__(97);
class KantuCVHost extends native_host_1.NativeMessagingHost {
    constructor() {
        super(KantuCVHost.HOST_NAME);
    }
}
exports.KantuCVHost = KantuCVHost;
KantuCVHost.HOST_NAME = "com.a9t9.kantu.cv";


/***/ }),

/***/ 346:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var base64;
(function (base64) {
    // prettier-ignore
    const encodingTable = new Uint8Array([
        65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
        97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,
        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47
    ]);
    // prettier-ignore
    const decodingTable = new Uint8Array([
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
        -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
        -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    ]);
    const paddingChar = 61;
    function calculateEncodedLength(length) {
        let result = (length / 3) * 4;
        result += length % 3 != 0 ? 4 : 0;
        return result;
    }
    function readWord(input, i, maxLength) {
        if (maxLength > 4) {
            throw new Error("maxLength should be in range [0, 4].");
        }
        const t = new Uint8Array(4);
        for (let k = 0; k < maxLength; ++k) {
            const c = input.charCodeAt(i + k);
            const b = decodingTable[c];
            if (b === 0xff) {
                return undefined;
            }
            t[k] = b;
        }
        return ((t[0] << (3 * 6)) +
            (t[1] << (2 * 6)) +
            (t[2] << (1 * 6)) +
            (t[3] << (0 * 6)));
    }
    function writeWord(output, i, triple) {
        output[i + 0] = (triple >> 16) & 0xff;
        output[i + 1] = (triple >> 8) & 0xff;
        output[i + 2] = triple & 0xff;
    }
    function encode(input) {
        const inLen = input.length;
        const outLen = calculateEncodedLength(inLen);
        const lengthMod3 = inLen % 3;
        const calcLength = inLen - lengthMod3;
        const output = new Uint8Array(outLen);
        let i;
        let j = 0;
        for (i = 0; i < calcLength; i += 3) {
            output[j + 0] = encodingTable[(input[i] & 0xfc) >> 2];
            output[j + 1] =
                encodingTable[((input[i] & 0x03) << 4) | ((input[i + 1] & 0xf0) >> 4)];
            output[j + 2] =
                encodingTable[((input[i + 1] & 0x0f) << 2) | ((input[i + 2] & 0xc0) >> 6)];
            output[j + 3] = encodingTable[input[i + 2] & 0x3f];
            j += 4;
        }
        i = calcLength;
        switch (lengthMod3) {
            case 2: // One character padding needed
                output[j + 0] = encodingTable[(input[i] & 0xfc) >> 2];
                output[j + 1] =
                    encodingTable[((input[i] & 0x03) << 4) | ((input[i + 1] & 0xf0) >> 4)];
                output[j + 2] = encodingTable[(input[i + 1] & 0x0f) << 2];
                output[j + 3] = paddingChar;
                j += 4;
                break;
            case 1: // Two character padding needed
                output[j + 0] = encodingTable[(input[i] & 0xfc) >> 2];
                output[j + 1] = encodingTable[(input[i] & 0x03) << 4];
                output[j + 2] = paddingChar;
                output[j + 3] = paddingChar;
                j += 4;
                break;
        }
        const decoder = new TextDecoder("ascii");
        return decoder.decode(output);
    }
    base64.encode = encode;
    function decode(input) {
        const inLen = input.length;
        if (inLen % 4 != 0) {
            return undefined;
        }
        let padding = 0;
        if (inLen > 0 && input.charCodeAt(inLen - 1) == paddingChar) {
            ++padding;
            if (inLen > 1 && input.charCodeAt(inLen - 2) == paddingChar) {
                ++padding;
            }
        }
        const encodedLen = inLen - padding;
        const completeLen = encodedLen & ~3;
        const outLen = (6 * inLen) / 8 - padding;
        const output = new Uint8Array(outLen);
        let triple;
        let i = 0;
        let j = 0;
        while (i < completeLen) {
            triple = readWord(input, i, 4);
            if (typeof triple === "undefined") {
                return undefined;
            }
            writeWord(output, j, triple);
            i += 4;
            j += 3;
        }
        if (padding > 0) {
            triple = readWord(input, i, 4 - padding);
            if (typeof triple === "undefined") {
                return undefined;
            }
            switch (padding) {
                case 1:
                    output[j + 0] = (triple >> 16) & 0xff;
                    output[j + 1] = (triple >> 8) & 0xff;
                    break;
                case 2:
                    output[j + 0] = (triple >> 16) & 0xff;
                    break;
            }
        }
        return output;
    }
    base64.decode = decode;
})(base64 = exports.base64 || (exports.base64 = {}));


/***/ }),

/***/ 349:
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var eventFactory = __webpack_require__(350),
    DataTransfer = __webpack_require__(181);

function _noop() {}

function parseParams(targetElement, eventProperties, configCallback) {
  if (typeof eventProperties === 'function') {
    configCallback = eventProperties;
    eventProperties = null;
  }

  if (!targetElement || (typeof targetElement === 'undefined' ? 'undefined' : _typeof(targetElement)) !== 'object') {
    throw new Error('Expected first parameter to be a targetElement. Instead got: ' + targetElement);
  }

  return {
    targetElement: targetElement,
    eventProperties: eventProperties || {},
    configCallback: configCallback || _noop
  };
}

function customizeEvent(event, configCallback, isPrimaryEvent) {
  if (configCallback) {
    // call configCallback only for the primary event if the callback takes less than two arguments
    if (configCallback.length < 2) {
      if (isPrimaryEvent) {
        configCallback(event);
      }
    }
    // call configCallback for each event if the callback takes two arguments
    else {
        configCallback(event, event.type);
      }
  }
}

function createAndDispatchEvents(targetElement, eventNames, primaryEventName, dataTransfer, eventProperties, configCallback) {
  eventNames.forEach(function (eventName) {
    var event = eventFactory.createEvent(eventName, eventProperties, dataTransfer);
    var isPrimaryEvent = eventName === primaryEventName;

    customizeEvent(event, configCallback, isPrimaryEvent);

    targetElement.dispatchEvent(event);
  });
}

var DragDropAction = function DragDropAction() {
  this.lastDragSource = null;
  this.lastDataTransfer = null;
  this.pendingActionsQueue = [];
};

DragDropAction.prototype._queue = function (fn) {
  this.pendingActionsQueue.push(fn);

  if (this.pendingActionsQueue.length === 1) {
    this._queueExecuteNext();
  }
};

DragDropAction.prototype._queueExecuteNext = function () {
  if (this.pendingActionsQueue.length === 0) {
    return;
  }

  var self = this;
  var firstPendingAction = this.pendingActionsQueue[0];

  var doneCallback = function doneCallback() {
    self.pendingActionsQueue.shift();
    self._queueExecuteNext();
  };

  if (firstPendingAction.length === 0) {
    firstPendingAction.call(this);
    doneCallback();
  } else {
    firstPendingAction.call(this, doneCallback);
  }
};

DragDropAction.prototype.dragStart = function (targetElement, eventProperties, configCallback) {
  var params = parseParams(targetElement, eventProperties, configCallback),
      events = ['mousedown', 'dragstart', 'drag'],
      dataTransfer = new DataTransfer();

  this._queue(function () {
    createAndDispatchEvents(params.targetElement, events, 'drag', dataTransfer, params.eventProperties, params.configCallback);

    this.lastDragSource = targetElement;
    this.lastDataTransfer = dataTransfer;
  });

  return this;
};

DragDropAction.prototype.dragEnter = function (overElement, eventProperties, configCallback) {
  var params = parseParams(overElement, eventProperties, configCallback),
      events = ['mousemove', 'mouseover', 'dragenter'];

  this._queue(function () {
    createAndDispatchEvents(params.targetElement, events, 'dragenter', this.lastDataTransfer, params.eventProperties, params.configCallback);
  });

  return this;
};

DragDropAction.prototype.dragOver = function (overElement, eventProperties, configCallback) {
  var params = parseParams(overElement, eventProperties, configCallback),
      events = ['mousemove', 'mouseover', 'dragover'];

  this._queue(function () {
    createAndDispatchEvents(params.targetElement, events, 'drag', this.lastDataTransfer, params.eventProperties, params.configCallback);
  });

  return this;
};

DragDropAction.prototype.dragLeave = function (overElement, eventProperties, configCallback) {
  var params = parseParams(overElement, eventProperties, configCallback),
      events = ['mousemove', 'mouseover', 'dragleave'];

  this._queue(function () {
    createAndDispatchEvents(params.targetElement, events, 'dragleave', this.lastDataTransfer, params.eventProperties, params.configCallback);
  });

  return this;
};

DragDropAction.prototype.drop = function (targetElement, eventProperties, configCallback) {
  var params = parseParams(targetElement, eventProperties, configCallback);
  var eventsOnDropTarget = ['mousemove', 'mouseup', 'drop'];
  var eventsOnDragSource = ['dragend'];

  this._queue(function () {
    createAndDispatchEvents(params.targetElement, eventsOnDropTarget, 'drop', this.lastDataTransfer, params.eventProperties, params.configCallback);

    if (this.lastDragSource) {
      // trigger dragend event on last drag source element
      createAndDispatchEvents(this.lastDragSource, eventsOnDragSource, 'drop', this.lastDataTransfer, params.eventProperties, params.configCallback);
    }
  });

  return this;
};

DragDropAction.prototype.then = function (callback) {
  this._queue(function () {
    callback.call(this);
  }); // make sure _queue() is given a callback with no arguments

  return this;
};

DragDropAction.prototype.delay = function (waitingTimeMs) {
  this._queue(function (done) {
    window.setTimeout(done, waitingTimeMs);
  });

  return this;
};

module.exports = DragDropAction;

/***/ }),

/***/ 350:
/***/ (function(module, exports, __webpack_require__) {


var DataTransfer = __webpack_require__(181);

var dataTransferEvents = ['drag', 'dragstart', 'dragenter', 'dragover', 'dragend', 'drop', 'dragleave'];

function mergeInto(destObj, srcObj) {
  for (var key in srcObj) {
    if (!srcObj.hasOwnProperty(key)) {
      continue;
    } // ignore inherited properties

    destObj[key] = srcObj[key];
  }

  return destObj;
}

function isFirefox() {
  return (/Firefox/.test(window.navigator.userAgent)
  );
}

function createModernEvent(eventName, eventType, eventProperties) {
  // if (eventType === 'DragEvent') { eventType = 'CustomEvent'; }     // Firefox fix (since FF does not allow us to override dataTransfer)

  var constructor = window[eventType];
  var options = { view: window, bubbles: true, cancelable: true };

  mergeInto(options, eventProperties);

  var event = new constructor(eventName, options);

  mergeInto(event, eventProperties);

  return event;
}

function createLegacyEvent(eventName, eventType, eventProperties) {
  var event;

  switch (eventType) {
    case 'MouseEvent':
      event = document.createEvent('MouseEvent');
      event.initEvent(eventName, true, true);
      break;

    default:
      event = document.createEvent('CustomEvent');
      event.initCustomEvent(eventName, true, true, 0);
  }

  // copy eventProperties into event
  if (eventProperties) {
    mergeInto(event, eventProperties);
  }

  return event;
}

function _createEvent(eventName, eventType, eventProperties) {
  if (isFirefox()) {
    return createLegacyEvent(eventName, eventType, eventProperties);
  }

  try {
    return createModernEvent(eventName, eventType, eventProperties);
  } catch (error) {
    return createLegacyEvent(eventName, eventType, eventProperties);
  }
}

var EventFactory = {
  createEvent: function createEvent(eventName, eventProperties, dataTransfer) {
    var eventType = 'CustomEvent';

    if (eventName.match(/^mouse/)) {
      eventType = 'MouseEvent';
    } else if (eventName.match(/^(drag|drop)/)) {
      eventType = 'DragEvent';
    }

    if (dataTransferEvents.indexOf(eventName) > -1) {
      eventProperties.dataTransfer = dataTransfer || new DataTransfer();
    }

    var event = _createEvent(eventName, eventType, eventProperties);

    return event;
  }
};

module.exports = EventFactory;

/***/ }),

/***/ 357:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = __webpack_require__(157);
const base_1 = __webpack_require__(182);
function convertToFirefoxProxyInfo(proxy) {
    return Object.assign(Object.assign({}, proxy), { type: (proxy.type === types_1.ProxyScheme.Socks5 ? types_1.FirefoxProxyType.Socks5 : proxy.type) });
}
exports.convertToFirefoxProxyInfo = convertToFirefoxProxyInfo;
class ProxyManagerViaListenerAPI extends base_1.BaseProxyManager {
    constructor() {
        super();
        this.unbind = () => { };
        this.isBound = false;
    }
    isSupported() {
        return typeof browser !== 'undefined' && browser.proxy && browser.proxy.onRequest;
    }
    isControllable(incognito) {
        return Promise.resolve(true);
    }
    setProxy(proxy) {
        this.bind();
        this.proxy = proxy;
        this.notifyProxyChange();
        return Promise.resolve();
    }
    reset() {
        this.proxy = null;
        this.notifyProxyChange();
        return Promise.resolve();
    }
    notifyProxyChange() {
        setTimeout(() => {
            this.registry.fire('change', this.proxy);
        }, 10);
    }
    bind() {
        if (this.isBound) {
            return;
        }
        this.isBound = true;
        const listener = this.onProxyRequest.bind(this);
        browser.proxy.onRequest.addListener(listener, { urls: ['<all_urls>'] });
        this.unbind = () => browser.proxy.onRequest.removeListener(listener);
    }
    onProxyRequest(requestInfo) {
        return this.proxy ? convertToFirefoxProxyInfo(this.proxy) : { type: types_1.FirefoxProxyType.Direct };
    }
}
exports.ProxyManagerViaListenerAPI = ProxyManagerViaListenerAPI;


/***/ }),

/***/ 358:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const file_saver_1 = __importDefault(__webpack_require__(70));
const jszip_1 = __importDefault(__webpack_require__(142));
const utils_1 = __webpack_require__(4);
const convert_utils_1 = __webpack_require__(50);
const convert_suite_utils_1 = __webpack_require__(69);
const storage_1 = __webpack_require__(13);
const path_1 = __webpack_require__(27);
const common_1 = __webpack_require__(374);
function backup(options) {
    const { backup, macroNodes, testSuites, screenshots, csvs, visions } = options;
    const zip = new jszip_1.default();
    const ps = [];
    const getFolder = (relativePath, zipRoot) => {
        if (relativePath === '.') {
            return zipRoot;
        }
        const dirs = relativePath.split(path_1.posix.sep);
        return dirs.reduce((prev, dir) => {
            return prev.folder(dir);
        }, zipRoot);
    };
    if (backup.testCase && macroNodes && macroNodes.length) {
        const rootFolder = zip.folder(common_1.ZipFolders.Macros);
        macroNodes.forEach(node => {
            const dirPath = path_1.posix.dirname(node.relativePath);
            const fileName = path_1.posix.basename(node.relativePath);
            const folder = getFolder(dirPath, rootFolder);
            ps.push(storage_1.getStorageManager().getMacroStorage().read(node.fullPath, 'Text')
                .then((data) => {
                const macro = data;
                folder.file(fileName, convert_utils_1.toJSONString({
                    name: macro.name,
                    commands: macro.data.commands
                }, {
                    ignoreTargetOptions: !!options.ignoreMacroTargetOptions
                }));
            }));
        });
    }
    if (backup.testSuite && testSuites && testSuites.length) {
        const folder = zip.folder(common_1.ZipFolders.TestSuites);
        const genName = utils_1.nameFactory();
        testSuites.forEach(ts => {
            const name = genName(ts.name);
            folder.file(`${name}.json`, convert_suite_utils_1.stringifyTestSuite(ts));
        });
    }
    if (backup.screenshot && screenshots && screenshots.length) {
        const folder = zip.folder(common_1.ZipFolders.Screenshots);
        const ssStorage = storage_1.getStorageManager().getScreenshotStorage();
        screenshots.forEach(ss => {
            ps.push(ssStorage.read(ss.fullPath, 'ArrayBuffer')
                .then(buffer => {
                folder.file(ss.name, buffer, { binary: true });
            }));
        });
    }
    if (backup.vision && visions && visions.length) {
        const folder = zip.folder(common_1.ZipFolders.Visions);
        const visionStorage = storage_1.getStorageManager().getVisionStorage();
        visions.forEach(vision => {
            ps.push(visionStorage.read(vision.fullPath, 'ArrayBuffer')
                .then(buffer => {
                folder.file(vision.name, buffer, { binary: true });
            }));
        });
    }
    if (backup.csv && csvs && csvs.length) {
        const folder = zip.folder(common_1.ZipFolders.Csvs);
        const csvStorage = storage_1.getStorageManager().getCSVStorage();
        csvs.forEach(csv => {
            ps.push(csvStorage.read(csv.fullPath, 'Text')
                .then(text => folder.file(csv.name, text)));
        });
    }
    return Promise.all(ps)
        .then(() => {
        zip.generateAsync({ type: 'blob' })
            .then(function (blob) {
            file_saver_1.default.saveAs(blob, 'uivision_backup.zip');
        });
    });
}
exports.backup = backup;


/***/ }),

/***/ 359:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/// <reference types="chrome"/>
Object.defineProperty(exports, "__esModule", { value: true });
const ts_utils_1 = __webpack_require__(12);
var CommandName;
(function (CommandName) {
    CommandName["GetVersion"] = "getVersion";
    CommandName["GetDPI"] = "getDPI";
    CommandName["SetDirectory"] = "setDirectory";
    CommandName["SaveScreenshot"] = "saveScreenshot";
})(CommandName || (CommandName = {}));
class NativeScreenCapture {
    reconnect() {
        return Promise.resolve(this);
    }
    getVersion() {
        return this.sendMessage(CommandName.GetVersion);
    }
    getDpi() {
        return this.sendMessage(CommandName.GetDPI);
    }
    captureDesktop() {
        return this.sendMessage(CommandName.SaveScreenshot);
    }
    changeDirectory(dir) {
        return this.sendMessage(CommandName.SaveScreenshot, { current: dir });
    }
    sendMessage(command, extra = {}) {
        return new Promise((resolve, reject) => {
            chrome.runtime.sendNativeMessage(NativeScreenCapture.HostName, Object.assign(Object.assign({}, extra), { command }), (response) => {
                if (response && response.result) {
                    resolve(response[NativeScreenCapture.FieldNameMapping[command]]);
                }
                else {
                    let error = response && response.error;
                    error = error || 'Unknown error';
                    reject(new Error(error));
                }
            });
        });
    }
}
exports.NativeScreenCapture = NativeScreenCapture;
NativeScreenCapture.HostName = 'com.github.teamdocs.kcmd';
NativeScreenCapture.FieldNameMapping = {
    [CommandName.GetVersion]: 'version',
    [CommandName.GetDPI]: 'dpi',
    [CommandName.SetDirectory]: 'directory',
    [CommandName.SaveScreenshot]: 'file',
};
exports.getNativeScreenCapture = ts_utils_1.singletonGetter(() => new NativeScreenCapture());


/***/ }),

/***/ 36:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/common/web_extension.js
var web_extension = __webpack_require__(10);
var web_extension_default = /*#__PURE__*/__webpack_require__.n(web_extension);

// CONCATENATED MODULE: ./src/common/storage/ext_storage.js
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var local = web_extension_default.a.storage.local;

/* harmony default export */ var ext_storage = ({
  get: function get(key) {
    return local.get(key).then(function (obj) {
      return obj[key];
    });
  },

  set: function set(key, value) {
    return local.set(_defineProperty({}, key, value)).then(function () {
      return true;
    });
  },

  remove: function remove(key) {
    return local.remove(key).then(function () {
      return true;
    });
  },

  clear: function clear() {
    return local.clear().then(function () {
      return true;
    });
  },

  addListener: function addListener(fn) {
    web_extension_default.a.storage.onChanged.addListener(function (changes, areaName) {
      var list = Object.keys(changes).map(function (key) {
        return _extends({}, changes[key], { key: key });
      });
      fn(list);
    });
  }
});
// CONCATENATED MODULE: ./src/common/storage/index.js



/* harmony default export */ var storage = __webpack_exports__["default"] = (ext_storage);

/***/ }),

/***/ 360:
/***/ (function(module, exports, __webpack_require__) {


var DragDropAction = __webpack_require__(349);

function call(instance, methodName, args) {
    return instance[methodName].apply(instance, args);
}

function triggerDragEvent(element, target) {
    var getXpathOfElement = function getXpathOfElement(element) {
        if (element == null) {
            return 'null';
        }
        if (element.parentElement == null) {
            return '/' + element.tagName;
        }

        var siblingElement = element.parentElement.children;
        var tagCount = 0;
        var totalTagCount = 0;
        var isFound = false;

        for (var i = 0; i < siblingElement.length; i++) {
            if (siblingElement[i].tagName == element.tagName && !isFound) {
                tagCount++;
                totalTagCount++;
            } else if (siblingElement[i].tagName == element.tagName) {
                totalTagCount++;
            }
            if (siblingElement[i] == element) {
                isFound = true;
            }
        }

        if (totalTagCount > 1) {
            return getXpathOfElement(element.parentElement) + "/" + element.tagName + "[" + tagCount + "]";
        }

        return getXpathOfElement(element.parentElement) + "/" + element.tagName;
    };
    var script = "                                              \
      function simulateDragDrop(sourceNode, destinationNode){\
      function createCustomEvent(type) {                     \
          var event = new CustomEvent('CustomEvent');        \
          event.initCustomEvent(type, true, true, null);     \
          event.dataTransfer = {                             \
              data: {                                        \
              },                                             \
              setData: function(type, val) {                 \
                  this.data[type] = val;                     \
              },                                             \
              getData: function(type) {                      \
                  return this.data[type];                    \
              }                                              \
          };                                                 \
          return event;                                      \
      }                                                      \
      function dispatchEvent(node, type, event) {            \
          if (node.dispatchEvent) {                          \
              return node.dispatchEvent(event);              \
          }                                                  \
          if (node.fireEvent) {                              \
              return node.fireEvent('on' + type, event);     \
          }                                                  \
      }                                                      \
      var event = createCustomEvent('dragstart');            \
      dispatchEvent(sourceNode, 'dragstart', event);         \
                                                             \
      var dropEvent = createCustomEvent('drop');             \
      dropEvent.dataTransfer = event.dataTransfer;           \
      dispatchEvent(destinationNode, 'drop', dropEvent);     \
                                                             \
      var dragEndEvent = createCustomEvent('dragend');       \
      dragEndEvent.dataTransfer = event.dataTransfer;        \
      dispatchEvent(sourceNode, 'dragend', dragEndEvent);    \
  }                                                          \
  simulateDragDrop(document.evaluate('" + getXpathOfElement(element) + "', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue, document.evaluate('" + getXpathOfElement(target) + "', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue);\
  ";
    var win = window;
    var doc = win.document;
    var scriptTag = doc.createElement("script");
    scriptTag.type = "text/javascript";
    scriptTag.text = script;
    doc.body.appendChild(scriptTag);
}

var dragMock = {
    dragStart: function dragStart(targetElement, eventProperties, configCallback) {
        return call(new DragDropAction(), 'dragStart', arguments);
    },
    dragEnter: function dragEnter(targetElement, eventProperties, configCallback) {
        return call(new DragDropAction(), 'dragEnter', arguments);
    },
    dragOver: function dragOver(targetElement, eventProperties, configCallback) {
        return call(new DragDropAction(), 'dragOver', arguments);
    },
    dragLeave: function dragLeave(targetElement, eventProperties, configCallback) {
        return call(new DragDropAction(), 'dragLeave', arguments);
    },
    drop: function drop(targetElement, eventProperties, configCallback) {
        return call(new DragDropAction(), 'drop', arguments);
    },
    delay: function delay(targetElement, eventProperties, configCallback) {
        return call(new DragDropAction(), 'delay', arguments);
    },

    triggerDragEvent: triggerDragEvent,

    // Just for unit testing:
    DataTransfer: __webpack_require__(181),
    DragDropAction: __webpack_require__(349),
    eventFactory: __webpack_require__(350)
};

module.exports = dragMock;

/***/ }),

/***/ 361:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(512);
const migration_data_1 = __webpack_require__(513);
const _2019_04_01_macro_suite_storage_1 = __webpack_require__(325);
const ts_utils_1 = __webpack_require__(12);
class KantuMigrationService extends common_1.MigrationService {
    constructor() {
        super({
            storage: {
                get(type) {
                    return migration_data_1.getMigrationKeyValueData().get(type);
                },
                set(type, data) {
                    return migration_data_1.getMigrationKeyValueData().set(type, data)
                        .then(() => true);
                },
                getAll() {
                    return migration_data_1.getMigrationKeyValueData().getAll()
                        .then((dict) => {
                        return Object.keys(dict).map((key) => dict[key]);
                    });
                }
            },
            jobs: [
                _2019_04_01_macro_suite_storage_1.getMigrateMacroTestSuiteToBrowserFileSystem()
            ]
        });
    }
}
exports.KantuMigrationService = KantuMigrationService;
exports.getKantuMigrationService = ts_utils_1.singletonGetter(() => {
    return new KantuMigrationService();
});


/***/ }),

/***/ 365:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(153);
const ts_utils_1 = __webpack_require__(12);
var MiscKey;
(function (MiscKey) {
    MiscKey["BrowserModeLastMacroId"] = "browser_mode_last_macro_id";
    MiscKey["XFileModeLastMacroId"] = "xfile_mode_last_macro_id";
})(MiscKey = exports.MiscKey || (exports.MiscKey = {}));
class MiscData extends common_1.KeyValueData {
    getMainKeyAndSubKeys(key) {
        const [mainKey, subKeys] = super.getMainKeyAndSubKeys(key);
        return [
            MiscData.STORAGE_KEY,
            [mainKey].concat(subKeys).filter(x => x && x.length)
        ];
    }
}
exports.MiscData = MiscData;
MiscData.STORAGE_KEY = 'misc_data';
exports.getMiscData = ts_utils_1.singletonGetter(() => new MiscData());


/***/ }),

/***/ 374:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ZipFolders;
(function (ZipFolders) {
    ZipFolders["Macros"] = "macros";
    ZipFolders["TestSuites"] = "testsuites";
    ZipFolders["Screenshots"] = "screenshots";
    ZipFolders["Csvs"] = "datasources";
    ZipFolders["Visions"] = "images";
})(ZipFolders = exports.ZipFolders || (exports.ZipFolders = {}));


/***/ }),

/***/ 389:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(153);
const ts_utils_1 = __webpack_require__(12);
class TestSuiteExtraKeyValueData extends common_1.KeyValueData {
    getAll() {
        return super.get("");
    }
    getMainKeyAndSubKeys(key) {
        const [mainKey, subKeys] = super.getMainKeyAndSubKeys(key);
        return [
            TestSuiteExtraKeyValueData.STORAGE_KEY,
            [mainKey].concat(subKeys).filter(x => x && x.length)
        ];
    }
}
exports.TestSuiteExtraKeyValueData = TestSuiteExtraKeyValueData;
TestSuiteExtraKeyValueData.STORAGE_KEY = 'test_suite_extra';
exports.getTestSuiteExtraKeyValueData = ts_utils_1.singletonGetter(() => new TestSuiteExtraKeyValueData());


/***/ }),

/***/ 390:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeTestSuite", function() { return normalizeTestSuite; });
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _common_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var _common_ts_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_common_ts_utils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92);




var model = {
  table: _db__WEBPACK_IMPORTED_MODULE_2__["default"].testSuites,
  list: function list() {
    return _db__WEBPACK_IMPORTED_MODULE_2__["default"].testSuites.toArray();
  },
  insert: function insert(data) {
    if (!data.name) {
      throw new Error('Model TestSuite - insert: missing name');
    }

    if (!Array.isArray(data.cases)) {
      throw new Error('Model TestSuite - insert: cases should an array');
    }

    data.updateTime = new Date() * 1;
    data.id = Object(_common_utils__WEBPACK_IMPORTED_MODULE_0__["uid"])();
    return _db__WEBPACK_IMPORTED_MODULE_2__["default"].testSuites.add(data);
  },
  bulkInsert: function bulkInsert(tcs) {
    var list = tcs.map(function (data) {
      if (!data.name) {
        throw new Error('Model TestSuite - insert: missing name');
      }

      if (!Array.isArray(data.cases)) {
        throw new Error('Model TestSuite - insert: cases should an array');
      }

      data.updateTime = new Date() * 1;
      data.id = Object(_common_utils__WEBPACK_IMPORTED_MODULE_0__["uid"])();

      return data;
    });

    return _db__WEBPACK_IMPORTED_MODULE_2__["default"].testSuites.bulkAdd(list);
  },
  update: function update(id, data) {
    return _db__WEBPACK_IMPORTED_MODULE_2__["default"].testSuites.update(id, data);
  },
  remove: function remove(id) {
    return _db__WEBPACK_IMPORTED_MODULE_2__["default"].testSuites.delete(id);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (model);

function normalizeTestSuite(ts) {
  return Object(_common_ts_utils__WEBPACK_IMPORTED_MODULE_1__["pickIfExist"])(['id', 'name', 'cases'], ts);
}

/***/ }),

/***/ 393:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeWindow", function() { return resizeWindow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeViewport", function() { return resizeViewport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeViewportOfTab", function() { return resizeViewportOfTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWindowSize", function() { return getWindowSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFocusedWindowSize", function() { return getFocusedWindowSize; });
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _web_extension__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_web_extension__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_log__WEBPACK_IMPORTED_MODULE_2__);




var calcOffset = function calcOffset(screenTotal, screenOffset, oldOffset, oldSize, newSize) {
  var preferStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  var isCloserToStart = preferStart || oldOffset < screenTotal - oldOffset - oldSize;

  _log__WEBPACK_IMPORTED_MODULE_2___default()('calcOffset', screenTotal, oldOffset, oldSize, newSize, preferStart);

  if (isCloserToStart) {
    return oldOffset;

    // Note: comment out a smarter position for now
    // if (newSize < oldSize) {
    //   return oldOffset
    // }

    // if (newSize < oldSize + oldOffset - screenOffset) {
    //   return oldSize + oldOffset - newSize
    // }

    // return screenOffset
  }

  if (!isCloserToStart) {
    var oldEndOffset = screenOffset + screenTotal - oldOffset - oldSize;

    return oldSize + oldOffset - newSize;

    // Note: comment out a smarter position for now
    // if (newSize < oldSize) {
    //   return oldSize + oldOffset - newSize
    // }

    // if (newSize < oldSize + oldEndOffset) {
    //   return oldOffset
    // }

    // return screenOffset + screenTotal - newSize
  }
};

// winSize.width
// winSize.height
function resizeWindow(winId, winSize) {
  var sw = screen.availWidth;
  var sh = screen.availHeight;
  var sl = screen.availLeft;
  var st = screen.availTop;

  return _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.windows.get(winId).then(function (win) {
    var lastLeft = win.left;
    var lastTop = win.top;
    var lastWidth = win.width;
    var lastHeight = win.height;

    return _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.windows.update(winId, winSize).then(function (win) {
      var left = calcOffset(sw, sl, lastLeft, lastWidth, win.width);
      var top = calcOffset(sh, st, lastTop, lastHeight, win.height, true);

      _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.windows.update(winId, { left: left, top: top });

      var actual = {
        width: win.width,
        height: win.height
      };

      return {
        actual: actual,
        desired: winSize,
        diff: ['width', 'height'].filter(function (key) {
          return actual[key] !== winSize[key];
        })
      };
    });
  });
}

// pureViewportSize.width
// pureViewportSize.height
// referenceViewportWindowSize.window.width
// referenceViewportWindowSize.window.height
// referenceViewportWindowSize.viewport.width
// referenceViewportWindowSize.viewport.height
function resizeViewport(winId, pureViewportSize) {
  var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

  var maxRetry = 2;
  _log__WEBPACK_IMPORTED_MODULE_2___default()('resizeViewport, ROUND', count);

  return getWindowSize(winId).then(function (currentSize) {
    logWindowSize(currentSize);

    var dx = currentSize.window.width - currentSize.viewport.width;
    var dy = currentSize.window.height - currentSize.viewport.height;

    var newWinSize = {
      width: dx + pureViewportSize.width,
      height: dy + pureViewportSize.height
    };

    _log__WEBPACK_IMPORTED_MODULE_2___default()('size set to', newWinSize);
    return resizeWindow(winId, newWinSize).then(function () {
      return getWindowSize(winId);
    }).then(function (newSize) {
      logWindowSize(newSize);

      var data = {
        actual: newSize.viewport,
        desired: pureViewportSize,
        diff: ['width', 'height'].filter(function (key) {
          return newSize.viewport[key] !== pureViewportSize[key];
        })
      };

      if (data.diff.length === 0 || count >= maxRetry) {
        return data;
      }

      return Object(_utils__WEBPACK_IMPORTED_MODULE_1__["delay"])(function () {}, 0).then(function () {
        return resizeViewport(winId, pureViewportSize, count + 1);
      });
    });
  });
}

function resizeViewportOfTab(tabId, pureViewportSize) {
  return _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.tabs.get(tabId).then(function (tab) {
    return resizeViewport(tab.windowId, pureViewportSize);
  });
}

// size.window.width
// size.window.height
// size.window.left
// size.window.top
// size.viewport.wdith
// size.viewport.height
function getWindowSize(winId) {
  return _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.windows.get(winId, { populate: true }).then(function (win) {
    var tab = win.tabs.find(function (tab) {
      return tab.active;
    });

    return {
      window: {
        width: win.width,
        height: win.height,
        left: win.left,
        top: win.top
      },
      viewport: {
        width: tab.width,
        height: tab.height
      }
    };
  });
}

function getFocusedWindowSize() {
  return _web_extension__WEBPACK_IMPORTED_MODULE_0___default.a.windows.getLastFocused().then(function (win) {
    return getWindowSize(win.id);
  });
}

function logWindowSize(winSize) {
  _log__WEBPACK_IMPORTED_MODULE_2___default()(winSize.window, winSize.viewport);
  _log__WEBPACK_IMPORTED_MODULE_2___default()('dx = ', winSize.window.width - winSize.viewport.width);
  _log__WEBPACK_IMPORTED_MODULE_2___default()('dy = ', winSize.window.height - winSize.viewport.height);
}

/***/ }),

/***/ 402:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CallStackEvent;
(function (CallStackEvent) {
    CallStackEvent["BeforeRun"] = "before_run";
    CallStackEvent["BeforeResume"] = "before_resume";
    CallStackEvent["AfterReturn"] = "after_return";
})(CallStackEvent = exports.CallStackEvent || (exports.CallStackEvent = {}));


/***/ }),

/***/ 404:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Counter {
    constructor(options = {}) {
        this.n = 0;
        const { initial, getMax, onMax } = options;
        if (typeof getMax !== 'function')
            throw new Error(`'getMax' function is required`);
        if (typeof onMax !== 'function')
            throw new Error(`onMax callback is required`);
        this.initial = initial || 0;
        this.getMax = getMax;
        this.onMax = onMax;
        this.reset();
    }
    reset() {
        this.n = this.initial;
    }
    get() {
        return this.n;
    }
    getMaximum() {
        return this.getMax();
    }
    check() {
        const max = this.getMax();
        if (this.n + 1 > max) {
            this.onMax(this.n, max, this.initial);
            return false;
        }
        return true;
    }
    inc() {
        const max = this.getMax();
        if (this.n < max) {
            this.n += 1;
            return true;
        }
        else {
            this.onMax(this.n, max, this.initial);
            return false;
        }
    }
}
exports.Counter = Counter;


/***/ }),

/***/ 41:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(0));
const antd_1 = __webpack_require__(117);
const scroll_into_view_if_needed_1 = __importDefault(__webpack_require__(1088));
const ts_utils_1 = __webpack_require__(12);
const storage_1 = __webpack_require__(13);
const ts_utils_2 = __webpack_require__(12);
const prompt_1 = __webpack_require__(187);
const log_1 = __importDefault(__webpack_require__(11));
const index_1 = __webpack_require__(16);
const recomputed_1 = __webpack_require__(23);
const tree_file_1 = __webpack_require__(137);
const test_suite_extra_data_1 = __webpack_require__(389);
const test_suite_model_1 = __webpack_require__(390);
const utils_1 = __webpack_require__(4);
const convert_utils_1 = __webpack_require__(50);
const state_1 = __webpack_require__(62);
const misc_data_1 = __webpack_require__(365);
const constant_1 = __webpack_require__(17);
const save_test_case_1 = __importDefault(__webpack_require__(99));
const file_saver_1 = __importDefault(__webpack_require__(70));
const command_1 = __webpack_require__(43);
const jszip_1 = __importDefault(__webpack_require__(142));
const config_1 = __importDefault(__webpack_require__(34));
const license_1 = __webpack_require__(30);
function getMacroIdChanges(options) {
    const { entryPath, isDirectory, getNewFilePath } = options;
    const macroStorage = storage_1.getStorageManager().getMacroStorage();
    const entryFullPath = macroStorage.entryPath(entryPath, isDirectory);
    if (!isDirectory) {
        return Promise.resolve({
            [entryFullPath]: getNewFilePath(entryFullPath)
        });
    }
    return macroStorage.listR(entryFullPath)
        .then((entryNodes) => {
        const listOfNodes = entryNodes.map(node => ts_utils_1.flatternTree(node));
        const nodes = ts_utils_1.flatten(listOfNodes);
        return nodes
            .map((node) => node.fullPath)
            .reduce((prev, oldMacroPath) => {
            prev[oldMacroPath] = getNewFilePath(oldMacroPath);
            return prev;
        }, {});
    });
}
exports.getMacroIdChanges = getMacroIdChanges;
function withMacroIdChanges(options) {
    return getMacroIdChanges(options)
        .then(macroIdChanges => {
        return Promise.resolve(options.run())
            // Note: the delay is waiting for macro ids updated in state
            .then(() => ts_utils_1.delay(() => { }, 1000))
            .then(() => {
            options.dispatch(exports.Actions.updateMacroIdsInTestSuites(macroIdChanges));
        });
    });
}
exports.withMacroIdChanges = withMacroIdChanges;
function checkNodeShowUp(params) {
    const { dispatch, getState, fullPath, message, switchToIt = true } = params;
    return ts_utils_1.until('node shows up', () => {
        const state = getState();
        const { macroFolderStructure } = getState().editor;
        const macroNodes = recomputed_1.getMacroFileNodeList(state);
        const nodes = ts_utils_1.flatten(macroFolderStructure.map(ts_utils_1.flatternTree));
        const found = nodes.find((item) => item.fullPath === fullPath);
        const foundInTestCases = macroNodes.find((item) => item.fullPath === fullPath);
        // Note: testCases are slower than macorFolderStructure, because testCases need to read file
        // So have to wait for both
        return {
            pass: !!found && !!foundInTestCases,
            result: found
        };
    }, 100, 10 * 1000)
        .then(() => {
        if (switchToIt) {
            dispatch(index_1.editTestCase(fullPath));
        }
        dispatch(exports.Actions.ensureTreeNodeUnfoldedForCurrentMacroNode());
    }, (e) => {
        log_1.default.error(e);
        fileFolderNotShown({
            dispatch,
            getState,
            message
        });
    });
}
exports.checkNodeShowUp = checkNodeShowUp;
function fileFolderNotShown(params) {
    const { dispatch, getState, message } = params;
    const { config } = getState();
    const { storageMode, xmodulesStatus = 'unregistered' } = config;
    if (storageMode !== storage_1.StorageStrategyType.XFile) {
        return;
    }
    if (license_1.getLicenseService().isProLicense() || license_1.getLicenseService().isPlayerLicense()) {
        return;
    }
    const reason = (() => {
        if (license_1.getLicenseService().hasNoLicense()) {
            return `${license_1.getLicenseService().getMaxXFileMacros()} macro/folder limit in free version`;
        }
        if (license_1.getLicenseService().isPersonalLicense()) {
            return `${license_1.getLicenseService().getMaxXFileMacros()} macro/folder limit in PRO1 version`;
        }
        throw new Error('Unknown cases');
    })();
    antd_1.Modal.warn({
        title: 'Please upgrade your XModule plan',
        content: `${message}, but not displayed due to ${reason}`,
        okText: 'OK',
        onOk: () => {
            dispatch(index_1.updateUI({ showSettings: true, settingsTab: 'register' }));
        }
    });
}
exports.fileFolderNotShown = fileFolderNotShown;
exports.ActionFactories = {
    setNoDisplayInPlay: (name) => (noDisplayInPlay) => {
        return createAction(name, noDisplayInPlay);
    },
    setFrom: (name) => (from) => {
        return createThunkAction((dispatch, getState) => {
            const { from: oldFrom } = getState();
            if (from === state_1.RunBy.Manual && oldFrom !== state_1.RunBy.Manual) {
                storage_1.getStorageManager().emit(storage_1.StorageManagerEvent.ForceReload);
            }
            dispatch(createAction(name, from));
        });
    },
    setIsLoadingMacros: (name) => (isLoading) => {
        return createAction(name, isLoading);
    },
    setCurrentMacro: (name) => (macro) => {
        return createAction(name, macro);
    },
    copyCurrentCommand: (name) => () => {
        return createThunkAction((dispatch, getState) => {
            const { selectedIndex } = getState().editor.editing.meta;
            if (selectedIndex === -1) {
                return;
            }
            dispatch(index_1.copyCommand(selectedIndex));
        });
    },
    cutCurrentCommand: (name) => () => {
        return createThunkAction((dispatch, getState) => {
            const { selectedIndex } = getState().editor.editing.meta;
            if (selectedIndex === -1) {
                return;
            }
            dispatch(index_1.cutCommand(selectedIndex));
        });
    },
    pasteAtCurrentCommand: (name) => () => {
        return createThunkAction((dispatch, getState) => {
            const { selectedIndex } = getState().editor.editing.meta;
            if (selectedIndex === -1) {
                return;
            }
            dispatch(index_1.pasteCommand(selectedIndex));
        });
    },
    selectNextCommand: (name) => () => {
        return createThunkAction((dispatch, getState) => {
            const { meta, commands } = getState().editor.editing;
            const { selectedIndex } = meta;
            if (selectedIndex < commands.length - 1) {
                dispatch(index_1.selectCommand(selectedIndex + 1, true));
            }
        });
    },
    selectPrevCommand: (name) => () => {
        return createThunkAction((dispatch, getState) => {
            const { meta, commands } = getState().editor.editing;
            const { selectedIndex } = meta;
            if (selectedIndex > 0) {
                dispatch(index_1.selectCommand(selectedIndex - 1, true));
            }
        });
    },
    moveCommands: (name) => (startIndex, endIndex) => {
        return createAction(name, { startIndex, endIndex });
    },
    setIsDraggingCommand: (name) => (isDraggingCommand) => {
        return createAction(name, isDraggingCommand);
    },
    setMacroFolderStructure: (name) => (entryNodes) => {
        return createAction(name, entryNodes);
    },
    setTestSuiteFolderStructure: (name) => (entryNodes) => {
        return createAction(name, entryNodes);
    },
    macroCreateFolder: (name) => (options) => {
        return createThunkAction((dispatch, getState) => {
            const macroStorage = storage_1.getStorageManager().getMacroStorage();
            const path = macroStorage.getPathLib();
            const parentDir = macroStorage.dirPath(options.dir);
            return prompt_1.prompt({
                width: 400,
                title: 'Create folder as..',
                message: '',
                value: '',
                placeholder: 'Folder name',
                selectionStart: 0,
                selectionEnd: 0,
                okText: 'Create',
                cancelText: 'Cancel',
                onCancel: () => Promise.resolve(true),
                onOk: (newName) => {
                    const newFullPath = path.join(parentDir, utils_1.sanitizeFileName(newName));
                    return macroStorage.directoryExists(newFullPath)
                        .then(exists => {
                        if (exists) {
                            const msg = `'${newName}' already exists`;
                            antd_1.message.error(msg);
                            throw new Error(msg);
                        }
                        return storage_1.getStorageManager().getMacroStorage().createDirectory(newFullPath)
                            .then(() => {
                            antd_1.message.success(`Created folder '${newName}'`);
                            checkNodeShowUp({
                                getState,
                                dispatch,
                                fullPath: newFullPath,
                                switchToIt: false,
                                message: 'Folder created'
                            });
                            return true;
                        }, (e) => {
                            log_1.default.error(e);
                            const msg = 'Failed to create folder: ' + e.message;
                            antd_1.message.error(msg);
                            throw new Error(msg);
                        });
                    });
                }
            });
        });
    },
    macroDeleteFolder: (name) => (options) => {
        // TODO: check if any macro is in use of some test suite
        return createThunkAction((dispatch, getState) => {
            const { dir } = options;
            const macroStorage = storage_1.getStorageManager().getMacroStorage();
            const assertNoMacroInUse = () => {
                return getMacroIdChanges({
                    entryPath: macroStorage.dirPath(dir),
                    isDirectory: true,
                    getNewFilePath: (str) => str
                })
                    .then(macroIdChanges => {
                    const state = getState();
                    const testSuites = recomputed_1.getTestSuitesWithAllInfo(state);
                    const oldMacroIds = Object.keys(macroIdChanges);
                    const problems = [];
                    oldMacroIds.forEach((oldMacroId) => {
                        testSuites.forEach((ts) => {
                            if (ts.cases.find(obj => obj.testCaseId === oldMacroId)) {
                                problems.push({
                                    macroPath: macroStorage.relativePath(oldMacroId),
                                    testSuiteName: ts.name
                                });
                            }
                        });
                    });
                    if (problems.length > 0) {
                        const cnt = 3;
                        const main = problems.slice(0, cnt)
                            .map(obj => `"${obj.macroPath}" is still used in test suite "${obj.testSuiteName}"`)
                            .join('\n');
                        const extra = problems.length <= cnt ? '' : `\n...\n(And ${problems.length - 1} more macro references)`;
                        const msg = main + extra;
                        throw new Error(msg);
                    }
                });
            };
            if (confirm(`Sure to delete ${dir} and all its content?`)) {
                return assertNoMacroInUse()
                    .then(() => macroStorage.remove(dir, true))
                    .catch((e) => {
                    antd_1.Modal.warn({
                        title: 'Failed to delete folder',
                        content: e.message.split('\n').map(str => react_1.default.createElement('li', null, str)),
                        okText: 'OK'
                    });
                });
            }
        });
    },
    macroMoveEntry: (name) => (data) => {
        return createThunkAction((dispatch, getState) => {
            const macroStorage = storage_1.getStorageManager().getMacroStorage();
            const path = macroStorage.getPathLib();
            const getNewFilePath = (oldMacroPath) => {
                const dirName = path.basename(data.entryId);
                const oldDirFullPath = macroStorage.dirPath(data.entryId);
                const relativePath = path.relative(oldMacroPath, oldDirFullPath);
                return path.join(data.dirId, dirName, relativePath);
            };
            const moveEntry = () => macroStorage.move(data.entryId, data.dirId, data.isSourceDirectory, true);
            return withMacroIdChanges({
                dispatch,
                getNewFilePath,
                run: moveEntry,
                entryPath: data.entryId,
                isDirectory: data.isSourceDirectory
            })
                .catch((e) => {
                antd_1.message.error(e.message);
            });
        });
    },
    macroRenameFolder: (name) => (options) => {
        return createThunkAction((dispatch, getState) => {
            const { dir } = options;
            const macroStorage = storage_1.getStorageManager().getMacroStorage();
            const path = macroStorage.getPathLib();
            const dirFullPath = macroStorage.dirPath(dir);
            const folderName = path.basename(dirFullPath);
            const parentDir = path.dirname(dirFullPath);
            const editingId = getState().editor.editing.meta.src.id;
            const isEditingCur = editingId.indexOf(dirFullPath + path.sep) === 0;
            return prompt_1.prompt({
                width: 400,
                title: 'Rename the folder as..',
                message: '',
                value: folderName,
                placeholder: 'Folder name',
                selectionStart: 0,
                selectionEnd: folderName.length,
                okText: 'Rename',
                cancelText: 'Cancel',
                onCancel: () => Promise.resolve(true),
                onOk: (newName) => {
                    const newFullPath = path.join(parentDir, utils_1.sanitizeFileName(newName));
                    return macroStorage.directoryExists(newFullPath)
                        .then(exists => {
                        if (exists) {
                            const msg = `'${newName}' already exists`;
                            antd_1.message.error(msg);
                            throw new Error(msg);
                        }
                        return withMacroIdChanges({
                            dispatch,
                            isDirectory: true,
                            entryPath: dirFullPath,
                            getNewFilePath: (oldMacroPath) => {
                                const relativePath = path.relative(oldMacroPath, dirFullPath);
                                return path.join(newFullPath, relativePath);
                            },
                            run: () => {
                                return macroStorage.moveDirectory(dirFullPath, newFullPath)
                                    .then(() => {
                                    antd_1.message.success(`Renamed to '${newName}'`);
                                    checkNodeShowUp({
                                        getState,
                                        dispatch,
                                        fullPath: newFullPath,
                                        switchToIt: false,
                                        message: 'Folder renamed'
                                    });
                                    if (isEditingCur) {
                                        const newMacroPath = editingId.replace(dirFullPath, newFullPath);
                                        dispatch(index_1.editTestCase(newMacroPath));
                                    }
                                }, (e) => {
                                    log_1.default.error(e);
                                    const msg = 'Failed to rename: ' + e.message;
                                    antd_1.message.error(msg);
                                    throw new Error(msg);
                                });
                            }
                        })
                            .then(() => true);
                    });
                }
            });
        });
    },
    macroCreateFile: (name) => (options) => {
        return createThunkAction((dispatch, getState) => {
            const { dir } = options;
            const macroStorage = storage_1.getStorageManager().getMacroStorage();
            const path = macroStorage.getPathLib();
            return prompt_1.prompt({
                width: 400,
                title: 'Create new macro as..',
                message: '',
                value: '',
                placeholder: 'Macro name',
                selectionStart: 0,
                selectionEnd: 0,
                okText: 'Confirm',
                cancelText: 'Cancel',
                onCancel: () => Promise.resolve(true),
                onOk: (macroName) => {
                    const filePath = path.join(dir, `${utils_1.sanitizeFileName(macroName)}.json`);
                    const fullPath = macroStorage.filePath(filePath);
                    return macroStorage.fileExists(fullPath)
                        .then(exists => {
                        if (exists) {
                            const msg = `'${macroName}' already exists`;
                            antd_1.message.error(msg);
                            throw new Error(msg);
                        }
                        return macroStorage.write(filePath, {
                            name: macroName,
                            data: {
                                commands: []
                            }
                        })
                            .then(() => {
                            antd_1.message.success(`Created macro '${macroName}'`);
                            checkNodeShowUp({
                                getState,
                                dispatch,
                                fullPath,
                                message: 'New macro created'
                            });
                            return true;
                        }, (e) => {
                            log_1.default.error(e);
                            const msg = 'Failed to create macro: ' + e.message;
                            antd_1.message.error(msg);
                            throw new Error(msg);
                        });
                    });
                }
            });
        });
    },
    ensureTreeNodeUnfoldedForCurrentMacroNode: (name) => (options) => {
        const opts = Object.assign({ scrollIntoView: true }, (options || {}));
        return createThunkAction((dispatch, getState) => {
            const state = getState();
            const macroId = recomputed_1.getCurrentMacroId(state);
            const macrosExtra = recomputed_1.getMacrosExtra(state);
            const fileNodes = recomputed_1.getMacroFileNodeData(state);
            const ancestors = ts_utils_1.ancestorsInNodesList((node) => node.id === macroId, fileNodes);
            const scrollIfNeeded = () => {
                if (opts.scrollIntoView) {
                    setTimeout(() => {
                        const id = ts_utils_1.normalizeHtmlId(macroId);
                        const $el = document.getElementById(id);
                        if ($el) {
                            scroll_into_view_if_needed_1.default($el, { behavior: 'smooth', block: 'nearest' });
                        }
                    }, 100);
                }
            };
            if (!ancestors || !ancestors.length) {
                return scrollIfNeeded();
            }
            const updates = ancestors.map((node) => {
                return ts_utils_1.safeUpdateIn([node.id], (data) => (Object.assign(Object.assign({}, (data || {})), { folded: false })));
            });
            const newMacrosExtra = ts_utils_2.compose(...updates)(macrosExtra);
            dispatch(index_1.setMacrosExtra(newMacrosExtra, { shouldPersist: true }));
            scrollIfNeeded();
        });
    },
    updateMacroIdsInTestSuites: (name) => (macroIdChanges) => {
        return createThunkAction((dispatch, getState) => {
            const state = getState();
            const testSuites = recomputed_1.getTestSuitesWithAllInfo(state);
            const oldMacroIds = Object.keys(macroIdChanges);
            oldMacroIds.forEach((oldMacroId) => {
                const newMacroId = macroIdChanges[oldMacroId];
                testSuites.forEach((ts) => {
                    const indices = ts.cases.reduce((prev, obj, i) => {
                        if (obj.testCaseId === oldMacroId) {
                            prev.push(i);
                        }
                        return prev;
                    }, []);
                    if (indices.length === 0) {
                        return;
                    }
                    const cases = ts_utils_2.compose(...indices.map(i => ts_utils_1.setIn([i, 'testCaseId'], newMacroId)))(ts.cases);
                    dispatch(exports.Actions.updateTestSuite(ts.id, { cases }));
                });
            });
        });
    },
    updateTestSuite: (name) => (id, data) => {
        return createThunkAction((dispatch, getState) => {
            const state = getState();
            const testSuites = recomputed_1.getTestSuitesWithAllInfo(state);
            const ts = testSuites.find(ts => ts.id === id);
            if (!ts) {
                return;
            }
            const realData = typeof data === 'function' ? data(ts) : data;
            const hasRename = realData.name && ts.name !== realData.name;
            if (hasRename) {
                const hasDuplciateName = !!testSuites.find(ts => ts.id !== id && ts.name === realData.name);
                if (hasDuplciateName) {
                    return Promise.reject(new Error(`The test suite name '${realData.name}' already exists!`));
                }
            }
            // Note: revised may contain `playStatus`
            const revised = Object.assign(Object.assign({}, ts), realData);
            const suiteStorage = storage_1.getStorageManager().getTestSuiteStorage();
            const suiteName = hasRename ? realData.name : ts.name;
            const pRename = hasRename ? suiteStorage.rename(ts.name, realData.name)
                : Promise.resolve();
            const pStoreExtra = hasRename && storage_1.getStorageManager().isXFileMode()
                ? test_suite_extra_data_1.getTestSuiteExtraKeyValueData()
                    .set(id, {
                    fold: false,
                    playStatus: {}
                })
                : test_suite_extra_data_1.getTestSuiteExtraKeyValueData()
                    .set(id, {
                    fold: revised.fold,
                    playStatus: revised.playStatus || {}
                });
            dispatch({
                type: name,
                data: {
                    id: id,
                    updated: test_suite_model_1.normalizeTestSuite(revised)
                }
            });
            if (hasRename && storage_1.getStorageManager().isXFileMode()) {
                // Reset test suite status
                dispatch({
                    type: 'UPDATE_TEST_SUITE_STATUS',
                    data: {
                        id,
                        extra: {
                            fold: false,
                            playStatus: {}
                        }
                    }
                });
            }
            else {
                dispatch({
                    type: 'UPDATE_TEST_SUITE_STATUS',
                    data: {
                        id,
                        extra: {
                            fold: revised.fold,
                            playStatus: revised.playStatus || {}
                        }
                    }
                });
            }
            return Promise.all([
                pRename,
                pStoreExtra
            ])
                .then(() => suiteStorage.write(suiteName, revised));
        });
    },
    renameTestCase: (name) => (newName, fullPath) => {
        return createThunkAction((dispatch, getState) => {
            const macroStorage = storage_1.getStorageManager().getMacroStorage();
            const path = macroStorage.getPathLib();
            const state = getState();
            const editingId = state.editor.editing.meta.src.id;
            const newPath = macroStorage.filePath(path.join(path.dirname(fullPath), utils_1.sanitizeFileName(newName)));
            return macroStorage.fileExists(fullPath)
                .then(exists => {
                if (!exists) {
                    throw new Error(`No macro found with id '${fullPath}'!`);
                }
                return macroStorage.fileExists(newPath)
                    .then(exists => {
                    if (exists) {
                        throw new Error('The macro name already exists!');
                    }
                });
            })
                .then(() => {
                if (storage_1.getStorageManager().isXFileMode()) {
                    // Reset test case status
                    dispatch(index_1.updateMacroPlayStatus(fullPath, null));
                }
                return withMacroIdChanges({
                    dispatch,
                    entryPath: fullPath,
                    isDirectory: false,
                    getNewFilePath: (_) => newPath,
                    run: () => {
                        return storage_1.getStorageManager()
                            .getMacroStorage()
                            .rename(fullPath, newPath)
                            .then(() => {
                            if (editingId === fullPath) {
                                dispatch({
                                    type: name,
                                    data: newName,
                                    post: index_1.saveEditing
                                });
                            }
                        });
                    }
                })
                    .then(() => {
                    const isRenamingCurrentMacro = editingId === fullPath;
                    if (isRenamingCurrentMacro) {
                        dispatch(index_1.editTestCase(newPath));
                    }
                    checkNodeShowUp({
                        getState,
                        dispatch,
                        fullPath: newPath,
                        switchToIt: false,
                        message: 'Macro renamed'
                    });
                });
            });
        });
    },
    duplicateTestCase: (name) => (macro) => {
        return createThunkAction((dispatch, getState) => {
            const macroStorage = storage_1.getStorageManager().getMacroStorage();
            const path = macroStorage.getPathLib();
            const dirPath = path.dirname(macro.fullPath);
            const getNewPath = (newName) => path.join(dirPath, `${newName}.json`);
            const getNewName = () => {
                return utils_1.uniqueName(macro.name, {
                    generate: (old, step = 1) => {
                        const reg = /-(\d+)$/;
                        const m = old.match(reg);
                        if (!m)
                            return `${old}-${step}`;
                        return old.replace(reg, (_, n) => `-${parseInt(n, 10) + step}`);
                    },
                    check: (fileName) => {
                        return macroStorage.fileExists(getNewPath(fileName)).then(exists => !exists);
                    }
                });
            };
            return getNewName()
                .then(newMacroName => {
                return prompt_1.prompt({
                    width: 400,
                    title: 'Duplicate macro as..',
                    message: '',
                    value: newMacroName,
                    placeholder: 'Macro name',
                    selectionStart: 0,
                    selectionEnd: newMacroName.length,
                    okText: 'Duplicate',
                    cancelText: 'Cancel',
                    onCancel: () => Promise.resolve(true),
                    onOk: (macroName) => {
                        const fullPath = macroStorage.filePath(getNewPath(utils_1.sanitizeFileName(macroName)));
                        return macroStorage.fileExists(fullPath)
                            .then(exists => {
                            if (exists) {
                                const msg = `'${macroName}' already exists`;
                                antd_1.message.error(msg);
                                throw new Error(msg);
                            }
                            return macroStorage.copy(macro.fullPath, fullPath, false, false)
                                .then(() => {
                                antd_1.message.success(`Successfully duplicated as '${macroName}'`);
                                // Note: need to wait until it's reflected in redux
                                checkNodeShowUp({
                                    getState,
                                    dispatch,
                                    fullPath,
                                    message: 'Macro duplicated'
                                });
                                return true;
                            }, (e) => {
                                log_1.default.error(e);
                                const msg = 'Failed to duplicate macro: ' + e.message;
                                antd_1.message.error(msg);
                                throw new Error(msg);
                            });
                        });
                    }
                });
            });
        });
    },
    duplicateVisionImage: (name) => (imageName) => {
        return createThunkAction((dispatch, getState) => {
            const visionStorage = storage_1.getStorageManager().getVisionStorage();
            const path = visionStorage.getPathLib();
            const dirPath = path.dirname(imageName);
            const getNewPath = (newName) => path.join(dirPath, newName);
            const getNewName = () => {
                return utils_1.uniqueName(imageName, {
                    generate: (old, step = 1) => {
                        const reg = /-(\d+)$/;
                        const m = old.match(reg);
                        if (!m)
                            return `${old}-${step}`;
                        return old.replace(reg, (_, n) => `-${parseInt(n, 10) + step}`);
                    },
                    check: (fileName) => {
                        return visionStorage.fileExists(getNewPath(fileName)).then(exists => {
                            return !exists;
                        });
                    }
                });
            };
            return getNewName()
                .then(newImageName => {
                return prompt_1.prompt({
                    width: 400,
                    title: 'Duplicate vision image as..',
                    message: '',
                    value: newImageName,
                    placeholder: 'Macro name',
                    selectionStart: 0,
                    selectionEnd: newImageName.length,
                    okText: 'Duplicate',
                    cancelText: 'Cancel',
                    onCancel: () => Promise.resolve(true),
                    onOk: (finalImageName) => {
                        const fullPath = visionStorage.filePath(getNewPath(utils_1.sanitizeFileName(finalImageName)));
                        return visionStorage.fileExists(fullPath)
                            .then(exists => {
                            if (exists) {
                                const msg = `'${finalImageName}' already exists`;
                                antd_1.message.error(msg);
                                throw new Error(msg);
                            }
                            return visionStorage.copy(imageName, fullPath, false, false)
                                .then(() => {
                                antd_1.message.success(`Successfully duplicated as '${finalImageName}'`);
                                dispatch(index_1.listVisions());
                                return true;
                            }, (e) => {
                                log_1.default.error(e);
                                const msg = 'Failed to duplicate vision image: ' + e.message;
                                antd_1.message.error(msg);
                                throw new Error(msg);
                            });
                        });
                    }
                });
            });
        });
    },
    selectInitialMacro: (name) => (mode) => {
        return createThunkAction((dispatch, getState) => {
            const key = (() => {
                switch (mode) {
                    case storage_1.StorageStrategyType.Browser:
                        return misc_data_1.MiscKey.BrowserModeLastMacroId;
                    case storage_1.StorageStrategyType.XFile:
                        return misc_data_1.MiscKey.XFileModeLastMacroId;
                    default:
                        throw new Error(`Invalid mode: ${mode}`);
                }
            })();
            return misc_data_1.getMiscData().get(key)
                .then((macroFullPath) => {
                const state = getState();
                const found = macroFullPath ? recomputed_1.findMacroNodeWithCaseInsensitiveFullPath(state, macroFullPath) : null;
                log_1.default('selectInitialMacro', key, macroFullPath, found, state);
                if (found) {
                    return macroFullPath;
                }
                const rootNodes = recomputed_1.getMacroFolderNodeList(state);
                const first = ts_utils_1.findNodeInForest(node => node.isFile, rootNodes);
                return first ? first.fullPath : null;
            })
                .then((macroFullPath) => {
                if (macroFullPath) {
                    dispatch(index_1.editTestCase(macroFullPath));
                }
                else {
                    dispatch(index_1.editNewTestCase());
                }
            });
        });
    },
    editMacroByOffset: (name) => (offset) => {
        return createThunkAction((dispatch, getState) => {
            const state = getState();
            if (state.ui.isSaving) {
                return;
            }
            const trees = recomputed_1.getFilteredMacroFileNodeData(state);
            const macroId = recomputed_1.getCurrentMacroId(state);
            if (macroId === constant_1.UNTITLED_ID) {
                return;
            }
            const found = ts_utils_1.nodeByOffset({
                offset,
                tree: trees,
                isTargetQualified: (node) => {
                    return node.id === macroId;
                },
                isCandidateQualified: (node) => {
                    return node.type === tree_file_1.FileNodeType.File;
                }
            });
            if (!found) {
                return;
            }
            return dispatch(index_1.editTestCase(found.id))
                .then(() => {
                dispatch(exports.Actions.ensureTreeNodeUnfoldedForCurrentMacroNode({ scrollIntoView: true }));
            });
        });
    },
    setMacroQuery: (name) => (query) => {
        return createAction(name, query);
    },
    setIndexToInsertRecorded: (name) => (index) => {
        return createAction(name, index);
    },
    toggleRecorderSkipOpen: (name) => (force) => {
        return createAction(name, force);
    },
    scrollToCommandAtIndex: (name) => (commandIndex) => {
        return createThunkAction(() => {
            const $tableBody = document.querySelector('.table-wrapper');
            const itemHeight = config_1.default.ui.commandItemHeight;
            if (!$tableBody) {
                return;
            }
            const totalHeight = $tableBody.clientHeight;
            const scrollTop = $tableBody.scrollTop;
            const isAboveScrollArea = itemHeight * commandIndex < scrollTop;
            const isBelowScrollArea = itemHeight * (commandIndex + 3) > scrollTop + totalHeight;
            if (isAboveScrollArea) {
                $tableBody.scrollTop = itemHeight * commandIndex;
            }
            else if (isBelowScrollArea) {
                $tableBody.scrollTop = itemHeight * (commandIndex + 3) - totalHeight;
            }
        });
    },
    gotoLineInMacro: (name) => (macroId, commandIndex) => {
        return createThunkAction((dispatch, getState) => {
            const state = getState();
            const currentMacroId = recomputed_1.getCurrentMacroId(state);
            const saveMacro = macroId === currentMacroId
                ? () => Promise.resolve(true)
                : () => {
                    return save_test_case_1.default({ dispatch, getState }).saveOrNot({
                        cancelText: 'Cancel'
                    });
                };
            const gotoLine = () => {
                return Promise.resolve(dispatch(index_1.editTestCase(macroId)))
                    .then(() => {
                    dispatch(index_1.selectCommand(commandIndex, true));
                    dispatch(exports.Actions.scrollToCommandAtIndex(commandIndex));
                });
            };
            saveMacro().then(success => {
                if (success) {
                    return gotoLine();
                }
            })
                .catch(e => {
                log_1.default.warn(e);
            });
        });
    },
    downloadMacroAsJson: (name) => (macroId) => {
        return createThunkAction((dispatch, getState) => {
            return storage_1.getStorageManager().getMacroStorage().read(macroId, 'Text')
                .then(content => {
                const macro = content;
                const downloadJson = () => {
                    const str = convert_utils_1.toJSONString({ name: macro.name, commands: macro.data.commands }, {
                        ignoreTargetOptions: recomputed_1.getShouldSaveAlternativeLocators(getState())
                    });
                    const blob = new Blob([str], { type: 'text/plain;charset=utf-8' });
                    file_saver_1.default.saveAs(blob, `${macro.name}.json`, true);
                };
                const involveOtherResources = () => {
                    const imageRelatedCommands = macro.data.commands.filter(command => {
                        var _a;
                        return !command_1.canCommandReadImage(command.cmd) ? false : (_a = command_1.parseImageTarget(command.target)) === null || _a === void 0 ? void 0 : _a.fileName;
                    });
                    const csvRelatedCommands = macro.data.commands.filter(cmd => command_1.canCommandReadCsv(cmd.cmd));
                    const macroRelatedCommands = macro.data.commands.filter(cmd => command_1.canCommandRunMacro(cmd.cmd));
                    if (imageRelatedCommands.length === 0 &&
                        csvRelatedCommands.length === 0 &&
                        macroRelatedCommands.length === 0) {
                        return false;
                    }
                    return true;
                };
                if (!involveOtherResources()) {
                    return downloadJson();
                }
                return prompt_1.prompt({
                    width: 400,
                    title: 'Export as zip instead?',
                    message: 'This macro contains images/csv.\nDo you want to use the ZIP export option instead?',
                    noInput: true,
                    closable: false,
                    okText: 'ZIP',
                    cancelText: 'JSON',
                    onCancel: () => {
                        downloadJson();
                        return Promise.resolve(true);
                    },
                    onOk: () => {
                        dispatch(exports.Actions.downloadMacroAsZip(macroId));
                        return Promise.resolve(true);
                    }
                })
                    .then(() => { });
            });
        });
    },
    downloadMacroAsHTML: (name) => (macroId) => {
        return createThunkAction((dispatch, getState) => {
            return storage_1.getStorageManager().getMacroStorage().read(macroId, 'Text')
                .then(content => {
                const macro = content;
                const str = convert_utils_1.toHtml({ name: macro.name, commands: macro.data.commands });
                const blob = new Blob([str], { type: 'text/plain;charset=utf-8' });
                file_saver_1.default.saveAs(blob, `${macro.name}.html`, true);
            });
        });
    },
    downloadMacroAsZip: (name) => (macroId) => {
        return createThunkAction((dispatch, getState) => {
            const zip = new jszip_1.default();
            const warn = (msg) => dispatch(index_1.addLog('warning', msg));
            const imageDict = {};
            const csvDict = {};
            const macroDict = {};
            const bundleMacroIntoZip = (macroId, isSubMacro) => {
                const macroStorage = storage_1.getStorageManager().getMacroStorage();
                const path = macroStorage.getPathLib();
                return macroStorage.read(macroId, 'Text')
                    .then(content => {
                    const macro = content;
                    const macroToSave = ts_utils_1.clone(macro);
                    const imageRelatedCommands = macro.data.commands.filter(cmd => command_1.canCommandReadImage(cmd.cmd));
                    const csvRelatedCommands = macro.data.commands.filter(cmd => command_1.canCommandReadCsv(cmd.cmd));
                    const macroRelatedCommands = [];
                    // Since all macros are saved in the same folder now,
                    // macro paths in `run` commands should be changed accordingly
                    macro.data.commands.forEach((cmd, i) => {
                        if (command_1.canCommandRunMacro(cmd.cmd)) {
                            macroRelatedCommands.push(cmd);
                            macroToSave.data.commands[i].target = path.basename(cmd.target);
                        }
                    });
                    Promise.all([
                        ...imageRelatedCommands.map(command => {
                            var _a;
                            const imageFileName = (_a = command_1.parseImageTarget(command.target)) === null || _a === void 0 ? void 0 : _a.fileName;
                            if (!imageFileName || imageDict[imageFileName]) {
                                return Promise.resolve();
                            }
                            imageDict[imageFileName] = true;
                            return storage_1.getStorageManager().getVisionStorage().read(imageFileName, 'ArrayBuffer')
                                .then(buffer => {
                                zip.file(imageFileName, buffer, { binary: true });
                            })
                                .catch((e) => {
                                warn(`Failed to add ${imageFileName} into zip: ${e.message}`);
                            });
                        }),
                        ...csvRelatedCommands.map(command => {
                            const csvFileName = command.target;
                            if (!csvFileName || csvDict[csvFileName]) {
                                return Promise.resolve();
                            }
                            csvDict[csvFileName] = true;
                            return storage_1.getStorageManager().getCSVStorage().read(csvFileName, 'Text')
                                .then(text => {
                                zip.file(csvFileName, text);
                            })
                                .catch((e) => {
                                warn(`Failed to add ${csvFileName} into zip: ${e.message}`);
                            });
                        }),
                        ...macroRelatedCommands.map(command => {
                            const subMacroRelativePath = ts_utils_1.resolvePath(macroStorage.getPathLib(), macroStorage.relativePath(macroId), command.target);
                            const subMacroNode = recomputed_1.findMacroNodeWithCaseInsensitiveRelativePath(getState(), subMacroRelativePath);
                            const subMacroId = subMacroNode ? subMacroNode.fullPath : subMacroRelativePath;
                            if (macroDict[subMacroId]) {
                                return Promise.resolve();
                            }
                            return bundleMacroIntoZip(subMacroId, true);
                        })
                    ])
                        .then(() => {
                        zip.file(macroToSave.name + '.json', convert_utils_1.toJSONString({ name: macroToSave.name, commands: macroToSave.data.commands }));
                        if (isSubMacro) {
                            return;
                        }
                        return zip.generateAsync({ type: 'blob' })
                            .then((blob) => file_saver_1.default.saveAs(blob, `${macroToSave.name}.zip`));
                    });
                });
            };
            return bundleMacroIntoZip(macroId)
                .catch((e) => {
                warn(`Failed to save zip file: ${e.message}`);
            });
        });
    },
    readFilesAndImportTestCases: (name) => (params) => {
        const { type, process, folder, files: rawFiles } = params;
        return createThunkAction((dispatch, getState) => {
            const files = Array.from(rawFiles);
            if (!files || !files.length) {
                return;
            }
            const read = (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        var _a;
                        const content = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;
                        new Promise(resolve => resolve(process(content, file.name, file)))
                            .then(result => {
                            if (!result || !result.macros.length) {
                                return resolve({
                                    err: new Error('Failed to parse macro'),
                                    fileName: file.name
                                });
                            }
                            const { macros, images = [], csvs = [] } = result;
                            resolve({
                                data: { macros, images, csvs }
                            });
                        })
                            .catch((e) => {
                            resolve({ err: e, fileName: file.name });
                        });
                    };
                    switch (type) {
                        case 'text':
                            return reader.readAsText(file);
                        case 'data_url':
                            return reader.readAsDataURL(file);
                        case 'binary_string':
                            return reader.readAsBinaryString(file);
                        case 'array_buffer':
                            return reader.readAsArrayBuffer(file);
                    }
                });
            };
            const saveResource = (storage, fileName, type, content) => {
                const blob = type === 'text' ? new Blob([content]) : content;
                return storage.fileExists(fileName)
                    .then(exists => {
                    if (exists) {
                        return { error: `${fileName} already exists` };
                    }
                    return storage.write(fileName, blob)
                        .then(() => ({ fileName }))
                        .catch((e) => ({ error: `Failed to save ${fileName}: ${e.message}` }));
                });
            };
            const saveAllForMacro = (item) => {
                return Promise.all([
                    Promise.all(item.csvs.map(csv => {
                        return saveResource(storage_1.getStorageManager().getCSVStorage(), csv.fileName, 'text', csv.content);
                    })),
                    Promise.all(item.images.map(csv => {
                        return saveResource(storage_1.getStorageManager().getVisionStorage(), csv.fileName, 'blob', csv.content);
                    }))
                ])
                    .then((tuple) => {
                    const [csvResult, pngResult] = tuple;
                    return Promise.resolve({
                        macros: item.macros,
                        csvImported: csvResult.filter(x => x.fileName).map(x => x.fileName),
                        pngImported: pngResult.filter(x => x.fileName).map(x => x.fileName),
                        errors: [
                            ...csvResult.filter(x => x.error).map(x => x.error),
                            ...pngResult.filter(x => x.error).map(x => x.error)
                        ]
                    });
                });
            };
            Promise.all(files.map(read))
                .then(list => {
                const doneList = list.filter(x => x.data);
                const failList = list.filter(x => x.err);
                return Promise.all(doneList.map(item => saveAllForMacro(item.data)))
                    .then(saveResourceResults => {
                    return dispatch(index_1.addTestCases({
                        folder,
                        macros: ts_utils_1.flatten(doneList.map(x => x.data.macros))
                    }))
                        .then(({ passCount, failCount, failTcs }) => {
                        antd_1.message.info([
                            `${passCount} macro${passCount > 1 ? 's' : ''} imported!`,
                            `${failList.length + failCount} macro${(failList.length + failCount) > 1 ? 's' : ''} failed!`
                        ].join(', '), 3);
                        failList.forEach(fail => {
                            dispatch(index_1.addLog('error', `in parsing ${fail.fileName}: ${fail.err.message}`));
                        });
                        failTcs.forEach((fail) => {
                            dispatch(index_1.addLog('error', `duplicated macro name: ${fail.name}`, {
                                noStack: true
                            }));
                        });
                        const allCsvs = ts_utils_1.flatten(saveResourceResults.map(item => item.csvImported));
                        const allPngs = ts_utils_1.flatten(saveResourceResults.map(item => item.pngImported));
                        const allErrors = ts_utils_1.flatten(saveResourceResults.map(item => item.errors));
                        const allMacroNames = ts_utils_1.flatten(saveResourceResults.map(item => item.macros))
                            .filter(item => !failTcs.find((fail) => fail.name == item.name))
                            .map(item => item.name);
                        if (allMacroNames.length > 0) {
                            dispatch(index_1.addLog('info', `${allMacroNames.length} ${allMacroNames.length > 1 ? 'macros' : 'macro'} imported:\n${allMacroNames.join('\n')}`));
                        }
                        if (allCsvs.length > 0) {
                            dispatch(index_1.addLog('info', `${allCsvs.length} CSV imported:\n${allCsvs.join('\n')}`));
                            dispatch(index_1.listCSV());
                        }
                        if (allPngs.length > 0) {
                            dispatch(index_1.addLog('info', `${allPngs.length} PNG imported:\n${allPngs.join('\n')}`));
                            dispatch(index_1.listVisions());
                        }
                        if (allErrors.length > 0) {
                            dispatch(index_1.addLog('error', `${allErrors.length} ${allErrors.length > 1 ? 'errors' : 'error'} in importing csv/png:\n${allErrors.join('\n')}`));
                        }
                    });
                })
                    .catch(e => {
                    dispatch(index_1.addLog('error', e.message, {
                        noStack: true
                    }));
                });
            });
        });
    },
    importMacroHtml: (name) => (files, folder) => {
        return createThunkAction((dispatch, getState) => {
            const process = (content, fileName) => ({
                macros: [convert_utils_1.fromHtml(content)],
                csvs: [],
                images: []
            });
            dispatch(exports.Actions.readFilesAndImportTestCases({
                folder,
                files,
                process,
                type: 'text'
            }));
        });
    },
    importMacroJsonOrZipFiles: (name) => (files, folder) => {
        return createThunkAction((dispatch, getState) => {
            const process = (content, fileName, file) => {
                if (/.json$/i.test(fileName)) {
                    const str = utils_1.arrayBufferToString(content);
                    return Promise.resolve({
                        macros: [convert_utils_1.fromJSONString(str, fileName)],
                        csvs: [],
                        images: []
                    });
                }
                return jszip_1.default.loadAsync(content)
                    .then(zip => {
                    const pJsonList = [];
                    const pCsvList = [];
                    const pPngList = [];
                    zip.forEach((relativePath, file) => {
                        const extName = ts_utils_1.getExtName(relativePath).toLowerCase();
                        switch (extName) {
                            case '.csv':
                                pCsvList.push(file.async('text').then(content => ({ content, fileName: relativePath })));
                                break;
                            case '.png':
                                pPngList.push(file.async('blob').then(content => ({ content, fileName: relativePath })));
                                break;
                            case '.json':
                                pJsonList.push(file.async('text').then(content => ({ content, fileName: relativePath })));
                                break;
                        }
                    });
                    if (pJsonList.length === 0) {
                        throw new Error('No json file found in zip');
                    }
                    return Promise.all([
                        Promise.all(pJsonList),
                        Promise.all(pCsvList),
                        Promise.all(pPngList)
                    ])
                        .then(triple => {
                        const macros = triple[0].map(obj => convert_utils_1.fromJSONString(obj.content, obj.fileName));
                        return {
                            macros,
                            csvs: triple[1],
                            images: triple[2]
                        };
                    });
                });
            };
            dispatch(exports.Actions.readFilesAndImportTestCases({
                files,
                folder,
                process,
                type: 'array_buffer'
            }));
        });
    }
};
exports.ActionTypes = ts_utils_1.objMap((_, key) => key, exports.ActionFactories);
exports.Actions = ts_utils_1.objMap((factory, key, i) => {
    return factory(exports.ActionTypes[key]);
}, exports.ActionFactories);
function createAction(type, data) {
    return {
        type,
        data
    };
}
exports.createAction = createAction;
function createThunkAction(thunk) {
    return thunk;
}
exports.createThunkAction = createThunkAction;


/***/ }),

/***/ 42:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ComputerVisionType;
(function (ComputerVisionType) {
    ComputerVisionType["Browser"] = "browser";
    ComputerVisionType["Desktop"] = "desktop";
    ComputerVisionType["DesktopScreenCapture"] = "desktop_screen_capture";
})(ComputerVisionType = exports.ComputerVisionType || (exports.ComputerVisionType = {}));
function isCVTypeForDesktop(type) {
    return type === ComputerVisionType.Desktop || type === ComputerVisionType.DesktopScreenCapture;
}
exports.isCVTypeForDesktop = isCVTypeForDesktop;


/***/ }),

/***/ 43:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.availableCommands = (() => {
    const list = [
        'open',
        'click',
        'clickAndWait',
        'select',
        'selectAndWait',
        'addSelection',
        'removeSelection',
        'type',
        'pause',
        'waitForPageToLoad',
        'selectFrame',
        'assertAlert',
        'assertConfirmation',
        'assertPrompt',
        'answerOnNextPrompt',
        'store',
        'storeText',
        'storeTitle',
        'storeAttribute',
        'storeXpathCount',
        'assertText',
        'assertTitle',
        'clickAt',
        'echo',
        'mouseOver',
        // 'storeEval',
        'verifyText',
        'verifyTitle',
        'sendKeys',
        'dragAndDropToObject',
        'selectWindow',
        'captureScreenshot',
        'captureDesktopScreenshot',
        'refresh',
        'assert',
        'assertElementPresent',
        'assertElementNotPresent',
        'assertEditable',
        'assertNotEditable',
        'verify',
        'verifyElementPresent',
        'verifyElementNotPresent',
        'verifyEditable',
        'verifyNotEditable',
        'deleteAllCookies',
        'label',
        'gotoLabel',
        //'gotoIf',
        'csvRead',
        'csvReadArray',
        'csvSave',
        'csvSaveArray',
        'storeValue',
        'assertValue',
        'verifyValue',
        'storeChecked',
        'captureEntirePageScreenshot',
        'onDownload',
        // 'assertError',
        // 'verifyError',
        'throwError',
        'comment',
        // 'waitForVisible',
        'waitForElementVisible',
        'waitForElementNotVisible',
        'waitForElementPresent',
        'waitForElementNotPresent',
        'onError',
        'sourceSearch',
        'sourceExtract',
        'storeImage',
        'localStorageExport',
        // 'visionFind',
        'visionLimitSearchArea',
        'visionLimitSearchAreaRelative',
        'visualSearch',
        'visualVerify',
        'visualAssert',
        'visualGetPixelColor',
        'editContent',
        'bringBrowserToForeground',
        'bringIDEandBrowserToBackground',
        //'resize',
        'setWindowSize',
        'prompt',
        'XRun',
        'XRunAndWait',
        'XClick',
        'XClickRelative',
        'XType',
        'XMove',
        'XMoveRelative',
        'XMouseWheel',
        'XDesktopAutomation',
        'OCRSearch',
        'OCRExtract',
        'OCRExtractRelative',
        'setProxy',
        'run',
        'executeScript',
        'executeScript_Sandbox',
        //  'executeAsyncScript',
        //  'executeAsyncScript_Sandbox',
        'check',
        'uncheck',
        'assertChecked',
        'assertNotChecked',
        'verifyChecked',
        'verifyNotChecked',
        //'while',
        // 'endWhile',
        'do',
        'repeatIf',
        //'if',
        'else',
        'elseif',
        // 'endif',
        'end',
        'if_v2',
        'while_v2',
        'gotoIf_v2',
        'times',
        'forEach',
        'break',
        'continue'
    ];
    list.sort((a, b) => a.toLowerCase() < b.toLowerCase() ? -1 : 1);
    return list;
})();
function normalizeCommandName(str) {
    if (!str) {
        return '';
    }
    const lower = str.toLowerCase();
    const lowerCommands = exports.availableCommands.map(str => str.toLowerCase());
    const index = lowerCommands.findIndex(cmd => cmd === lower);
    return index === -1 ? str : exports.availableCommands[index];
}
exports.normalizeCommandName = normalizeCommandName;
function commandText(cmd) {
    switch (cmd) {
        case 'if':
        case 'while':
        case 'gotoIf':
            return cmd + '_v1_deprecated';
        case 'storeEval':
        case 'endif':
        case 'endwhile':
        case 'resize':
            return cmd + '_deprecated';
        default:
            return cmd;
    }
}
exports.commandText = commandText;
function isValidCmd(str) {
    return exports.availableCommands.indexOf(str) !== -1;
}
exports.isValidCmd = isValidCmd;
function isExtensionResourceOnlyCommand(str) {
    switch (str) {
        case 'if':
        case 'while':
        case 'gotoIf':
        case 'if_v2':
        case 'while_v2':
        case 'gotoIf_v2':
        case 'executeScript_Sandbox':
        case 'run':
        case 'store':
        case 'echo':
        case 'prompt':
        case 'throwError':
        case 'pause':
        case 'localStorageExport':
            return true;
        default:
            return false;
    }
}
exports.isExtensionResourceOnlyCommand = isExtensionResourceOnlyCommand;
function canCommandReadImage(str) {
    switch (str) {
        case 'visualSearch':
        case 'visualVerify':
        case 'visualAssert':
        case 'XClick':
        case 'XClickRelative':
        case 'XMove':
        case 'XMoveRelative':
        case 'OCRExtract':
        case 'OCRExtractRelative':
            return true;
        default:
            return false;
    }
}
exports.canCommandReadImage = canCommandReadImage;
function canCommandReadCsv(str) {
    switch (str) {
        case 'csvRead':
        case 'csvReadArray':
            return true;
        default:
            return false;
    }
}
exports.canCommandReadCsv = canCommandReadCsv;
function canCommandRunMacro(str) {
    switch (str) {
        case 'run':
            return true;
        default:
            return false;
    }
}
exports.canCommandRunMacro = canCommandRunMacro;
function doesCommandSupportTargetOptions(str) {
    switch (str) {
        case 'click':
        case 'clickAndWait':
        case 'select':
        case 'selectAndWait':
        case 'type':
        case 'mouseOver':
        case 'verifyText':
        case 'sendKeys':
        case 'dragAndDropToObject':
        case 'assertElementPresent':
        case 'assertEditable':
        case 'assertNotEditable':
        case 'verifyElementPresent':
        case 'verifyEditable':
        case 'verifyNotEditable':
        case 'storeValue':
        case 'assertValue':
        case 'verifyValue':
        case 'storeChecked':
        case 'waitForElementVisible':
        case 'waitForElementPresent':
        case 'XClick':
        case 'XClickRelative':
        case 'XMove':
        case 'XMoveRelative':
        case 'check':
        case 'uncheck':
        case 'assertChecked':
        case 'assertNotChecked':
        case 'verifyChecked':
        case 'verifyNotChecked':
            return true;
        default:
            return false;
    }
}
exports.doesCommandSupportTargetOptions = doesCommandSupportTargetOptions;
function canCommandFind(str) {
    switch (str) {
        case 'echo':
        case 'open':
        case 'pause':
        case 'waitForPageToLoad':
        case 'assertAlert':
        case 'assertConfirmation':
        case 'assertPrompt':
        case 'answerOnNextPrompt':
        case 'store':
        case 'storeTitle':
        case 'assertTitle':
        case 'verifyTitle':
        case 'selectWindow':
        case 'captureScreenshot':
        case 'captureDesktopScreenshot':
        case 'refresh':
        case 'deleteAllCookies':
        case 'label':
        case 'gotoLabel':
        case 'csvRead':
        case 'csvReadArray':
        case 'csvSave':
        case 'csvSaveArray':
        case 'captureEntirePageScreenshot':
        case 'onDownload':
        case 'throwError':
        case 'comment':
        case 'onError':
        case 'sourceSearch':
        case 'sourceExtract':
        case 'localStorageExport':
        case 'visionLimitSearchArea':
        case 'visionLimitSearchAreaRelative':
        case 'visualGetPixelColor':
        case 'bringBrowserToForeground':
        case 'bringIDEandBrowserToBackground':
        case 'setWindowSize':
        case 'prompt':
        case 'XRun':
        case 'XRunAndWait':
        case 'XDesktopAutomation':
        case 'setProxy':
        case 'run':
        case 'executeScript':
        case 'executeScript_Sandbox':
        case 'do':
        case 'repeatIf':
        case 'else':
        case 'elseif':
        case 'end':
        case 'if_v2':
        case 'while_v2':
        case 'gotoIf_v2':
        case 'times':
        case 'forEach':
            return false;
        default:
            return true;
    }
}
exports.canCommandFind = canCommandFind;
function canCommandSelect(str) {
    const canFind = canCommandFind(str);
    if (canFind) {
        return canFind;
    }
    switch (str) {
        case 'visualGetPixelColor':
            return true;
        default:
            return false;
    }
}
exports.canCommandSelect = canCommandSelect;
function indentCreatedByCommand(str) {
    switch (str) {
        case 'if':
        case 'if_v2':
        case 'while':
        case 'while_v2':
        case 'do':
        case 'times':
        case 'forEach':
            return {
                selfIndent: 0,
                nextIndent: 1
            };
        case 'else':
        case 'elseif':
            return {
                selfIndent: -1,
                nextIndent: 1
            };
        case 'end':
        case 'endif':
        case 'endwhile':
        case 'repeatIf':
            return {
                selfIndent: -1,
                nextIndent: 0
            };
        default:
            return {
                selfIndent: 0,
                nextIndent: 0
            };
    }
}
exports.indentCreatedByCommand = indentCreatedByCommand;
function parseImageTarget(target) {
    if (!target || !target.length) {
        return null;
    }
    const reg = /^([^@#]+?\.png)(?:@([\d.]+))?(?:#(\d+))?(?:\[([^\]]+)\])?$/;
    const m = target.match(reg);
    if (!m) {
        return null;
    }
    // throw new Error(`Target should be like 'abc.png@0.8#1'`)
    const fileName = m[1];
    const confidence = m[2] ? parseFloat(m[2]) : undefined;
    const index = m[3] ? (parseInt(m[3]) - 1) : undefined;
    const imageUrl = m[4];
    return { fileName, confidence, index, imageUrl };
}
exports.parseImageTarget = parseImageTarget;


/***/ }),

/***/ 431:
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 202,
	"./af.js": 202,
	"./ar": 203,
	"./ar-dz": 204,
	"./ar-dz.js": 204,
	"./ar-kw": 205,
	"./ar-kw.js": 205,
	"./ar-ly": 206,
	"./ar-ly.js": 206,
	"./ar-ma": 207,
	"./ar-ma.js": 207,
	"./ar-sa": 208,
	"./ar-sa.js": 208,
	"./ar-tn": 209,
	"./ar-tn.js": 209,
	"./ar.js": 203,
	"./az": 210,
	"./az.js": 210,
	"./be": 211,
	"./be.js": 211,
	"./bg": 212,
	"./bg.js": 212,
	"./bm": 213,
	"./bm.js": 213,
	"./bn": 214,
	"./bn.js": 214,
	"./bo": 215,
	"./bo.js": 215,
	"./br": 216,
	"./br.js": 216,
	"./bs": 217,
	"./bs.js": 217,
	"./ca": 218,
	"./ca.js": 218,
	"./cs": 219,
	"./cs.js": 219,
	"./cv": 220,
	"./cv.js": 220,
	"./cy": 221,
	"./cy.js": 221,
	"./da": 222,
	"./da.js": 222,
	"./de": 223,
	"./de-at": 224,
	"./de-at.js": 224,
	"./de-ch": 225,
	"./de-ch.js": 225,
	"./de.js": 223,
	"./dv": 226,
	"./dv.js": 226,
	"./el": 227,
	"./el.js": 227,
	"./en-au": 228,
	"./en-au.js": 228,
	"./en-ca": 229,
	"./en-ca.js": 229,
	"./en-gb": 230,
	"./en-gb.js": 230,
	"./en-ie": 231,
	"./en-ie.js": 231,
	"./en-nz": 232,
	"./en-nz.js": 232,
	"./eo": 233,
	"./eo.js": 233,
	"./es": 234,
	"./es-do": 235,
	"./es-do.js": 235,
	"./es-us": 236,
	"./es-us.js": 236,
	"./es.js": 234,
	"./et": 237,
	"./et.js": 237,
	"./eu": 238,
	"./eu.js": 238,
	"./fa": 239,
	"./fa.js": 239,
	"./fi": 240,
	"./fi.js": 240,
	"./fo": 241,
	"./fo.js": 241,
	"./fr": 242,
	"./fr-ca": 243,
	"./fr-ca.js": 243,
	"./fr-ch": 244,
	"./fr-ch.js": 244,
	"./fr.js": 242,
	"./fy": 245,
	"./fy.js": 245,
	"./gd": 246,
	"./gd.js": 246,
	"./gl": 247,
	"./gl.js": 247,
	"./gom-latn": 248,
	"./gom-latn.js": 248,
	"./gu": 249,
	"./gu.js": 249,
	"./he": 250,
	"./he.js": 250,
	"./hi": 251,
	"./hi.js": 251,
	"./hr": 252,
	"./hr.js": 252,
	"./hu": 253,
	"./hu.js": 253,
	"./hy-am": 254,
	"./hy-am.js": 254,
	"./id": 255,
	"./id.js": 255,
	"./is": 256,
	"./is.js": 256,
	"./it": 257,
	"./it.js": 257,
	"./ja": 258,
	"./ja.js": 258,
	"./jv": 259,
	"./jv.js": 259,
	"./ka": 260,
	"./ka.js": 260,
	"./kk": 261,
	"./kk.js": 261,
	"./km": 262,
	"./km.js": 262,
	"./kn": 263,
	"./kn.js": 263,
	"./ko": 264,
	"./ko.js": 264,
	"./ky": 265,
	"./ky.js": 265,
	"./lb": 266,
	"./lb.js": 266,
	"./lo": 267,
	"./lo.js": 267,
	"./lt": 268,
	"./lt.js": 268,
	"./lv": 269,
	"./lv.js": 269,
	"./me": 270,
	"./me.js": 270,
	"./mi": 271,
	"./mi.js": 271,
	"./mk": 272,
	"./mk.js": 272,
	"./ml": 273,
	"./ml.js": 273,
	"./mr": 274,
	"./mr.js": 274,
	"./ms": 275,
	"./ms-my": 276,
	"./ms-my.js": 276,
	"./ms.js": 275,
	"./mt": 277,
	"./mt.js": 277,
	"./my": 278,
	"./my.js": 278,
	"./nb": 279,
	"./nb.js": 279,
	"./ne": 280,
	"./ne.js": 280,
	"./nl": 281,
	"./nl-be": 282,
	"./nl-be.js": 282,
	"./nl.js": 281,
	"./nn": 283,
	"./nn.js": 283,
	"./pa-in": 284,
	"./pa-in.js": 284,
	"./pl": 285,
	"./pl.js": 285,
	"./pt": 286,
	"./pt-br": 287,
	"./pt-br.js": 287,
	"./pt.js": 286,
	"./ro": 288,
	"./ro.js": 288,
	"./ru": 289,
	"./ru.js": 289,
	"./sd": 290,
	"./sd.js": 290,
	"./se": 291,
	"./se.js": 291,
	"./si": 292,
	"./si.js": 292,
	"./sk": 293,
	"./sk.js": 293,
	"./sl": 294,
	"./sl.js": 294,
	"./sq": 295,
	"./sq.js": 295,
	"./sr": 296,
	"./sr-cyrl": 297,
	"./sr-cyrl.js": 297,
	"./sr.js": 296,
	"./ss": 298,
	"./ss.js": 298,
	"./sv": 299,
	"./sv.js": 299,
	"./sw": 300,
	"./sw.js": 300,
	"./ta": 301,
	"./ta.js": 301,
	"./te": 302,
	"./te.js": 302,
	"./tet": 303,
	"./tet.js": 303,
	"./th": 304,
	"./th.js": 304,
	"./tl-ph": 305,
	"./tl-ph.js": 305,
	"./tlh": 306,
	"./tlh.js": 306,
	"./tr": 307,
	"./tr.js": 307,
	"./tzl": 308,
	"./tzl.js": 308,
	"./tzm": 309,
	"./tzm-latn": 310,
	"./tzm-latn.js": 310,
	"./tzm.js": 309,
	"./uk": 311,
	"./uk.js": 311,
	"./ur": 312,
	"./ur.js": 312,
	"./uz": 313,
	"./uz-latn": 314,
	"./uz-latn.js": 314,
	"./uz.js": 313,
	"./vi": 315,
	"./vi.js": 315,
	"./x-pseudo": 316,
	"./x-pseudo.js": 316,
	"./yo": 317,
	"./yo.js": 317,
	"./zh-cn": 169,
	"./zh-cn.js": 169,
	"./zh-hk": 318,
	"./zh-hk.js": 318,
	"./zh-tw": 319,
	"./zh-tw.js": 319
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 431;

/***/ }),

/***/ 482:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 49:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_log__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _command_runner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(100);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };




/*
 * Basic tool function
 */

var extend = function extend() {
  var args = Array.from(arguments);
  var len = args.length;

  if (len <= 0) return {};
  if (len === 1) return args[0];

  var head = args[0];
  var rest = args.slice(1);

  return rest.reduce(function (prev, cur) {
    for (var i = 0, keys = Object.keys(cur), len = keys.length; i < len; i++) {
      prev[keys[i]] = cur[keys[i]];
    }

    return prev;
  }, head);
};

var isArray = Array.isArray;

var id = function id(x) {
  return x;
};

var trim = function trim(str) {
  return str.replace(/^\s*|\s*$/g, '');
};

var flatten = function flatten(list) {
  return [].concat.apply([], list);
};

var sum = function sum() {
  var list = Array.from(arguments);
  return list.reduce(function (prev, cur) {
    return prev + cur;
  }, 0);
};

var last = function last(list) {
  return list[list.length - 1];
};

var or = function or(list) {
  return (list || []).reduce(function (prev, cur) {
    return prev || cur;
  }, false);
};

var and = function and(list) {
  return (list || []).reduce(function (prev, cur) {
    return prev && cur;
  }, true);
};

var zipWith = function zipWith(fn) {
  if (arguments.length < 3) return null;

  var list = Array.from(arguments).slice(1);
  var len = list.reduce(function (min, cur) {
    return cur.length < min ? cur.length : min;
  }, Infinity);
  var ret = [];

  for (var i = 0; i < len; i++) {
    ret.push(fn.apply(null, list.map(function (item) {
      return item[i];
    })));
  }

  return ret;
};

var intersect = function intersect() {
  var list = Array.from(arguments);
  var len = Math.max.apply(null, list.map(function (item) {
    return item.length;
  }));
  var result = [];

  for (var i = 0; i < len; i++) {
    var val = list[0][i];
    var no = list.filter(function (item) {
      return item[i] !== val;
    });

    if (no && no.length) break;

    result.push(val);
  }

  return result;
};

var deepEqual = function deepEqual(a, b) {
  if (isArray(a) && isArray(b)) {
    return a.length === b.length && and(zipWith(deepEqual, a, b));
  }

  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object' && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object') {
    // TODO
    return false;
  }

  return a === b;
};

/*
 * Dom helper function
 */

var pixel = function pixel(num) {
  if ((num + '').indexOf('px') !== -1) return num;
  return (num || 0) + 'px';
};

var getStyle = function getStyle(dom, styleName) {
  if (!dom) throw new Error('getStyle: dom does not exist');
  return getComputedStyle(dom)[styleName];
};

var setStyle = function setStyle(dom, style) {
  if (!dom) throw new Error('setStyle: dom does not exist');

  for (var i = 0, keys = Object.keys(style), len = keys.length; i < len; i++) {
    dom.style[keys[i]] = style[keys[i]];
  }

  return dom;
};

var cssSum = function cssSum(dom, list) {
  var isInline = getStyle(dom, 'display') === 'inline';

  return list.reduce(function (prev, cur) {
    var val = isInline && ['width', 'height'].indexOf(cur) !== -1 ? dom.getClientRects()[0][cur] : getStyle(dom, cur);

    return prev + parseInt(val || '0', 10);
  }, 0);
};

var offset = function offset(dom, noPx) {
  if (!dom) return { left: 0, top: 0 };

  var rect = dom.getBoundingClientRect();
  var fn = noPx ? id : pixel;

  return {
    left: fn(rect.left + window.scrollX),
    top: fn(rect.top + window.scrollY)
  };
};

var rect = function rect(dom, noPx) {
  var pos = offset(dom, noPx);
  var isInline = getStyle(dom, 'display') === 'inline';
  var w = isInline ? dom.getClientRects()[0]['width'] : getStyle(dom, 'width');
  var h = isInline ? dom.getClientRects()[0]['height'] : getStyle(dom, 'height');
  var fn = noPx ? id : pixel;

  return extend({ width: fn(w), height: fn(h) }, pos);
};

// Reference: http://ryanve.com/lab/dimensions/
var clientWidth = function clientWidth(document) {
  return document.documentElement.clientWidth;
};

var clientHeight = function clientHeight(document) {
  return document.documentElement.clientHeight;
};

var removeChildren = function removeChildren(dom, predicate) {
  var pred = predicate || function () {
    return true;
  };
  var children = dom.childNodes;

  for (var i = children.length - 1; i >= 0; i--) {
    if (pred(children[i])) {
      dom.removeChild(children[i]);
    }
  }
};

var inDom = function inDom($outer, $el) {
  if (!$el) return false;
  if ($outer === $el) return true;
  return inDom($outer, $el.parentNode);
};

var inDomList = function inDomList(list, $el) {
  return or(list.map(function ($outer) {
    return inDom($outer, $el);
  }));
};

var parentWithTag = function parentWithTag(tag, $el) {
  var lowerTag = tag.toLowerCase();
  var $dom = $el;

  while ($dom) {
    if ($dom.tagName.toLowerCase() === lowerTag) {
      return $dom;
    }

    $dom = $dom.parentNode;
  }

  return null;
};

var parentWithClass = function parentWithClass(className, $el) {
  var $dom = $el;

  while ($dom) {
    // Note: In Firefox, HTML Document object doesn't have `classList` property
    if ($dom.classList !== undefined && $dom.classList.contains(className)) {
      return $dom;
    }

    $dom = $dom.parentNode;
  }

  return null;
};

var selector = function selector(dom) {
  if (dom.nodeType !== 1) return '';
  if (dom.tagName === 'BODY') return 'body';
  if (dom.id) return '#' + dom.id;

  var classes = (dom.getAttribute('class') || '').split(/\s+/g).filter(function (item) {
    return item && item.length;
  });

  var children = Array.from(dom.parentNode.childNodes).filter(function ($el) {
    return $el.nodeType === 1;
  });

  var sameTag = children.filter(function ($el) {
    return $el.tagName === dom.tagName;
  });

  var sameClass = children.filter(function ($el) {
    var cs = ($el.getAttribute('class') || '').split(/\s+/g);

    return and(classes.map(function (c) {
      return cs.indexOf(c) !== -1;
    }));
  });

  var extra = '';

  if (sameTag.length === 1) {
    extra = '';
  } else if (classes.length && sameClass.length === 1) {
    extra = '.' + classes.join('.');
  } else {
    extra = ':nth-child(' + (1 + children.findIndex(function (item) {
      return item === dom;
    })) + ')';
  }

  var me = dom.tagName.toLowerCase() + extra;

  // Note: browser will add an extra 'tbody' when tr directly in table, which will cause an wrong selector,
  // so the hack is to remove all tbody here
  var ret = selector(dom.parentNode) + ' > ' + me;
  return ret;
  // return ret.replace(/\s*>\s*tbody\s*>?/g, ' ')
};

var getTagIndex = function getTagIndex(dom) {
  return Array.from(dom.parentNode.childNodes).filter(function (item) {
    return item.nodeType === dom.nodeType && item.tagName === dom.tagName;
  }).reduce(function (prev, node, i) {
    if (prev !== null) return prev;
    return node === dom ? i + 1 : prev;
  }, null);
};

var relativeXPath = function relativeXPath(dom) {
  if (!dom) return null;
  if (dom.nodeType === 3) return '@text';

  var index = getTagIndex(dom);
  var count = Array.from(dom.parentNode.childNodes).filter(function (item) {
    return item.nodeType === dom.nodeType && item.tagName === dom.tagName;
  }).length;
  var tag = dom.tagName.toLowerCase();

  return index > 1 ? tag + '[' + index + ']' : tag;
};

var xpath = function xpath(dom, cur, list) {
  var helper = function helper(dom, cur, list) {
    if (!dom) return null;

    if (!cur) {
      if (dom.nodeType === 3) {
        return helper(dom.parentNode);
      } else {
        return helper(dom, dom, []);
      }
    }

    if (!cur.parentNode) {
      return ['html'].concat(list);
    }

    if (cur.tagName === 'BODY') {
      return ['html', 'body'].concat(list);
    }

    if (cur.id) {
      return ['*[@id="' + cur.id + '"]'].concat(list);
    }

    return helper(dom, cur.parentNode, [relativeXPath(cur)].concat(list));
  };

  var parts = helper(dom, cur, list);
  var prefix = parts[0] === 'html' ? '/' : '//';
  var ret = prefix + parts.join('/');

  return ret;
};

var xpathPosition = function xpathPosition(dom) {
  var path = '';
  var current = dom;

  try {
    while (current !== null) {
      var currentPath = void 0;

      if (current.parentNode != null) {
        currentPath = '/' + relativeXPath(current);
      } else if (current.tagName === 'BODY') {
        currentPath = 'html/body';
      } else {
        currentPath = '/' + current.nodeName.toLowerCase();
      }

      path = currentPath + path;
      var locator = '/' + path;

      if (dom === Object(_command_runner__WEBPACK_IMPORTED_MODULE_1__[/* getElementByXPath */ "b"])(locator)) {
        return locator;
      }

      current = current.parentNode;
    }
  } catch (e) {}

  return null;
};

var attributeValue = function attributeValue(value) {
  if (value.indexOf("'") < 0) {
    return "'" + value + "'";
  } else if (value.indexOf('"') < 0) {
    return '"' + value + '"';
  } else {
    var result = 'concat(';
    var part = '';
    var didReachEndOfValue = false;
    while (!didReachEndOfValue) {
      var apos = value.indexOf("'");
      var quot = value.indexOf('"');
      if (apos < 0) {
        result += "'" + value + "'";
        didReachEndOfValue = true;
        break;
      } else if (quot < 0) {
        result += '"' + value + '"';
        didReachEndOfValue = true;
        break;
      } else if (quot < apos) {
        part = value.substring(0, apos);
        result += "'" + part + "'";
        value = value.substring(part.length);
      } else {
        part = value.substring(0, quot);
        result += '"' + part + '"';
        value = value.substring(part.length);
      }
      result += ',';
    }
    result += ')';
    return result;
  }
};

var xpathAttr = function xpathAttr(dom) {
  function attributesXPath(name, attNames, attributes) {
    var locator = '//' + name + '[';
    for (var i = 0; i < attNames.length; i++) {
      if (i > 0) {
        locator += ' and ';
      }
      var attName = attNames[i];
      locator += '@' + attName + '=' + attributeValue(attributes[attName]);
    }
    locator += ']';
    return locator;
  }

  try {
    var PREFERRED_ATTRIBUTES = ['id', 'name', 'value', 'type', 'action', 'onclick'];
    var i = 0;

    if (dom.attributes) {
      var atts = dom.attributes;
      var attsMap = {};
      for (i = 0; i < atts.length; i++) {
        var att = atts[i];
        attsMap[att.name] = att.value;
      }
      var names = [];
      // try preferred attributes
      for (i = 0; i < PREFERRED_ATTRIBUTES.length; i++) {
        var name = PREFERRED_ATTRIBUTES[i];

        if (attsMap[name] != null) {
          names.push(name);

          var locator = attributesXPath(dom.nodeName.toLowerCase(), names, attsMap);

          if (dom === Object(_command_runner__WEBPACK_IMPORTED_MODULE_1__[/* getElementByXPath */ "b"])(locator)) {
            return locator;
          }
        }
      }
    }
  } catch (e) {}

  return null;
};

var atXPath = function atXPath(xpath, document) {
  var lower = function lower(str) {
    return str && str.toLowerCase();
  };
  var reg = /^([a-zA-Z0-9]+)(\[(\d+)\])?$/;

  return xpath.reduce(function (prev, cur) {
    if (!prev) return prev;
    if (!prev.childNodes || !prev.childNodes.length) return null;

    var match = cur.match(reg);
    var tag = match[1];
    var index = match[3] ? parseInt(match[3], 10) : 1;
    var list = Array.from(prev.childNodes).filter(function (item) {
      return item.nodeType === 1 && lower(item.tagName) === lower(tag);
    });

    return list[index - 1];
  }, document);
};

var domText = function domText($dom) {
  var it = $dom.innerText && $dom.innerText.trim();
  var tc = $dom.textContent;
  var pos = tc.toUpperCase().indexOf(it.toUpperCase());

  return tc.substr(pos, it.length);
};

var getFirstWorkingLocator = function getFirstWorkingLocator(locators, $el) {
  var _loop = function _loop(i, len) {
    var $match = function () {
      try {
        return Object(_command_runner__WEBPACK_IMPORTED_MODULE_1__[/* getElementByLocator */ "a"])(locators[i]);
      } catch (e) {
        return null;
      }
    }();

    if ($el === $match) {
      return {
        v: locators[i]
      };
    }
  };

  for (var i = 0, len = locators.length; i < len; i++) {
    var _ret = _loop(i, len);

    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
  }

  return null;
};

// Note: get the locator of a DOM
var getLocator = function getLocator($dom, withAllOptions) {
  var id = $dom.getAttribute('id');
  var name = $dom.getAttribute('name');
  var isLink = $dom.tagName.toLowerCase() === 'a';
  var text = function () {
    try {
      return domText($dom);
    } catch (e) {
      return null;
    }
  }();
  var classes = Array.from($dom.classList);
  var candidates = [];

  // link
  if (isLink && text && text.length) {
    var links = [].slice.call(document.getElementsByTagName('a'));
    var matches = links.filter(function ($el) {
      return domText($el) === text;
    });
    var index = matches.findIndex(function ($el) {
      return $el === $dom;
    });

    if (index !== -1) {
      candidates.push(index === 0 ? 'linkText=' + text : 'linkText=' + text + '@POS=' + (index + 1));
    }
  }

  // id
  if (id && id.length) {
    candidates.push('id=' + id);
  }

  // name
  if (name && name.length) {
    candidates.push('name=' + name);
  }

  // xpath
  candidates.push('xpath=' + xpath($dom));

  var attrXPath = xpathAttr($dom);

  if (attrXPath) {
    candidates.push('xpath=' + attrXPath);
  }

  var positionXPath = xpathPosition($dom);

  if (positionXPath) {
    candidates.push('xpath=' + positionXPath);
  }

  // css
  // Try with simple css selector first. If not unqiue, use full css selector
  /**
   * Below is the old logic with a shorter css selector
   *
    let sel = null
    if (classes.length > 0) {
    sel = $dom.tagName.toLowerCase() + classes.map(c => '.' + c).join('')
      if ($dom !== document.querySelectorAll(sel)[0]) {
      sel = null
    }
  }
    if (!sel) {
    sel = selector($dom)
  }
  */
  candidates.push('css=' + selector($dom));

  // Get the first one working
  var chosen = getFirstWorkingLocator(candidates, $dom);

  if (withAllOptions) {
    return {
      target: chosen,
      targetOptions: candidates
    };
  }

  return chosen;
};

var checkIframe = function checkIframe(iframeWin) {
  var key = new Date() * 1 + '' + Math.random();

  try {
    iframeWin[key] = 'asd';
    return iframeWin[key] === 'asd';
  } catch (e) {
    return false;
  }
};

// Note: get the locator for frame
var getFrameLocator = function getFrameLocator(frameWin, win) {
  if (checkIframe(frameWin)) {
    var frameDom = frameWin.frameElement;
    var locator = getLocator(frameDom);

    if (/^id=/.test(locator) || /^name=/.test(locator)) {
      return locator;
    }
  }

  for (var i = 0, len = win.frames.length; i < len; i++) {
    if (win.frames[i] === frameWin) {
      return 'index=' + i;
    }
  }

  throw new Error('Frame locator not found');
};

/*
 * Mask related
 */

var maskFactory = function maskFactory() {
  var cache = [];
  var prefix = '__mask__' + new Date() * 1 + Math.round(Math.random() * 1000) + '__';
  var uid = 1;
  var defaultStyle = {
    position: 'absolute',
    zIndex: '999',
    display: 'none',
    boxSizing: 'border-box',
    backgroundColor: 'red',
    opacity: 0.5,
    pointerEvents: 'none'
  };

  var genMask = function genMask(style, dom) {
    var mask = document.createElement('div');

    if (dom) {
      style = extend({}, defaultStyle, style || {}, rect(dom));
    } else {
      style = extend({}, defaultStyle, style || {});
    }

    setStyle(mask, style);
    mask.id = prefix + uid++;
    cache.push(mask);

    return mask;
  };

  var clear = function clear() {
    for (var i = 0, len = cache.length; i < len; i++) {
      var mask = cache[i];

      if (mask && mask.parentNode) {
        mask.parentNode.removeChild(mask);
      }
    }
  };

  return {
    gen: genMask,
    clear: clear
  };
};

var showMaskOver = function showMaskOver(mask, el) {
  var pos = offset(el);
  var w = cssSum(el, ['width', 'paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth']);
  var h = cssSum(el, ['height', 'paddingTop', 'paddingBottom', 'borderTopWidth', ' borderBottomWidth']);

  setStyle(mask, extend(pos, {
    width: pixel(w),
    height: pixel(h),
    display: 'block'
  }));
};

var isVisible = function isVisible(el) {
  if (el === window.document) return true;
  if (!el) return true;

  var style = window.getComputedStyle(el);
  if (style.display === 'none' || style.opacity === '0' || style.visibility === 'hidden') return false;

  return isVisible(el.parentNode);
};

/* harmony default export */ __webpack_exports__["a"] = ({
  offset: offset,
  setStyle: setStyle,
  selector: selector,
  xpath: xpath,
  atXPath: atXPath,
  domText: domText,
  getLocator: getLocator,
  getFrameLocator: getFrameLocator,
  maskFactory: maskFactory,
  showMaskOver: showMaskOver,
  inDom: inDom,
  isVisible: isVisible,
  parentWithTag: parentWithTag,
  parentWithClass: parentWithClass
});

/***/ }),

/***/ 50:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toHtml", function() { return toHtml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateEmptyHtml", function() { return generateEmptyHtml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toHtmlDataUri", function() { return toHtmlDataUri; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromHtml", function() { return fromHtml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromJSONString", function() { return fromJSONString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toJSONString", function() { return toJSONString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toJSONDataUri", function() { return toJSONDataUri; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toBookmarkData", function() { return toBookmarkData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateMacroEntryHtml", function() { return generateMacroEntryHtml; });
/* harmony import */ var error_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(108);
/* harmony import */ var error_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(error_polyfill__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var parse_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66);
/* harmony import */ var parse_json__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(parse_json__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var url_parse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(104);
/* harmony import */ var url_parse__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(url_parse__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _command__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43);
/* harmony import */ var _command__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_command__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _services_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(13);
/* harmony import */ var _services_storage__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_services_storage__WEBPACK_IMPORTED_MODULE_5__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var joinUrl = function joinUrl(base, url) {
  var urlObj = new url_parse__WEBPACK_IMPORTED_MODULE_3___default.a(url, base);
  return urlObj.toString();
};

// HTML template from test case
function genHtml(_ref) {
  var name = _ref.name,
      baseUrl = _ref.baseUrl,
      commandTrs = _ref.commandTrs,
      noImport = _ref.noImport;

  var tableHtml = noImport ? '<h3>Starting Browser and UI.Vision...</h3>' : '\n    <table cellpadding="1" cellspacing="1" border="1">\n    <thead>\n    <tr><td rowspan="1" colspan="3">' + name + '</td></tr>\n    </thead><tbody>\n    ' + commandTrs.join('\n') + '\n    </tbody></table>\n  ';
  var baseLink = noImport ? '' : '<link rel="selenium.base" href="' + baseUrl + '" />';

  return '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">\n<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">\n<head profile="http://selenium-ide.openqa.org/profiles/test-case">\n<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />\n' + baseLink + '\n<title>' + name + '</title>\n</head>\n<body>\n' + tableHtml + '\n<script>\n(function() {\n  var isExtensionLoaded = function () {\n    const $root = document.documentElement\n    return !!$root && !!$root.getAttribute(\'data-kantu\')\n  }\n  var increaseCountInUrl = function (max) {\n    var url   = new URL(window.location.href)\n    var count = 1 + (parseInt(url.searchParams.get(\'reload\') || 0))\n\n    url.searchParams.set(\'reload\', count)\n    var nextUrl = url.toString()\n\n    var shouldStop = count > max\n    return [shouldStop, !shouldStop ? nextUrl : null]\n  }\n  var run = function () {\n    try {\n      var evt = new CustomEvent(\'kantuSaveAndRunMacro\', {\n        detail: {\n          html: document.documentElement.outerHTML,\n          noImport: ' + (noImport || 'false') + ',\n          storageMode: \'' + Object(_services_storage__WEBPACK_IMPORTED_MODULE_5__["getStorageManager"])().getCurrentStrategyType() + '\'\n        }\n      })\n\n      window.dispatchEvent(evt)\n      var intervalTimer = setInterval(() => window.dispatchEvent(evt), 1000);\n\n      if (window.location.protocol === \'file:\') {\n        var onInvokeSuccess = function () {\n          clearTimeout(timer)\n          clearTimeout(reloadTimer)\n          clearInterval(intervalTimer)\n          window.removeEventListener(\'kantuInvokeSuccess\', onInvokeSuccess)\n        }\n        var timer = setTimeout(function () {\n          alert(\'Error #203: It seems you need to turn on *Allow access to file URLs* for Kantu in your browser extension settings.\')\n        }, 8000)\n\n        window.addEventListener(\'kantuInvokeSuccess\', onInvokeSuccess)\n      }\n    } catch (e) {\n      alert(\'Kantu Bookmarklet error: \' + e.toString());\n    }\n  }\n  var reloadTimer = null\n  var main = function () {\n    if (isExtensionLoaded())  return run()\n\n    var MAX_TRY   = 3\n    var INTERVAL  = 1000\n    var tuple     = increaseCountInUrl(MAX_TRY)\n\n    if (tuple[0]) {\n      return alert(\'Error #204: It seems UI.Vision RPA is not installed yet - or you need to turn on *Allow access to file URLs* for UI.Vision RPA in your browser extension settings.\')\n    } else {\n      reloadTimer = setTimeout(function () {\n        window.location.href = tuple[1]\n      }, INTERVAL)\n    }\n  }\n\n  setTimeout(main, 500)\n})();\n</script>\n</body>\n</html>\n  ';
}

// generate data uri from html
function htmlDataUri(html) {
  return 'data:text/html;base64,' + window.btoa(unescape(encodeURIComponent(html)));
}

// generate data uri from json
function jsonDataUri(str) {
  return 'data:text/json;base64,' + window.btoa(unescape(encodeURIComponent(str)));
}

// generate html from a test case
function toHtml(_ref2) {
  var name = _ref2.name,
      commands = _ref2.commands;

  var copyCommands = commands.map(function (c) {
    return _extends({}, c);
  });
  var openTc = copyCommands.find(function (tc) {
    return tc.cmd === 'open';
  });

  // Note: Aug 10, 2018, no baseUrl when exported to html
  // so that `${variable}` could be used in open command, and won't be prefixed with baseUrl
  var origin = null;
  var replacePath = function replacePath(path) {
    return path;
  };
  // const url         = openTc && new URL(openTc.target)
  // const origin      = url && url.origin
  // const replacePath = (path) => {
  //   if (path.indexOf(origin) !== 0) return path
  //   const result = path.replace(origin, '')
  //   return result.length === 0 ? '/' : result
  // }

  if (openTc) {
    openTc.target = replacePath(openTc.target);
  }

  var commandTrs = copyCommands.map(function (c) {
    if (c.cmd === 'open') {
      // Note: remove origin if it's the same as the first open command
      c.target = replacePath(c.target);
    }

    return '\n      <tr>\n        <td>' + (c.cmd || '') + '</td>\n        <td>' + (c.target || '') + '</td>\n        <td>' + (c.value || '') + '</td>\n      </tr>\n    ';
  });

  return genHtml({
    name: name,
    commandTrs: commandTrs,
    baseUrl: origin || ''
  });
}

function generateEmptyHtml() {
  return genHtml({
    name: 'UI.Vision Autostart Page',
    commandTrs: [],
    baseUrl: '',
    noImport: true
  });
}

// generate data uri of html from a test case
function toHtmlDataUri(obj) {
  return htmlDataUri(toHtml(obj));
}

// parse html to test case
function fromHtml(html) {
  var $root = jquery__WEBPACK_IMPORTED_MODULE_2___default()('<div>' + html + '</div>');
  var $base = $root.find('link');
  var $title = $root.find('title');
  var $trs = $root.find('tbody > tr');

  var baseUrl = $base && $base.attr('href');
  var name = $title.text();

  if (!name || !name.length) {
    throw new Error('fromHtml: missing title');
  }

  var commands = [].slice.call($trs).map(function (tr) {
    var $el = jquery__WEBPACK_IMPORTED_MODULE_2___default()(tr);
    var trHtml = $el[0].outerHtml;

    // Note: remove any datalist option in katalon-like html file
    $el.find('datalist').remove();

    var $children = $el.children();
    var $cmd = $children.eq(0);
    var $tgt = $children.eq(1);
    var $val = $children.eq(2);
    var cmd = Object(_command__WEBPACK_IMPORTED_MODULE_4__["normalizeCommandName"])($cmd && $cmd.text());
    var value = $val && $val.text();
    var target = $tgt && $tgt.text();

    if (!cmd || !cmd.length) {
      throw new Error('missing cmd in ' + trHtml);
    }

    if (cmd === 'open') {
      // Note: with or without baseUrl
      target = baseUrl && baseUrl.length && !/:\/\//.test(target) ? joinUrl(baseUrl, target) : target;
    }

    return { cmd: cmd, target: target, value: value };
  });

  return { name: name, data: { commands: commands } };
}

// parse json to test case
// the current json structure doesn't provide fileName,
// so must provide a file name as the second parameter
function fromJSONString(str, fileName) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // Note: Exported JSON from older version Kantu (via 'export to json')
  // has an invisible charactor (char code65279, known as BOM). It breaks JSON parser.
  // So it's safer to filter it out here
  var obj = parse_json__WEBPACK_IMPORTED_MODULE_1___default()(str.replace(/^\s*/, ''));
  var name = fileName ? fileName.replace(/\.json$/i, '') : obj.Name || '__imported__';

  if (obj.macros) {
    throw new Error('This is a test suite, not a macro');
  }

  if (!Array.isArray(obj.Commands)) {
    throw new Error('\'Commands\' field must be an array');
  }

  var commands = obj.Commands.map(function (c) {
    var obj = {
      cmd: Object(_command__WEBPACK_IMPORTED_MODULE_4__["normalizeCommandName"])(c.Command),
      target: c.Target,
      value: c.Value,
      description: c.Description || ''
    };

    if (Array.isArray(c.Targets)) {
      obj.targetOptions = c.Targets;
    }

    return obj;
  });

  return _extends({
    name: name,
    data: { commands: commands }
  }, opts.withStatus && obj.status ? { status: obj.status } : {}, opts.withId && obj.id ? { id: obj.id } : {});
}

// generate json from a test case
function toJSONString(obj) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var getToday = function getToday() {
    var d = new Date();
    return [d.getFullYear(), d.getMonth() + 1, d.getDate()].join('-');
  };
  var data = _extends({
    Name: obj.name,
    CreationDate: getToday(),
    Commands: obj.commands.map(function (c) {
      return {
        Command: c.cmd,
        Target: c.target || '',
        Value: c.value || '',
        Targets: opts.ignoreTargetOptions ? c.targetOptions : undefined,
        Description: c.description || ''
      };
    })
  }, opts.withStatus && obj.status ? { status: obj.status } : {}, opts.withId && obj.id ? { id: obj.id } : {});

  return JSON.stringify(data, null, 2);
}

// generate data uri of json from a test case
function toJSONDataUri(obj) {
  return jsonDataUri(toJSONString(obj));
}

function toBookmarkData(obj) {
  var path = obj.path,
      bookmarkTitle = obj.bookmarkTitle;


  if (!path) throw new Error('path is required to generate bookmark for macro');
  if (!bookmarkTitle) throw new Error('bookmarkTitle is required to generate bookmark for macro');

  // Note: for backward compatibility, still use `name` field (which makes sense in flat fs mode) to store `path`
  // after we migrate to standard folder mode
  //
  // Use `JSON.stringify(path)` so that it could escape "\" in win32 paths
  return {
    title: bookmarkTitle,
    url: ('javascript:\n      (function() {\n        try {\n          var evt = new CustomEvent(\'kantuRunMacro\', {\n            detail: {\n              name: ' + JSON.stringify(path.replace(/\.json$/i, '')) + ',\n              from: \'bookmark\',\n              storageMode: \'' + Object(_services_storage__WEBPACK_IMPORTED_MODULE_5__["getStorageManager"])().getCurrentStrategyType() + '\',\n              closeRPA: 1\n            }\n          });\n          window.dispatchEvent(evt);\n        } catch (e) {\n          alert(\'UI.Vision RPA Bookmarklet error: \' + e.toString());\n        }\n      })();\n    ').replace(/\n\s*/g, '')
  };
}

// It's a macro.html file that tries to open ui.vision.html which will be exported together
// with this entry html
function generateMacroEntryHtml(macroRelativePath) {
  return '<!doctype html>\n<html lang="en">\n  <head>\n    <title>UI.Vision Shortcut Page</title>\n  </head>\n  <body>\n    <h3>Command line:</h3>\n    <a id="run" href="ui.vision.html?direct=1&savelog=log.txt&macro=' + macroRelativePath + '">Click here</a>\n    <br>\n    <br>\n\t<!-- To start another macro just edit this HTML file and change the macro name in the command line above^. -->\n\t<!-- For more command line parameters see https://ui.vision/rpa/docs#cmd -->\n    <script>\n      window.location.href = document.getElementById("run").getAttribute("href");\n    </script>\n  </body>\n</html>\n';
}

/***/ }),

/***/ 504:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(182);
class ProxyManagerViaSettingsAPI extends base_1.BaseProxyManager {
    constructor() {
        super();
        this.isBound = false;
    }
    isSupported() {
        return typeof chrome !== 'undefined' && chrome.proxy && chrome.proxy.settings && chrome.proxy.settings.onChange;
    }
    isControllable(incognito) {
        return new Promise((resolve, reject) => {
            chrome.proxy.settings.get({ incognito: !!incognito }, (details) => {
                if (chrome.runtime.lastError) {
                    return reject(chrome.runtime.lastError);
                }
                const { levelOfControl } = details;
                const inControl = ['controllable_by_this_extension', 'controlled_by_this_extension'].indexOf(levelOfControl) !== -1;
                resolve(inControl);
            });
        });
    }
    setProxy(proxy) {
        this.bindProxyChange();
        this.proxy = proxy;
        return new Promise((resolve, reject) => {
            chrome.proxy.settings.set({
                value: {
                    mode: 'fixed_servers',
                    rules: {
                        singleProxy: {
                            scheme: proxy.type,
                            host: proxy.host,
                            port: parseInt(proxy.port, 10)
                        }
                    }
                }
            }, () => {
                if (chrome.runtime.lastError) {
                    return reject(chrome.runtime.lastError);
                }
                resolve();
            });
        });
    }
    reset() {
        return new Promise((resolve, reject) => {
            chrome.proxy.settings.set({
                value: {
                    mode: 'direct'
                }
            }, () => {
                if (chrome.runtime.lastError) {
                    return reject(chrome.runtime.lastError);
                }
                resolve();
            });
        });
    }
    bindProxyChange() {
        if (this.isBound) {
            return;
        }
        this.isBound = true;
        chrome.proxy.settings.onChange.addListener((details) => {
            const proxyData = this.fromChromeDetails(details);
            // Proxy data returned by fromChromeDetails doesn't contain username/password
            // so must avoid it overwrites the one with auth info
            this.setLocalProxyIfIsNew(proxyData);
            this.registry.fire('change', proxyData);
        });
    }
    fetchProxyFromSettings() {
        return new Promise((resolve, reject) => {
            chrome.proxy.settings.get({ incognito: false }, (details) => {
                if (chrome.runtime.lastError) {
                    return reject(chrome.runtime.lastError);
                }
                const proxyData = this.fromChromeDetails(details);
                this.setLocalProxyIfIsNew(proxyData);
                this.registry.fire('change', proxyData);
                resolve();
            });
        });
    }
    fromChromeDetails(details) {
        if (details.value.mode !== 'fixed_servers' || !details.value.rules || !details.value.rules.singleProxy) {
            return null;
        }
        const singleProxy = details.value.rules.singleProxy;
        return {
            host: singleProxy.host,
            port: '' + singleProxy.port,
            type: singleProxy.scheme
        };
    }
    setLocalProxyIfIsNew(proxyData) {
        var _a, _b;
        if ((proxyData === null || proxyData === void 0 ? void 0 : proxyData.host) !== ((_a = this.proxy) === null || _a === void 0 ? void 0 : _a.host) ||
            (proxyData === null || proxyData === void 0 ? void 0 : proxyData.port) !== ((_b = this.proxy) === null || _b === void 0 ? void 0 : _b.port)) {
            this.proxy = proxyData;
        }
    }
}
exports.ProxyManagerViaSettingsAPI = ProxyManagerViaSettingsAPI;


/***/ }),

/***/ 505:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __webpack_require__(182);
const listener_api_proxy_1 = __webpack_require__(357);
const ipc_cs_1 = __importDefault(__webpack_require__(20));
const log_1 = __importDefault(__webpack_require__(11));
const ts_utils_1 = __webpack_require__(12);
class ProxyManagerViaPacAPI extends base_1.BaseProxyManager {
    constructor() {
        super();
        this.unbind = () => { };
        this.isBound = false;
    }
    isSupported() {
        return typeof browser !== 'undefined' && browser.proxy && browser.proxy.register;
    }
    isControllable() {
        return Promise.resolve(true);
    }
    setProxy(proxy) {
        this.bind();
        this.proxy = proxy;
        this.notifyProxyChange();
        // Not sure if 1s delay could be omitted. Just keep it here in case legacy pac api
        // takes time before proxy takes effect
        return browser.runtime.sendMessage({
            cmd: 'SET_PROXY',
            data: proxy ? listener_api_proxy_1.convertToFirefoxProxyInfo(proxy) : null
        }, { toProxyScript: true })
            .then(() => ts_utils_1.delay(() => { }, 1000));
    }
    reset() {
        this.proxy = null;
        this.notifyProxyChange();
        return ipc_cs_1.default.ask('PANEL_SET_PROXY_FOR_PAC', { proxy: null })
            .then(() => ts_utils_1.delay(() => { }, 1000));
    }
    getAuth(host, port) {
        if (!this.proxy || !this.proxy.username) {
            return null;
        }
        if (this.proxy.host === host && this.proxy.port === port) {
            return {
                username: this.proxy.username,
                password: this.proxy.password
            };
        }
        return null;
    }
    notifyProxyChange() {
        setTimeout(() => {
            this.registry.fire('change', this.proxy);
        }, 10);
    }
    bind() {
        if (this.isBound) {
            return;
        }
        this.isBound = true;
        const pacListener = (data) => {
            if (data.type === 'PROXY_LOG') {
                log_1.default('PROXY_LOG', data);
            }
        };
        browser.proxy.register('firefox_pac.js');
        browser.runtime.onMessage.addListener(pacListener);
        this.unbind = () => {
            browser.proxy.unregister();
            browser.runtime.onMessage.removeListener(pacListener);
        };
    }
}
exports.ProxyManagerViaPacAPI = ProxyManagerViaPacAPI;


/***/ }),

/***/ 506:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web_extension_1 = __importDefault(__webpack_require__(10));
class ProxyHttpAuth {
    constructor(params) {
        this.unbindListener = () => { };
        this.bound = false;
        this.getAuth = params.getAuth;
    }
    bind() {
        if (this.bound) {
            return;
        }
        this.bound = true;
        const listener = this.onAuthRequired.bind(this);
        web_extension_1.default.webRequest.onAuthRequired.addListener(listener, { urls: ['<all_urls>'] }, ['blocking']);
        this.unbindListener = () => web_extension_1.default.webRequest.onAuthRequired.removeListener(listener);
    }
    unbind() {
        if (!this.bound) {
            return;
        }
        this.unbindListener();
        this.bound = false;
    }
    onAuthRequired(details) {
        if (!details.isProxy) {
            return {};
        }
        const auth = this.getAuth(details.challenger.host, '' + details.challenger.port);
        return auth ? { authCredentials: auth } : {};
    }
}
exports.ProxyHttpAuth = ProxyHttpAuth;


/***/ }),

/***/ 511:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const storage_1 = __webpack_require__(76);
const db_1 = __importDefault(__webpack_require__(92));
const utils_1 = __webpack_require__(4);
const ts_utils_1 = __webpack_require__(12);
class IndexeddbFlatStorage extends storage_1.FlatStorage {
    constructor(options) {
        super();
        this.displayedCount = 0;
        this.totalCount = 0;
        const tableName = options.table;
        if (!db_1.default.tables.find(t => t.name === tableName)) {
            throw new Error(`Unknown indexeddb table name '${tableName}'`);
        }
        this.table = db_1.default.table(options.table);
    }
    getDisplayCount() {
        return this.displayedCount;
    }
    getTotalCount() {
        return this.totalCount;
    }
    __list() {
        // Note: must wrap dexie's "Promise", as it's dexie's own thenable Promise
        return Promise.resolve(this.table.toArray())
            .then((xs) => {
            const convert = (x) => ({
                dir: '',
                fileName: (x.name),
                lastModified: new Date(),
                size: 'unknown'
            });
            this.totalCount = xs.length;
            this.displayedCount = xs.length;
            return xs.map(convert);
        });
    }
    exists(fileName) {
        return Promise.resolve(this.table
            .where('name')
            .equals(fileName)
            .toArray())
            .then((xs) => {
            return xs.length > 0;
        });
    }
    read(fileName, type) {
        if (type !== 'Text') {
            throw new Error(`ReadFileType '${type}' is not supported in indexeddb storage`);
        }
        return this.findByName(fileName);
    }
    readAll(readFileType = 'Text', onErrorFiles) {
        return Promise.resolve(this.table.toArray())
            .then(items => {
            return items.map(item => ({
                fileName: item.name,
                content: item
            }));
        });
    }
    __write(fileName, content) {
        return this.findByName(fileName)
            .catch(() => null)
            .then((item) => {
            if (item) {
                const data = this.normalize(Object.assign(Object.assign({}, item), content));
                delete data.id;
                return this.table.update(item.id, data);
            }
            else {
                const data = this.normalize(Object.assign({ id: utils_1.uid() }, content));
                return this.table.add(data);
            }
        })
            .then(() => { });
    }
    __overwrite(fileName, content) {
        return this.write(fileName, content);
    }
    __clear() {
        return Promise.resolve(this.table.clear());
    }
    __remove(fileName) {
        return this.findByName(fileName)
            .then(item => {
            return this.table.delete(item.id);
        });
    }
    __rename(fileName, newName) {
        return this.findByName(fileName)
            .then((item) => {
            return this.table.update(item.id, { name: newName });
        })
            .then(() => { });
    }
    __copy(fileName, newName) {
        return this.findByName(fileName)
            .then((item) => {
            delete item.id;
            item.name = newName;
            return this.__write(newName, item);
        });
    }
    ensureDir() {
        return Promise.resolve();
    }
    findByName(name) {
        return Promise.resolve(this.table
            .where('name')
            .equals(name)
            .first())
            .then((item) => {
            if (!item)
                throw new Error(`indexeddb storage: Item with name '${name}' is not found`);
            return item;
        });
    }
    normalize(data) {
        return data;
    }
    dataToString(data) {
        return JSON.stringify(data);
    }
}
exports.IndexeddbFlatStorage = IndexeddbFlatStorage;
exports.getIndexeddbFlatStorage = ts_utils_1.singletonGetterByKey((opts) => {
    return opts.table;
}, (opts) => {
    return new IndexeddbFlatStorage(opts);
});


/***/ }),

/***/ 512:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const semver_1 = __importDefault(__webpack_require__(135));
const types_1 = __webpack_require__(185);
const ts_utils_1 = __webpack_require__(12);
class MigrationService {
    constructor(options) {
        this.storage = options.storage;
        this.jobs = options.jobs;
    }
    isMigrated(type) {
        return this.storage.get(type)
            .then((record) => !!record);
    }
    getRecords() {
        return this.storage.getAll();
    }
    runType(type) {
        return this.isMigrated(type)
            .then((migrated) => {
            if (migrated) {
                return types_1.MigrationResult.AlreadyMigrated;
            }
            const job = this.findJob(type);
            if (!job) {
                return types_1.MigrationResult.JobUnknown;
            }
            return job.shouldMigrate()
                .then((pass) => {
                if (!pass) {
                    return types_1.MigrationResult.NotQualified;
                }
                return job.migrate()
                    .then(() => types_1.MigrationResult.Success);
            });
        })
            .catch((e) => {
            console.error(e);
            return types_1.MigrationResult.Error;
        })
            .then((result) => {
            if (result !== types_1.MigrationResult.Success) {
                return Promise.resolve(result);
            }
            return this.storage.set(type, {
                result,
                id: ts_utils_1.uid(),
                runAt: new Date().getTime(),
                jobType: type
            })
                .then(() => result);
        });
    }
    runAll(previousVersion, currentVersion) {
        const validJobs = this.jobs.filter((job) => {
            return semver_1.default.satisfies(previousVersion, job.previousVersionRange());
        });
        return ts_utils_1.flow(...validJobs.map((job) => {
            const type = job.getType();
            return () => {
                return this.runType(type)
                    .then((result) => ({ type, result }));
            };
        }))
            .then((list) => {
            const result = list.reduce((prev, cur) => {
                prev[cur.type] = cur.result;
                return prev;
            }, {});
            return result;
        });
    }
    findJob(type) {
        return this.jobs.find((item) => item.getType() === type);
    }
}
exports.MigrationService = MigrationService;


/***/ }),

/***/ 513:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(153);
const ts_utils_1 = __webpack_require__(12);
class MigrationKeyValueData extends common_1.KeyValueData {
    getAll() {
        return super.get("");
    }
    getMainKeyAndSubKeys(key) {
        const [mainKey, subKeys] = super.getMainKeyAndSubKeys(key);
        return [
            MigrationKeyValueData.STORAGE_KEY,
            [mainKey].concat(subKeys).filter(x => x && x.length)
        ];
    }
}
exports.MigrationKeyValueData = MigrationKeyValueData;
MigrationKeyValueData.STORAGE_KEY = 'migration_records';
exports.getMigrationKeyValueData = ts_utils_1.singletonGetter(() => new MigrationKeyValueData());


/***/ }),

/***/ 523:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(__webpack_require__(1006));
const config_1 = __importDefault(__webpack_require__(34));
const ts_utils_1 = __webpack_require__(12);
function isNetworkError(error) {
    return error.message === 'Network Error';
}
exports.isNetworkError = isNetworkError;
function convertToLicenseInfo(result, licenseKey) {
    switch (result.status) {
        case 'key_not_found':
            return { licenseKey, status: 'key_not_found' };
        case 'off':
            return { licenseKey, status: 'off', type: result.product };
        case 'on':
            return {
                licenseKey,
                status: 'on',
                type: result.product,
                name: result.data1a,
                upgradeUrl: result.data1b,
                maxOcrCalls: parseInt(result.data2b)
            };
    }
}
exports.convertToLicenseInfo = convertToLicenseInfo;
function checkLicense(params) {
    const url = ts_utils_1.urlWithQueries(config_1.default.license.api.url, {
        version: params.version,
        licensekey: params.licenseKey
    });
    return axios_1.default.get(url).then(res => {
        const result = res.data;
        return convertToLicenseInfo(result, params.licenseKey);
    })
        .catch((e) => {
        if (e.response) {
            throw new Error(e.response.data);
        }
        return Promise.reject(e);
    });
}
exports.checkLicense = checkLicense;


/***/ }),

/***/ 58:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = __webpack_require__(1023);
const ts_utils_1 = __webpack_require__(12);
const kantu_xy_host_1 = __webpack_require__(1024);
const resize_window_1 = __webpack_require__(393);
const log_1 = __importDefault(__webpack_require__(11));
var MouseButton;
(function (MouseButton) {
    MouseButton[MouseButton["Left"] = 0] = "Left";
    MouseButton[MouseButton["Right"] = 1] = "Right";
    MouseButton[MouseButton["Middle"] = 2] = "Middle";
})(MouseButton = exports.MouseButton || (exports.MouseButton = {}));
var MouseEventType;
(function (MouseEventType) {
    MouseEventType[MouseEventType["Move"] = 0] = "Move";
    MouseEventType[MouseEventType["Down"] = 1] = "Down";
    MouseEventType[MouseEventType["Up"] = 2] = "Up";
    MouseEventType[MouseEventType["Click"] = 3] = "Click";
    MouseEventType[MouseEventType["DoubleClick"] = 4] = "DoubleClick";
    MouseEventType[MouseEventType["CtrlClick"] = 5] = "CtrlClick";
    MouseEventType[MouseEventType["ShiftClick"] = 6] = "ShiftClick";
    MouseEventType[MouseEventType["TripleClick"] = 7] = "TripleClick";
})(MouseEventType = exports.MouseEventType || (exports.MouseEventType = {}));
exports.getNativeXYAPI = ts_utils_1.singletonGetter(() => {
    const nativeHost = new kantu_xy_host_1.KantuXYHost();
    let pReady = nativeHost.connectAsync().catch(e => {
        log_1.default.warn('pReady - error', e);
        throw e;
    });
    const api = constants_1.MethodTypeInvocationNames.reduce((prev, method) => {
        const camel = ts_utils_1.snakeToCamel(method);
        prev[camel] = (() => {
            const fn = (params) => pReady.then(() => {
                return nativeHost.invokeAsync(method, params)
                    .catch(e => {
                    // Note: Looks like for now whenever there is an error, you have to reconnect native host
                    // otherwise, all commands return "Disconnected" afterwards
                    const typeSafeAPI = api;
                    typeSafeAPI.reconnect().catch(() => { });
                    throw e;
                });
            });
            return fn;
        })();
        return prev;
    }, {
        reconnect: () => {
            nativeHost.disconnect();
            pReady = nativeHost.connectAsync();
            return pReady.then(() => api);
        },
        // Note: This factor equals to ScreenMouseCoornidate / CssMouseCoordinate
        getScalingFactor: () => {
            const typeSafeAPI = api;
            return typeSafeAPI.getScreenBackingScaleFactor()
                .then(screenBackingFactor => window.devicePixelRatio / screenBackingFactor);
        },
        sendViewportMouseEvent: (event, options) => {
            const typeSafeAPI = api;
            return Promise.all([
                options.getViewportRectInScreen(),
                resize_window_1.getFocusedWindowSize(),
                typeSafeAPI.getScalingFactor()
            ])
                .then(tuple => {
                const viewportRect = tuple[0];
                const winSize = tuple[1];
                const scalingFactor = tuple[2];
                const offsetX = viewportRect.x;
                const offsetY = viewportRect.y;
                return typeSafeAPI.sendMouseEvent({
                    type: event.type,
                    button: event.button,
                    x: event.x * scalingFactor + offsetX * scalingFactor,
                    y: event.y * scalingFactor + offsetY * scalingFactor
                });
            })
                .catch(e => {
                console.error(e);
                return false;
            });
        }
    });
    return api;
});


/***/ }),

/***/ 60:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = __webpack_require__(124);
const kantu_file_access_host_1 = __webpack_require__(125);
const ts_utils_1 = __webpack_require__(12);
const log_1 = __importDefault(__webpack_require__(11));
const path_1 = __importDefault(__webpack_require__(27));
const utf8_1 = __webpack_require__(126);
const base64_1 = __webpack_require__(127);
const utils_1 = __webpack_require__(4);
const semver_1 = __importDefault(__webpack_require__(135));
const config_1 = __importDefault(__webpack_require__(34));
var SpecialFolder;
(function (SpecialFolder) {
    SpecialFolder[SpecialFolder["UserProfile"] = 0] = "UserProfile";
    SpecialFolder[SpecialFolder["UserDesktop"] = 1] = "UserDesktop";
})(SpecialFolder = exports.SpecialFolder || (exports.SpecialFolder = {}));
exports.getNativeFileSystemAPI = ts_utils_1.singletonGetter(() => {
    const nativeHost = new kantu_file_access_host_1.KantuFileAccessHost();
    let pReady = nativeHost.connectAsync().catch(e => {
        log_1.default.warn('pReady - error', e);
        throw e;
    });
    let pendingRequestCount = 0;
    const api = constants_1.MethodTypeInvocationNames.reduce((prev, method) => {
        const camel = ts_utils_1.snakeToCamel(method);
        if (prev[camel]) {
            return prev;
        }
        prev[camel] = (() => {
            const fn = (params) => pReady.then(() => {
                pendingRequestCount += 1;
                return nativeHost.invokeAsync(method, params);
            })
                .then((data) => {
                pendingRequestCount -= 1;
                return data;
            }, e => {
                pendingRequestCount -= 1;
                // Note: Looks like for now whenever there is an error, you have to reconnect native host
                // otherwise, all commands return "Disconnected" afterwards
                const typeSafeAPI = api;
                typeSafeAPI.reconnect().catch(() => { });
                throw e;
            });
            return fn;
        })();
        return prev;
    }, {
        reconnect: () => {
            return ts_utils_1.until('pendingRequestCount === 0', () => {
                return {
                    pass: pendingRequestCount === 0,
                    result: true
                };
            })
                .then(() => {
                log_1.default(`FileSystem - reconnect`, new Error().stack);
                nativeHost.disconnect();
                pReady = nativeHost.connectAsync();
                return pReady.then(() => api);
            });
        },
        getEntries: (params) => {
            const typeSafeAPI = api;
            return typeSafeAPI.getFileSystemEntries(params)
                .then(res => {
                const { errorCode, entries } = res;
                if (params.brief) {
                    return Promise.resolve({
                        errorCode,
                        entries: entries.map((name) => ({
                            name,
                            length: 0,
                            isDirectory: false,
                            lastWriteTime: 0
                        }))
                    });
                }
                return Promise.all(entries.map((name) => {
                    const entryPath = path_1.default.join(params.path, name);
                    return typeSafeAPI.getFileSystemEntryInfo({ path: entryPath })
                        .then(info => ({
                        name,
                        length: info.length,
                        isDirectory: info.isDirectory,
                        lastWriteTime: info.lastWriteTime
                    }));
                }))
                    .then(entryInfos => ({
                    errorCode,
                    entries: entryInfos
                }));
            });
        },
        ensureDir: (params) => {
            const typeSafeAPI = api;
            return typeSafeAPI.directoryExists({
                path: params.path
            })
                .then(exists => {
                if (exists)
                    return true;
                return typeSafeAPI.ensureDir({ path: path_1.default.dirname(params.path) })
                    .then(done => {
                    if (!done)
                        return false;
                    return typeSafeAPI.createDirectory({ path: params.path });
                });
            })
                .catch(e => false);
        },
        readBigFile: (params) => {
            const typeSafeAPI = api;
            return typeSafeAPI.getFileSize(params)
                .then((fileSize) => {
                if (fileSize === 0) {
                    return new Uint8Array(0);
                }
                const content = [];
                const go = (pos) => {
                    return typeSafeAPI.readFileRange({
                        path: params.path,
                        rangeStart: pos
                    })
                        .then(result => {
                        const data = base64_1.base64.decode(result.buffer);
                        if (data) {
                            for (let i = 0; i < data.length; i++) {
                                content.push(data[i]);
                            }
                        }
                        if (result.rangeEnd <= pos || result.rangeEnd >= fileSize) {
                            return new Uint8Array(content);
                        }
                        return go(result.rangeEnd);
                    });
                };
                return go(0);
            });
        },
        isReadBigFileSupported: () => {
            const typeSafeAPI = api;
            return typeSafeAPI.getVersion()
                .then(version => {
                return !semver_1.default.lt(version, config_1.default.xfile.minVersionToReadBigFile);
            });
        },
        readAllTextCompat: (params) => {
            const typeSafeAPI = api;
            return typeSafeAPI.isReadBigFileSupported()
                .then(supported => {
                if (!supported) {
                    return typeSafeAPI.readAllText(params);
                }
                return typeSafeAPI.readBigFile(params)
                    .then(content => {
                    const text = utf8_1.utf8.decode(content);
                    return {
                        errorCode: 0,
                        content: text
                    };
                });
            });
        },
        readAllBytesCompat: (params) => {
            const typeSafeAPI = api;
            return typeSafeAPI.isReadBigFileSupported()
                .then(supported => {
                if (!supported) {
                    return typeSafeAPI.readAllBytes(params);
                }
                return typeSafeAPI.readBigFile(params)
                    .then(content => {
                    return utils_1.blobToDataURL(new Blob([content]))
                        .then(dataUrl => ({
                        errorCode: 0,
                        content: dataUrl
                    }));
                });
            });
        },
    });
    return api;
});


/***/ }),

/***/ 619:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(0));
const antd_1 = __webpack_require__(117);
const prop_types_1 = __importDefault(__webpack_require__(1));
class EditInPlace extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.state = {
            isEditing: false,
            value: ''
        };
        this.edit = () => {
            this.setState({ isEditing: true });
            setTimeout(() => {
                const $input = this.$input && this.$input.refs && this.$input.refs.input;
                if ($input) {
                    $input.focus();
                    const selection = this.props.getSelection(this.state.value, $input);
                    $input.selectionStart = selection ? selection.start : 0;
                    $input.selectionEnd = selection ? selection.end : $input.value.length;
                }
            }, 100);
        };
        this.submit = () => {
            this.props.checkValue(this.state.value)
                .then(pass => {
                if (pass) {
                    this.setState({ isEditing: false });
                    this.props.onChange(this.state.value)
                        .catch(e => this.setState({ value: this.props.value }));
                }
            });
        };
        this.reset = () => {
            this.setState({
                isEditing: false,
                value: this.props.value
            });
        };
    }
    componentDidMount() {
        this.setState({
            value: this.props.value
        });
    }
    componentWillReceiveProps(nextProps) {
        if (nextProps.value !== this.props.value) {
            this.setState({ value: nextProps.value });
        }
    }
    render() {
        if (!this.state.isEditing) {
            return (react_1.default.createElement("span", null,
                this.props.value,
                react_1.default.createElement(antd_1.Icon, { type: "edit", style: { marginLeft: '10px', cursor: 'pointer' }, onClick: this.edit })));
        }
        else {
            return (react_1.default.createElement(antd_1.Input, { defaultValue: "", autosize: true, ref: ref => { this.$input = ref; }, value: this.state.value, onChange: e => this.setState({ value: e.target.value }), onBlur: this.reset, onKeyDown: (e) => {
                    if (e.keyCode === 13)
                        return this.submit();
                    if (e.keyCode === 27)
                        return this.reset();
                } }));
        }
    }
}
exports.default = EditInPlace;
EditInPlace.propTypes = {
    value: prop_types_1.default.string.isRequired,
    onChange: prop_types_1.default.func.isRequired,
    checkValue: prop_types_1.default.func.isRequired,
    getSelection: prop_types_1.default.func
};
EditInPlace.defaultProps = {
    getSelection: () => null
};


/***/ }),

/***/ 62:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const C = __importStar(__webpack_require__(17));
var RunBy;
(function (RunBy) {
    RunBy["Html"] = "html";
    RunBy["Bookmark"] = "bookmark";
    RunBy["Manual"] = "manual";
})(RunBy = exports.RunBy || (exports.RunBy = {}));
function stringForRunBy(type) {
    switch (type) {
        case RunBy.Bookmark:
            return 'bookmark';
        case RunBy.Html:
            return 'command line';
        case RunBy.Manual:
            return 'manual';
    }
}
exports.stringForRunBy = stringForRunBy;
var FocusArea;
(function (FocusArea) {
    FocusArea["Unknown"] = "unknown";
    FocusArea["Sidebar"] = "sidebar";
    FocusArea["CommandTable"] = "command_table";
    FocusArea["CodeSource"] = "code_source";
})(FocusArea = exports.FocusArea || (exports.FocusArea = {}));
exports.newTestCaseEditing = {
    commands: [],
    meta: {
        src: null,
        hasUnsaved: true,
        selectedIndex: -1
    }
};
// * editor
//    * testCases:          all test cases stored in indexedDB
//    * editing:            the current test cases being edited
//    * clipbard            for copy / cut / paste
//
// * player                 the state for player
//    * nextCommandIndex    the current command beging executed
//    * currentLoop         the current round
//    * loops               how many rounds to run totally
exports.initialState = {
    status: C.APP_STATUS.NORMAL,
    recorderStatus: C.RECORDER_STATUS.STOPPED,
    inspectorStatus: C.INSPECTOR_STATUS.STOPPED,
    isLoadingMacros: false,
    from: RunBy.Manual,
    noDisplayInPlay: false,
    editor: {
        testSuites: [],
        testCases: [],
        currentMacro: null,
        // macrosExtra is used to store:
        // * status
        // * breakpoints
        // * doneCommandIndices
        // * errorCommandIndices
        // * warningCommandIndices
        macrosExtra: {},
        // `macroFolderStructure` just holds folder and path info,
        // while macro content is still in `testCases`.
        // Similar case for `testSuitesFolderStructure`
        macroFolderStructure: [],
        testSuitesExtra: {},
        testSuitesFolderStructure: [],
        editing: Object.assign({}, exports.newTestCaseEditing),
        editingSource: {
            // Saved version
            original: null,
            // Version before editing
            pure: null,
            // Version keeping track of any editing
            current: null,
            error: null
        },
        clipboard: {
            commands: []
        },
        activeTab: 'table_view',
        isDraggingCommand: false
    },
    player: {
        mode: C.PLAYER_MODE.TEST_CASE,
        status: C.PLAYER_STATUS.STOPPED,
        stopReason: null,
        currentLoop: 0,
        loops: 0,
        nextCommandIndex: null,
        playInterval: 0,
        timeoutStatus: {
            type: null,
            total: null,
            past: null
        }
    },
    recorder: {
        skipOpen: false
    },
    variables: [],
    logs: [],
    screenshots: [],
    csvs: [],
    visions: [],
    config: {},
    proxy: null,
    ui: {
        focusArea: FocusArea.Unknown
    },
    macroQuery: ''
};


/***/ }),

/***/ 620:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(0));
const ts_utils_1 = __webpack_require__(12);
const log_1 = __importDefault(__webpack_require__(11));
class IntersectionObserverManager {
    constructor(params) {
        this.targets = [];
        log_1.default('Create observer', params);
        this.observer = new IntersectionObserver(this.handleObserve.bind(this), params);
    }
    observe(el, run) {
        this.targets.push({ el, run, done: false });
        this.observer.observe(el);
    }
    remove(el) {
        const index = this.targets.findIndex(target => target.el === el);
        if (index !== -1) {
            this.targets.splice(index, 1);
        }
    }
    handleObserve(entries) {
        entries.forEach(entry => {
            if (entry.intersectionRatio <= 0) {
                return;
            }
            const el = entry.target;
            const index = this.targets.findIndex(target => target.el === el);
            if (index === -1 || this.targets[index].done) {
                return;
            }
            this.targets[index].run();
            this.targets[index].done = true;
        });
    }
}
exports.IntersectionObserverManager = IntersectionObserverManager;
exports.getIntersectionObserverManager = ts_utils_1.singletonGetterByKey((key) => key, (key, params) => {
    return new IntersectionObserverManager(params);
});
class LazyImage extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.el = null;
        this.manager = null;
        this.state = {
            url: '',
            isLoading: false
        };
    }
    componentWillMount() {
        this.manager = exports.getIntersectionObserverManager(this.props.type, {
            root: this.props.root,
            rootMargin: '20px',
            threshold: 0.01
        });
    }
    componentWillUnmount() {
        if (this.el && this.manager) {
            this.manager.remove(this.el);
        }
    }
    startObserve(el) {
        if (!this.manager) {
            return;
        }
        this.manager.observe(el, () => {
            this.getUrl();
        });
    }
    getSizeString(size) {
        if (typeof size === 'number') {
            return size + 'px';
        }
        return size;
    }
    getImageStyle() {
        return Object.assign(Object.assign(Object.assign({}, (!this.props.width ? {} : { width: this.getSizeString(this.props.width) })), (!this.props.height ? {} : { height: this.getSizeString(this.props.height) })), { backgroundImage: `url(${this.state.url})`, backgroundSize: 'contain', backgroundRepeat: 'no-repeat', backgroundPosition: 'center center' });
    }
    getUrl() {
        this.setState({ isLoading: true });
        return this.props.getUrl()
            .then((realUrl) => {
            this.setState({
                url: realUrl,
                isLoading: false
            });
        });
    }
    render() {
        return (react_1.default.createElement("div", { className: "lazy-image", style: this.getImageStyle(), ref: (el) => {
                this.el = el;
                if (el) {
                    this.startObserve(el);
                }
            } }));
    }
}
exports.LazyImage = LazyImage;


/***/ }),

/***/ 63:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "postMessage", function() { return postMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onMessage", function() { return onMessage; });
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var TYPE = 'SELENIUM_IDE_CS_MSG';

var postMessage = function postMessage(targetWin, myWin, payload) {
  var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '*';
  var timeout = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 60000;

  return new Promise(function (resolve, reject) {
    if (!targetWin || !targetWin.postMessage) {
      throw new Error('csPostMessage: targetWin is not a window');
    }

    if (!myWin || !myWin.addEventListener || !myWin.removeEventListener) {
      throw new Error('csPostMessage: myWin is not a window', myWin);
    }

    var secret = Math.random();
    var type = TYPE;

    // Note: create a listener with a corresponding secret every time
    var onMsg = function onMsg(e) {
      if (e.data && e.data.type === TYPE && !e.data.isRequest && e.data.secret === secret) {
        myWin.removeEventListener('message', onMsg);
        var _e$data = e.data,
            _payload = _e$data.payload,
            error = _e$data.error;


        if (error) return reject(new Error(error));
        if (_payload !== undefined) return resolve(_payload);

        reject(new Error('csPostMessage: No payload nor error found'));
      }
    };

    myWin.addEventListener('message', onMsg);

    // Note:
    // * `type` to make sure we check our own msg only
    // * `secret` is for 1 to 1 relationship between a msg and a listener
    // * `payload` is the real data you want to send
    // * `isRequest` is to mark that it's not an answer to some previous request

    targetWin.postMessage({
      type: type,
      secret: secret,
      payload: payload,
      isRequest: true
    }, target);

    setTimeout(function () {
      reject(new Error('csPostMessage: timeout ' + timeout + ' ms'));
    }, timeout);
  });
};

var onMessage = function onMessage(win, fn) {
  if (!win || !win.addEventListener || !win.removeEventListener) {
    throw new Error('csOnMessage: not a window', win);
  }

  var onMsg = function onMsg(e) {
    // Note: only respond to msg with `isRequest` as true
    if (e && e.data && e.data.type === TYPE && e.data.isRequest && e.data.secret) {
      var tpl = {
        type: TYPE,
        secret: e.data.secret

        // Note: wrapped with a new Promise to catch any exception during the execution of fn
      };new Promise(function (resolve, reject) {
        var ret = void 0;

        try {
          ret = fn(e.data.payload, {
            source: e.source
          });
        } catch (err) {
          reject(err);
        }

        // Note: only resolve if returned value is not undefined. With this, we can have multiple
        // listeners added to onMessage, and each one takes care of what it really cares
        if (ret !== undefined) {
          resolve(ret);
        }
      }).then(function (res) {
        e.source.postMessage(_extends({}, tpl, {
          payload: res
        }), '*');
      }, function (err) {
        e.source.postMessage(_extends({}, tpl, {
          error: err.message
        }), '*');
      });
    }
  };

  win.addEventListener('message', onMsg);
  return function () {
    return win.removeEventListener('message', onMsg);
  };
};

/***/ }),

/***/ 641:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ts_utils_1 = __webpack_require__(12);
const storage_1 = __webpack_require__(13);
const log_1 = __importDefault(__webpack_require__(11));
const utils_1 = __webpack_require__(4);
function importSideProject(project) {
    const folderName = utils_1.sanitizeFileName(project.name);
    const macroStorage = storage_1.getStorageManager().getMacroStorage();
    const path = macroStorage.getPathLib();
    return ts_utils_1.uniqueName(folderName, {
        check: (name) => {
            return macroStorage.directoryExists(name)
                .then(result => !result);
        }
    })
        .then(finalFolderName => {
        return macroStorage.createDirectory(finalFolderName)
            .then(() => {
            return Promise.all(project.tests.map(sideMacro => {
                sideMacro.name = utils_1.sanitizeFileName(sideMacro.name);
                const filePath = path.join(finalFolderName, sideMacro.name + '.json');
                const macro = convertSideMacro(sideMacro, project.url);
                return macroStorage.write(filePath, {
                    name: macro.name,
                    data: {
                        commands: macro.commands
                    }
                })
                    .then(() => true, (e) => {
                    log_1.default(e);
                    return e.message;
                });
            }))
                .then(list => {
                return {
                    successCount: list.filter((x) => x && typeof x === 'boolean').length,
                    errorCount: list.filter((x) => typeof x === 'string').length,
                    errors: list.filter((x) => typeof x === 'string'),
                    ignoreCount: 0
                };
            });
        })
            .then(macrosResult => {
            return {
                projectName: project.name,
                folderName: finalFolderName,
                macros: macrosResult,
                suites: {
                    successCount: 0,
                    ignoreCount: project.suites.length,
                    errorCount: 0,
                    errors: []
                }
            };
        });
    });
}
exports.importSideProject = importSideProject;
function convertSideMacro(macro, baseUrl) {
    return {
        name: macro.name,
        commands: ts_utils_1.flatten(macro.commands.map(command => convertSideCommand(command, baseUrl)))
    };
}
exports.convertSideMacro = convertSideMacro;
function convertSideCommand(command, baseUrl) {
    if (command.command === 'open') {
        return [{
                cmd: 'open',
                target: resolveUrl(baseUrl, command.target),
                value: ''
            }];
    }
    if (isSameNameSupported(command.command)) {
        return [Object.assign({ cmd: command.command, target: command.target, value: command.value }, (command.targets ? { targetOptions: command.targets.map(item => item[0]) } : {}))];
    }
    const res = convertSideCommandMapping(command);
    if (res.length > 0) {
        return res;
    }
    return [{
            cmd: 'comment',
            target: `${command.command} // ${command.target}`,
            value: command.value
        }];
}
exports.convertSideCommand = convertSideCommand;
function isSameNameSupported(name) {
    switch (name) {
        case 'open':
        case 'select':
        case 'type':
        case 'pause':
        case 'addSelection':
        case 'answerOnNextPrompt':
        case 'assertAlert':
        case 'assertChecked':
        case 'assertConfirmation':
        case 'assertEditable':
        case 'assertElementPresent':
        case 'assertElementNotPresent':
        case 'assertNotEditable':
        case 'assertNotChecked':
        case 'assertPrompt':
        case 'assertTitle':
        case 'assertText':
        case 'assertValue':
        case 'check':
        case 'click':
        case 'clickAt':
        case 'do':
        case 'dragAndDropToObject':
        case 'echo':
        case 'editContent':
        case 'else':
        case 'elseIf':
        case 'end':
        case 'executeAsyncScript':
        case 'executeScript':
        case 'forEach':
        case 'mouseOver':
        case 'repeatIf':
        case 'removeSelection':
        case 'run':
        case 'select':
        case 'selectFrame':
        case 'sendKeys':
        case 'setWindowSize':
        case 'store':
        case 'storeAttribute':
        case 'storeText':
        case 'storeTitle':
        case 'storeValue':
        case 'storeXpathCount':
        case 'times':
        case 'uncheck':
        case 'verifyChecked':
        case 'verifyText':
        case 'verifyTitle':
        case 'verifyValue':
        case 'verifyEditable':
        case 'verifyElementPresent':
        case 'verifyElementNotPresent':
        case 'verifyNotChecked':
        case 'verifyNotEditable':
        case 'waitForElementVisible':
        case 'waitForElementNotVisible':
        case 'waitForElementPresent':
        case 'waitForElementNotPresent':
            return true;
        default:
            return false;
    }
}
function convertSideCommandMapping(command) {
    const withTimeoutWaitChanged = (value, command) => {
        return [{
                cmd: 'store',
                target: '${!TIMEOUT_WAIT}',
                value: '__LAST_TIMEOUT_WAIT__'
            }, {
                cmd: 'store',
                target: (parseFloat(value) / 1000).toFixed(3),
                value: '!TIMEOUT_WAIT'
            },
            command,
            {
                cmd: 'store',
                target: '${__LAST_TIMEOUT_WAIT__}',
                value: '!TIMEOUT_WAIT'
            }];
    };
    switch (command.command) {
        case 'runScript': {
            return [{
                    cmd: 'executeScript',
                    target: command.target,
                    value: ''
                }];
        }
        case 'if': {
            return [{
                    cmd: 'if_v2',
                    target: command.target,
                    value: command.value
                }];
        }
        case 'while': {
            return [{
                    cmd: 'while_v2',
                    target: command.target,
                    value: command.value
                }];
        }
        default:
            return [];
    }
}
function resolveUrl(baseUrl, url) {
    if (/^https?:\/\//.test(url)) {
        return url;
    }
    if (url.charAt(0) === '/') {
        const u = new URL(baseUrl);
        return u.origin + url;
    }
    return baseUrl + url;
}


/***/ }),

/***/ 642:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jszip_1 = __importDefault(__webpack_require__(142));
const storage_1 = __webpack_require__(13);
const ts_utils_1 = __webpack_require__(12);
const convert_utils_1 = __webpack_require__(50);
const common_1 = __webpack_require__(374);
function restoreBackup(options) {
    const storageManager = storage_1.getStorageManager(options.storage);
    return jszip_1.default.loadAsync(options.file)
        .then(zip => {
        // 0. sort entries by folder/file, name
        // 1. Find all folders that is in valid root, create them one by one if not exists
        // 2. Find all files, write into storage
        const fileZipObjects = [];
        const folderZipObjects = [];
        zip.forEach((_, obj) => {
            if (obj.dir) {
                folderZipObjects.push(obj);
            }
            else {
                fileZipObjects.push(obj);
            }
        });
        sortZipObjectsInline(fileZipObjects);
        sortZipObjectsInline(folderZipObjects);
        const createAllFolders = () => {
            return ts_utils_1.flow(...folderZipObjects.map(obj => {
                const res = getStorageAndPath({
                    manager: storageManager,
                    path: obj.name
                });
                if (!res || res.relativePath === '.' || res.relativePath === '') {
                    return () => Promise.resolve();
                }
                return () => {
                    return res.storage.directoryExists(res.relativePath)
                        .then(exists => {
                        if (exists) {
                            return;
                        }
                        return res.storage.createDirectory(res.relativePath)
                            .then(() => { });
                    });
                };
            }));
        };
        const createAllFiles = () => {
            return ts_utils_1.flow(...fileZipObjects.map(obj => {
                const res = getStorageAndPath({
                    manager: storageManager,
                    path: obj.name
                });
                if (!res) {
                    return () => Promise.resolve();
                }
                switch (res.target) {
                    case storage_1.StorageTarget.Macro: {
                        return () => {
                            return obj.async('text')
                                .then(text => {
                                return res.storage.write(res.relativePath, convert_utils_1.fromJSONString(text));
                            })
                                .then(() => res.target);
                        };
                    }
                    case storage_1.StorageTarget.Screenshot:
                    case storage_1.StorageTarget.Vision:
                    case storage_1.StorageTarget.CSV: {
                        return () => {
                            return obj.async('blob')
                                .then(blob => {
                                return res.storage.write(res.relativePath, blob);
                            })
                                .then(() => res.target);
                        };
                    }
                    default: {
                        return () => Promise.resolve();
                    }
                }
            }))
                .then(results => {
                return {
                    count: {
                        macro: results.filter((x) => x === storage_1.StorageTarget.Macro).length,
                        testSuite: results.filter((x) => x === storage_1.StorageTarget.TestSuite).length,
                        screenshot: results.filter((x) => x === storage_1.StorageTarget.Screenshot).length,
                        vision: results.filter((x) => x === storage_1.StorageTarget.Vision).length,
                        csv: results.filter((x) => x === storage_1.StorageTarget.CSV).length
                    }
                };
            });
        };
        return createAllFolders().then(createAllFiles);
    });
}
exports.restoreBackup = restoreBackup;
function sortZipObjectsInline(list) {
    list.sort((a, b) => {
        if (a.name < b.name) {
            return -1;
        }
        if (a.name > b.name) {
            return 1;
        }
        return 0;
    });
}
exports.sortZipObjectsInline = sortZipObjectsInline;
function sortZipObjects(list) {
    const result = [...list];
    sortZipObjectsInline(result);
    return result;
}
exports.sortZipObjects = sortZipObjects;
function getStorageAndPath(options) {
    const DELIM = '/';
    const parts = options.path.split(DELIM).filter(part => part !== '.');
    const subPath = parts.slice(1).join(DELIM);
    const isDir = parts[parts.length - 1] === '';
    const [storage, target] = (() => {
        switch (parts[0]) {
            case common_1.ZipFolders.Macros:
                return [options.manager.getMacroStorage(), storage_1.StorageTarget.Macro];
            case common_1.ZipFolders.TestSuites:
                return [options.manager.getTestSuiteStorage(), storage_1.StorageTarget.TestSuite];
            case common_1.ZipFolders.Csvs:
                return [options.manager.getCSVStorage(), storage_1.StorageTarget.CSV];
            case common_1.ZipFolders.Screenshots:
                return [options.manager.getScreenshotStorage(), storage_1.StorageTarget.Screenshot];
            case common_1.ZipFolders.Visions:
                return [options.manager.getVisionStorage(), storage_1.StorageTarget.Vision];
            default:
                return [null, null];
        }
    })();
    if (!storage) {
        return null;
    }
    return {
        storage: storage,
        target: target,
        dir: isDir,
        relativePath: subPath
    };
}
exports.getStorageAndPath = getStorageAndPath;


/***/ }),

/***/ 644:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(0));
const react_dom_1 = __importDefault(__webpack_require__(18));
const antd_1 = __webpack_require__(117);
const uuid_1 = __webpack_require__(1087);
const ts_utils_1 = __webpack_require__(12);
__webpack_require__(1059);
const utils_1 = __webpack_require__(4);
class SelectInput extends react_1.default.Component {
    constructor(props) {
        super(props);
        this.state = {
            text: '',
            shouldShowOptions: false
        };
        this.getDropDownElementId = ts_utils_1.singletonGetter(() => 'dropdown_' + uuid_1.v1());
        this.onFocus = () => {
            if (this.props.disabled) {
                return;
            }
            this.setState({
                shouldShowOptions: true
            });
        };
        this.onBlur = () => {
            setTimeout(() => {
                this.setState({
                    shouldShowOptions: false
                });
            }, 100);
        };
        this.onToggle = () => {
            if (this.props.disabled) {
                return;
            }
            if (this.state.shouldShowOptions) {
                this.onBlur();
            }
            else {
                this.onFocus();
                this.focusOnTextInput();
            }
        };
        this.onKeyDown = (e) => {
            switch (e.keyCode) {
                case 13:
                case 27:
                    this.setState({ shouldShowOptions: false });
                    break;
            }
        };
        this.onTextChange = (e) => {
            const text = e.target.value;
            this.setState({
                text,
                shouldShowOptions: true
            });
            this.props.onChange(text);
        };
        this.onItemClick = (e, item, index) => {
            var _a;
            const text = (_a = this.props.stringifyOption(item)) !== null && _a !== void 0 ? _a : this.props.getId(item, index);
            this.setState({
                text,
                shouldShowOptions: false
            });
            this.focusOnTextInput();
            this.props.onChange(text);
        };
        this.container = react_1.default.createRef();
        this.input = react_1.default.createRef();
    }
    componentDidMount() {
        if (this.props.value) {
            this.setState({
                text: this.props.value
            });
        }
    }
    componentDidUpdate(prevProps) {
        var _a;
        if (this.props.value !== prevProps.value) {
            this.setState({
                text: (_a = this.props.value) !== null && _a !== void 0 ? _a : ''
            });
        }
    }
    focusOnTextInput() {
        if (!this.input.current) {
            return;
        }
        const $input = this.input.current.refs.input;
        $input.focus();
    }
    getDropDownContainer() {
        const id = 'drop_down_container';
        const existing = document.getElementById(id);
        if (existing) {
            return existing;
        }
        const el = document.createElement('div');
        el.id = id;
        document.body.appendChild(el);
        return el;
    }
    getDropDownMountPoint() {
        const id = this.getDropDownElementId();
        const existing = document.getElementById(id);
        if (existing) {
            return existing;
        }
        const el = document.createElement('div');
        el.id = id;
        el.className = "drop-down";
        this.getDropDownContainer().appendChild(el);
        return el;
    }
    renderOneOption(item, index, selected) {
        var _a;
        const { getId, stringifyOption } = this.props;
        const OptionItem = this.props.OptionItem;
        const id = getId(item, index);
        if (OptionItem) {
            return react_1.default.createElement(OptionItem, { value: item, key: id });
        }
        const text = (_a = stringifyOption === null || stringifyOption === void 0 ? void 0 : stringifyOption(item)) !== null && _a !== void 0 ? _a : id;
        return (react_1.default.createElement(PlainTextOption, { key: id, item: item, index: index, text: text, selected: selected, onItemClick: this.onItemClick }));
    }
    renderOptions() {
        if (!this.state.shouldShowOptions) {
            return null;
        }
        const el = this.container.current;
        if (!el) {
            return null;
        }
        const rect = el.getBoundingClientRect();
        const margin = 3;
        const style = {
            position: 'absolute',
            left: rect.left,
            top: rect.top + rect.height + margin
        };
        if (!this.props.dropdownAutoWidth) {
            style.width = rect.width;
        }
        const node = (react_1.default.createElement("div", { className: "option-list", style: style }, this.props.options.map((item, i) => {
            return this.renderOneOption(item, i, this.state.text === this.props.stringifyOption(item));
        })));
        return react_dom_1.default.createPortal(node, this.getDropDownMountPoint());
    }
    render() {
        return (react_1.default.createElement("div", { className: utils_1.cn('select-input', { opened: this.state.shouldShowOptions }), ref: this.container },
            react_1.default.createElement(antd_1.Input, { ref: this.input, disabled: this.props.disabled, placeholder: this.props.placeholder, value: this.state.text, onFocus: this.onFocus, onBlur: this.onBlur, onClick: this.onFocus, onChange: this.onTextChange, onKeyDown: this.onKeyDown }),
            react_1.default.createElement("span", { className: "arrow-icon ant-select-arrow", onClick: this.onToggle }),
            this.renderOptions()));
    }
}
exports.SelectInput = SelectInput;
SelectInput.defaultProps = {
    disabled: false,
    dropdownAutoWidth: false
};
class PlainTextOption extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.onClick = (e) => {
            this.props.onItemClick(e, this.props.item, this.props.index);
        };
    }
    render() {
        return (react_1.default.createElement("div", { className: utils_1.cn('plain-text-option', { selected: this.props.selected }), onMouseDown: this.onClick }, this.props.text));
    }
}


/***/ }),

/***/ 645:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(0));
const prop_types_1 = __importDefault(__webpack_require__(1));
const react_dom_1 = __webpack_require__(18);
const antd_1 = __webpack_require__(117);
const ts_utils_1 = __webpack_require__(12);
const react_dnd_1 = __webpack_require__(515);
const command_1 = __webpack_require__(43);
const utils_1 = __webpack_require__(4);
var ItemTypes;
(function (ItemTypes) {
    ItemTypes["Command"] = "command";
})(ItemTypes || (ItemTypes = {}));
class InternalCommandItem extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.onClick = (e) => {
            this.props.onClick(e, this.props.command);
        };
        this.onContextMenu = (e) => {
            this.props.onContextMenu(e, this.props.command);
        };
    }
    render() {
        const { index, command, editable, isDragging, connectDropTarget, connectDragSource } = this.props;
        const decorate = ts_utils_1.compose(connectDragSource, connectDropTarget);
        const hasDescription = command.description && command.description.length > 0;
        return decorate(react_1.default.createElement("div", Object.assign({}, this.props.attributes, { style: this.props.style, className: utils_1.cn(this.props.className || '', { dragging: isDragging }), onClick: this.onClick, onContextMenu: this.onContextMenu }),
            react_1.default.createElement("div", { className: "row-col index-col" }, index),
            react_1.default.createElement("div", { className: "row-col command-col", title: command_1.commandText(command.cmd) },
                ts_utils_1.repeatStr(command.indent * 2, '\u00A0'),
                command_1.commandText(command.cmd)),
            react_1.default.createElement("div", { className: "row-col target-col", title: command.target, onMouseEnter: (e) => this.props.onMouseEnterTarget(e, command), onMouseLeave: (e) => this.props.onMouseLeaveTarget(e, command) }, command.target),
            react_1.default.createElement("div", { className: "row-col value-col", title: command.value }, command.value),
            react_1.default.createElement("div", { className: "row-col op-col" },
                hasDescription ? (react_1.default.createElement(antd_1.Tooltip, { title: command.description },
                    react_1.default.createElement(antd_1.Button, { disabled: !editable, type: "primary", shape: "circle", size: "small", onClick: (e) => {
                            this.props.onToggleComment(e, command);
                            e.stopPropagation();
                        } }, "//"))) : (react_1.default.createElement(antd_1.Button, { disabled: !editable, shape: "circle", size: "small", onClick: (e) => {
                        this.props.onToggleComment(e, command);
                        e.stopPropagation();
                    } }, "//")),
                react_1.default.createElement(antd_1.Button, { disabled: !editable, shape: "circle", size: "small", onClick: (e) => {
                        this.props.onDuplicate(e, command);
                        e.stopPropagation();
                    } },
                    react_1.default.createElement(antd_1.Icon, { type: "plus" })))));
    }
}
InternalCommandItem.propTypes = {
    style: prop_types_1.default.object,
    className: prop_types_1.default.string,
    attributes: prop_types_1.default.object,
    command: prop_types_1.default.object.isRequired,
    editable: prop_types_1.default.bool.isRequired,
    onClick: prop_types_1.default.func.isRequired,
    onContextMenu: prop_types_1.default.func.isRequired,
    onMouseEnterTarget: prop_types_1.default.func.isRequired,
    onMouseLeaveTarget: prop_types_1.default.func.isRequired,
    onToggleComment: prop_types_1.default.func.isRequired,
    onDuplicate: prop_types_1.default.func.isRequired,
    onMoveCommand: prop_types_1.default.func.isRequired,
    onDragStart: prop_types_1.default.func.isRequired,
    onDragEnd: prop_types_1.default.func.isRequired
};
InternalCommandItem.defaultProps = {
    style: {},
    attributes: {},
    className: ''
};
exports.CommandItem = ts_utils_1.compose(react_dnd_1.DragSource(ItemTypes.Command, {
    beginDrag: (props) => {
        return {
            index: props.command.realIndex
        };
    },
    isDragging: (props, monitor) => {
        return monitor.getItem().index === props.command.realIndex;
    }
}, (connect, monitor) => ({
    connectDragSource: connect.dragSource(),
    isDragging: monitor.isDragging()
})), react_dnd_1.DropTarget(ItemTypes.Command, {
    hover: (props, monitor, component) => {
        if (!component) {
            return;
        }
        const dragIndex = monitor.getItem().index;
        const hoverIndex = props.command.realIndex;
        if (dragIndex === hoverIndex) {
            return;
        }
        const hoverBoundingRect = react_dom_1.findDOMNode(component).getBoundingClientRect();
        const halfHeight = hoverBoundingRect.height / 2;
        const clientOffset = monitor.getClientOffset();
        if (!clientOffset) {
            return;
        }
        const yInElement = clientOffset.y - hoverBoundingRect.top;
        // Only perform the move when the mouse has crossed half of the items height
        // When dragging downwards, only move when the cursor is below 50%
        // When dragging upwards, only move when the cursor is above 50%
        // Dragging downwards
        if (dragIndex < hoverIndex && yInElement < halfHeight) {
            return;
        }
        // Dragging upwards
        if (dragIndex > hoverIndex && yInElement > halfHeight) {
            return;
        }
        props.onMoveCommand(dragIndex, hoverIndex);
        // Note: we're mutating the monitor item here!
        // Generally it's better to avoid mutations,
        // but we don't have id for command, so have to update index here
        monitor.getItem().index = hoverIndex;
    }
}, (connect) => ({
    connectDropTarget: connect.dropTarget()
})))(InternalCommandItem);


/***/ }),

/***/ 646:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(0));
const antd_1 = __webpack_require__(117);
const storage_1 = __webpack_require__(76);
class CsvList extends react_1.default.PureComponent {
    render() {
        const columns = [
            {
                title: 'Name',
                dataIndex: 'name',
                key: 'name'
            },
            {
                title: 'Size',
                dataIndex: 'size',
                key: 'size',
                render: (d) => {
                    return storage_1.readableSize(d);
                }
            },
            {
                title: 'Last Modified',
                dataIndex: 'createTime',
                key: 'createTime',
                render: (d) => {
                    const pad = (n) => n >= 10 ? ('' + n) : ('0' + n);
                    return `${d.getFullYear()}/${pad(d.getMonth() + 1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
                }
            },
            {
                title: 'Action',
                key: 'ops',
                width: 100,
                render: (text, csv, index) => {
                    return (react_1.default.createElement("div", null,
                        react_1.default.createElement(antd_1.Button, { size: "small", shape: "circle", onClick: (ev) => {
                                this.props.viewCSV(csv);
                            } },
                            react_1.default.createElement(antd_1.Icon, { type: "eye-o" })),
                        react_1.default.createElement(antd_1.Button, { size: "small", type: "primary", shape: "circle", onClick: () => {
                                this.props.downloadCSV(csv);
                            } },
                            react_1.default.createElement(antd_1.Icon, { type: "download" })),
                        react_1.default.createElement(antd_1.Popconfirm, { title: "Sure to delete?", okText: "Delete", onConfirm: () => { this.props.removeCSV(csv); } },
                            react_1.default.createElement(antd_1.Button, { size: "small", type: "danger", shape: "circle" },
                                react_1.default.createElement(antd_1.Icon, { type: "close" })))));
                }
            }
        ];
        const tableConfig = {
            columns,
            dataSource: this.props.list,
            pagination: false,
            bordered: true,
            size: 'middle',
            rowKey: 'fullPath',
            onRowClick: () => {
                // Do nothing
            },
            rowClassName: () => {
                return '';
            }
        };
        return react_1.default.createElement(antd_1.Table, Object.assign({}, tableConfig));
    }
}
exports.CsvList = CsvList;


/***/ }),

/***/ 647:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(0));
const antd_1 = __webpack_require__(117);
const lazy_image_1 = __webpack_require__(620);
const edit_in_place_1 = __importDefault(__webpack_require__(619));
const storage_1 = __webpack_require__(13);
class VisionList extends react_1.default.PureComponent {
    render() {
        if (!this.props.intersectRoot) {
            return null;
        }
        const columns = [
            {
                title: 'Image',
                dataIndex: 'fullPath',
                key: 'fullPath',
                width: 116,
                render: (fullPath) => {
                    return (react_1.default.createElement(lazy_image_1.LazyImage, { type: 'vision', root: this.props.intersectRoot, width: 100, height: 100, defaultUrl: "", getUrl: () => {
                            return storage_1.getStorageManager().getVisionStorage().getLink(fullPath);
                        } }));
                }
            },
            {
                title: 'Name',
                dataIndex: 'name',
                key: 'name',
                render: (name, vision) => {
                    return (react_1.default.createElement("div", { className: "vision-name-1", id: name },
                        react_1.default.createElement(edit_in_place_1.default, { value: vision.name, onChange: (name) => {
                                return Promise.resolve(this.props.renameVision(vision.name, name));
                            }, checkValue: (name) => {
                                return this.props.isNameValid(name);
                            }, getSelection: (name, $input) => {
                                const reg = /(?:_dpi_\d+)?\.png$/i;
                                const result = reg.exec(name);
                                if (!result) {
                                    return null;
                                }
                                const endIndex = result.index;
                                return {
                                    start: 0,
                                    end: endIndex
                                };
                            } })));
                }
            },
            {
                title: 'Action',
                key: 'ops',
                width: 100,
                render: (text, vision, index) => {
                    return (react_1.default.createElement("div", { className: "vision-actions" },
                        react_1.default.createElement(antd_1.Button, { size: "small", shape: "circle", onClick: (ev) => {
                                this.props.viewVision(vision.name);
                            } },
                            react_1.default.createElement(antd_1.Icon, { type: "eye-o" })),
                        react_1.default.createElement(antd_1.Dropdown, { overlay: react_1.default.createElement(antd_1.Menu, { onClick: ({ key }) => {
                                    switch (key) {
                                        case 'duplicate':
                                            return this.props.duplicateVision(vision.name);
                                        case 'name_to_target':
                                            return this.props.copyNameToTarget(vision.name);
                                        case 'delete':
                                            return this.props.deleteVision(vision.name);
                                    }
                                } },
                                react_1.default.createElement(antd_1.Menu.Item, { key: "duplicate" }, "Duplicate"),
                                react_1.default.createElement(antd_1.Menu.Item, { key: "name_to_target" }, "Add name to target box"),
                                react_1.default.createElement(antd_1.Menu.Divider, null),
                                react_1.default.createElement(antd_1.Menu.Item, { key: "delete" }, "Delete")) },
                            react_1.default.createElement(antd_1.Button, { size: "small", shape: "circle" },
                                react_1.default.createElement(antd_1.Icon, { type: "bars" })))));
                }
            }
        ];
        const search = (this.props.query || '').toLowerCase().trim();
        const matchedVisions = this.props.visions.filter(vision => {
            if (search.length === 0)
                return true;
            return vision.name.toLowerCase().indexOf(search) !== -1;
        });
        const tableConfig = {
            columns,
            dataSource: matchedVisions,
            pagination: false,
            bordered: true,
            size: 'middle',
            rowKey: (record) => {
                return record.fullPath + '__' + record.createTime.getTime();
            },
            onRowClick: () => {
                // Do nothing
            },
            rowClassName: () => {
                return '';
            }
        };
        return react_1.default.createElement(antd_1.Table, Object.assign({}, tableConfig));
    }
}
exports.VisionList = VisionList;


/***/ }),

/***/ 648:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(0));
const lazy_image_1 = __webpack_require__(620);
const storage_1 = __webpack_require__(13);
class ScreenshotList extends react_1.default.PureComponent {
    render() {
        return (react_1.default.createElement("ul", { className: "screenshot-content" }, this.props.screenshots.map((ss, i) => (react_1.default.createElement("li", { key: ss.createTime + '_' + ss.createTime },
            react_1.default.createElement("span", { className: "timestamp" },
                ss.createTime && ss.createTime.toLocaleString(),
                " - ",
                react_1.default.createElement("span", { className: "filename" }, decodeURIComponent(ss.name))),
            react_1.default.createElement("a", { href: "#", onClick: e => {
                    e.preventDefault();
                    this.props.downloadScreenshot(ss.name, ss.fullPath);
                } },
                react_1.default.createElement(lazy_image_1.LazyImage, { type: 'screenshot', root: this.props.intersectRoot, width: 200, height: 200, defaultUrl: "", getUrl: () => {
                        return storage_1.getStorageManager().getScreenshotStorage().getLink(ss.fullPath);
                    } })))))));
    }
}
exports.ScreenshotList = ScreenshotList;


/***/ }),

/***/ 69:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stringifyTestSuite", function() { return stringifyTestSuite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseTestSuite", function() { return parseTestSuite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateTestSuiteText", function() { return validateTestSuiteText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toBookmarkData", function() { return toBookmarkData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toHtml", function() { return toHtml; });
/* harmony import */ var error_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(108);
/* harmony import */ var error_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(error_polyfill__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var parse_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66);
/* harmony import */ var parse_json__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(parse_json__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _services_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
/* harmony import */ var _services_storage__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_services_storage__WEBPACK_IMPORTED_MODULE_3__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };






var stringifyTestSuite = function stringifyTestSuite(testSuite) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var obj = _extends({
    creationDate: Object(_utils__WEBPACK_IMPORTED_MODULE_2__["formatDate"])(new Date()),
    name: testSuite.name,
    macros: testSuite.cases.map(function (item) {
      var loops = parseInt(item.loops, 10);

      return {
        macro: item.testCaseId,
        loops: loops
      };
    })
  }, opts.withFold ? { fold: !!testSuite.fold } : {}, opts.withId && testSuite.id ? { id: testSuite.id } : {}, opts.withPlayStatus && testSuite.playStatus ? { playStatus: testSuite.playStatus } : {});

  return JSON.stringify(obj, null, 2);
};

var parseTestSuite = function parseTestSuite(text) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // Note: Exported JSON from older version Kantu (via 'export to json')
  // has an invisible charactor (char code65279, known as BOM). It breaks JSON parser.
  // So it's safer to filter it out here
  var obj = parse_json__WEBPACK_IMPORTED_MODULE_1___default()(text.replace(/^\s*/, ''));

  if (typeof obj.name !== 'string' || obj.name.length === 0) {
    throw new Error('name must be a string');
  }

  if (!Array.isArray(obj.macros)) {
    throw new Error('macros must be an array');
  }

  var cases = obj.macros.map(function (item) {
    if (typeof item.loops !== 'number' || item.loops < 1) {
      item.loops = 1;
    }

    return {
      testCaseId: item.macro,
      loops: item.loops
    };
  });

  var ts = _extends({
    cases: cases,
    name: opts.fileName ? opts.fileName.replace(/\.json$/i, '') : obj.name
  }, opts.withFold ? { fold: obj.fold === undefined ? true : obj.fold } : {}, opts.withId && obj.id ? { id: obj.id } : {}, opts.withPlayStatus && obj.playStatus ? { playStatus: obj.playStatus } : {});

  return ts;
};

var validateTestSuiteText = parseTestSuite;

var toBookmarkData = function toBookmarkData(obj) {
  var name = obj.name,
      bookmarkTitle = obj.bookmarkTitle;


  if (!name) throw new Error('name is required to generate bookmark for test suite');
  if (!bookmarkTitle) throw new Error('bookmarkTitle is required to generate bookmark for test suite');

  return {
    title: bookmarkTitle,
    url: ('javascript:\n      (function() {\n        try {\n          var evt = new CustomEvent(\'kantuRunTestSuite\', {\n            detail: {\n              name: \'' + name + '\',\n              from: \'bookmark\',\n              storageMode: \'' + Object(_services_storage__WEBPACK_IMPORTED_MODULE_3__["getStorageManager"])().getCurrentStrategyType() + '\',\n              closeRPA: 1\n            }\n          });\n          window.dispatchEvent(evt);\n        } catch (e) {\n          alert(\'UI.Vision RPA Bookmarklet error: \' + e.toString());\n        }\n      })();\n    ').replace(/\n\s*/g, '')
  };
};

var toHtml = function toHtml(_ref) {
  var name = _ref.name;

  return '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">\n<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">\n<head>\n<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />\n<title>' + name + '</title>\n</head>\n<body>\n<h1>' + name + '</h1>\n<script>\n(function() {\n  var isExtensionLoaded = function () {\n    const $root = document.documentElement\n    return !!$root && !!$root.getAttribute(\'data-kantu\')\n  }\n  var increaseCountInUrl = function (max) {\n    var url   = new URL(window.location.href)\n    var count = 1 + (url.searchParams.get(\'reload\') || 0)\n\n    url.searchParams.set(\'reload\', count)\n    var nextUrl = url.toString()\n\n    var shouldStop = count > max\n    return [shouldStop, !shouldStop ? nextUrl : null]\n  }\n  var run = function () {\n    try {\n      var evt = new CustomEvent(\'kantuRunTestSuite\', { detail: { name: \'' + name + '\', from: \'html\', storageMode: \'' + Object(_services_storage__WEBPACK_IMPORTED_MODULE_3__["getStorageManager"])().getCurrentStrategyType() + '\' } })\n\n      window.dispatchEvent(evt)\n      var intervalTimer = setInterval(() => window.dispatchEvent(evt), 1000);\n\n      if (window.location.protocol === \'file:\') {\n        var onInvokeSuccess = function () {\n          clearTimeout(timer)\n          clearTimeout(reloadTimer)\n          clearInterval(intervalTimer)\n          window.removeEventListener(\'kantuInvokeSuccess\', onInvokeSuccess)\n        }\n        var timer = setTimeout(function () {\n          alert(\'Error #201: It seems you need to turn on *Allow access to file URLs* for Kantu in your browser extension settings.\')\n        }, 8000)\n\n        window.addEventListener(\'kantuInvokeSuccess\', onInvokeSuccess)\n      }\n    } catch (e) {\n      alert(\'UI.Vision RPA Bookmarklet error: \' + e.toString());\n    }\n  }\n  var main = function () {\n    if (isExtensionLoaded())  return run()\n\n    var MAX_TRY   = 3\n    var INTERVAL  = 1000\n    var tuple     = increaseCountInUrl(MAX_TRY)\n\n    if (tuple[0]) {\n      return alert(\'Error #202: It seems UI.Vision RPA is not installed yet, *or* you need to turn on *Allow access to file URLs* for UI.Vision RPA.\')\n    } else {\n      setTimeout(function () {\n        window.location.href = tuple[1]\n      }, INTERVAL)\n    }\n  }\n\n  main()\n})();\n</script>\n</body>\n</html>\n  ';
};

/***/ }),

/***/ 70:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.2
 * 2016-06-16 18:25:19
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || function (view) {
	"use strict";
	// IE <10 is explicitly unsupported

	if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var doc = view.document
	// only get URL when necessary in case Blob.js hasn't overridden it yet
	,
	    get_URL = function get_URL() {
		return view.URL || view.webkitURL || view;
	},
	    is_firefox_extension = window.location.protocol === 'moz-extension:',
	    create_link_for_ff_ext = function create_link_for_ff_ext() {
		// Temporary fix for firefox extension on Mac / Linux
		// reference: https://bugzilla.mozilla.org/show_bug.cgi?format=default&id=1420419
		var iframeId = 'downloadFrame';
		var $iframe = doc.createElementNS("http://www.w3.org/1999/xhtml", "iframe");

		$iframe.id = iframeId;
		$iframe.style.visibility = 'hidden';
		$iframe.style.position = 'absolute';
		$iframe.style.left = '-999px';
		doc.body.appendChild($iframe);

		var link = $iframe.contentDocument.createElement('a');

		// wait for next tick when iframe is already in document,
		// otherwise link won't be add to body of iframe
		setTimeout(function () {
			$iframe.contentDocument.body.appendChild(link);
		});

		return link;
	},
	    save_link = is_firefox_extension ? create_link_for_ff_ext() : doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
	    can_use_save_link = "download" in save_link,
	    click = function click(node) {
		var event = new MouseEvent("click");
		node.dispatchEvent(event);
	},
	    is_safari = /constructor/i.test(view.HTMLElement) || view.safari,
	    is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent),
	    throw_outside = function throw_outside(ex) {
		(view.setImmediate || view.setTimeout)(function () {
			throw ex;
		}, 0);
	},
	    force_saveable_type = "application/octet-stream"
	// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
	,
	    arbitrary_revoke_timeout = 1000 * 40 // in ms
	,
	    revoke = function revoke(file) {
		var revoker = function revoker() {
			if (typeof file === "string") {
				// file is an object URL
				get_URL().revokeObjectURL(file);
			} else {
				// file is a File
				file.remove();
			}
		};
		setTimeout(revoker, arbitrary_revoke_timeout);
	},
	    dispatch = function dispatch(filesaver, event_types, event) {
		event_types = [].concat(event_types);
		var i = event_types.length;
		while (i--) {
			var listener = filesaver["on" + event_types[i]];
			if (typeof listener === "function") {
				try {
					listener.call(filesaver, event || filesaver);
				} catch (ex) {
					throw_outside(ex);
				}
			}
		}
	},
	    auto_bom = function auto_bom(blob) {
		// prepend BOM for UTF-8 XML and text/* types (including HTML)
		// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
		if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
			return new Blob([String.fromCharCode(0xFEFF), blob], { type: blob.type });
		}
		return blob;
	},
	    FileSaver = function FileSaver(blob, name, no_auto_bom) {
		if (!no_auto_bom) {
			blob = auto_bom(blob);
		}
		// First try a.download, then web filesystem, then object URLs
		var filesaver = this,
		    type = blob.type,
		    force = type === force_saveable_type,
		    object_url,
		    dispatch_all = function dispatch_all() {
			dispatch(filesaver, "writestart progress write writeend".split(" "));
		}
		// on any filesys errors revert to saving with object URLs
		,
		    fs_error = function fs_error() {
			if ((is_chrome_ios || force && is_safari) && view.FileReader) {
				// Safari doesn't allow downloading of blob urls
				var reader = new FileReader();
				reader.onloadend = function () {
					var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
					var popup = view.open(url, '_blank');
					if (!popup) view.location.href = url;
					url = undefined; // release reference before dispatching
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
				};
				reader.readAsDataURL(blob);
				filesaver.readyState = filesaver.INIT;
				return;
			}
			// don't create more object URLs than needed
			if (!object_url) {
				object_url = get_URL().createObjectURL(blob);
			}
			if (force) {
				view.location.href = object_url;
			} else {
				var opened = view.open(object_url, "_blank");
				if (!opened) {
					// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
					view.location.href = object_url;
				}
			}
			filesaver.readyState = filesaver.DONE;
			dispatch_all();
			revoke(object_url);
		};
		filesaver.readyState = filesaver.INIT;

		if (can_use_save_link) {
			object_url = get_URL().createObjectURL(blob);
			setTimeout(function () {
				save_link.href = object_url;
				save_link.download = name;
				click(save_link);
				dispatch_all();
				revoke(object_url);
				filesaver.readyState = filesaver.DONE;
			});
			return;
		}

		fs_error();
	},
	    FS_proto = FileSaver.prototype,
	    saveAs = function saveAs(blob, name, no_auto_bom) {
		return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
	};
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function (blob, name, no_auto_bom) {
			name = name || blob.name || "download";

			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}

	FS_proto.abort = function () {};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;

	return saveAs;
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content);
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if ( true && module.exports) {
	module.exports.saveAs = saveAs;
} else if ( true && __webpack_require__(551) !== null && __webpack_require__(433) !== null) {
	!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
		return saveAs;
	}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}

/***/ }),

/***/ 71:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(0));
const react_dom_1 = __importDefault(__webpack_require__(18));
const prop_types_1 = __importDefault(__webpack_require__(1));
const antd_1 = __webpack_require__(117);
const react_click_outside_1 = __importDefault(__webpack_require__(406));
const ts_utils_1 = __webpack_require__(12);
var MenuItemType;
(function (MenuItemType) {
    MenuItemType["Divider"] = "divider";
    MenuItemType["Button"] = "button";
})(MenuItemType = exports.MenuItemType || (exports.MenuItemType = {}));
var ContextMenuDisplayStatus;
(function (ContextMenuDisplayStatus) {
    ContextMenuDisplayStatus[ContextMenuDisplayStatus["Hidden"] = 0] = "Hidden";
    ContextMenuDisplayStatus[ContextMenuDisplayStatus["Transparent"] = 1] = "Transparent";
    ContextMenuDisplayStatus[ContextMenuDisplayStatus["Visible"] = 2] = "Visible";
})(ContextMenuDisplayStatus = exports.ContextMenuDisplayStatus || (exports.ContextMenuDisplayStatus = {}));
class ContextMenu extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.$container = null;
        this.state = {
            isCollectingSize: false,
            status: ContextMenuDisplayStatus.Transparent,
            size: {
                width: 0,
                height: 0
            }
        };
        this.hide = () => {
            this.props.onHide();
        };
        this.onClick = (e) => {
            const found = this.findMenuItem(e.key);
            if (!found) {
                return;
            }
            switch (found.type) {
                case MenuItemType.Button: {
                    const { context, onClick } = found.data;
                    try {
                        onClick(e.domEvent, context);
                    }
                    catch (e) {
                        console.warn(e);
                    }
                    finally {
                        this.hide();
                    }
                    break;
                }
                case MenuItemType.Divider:
                default:
                    break;
            }
        };
    }
    findMenuItem(menuItemId) {
        return this.props.menuItems.find((item, i) => this.getId(item, i) === menuItemId);
    }
    getId(menuItem, index) {
        return menuItem.id + '_' + index;
    }
    getContextMenuStyle() {
        const { status } = this.state;
        const common = {
            position: 'fixed'
        };
        const byStatus = (() => {
            switch (status) {
                case ContextMenuDisplayStatus.Hidden:
                    return {
                        display: 'none'
                    };
                case ContextMenuDisplayStatus.Transparent: {
                    return {
                        top: 0,
                        left: 0,
                        visibility: 'hidden'
                    };
                }
                case ContextMenuDisplayStatus.Visible: {
                    const leftTopPoint = ts_utils_1.pointToFitRect({
                        bound: {
                            x: 0,
                            y: 0,
                            width: window.innerWidth,
                            height: window.innerHeight
                        },
                        size: this.state.size,
                        point: {
                            x: this.props.x,
                            y: this.props.y
                        }
                    });
                    return {
                        top: leftTopPoint.y + 'px',
                        left: leftTopPoint.x + 'px',
                    };
                }
            }
        })();
        return Object.assign(Object.assign({}, common), byStatus);
    }
    collectSize() {
        this.setState({
            isCollectingSize: true
        });
        setTimeout(() => {
            if (!this.$container) {
                return;
            }
            this.setState({
                isCollectingSize: false,
                status: ContextMenuDisplayStatus.Visible,
                size: {
                    width: this.$container.offsetWidth,
                    height: this.$container.offsetHeight
                }
            });
        }, 100);
    }
    componentDidMount() {
        if (!this.state.isCollectingSize && this.state.status === ContextMenuDisplayStatus.Transparent) {
            this.collectSize();
        }
    }
    render() {
        return (react_1.default.createElement("div", { ref: (ref) => { this.$container = ref; }, style: this.getContextMenuStyle(), className: "context-menu" },
            react_1.default.createElement(react_click_outside_1.default, { onClickOutside: this.hide },
                react_1.default.createElement(antd_1.Menu, { onClick: this.onClick, style: { width: this.props.width + 'px' }, mode: "vertical", selectable: false }, this.props.menuItems.map((item, i) => {
                    switch (item.type) {
                        case MenuItemType.Divider:
                            return react_1.default.createElement(antd_1.Menu.Divider, { key: this.getId(item, i) });
                        case MenuItemType.Button:
                            return (react_1.default.createElement(antd_1.Menu.Item, { key: this.getId(item, i), disabled: !!item.disabled }, item.data.content));
                        default:
                            return null;
                    }
                })))));
    }
}
exports.ContextMenu = ContextMenu;
ContextMenu.propTypes = {
    menuItems: prop_types_1.default.array.isRequired,
    onHide: prop_types_1.default.func.isRequired,
    width: prop_types_1.default.number
};
ContextMenu.defaultProps = {
    width: 230
};
function getContainer() {
    const id = '__kantu_context_menus__';
    const $el = document.getElementById(id);
    if ($el)
        return $el;
    const $new = document.createElement('div');
    $new.id = id;
    document.body.appendChild($new);
    return $new;
}
function showContextMenu(props) {
    const $box = document.createElement('div');
    getContainer().appendChild($box);
    // Delay 20ms is for firefox
    setTimeout(() => {
        react_dom_1.default.render(react_1.default.createElement(ContextMenu, Object.assign({}, props, { onHide: () => {
                setTimeout(() => {
                    $box.remove();
                });
                props.onHide();
            } })), $box);
    }, 20);
}
exports.showContextMenu = showContextMenu;


/***/ }),

/***/ 74:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(90);
const desktop_1 = __webpack_require__(91);
const ts_utils_1 = __webpack_require__(12);
class XDesktop extends common_1.XModule {
    getName() {
        return common_1.XModuleTypes.XDesktop;
    }
    getAPI() {
        return desktop_1.getNativeCVAPI();
    }
    initConfig() {
        return this.getConfig();
    }
    sanityCheck() {
        return Promise.all([
            this.getConfig(),
            this.getAPI().getVersion()
                .then(() => this.getAPI(), () => this.getAPI().reconnect())
                .catch(e => {
                throw new Error('Error #301: Visual Desktop Automation XModule is not installed yet');
            })
        ])
            .then(() => true);
    }
    checkUpdate() {
        return Promise.reject(new Error('checkUpdate is not implemented yet'));
    }
    checkUpdateLink(modVersion, extVersion) {
        return `https://ui.vision/x/idehelp?help=xdesktop_updatecheck&xversion=${modVersion}&kantuversion=${extVersion}`;
    }
    downloadLink() {
        return 'https://ui.vision/x/idehelp?help=xdesktop_download';
    }
    infoLink() {
        return 'https://ui.vision/x/idehelp?help=xdesktop';
    }
}
exports.XDesktop = XDesktop;
exports.getXDesktop = ts_utils_1.singletonGetter(() => {
    return new XDesktop();
});


/***/ }),

/***/ 75:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(90);
const ts_utils_1 = __webpack_require__(12);
const screen_capture_1 = __webpack_require__(359);
class XScreenCapture extends common_1.XModule {
    getName() {
        return common_1.XModuleTypes.XScreenCapture;
    }
    getAPI() {
        return screen_capture_1.getNativeScreenCapture();
    }
    initConfig() {
        return this.getConfig();
    }
    sanityCheck() {
        return Promise.all([
            this.getConfig(),
            this.getAPI().getVersion()
                .catch(e => {
                throw new Error('Error #301: Screen Capture XModule is not installed yet');
            })
        ])
            .then(() => true);
    }
    checkUpdate() {
        return Promise.reject(new Error('checkUpdate is not implemented yet'));
    }
    checkUpdateLink(modVersion, extVersion) {
        return `https://ui.vision/x/idehelp?help=xscreencapture_updatecheck&xversion=${modVersion}&kantuversion=${extVersion}`;
    }
    downloadLink() {
        return 'https://ui.vision/x/idehelp?help=xscreencapture_download';
    }
    infoLink() {
        return 'https://ui.vision/x/idehelp?help=xscreencapture';
    }
}
exports.XScreenCapture = XScreenCapture;
exports.getXScreenCapture = ts_utils_1.singletonGetter(() => {
    return new XScreenCapture();
});


/***/ }),

/***/ 76:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const eventemitter3_1 = __importDefault(__webpack_require__(81));
const debounce = __webpack_require__(79);
const utils_1 = __webpack_require__(4);
const ts_utils_1 = __webpack_require__(12);
var FlatStorageEvent;
(function (FlatStorageEvent) {
    FlatStorageEvent["ListChanged"] = "list_changed";
    FlatStorageEvent["FilesChanged"] = "files_changed";
})(FlatStorageEvent = exports.FlatStorageEvent || (exports.FlatStorageEvent = {}));
class FlatStorage extends eventemitter3_1.default {
    constructor(options = {}) {
        super();
        this.encode = (x, fileName) => x;
        this.decode = (x, fileName) => x;
        // Q: Why do we need debounce for followingemitXXX?
        // A: So that there could be more than 1 invocation of emitXXX in one operation
        //    And it will just emit once. For downstream like React / Vue, it won't trigger
        //    unnecessary render
        // Note: list changed event is for move (rename) / remove / clear / write a new file
        this.emitListChanged = debounce(() => {
            this.list()
                .then(fileInfos => {
                this.emit(FlatStorageEvent.ListChanged, fileInfos);
            });
        }, 100);
        this.changedFileNames = [];
        this.__emitFilesChanged = debounce(() => {
            const fileNames = this.changedFileNames;
            // Note: clear changedFileNames right after this method is called,
            // instead of waiting till promise resolved
            // so that new file changes won't be blocked or affect current emit
            this.changedFileNames = [];
            return Promise.all(fileNames.map(fileName => {
                return this.read(fileName, 'Text')
                    .catch(() => null);
            }))
                .then(contents => {
                if (contents.length === 0)
                    return;
                // Note: in case some files don't exist any more, filter by content
                const changedFiles = contents.map((content, i) => ({
                    content,
                    fileName: fileNames[i]
                }))
                    .filter(item => !!item.content);
                this.emit(FlatStorageEvent.FilesChanged, changedFiles);
            });
        }, 100);
        if (options.decode) {
            this.decode = options.decode;
        }
        if (options.encode) {
            this.encode = options.encode;
        }
    }
    list() {
        return this.__list()
            .then(items => {
            items.sort((a, b) => {
                const aFileName = a.fileName.toLowerCase();
                const bFileName = b.fileName.toLowerCase();
                if (aFileName < bFileName)
                    return -1;
                if (aFileName > bFileName)
                    return 1;
                return 0;
            });
            return items;
        });
    }
    readAll(readFileType = 'Text', onErrorFiles) {
        return this.list()
            .then(items => {
            return Promise.all(items.map(item => {
                return this.read(item.fileName, readFileType)
                    .then(content => ({
                    content,
                    fileName: item.fileName
                }));
            }));
        });
    }
    bulkWrite(list) {
        return Promise.all(list.map(item => this.write(item.fileName, item.content)))
            .then(() => { });
    }
    write(fileName, content) {
        return this.exists(fileName)
            .then(isExist => {
            const next = () => {
                if (!isExist)
                    this.emitListChanged();
                this.emitFilesChanged([fileName]);
            };
            return this.__write(fileName, content)
                .then(next);
        });
    }
    overwrite(fileName, content) {
        return this.__overwrite(fileName, content)
            .then(() => {
            this.emitFilesChanged([fileName]);
        });
    }
    clear() {
        return this.__clear()
            .then(() => {
            this.emitListChanged();
        });
    }
    remove(fileName) {
        return this.__remove(fileName)
            .then(() => {
            this.emitListChanged();
        });
    }
    rename(fileName, newName) {
        return this.__rename(fileName, newName)
            .then(() => {
            this.emitListChanged();
            this.emitFilesChanged([newName]);
        });
    }
    copy(fileName, newName) {
        const pName = newName && newName.length
            ? Promise.resolve(newName)
            : ts_utils_1.uniqueName(fileName, {
                generate: (old, step = 1) => {
                    const reg = /-(\d+)$/;
                    const m = old.match(reg);
                    if (!m)
                        return `${old}-${step}`;
                    return old.replace(reg, (_, n) => `-${parseInt(n, 10) + step}`);
                },
                check: (fileName) => {
                    return this.exists(fileName).then(exists => !exists);
                },
                postfixReg: /(_relative)?\.\w+$/
            });
        return pName.then(name => {
            return this.__copy(fileName, name)
                .then(() => {
                this.emitListChanged();
                this.emitFilesChanged([name]);
            });
        });
    }
    // Note: files changed event is for write file only  (rename excluded)
    emitFilesChanged(fileNames) {
        this.changedFileNames = fileNames.reduce((prev, fileName) => {
            if (prev.indexOf(fileName) === -1)
                prev.push(fileName);
            return prev;
        }, this.changedFileNames);
        this.__emitFilesChanged();
    }
}
exports.FlatStorage = FlatStorage;
exports.readableSize = (byteSize) => {
    const kb = 1024;
    const mb = kb * kb;
    if (byteSize < kb) {
        return byteSize + ' byte';
    }
    if (byteSize < mb) {
        return (byteSize / kb).toFixed(1) + ' KB';
    }
    return (byteSize / mb).toFixed(1) + ' MB';
};
function checkFileName(fileName) {
    utils_1.withFileExtension(fileName, (baseName) => {
        try {
            utils_1.validateStandardName(baseName, true);
        }
        catch (e) {
            throw new Error(`Invalid file name '${fileName}'. File name ` + e.message);
        }
        return baseName;
    });
}
exports.checkFileName = checkFileName;


/***/ }),

/***/ 84:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LicenseType;
(function (LicenseType) {
    LicenseType["Enterprise"] = "ui-ee";
    LicenseType["Personal"] = "ui-personal";
    LicenseType["Player"] = "ui-player";
    LicenseType["Pro"] = "ui-pro";
})(LicenseType = exports.LicenseType || (exports.LicenseType = {}));
var Feature;
(function (Feature) {
    Feature[Feature["Replay"] = 0] = "Replay";
    Feature[Feature["Record"] = 1] = "Record";
    Feature[Feature["Edit"] = 2] = "Edit";
})(Feature = exports.Feature || (exports.Feature = {}));


/***/ }),

/***/ 87:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DesktopScreenshot;
(function (DesktopScreenshot) {
    let RequestType;
    (function (RequestType) {
        RequestType["DisplayVisualResult"] = "display_visual_result";
        RequestType["DisplayOcrResult"] = "display_ocr_result";
        RequestType["Capture"] = "capture";
    })(RequestType = DesktopScreenshot.RequestType || (DesktopScreenshot.RequestType = {}));
    let ImageSource;
    (function (ImageSource) {
        ImageSource[ImageSource["Storage"] = 0] = "Storage";
        ImageSource[ImageSource["HardDrive"] = 1] = "HardDrive";
        ImageSource[ImageSource["CV"] = 2] = "CV";
        ImageSource[ImageSource["DataUrl"] = 3] = "DataUrl";
    })(ImageSource = DesktopScreenshot.ImageSource || (DesktopScreenshot.ImageSource = {}));
    let RectType;
    (function (RectType) {
        RectType[RectType["Match"] = 0] = "Match";
        RectType[RectType["Reference"] = 1] = "Reference";
        RectType[RectType["BestMatch"] = 2] = "BestMatch";
        RectType[RectType["ReferenceOfBestMatch"] = 3] = "ReferenceOfBestMatch";
    })(RectType = DesktopScreenshot.RectType || (DesktopScreenshot.RectType = {}));
})(DesktopScreenshot = exports.DesktopScreenshot || (exports.DesktopScreenshot = {}));


/***/ }),

/***/ 88:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(90);
const xy_1 = __webpack_require__(58);
const ts_utils_1 = __webpack_require__(12);
class XUserIO extends common_1.XModule {
    getName() {
        return common_1.XModuleTypes.XUserIO;
    }
    getAPI() {
        return xy_1.getNativeXYAPI();
    }
    initConfig() {
        return this.getConfig();
    }
    sanityCheck() {
        return Promise.all([
            this.getConfig(),
            this.getAPI().getVersion()
                .then(() => this.getAPI(), () => this.getAPI().reconnect())
                .catch(e => {
                throw new Error('Error #301: RealUser Simulation XModule is not installed yet');
            })
        ])
            .then(() => true);
    }
    checkUpdate() {
        return Promise.reject(new Error('checkUpdate is not implemented yet'));
    }
    checkUpdateLink(modVersion, extVersion) {
        return `https://ui.vision/x/idehelp?help=xclick_updatecheck&xversion=${modVersion}&kantuversion=${extVersion}`;
    }
    downloadLink() {
        return 'https://ui.vision/x/idehelp?help=xclick_download';
    }
    infoLink() {
        return 'https://ui.vision/x/idehelp?help=xclick';
    }
}
exports.XUserIO = XUserIO;
exports.getXUserIO = ts_utils_1.singletonGetter(() => {
    return new XUserIO();
});


/***/ }),

/***/ 89:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const eventemitter3_1 = __importDefault(__webpack_require__(81));
const debounce = __webpack_require__(79);
const ts_utils_1 = __webpack_require__(12);
const path_1 = __webpack_require__(27);
const error_1 = __webpack_require__(122);
var StorageEvent;
(function (StorageEvent) {
    StorageEvent["ListChanged"] = "list_changed";
    StorageEvent["FilesChanged"] = "files_changed";
})(StorageEvent = exports.StorageEvent || (exports.StorageEvent = {}));
var EntryStatus;
(function (EntryStatus) {
    EntryStatus[EntryStatus["Unknown"] = 0] = "Unknown";
    EntryStatus[EntryStatus["NonExistent"] = 1] = "NonExistent";
    EntryStatus[EntryStatus["File"] = 2] = "File";
    EntryStatus[EntryStatus["Directory"] = 3] = "Directory";
})(EntryStatus = exports.EntryStatus || (exports.EntryStatus = {}));
class StandardStorage extends eventemitter3_1.default {
    constructor(options = {}) {
        super();
        this.encode = (x, fileName) => x;
        this.decode = (x, fileName) => x;
        this.displayedCount = 0;
        this.totalCount = 0;
        this.listFilter = (list) => list;
        // Q: Why do we need debounce for followingemitXXX?
        // A: So that there could be more than 1 invocation of emitXXX in one operation
        //    And it will just emit once. For downstream like React / Vue, it won't trigger
        //    unnecessary render
        // Note: list changed event is for move (rename) / remove / clear / write a new file
        this.emitListChanged = debounce(() => {
            // FIXME:
            this.list('/')
                .then(fileInfos => {
                this.emit(StorageEvent.ListChanged, fileInfos);
            });
        }, 100);
        this.changedFileNames = [];
        this.__emitFilesChanged = debounce(() => {
            const fileNames = this.changedFileNames;
            // Note: clear changedFileNames right after this method is called,
            // instead of waiting till promise resolved
            // so that new file changes won't be blocked or affect current emit
            this.changedFileNames = [];
            return Promise.all(fileNames.map(fileName => {
                return this.read(fileName, 'Text')
                    .catch(() => null);
            }))
                .then(contents => {
                if (contents.length === 0)
                    return;
                // Note: in case some files don't exist any more, filter by content
                const changedFiles = contents.map((content, i) => ({
                    content,
                    fileName: fileNames[i]
                }))
                    .filter(item => !!item.content);
                this.emit(StorageEvent.FilesChanged, changedFiles);
            });
        }, 100);
        if (options.decode) {
            this.decode = options.decode;
        }
        if (options.encode) {
            this.encode = options.encode;
        }
        if (options.listFilter) {
            this.listFilter = options.listFilter;
        }
    }
    getPathLib() {
        // Note: only subclass knows whether it should use win32/posix style path
        return this.isWin32Path() ? path_1.win32 : path_1.posix;
    }
    relativePath(entryPath, isDirectory) {
        const absPath = isDirectory ? this.dirPath(entryPath) : this.filePath(entryPath);
        const rootPath = this.dirPath('/');
        return this.getPathLib().relative(rootPath, absPath);
    }
    entryPath(entryPath, isDirectory) {
        return isDirectory ? this.dirPath(entryPath) : this.filePath(entryPath);
    }
    list(directoryPath = '/', brief = false) {
        return this.__list(directoryPath, brief)
            .then((items) => {
            return this.sortEntries(items);
        });
    }
    listR(directoryPath = '/') {
        const listDir = (dir) => {
            return this.list(dir, false)
                .then((entries) => {
                return Promise.all(entries.map((entry) => {
                    if (entry.isDirectory) {
                        return listDir(entry.fullPath);
                    }
                    return Promise.resolve(null);
                }))
                    .then((listOfEntries) => {
                    return this.sortEntries(entries.map((entry, i) => (Object.assign(Object.assign({}, entry), { children: listOfEntries[i] || [] }))));
                });
            });
        };
        return listDir(directoryPath)
            .then((entryNodes) => {
            if (directoryPath !== '/') {
                return entryNodes;
            }
            return Promise.resolve(this.listFilter(entryNodes))
                .then(displayEntryNodes => {
                this.totalCount = ts_utils_1.sum(...entryNodes.map(ts_utils_1.nodeCount));
                this.displayedCount = ts_utils_1.sum(...displayEntryNodes.map(ts_utils_1.nodeCount));
                return displayEntryNodes;
            });
        });
    }
    getDisplayCount() {
        return this.displayedCount;
    }
    getTotalCount() {
        return this.totalCount;
    }
    exists(path) {
        return this.stat(path)
            .then(({ isFile, isDirectory }) => isFile || isDirectory, () => false);
    }
    fileExists(path) {
        return this.stat(path)
            .then((entry) => entry.isFile, () => false);
    }
    directoryExists(path) {
        return this.stat(path, true)
            .then((entry) => {
            return entry.isDirectory;
        }, () => false);
    }
    readR(directoryPath, readFileType = 'Text', onErrorFiles) {
        return this.listR(directoryPath)
            .then((entryNodes) => {
            return Promise.all(entryNodes.map((node) => {
                if (node.isFile) {
                    return this.read(node.fullPath, readFileType)
                        .then((content) => [{
                            content: content,
                            filePath: node.fullPath
                        }]);
                }
                if (node.isDirectory) {
                    return this.readR(node.fullPath, readFileType);
                }
                throw new Error('Not file or directory');
            }))
                .then((result) => {
                return ts_utils_1.flatten(result);
            });
        });
    }
    write(fileName, content) {
        return this.exists(fileName)
            .then(isExist => {
            const next = () => {
                if (!isExist)
                    this.emitListChanged();
                this.emitFilesChanged([fileName]);
            };
            return this.__write(fileName, content)
                .then(next);
        });
    }
    overwrite(fileName, content) {
        return this.__overwrite(fileName, content)
            .then(() => {
            this.emitFilesChanged([fileName]);
        });
    }
    bulkWrite(list) {
        return Promise.all(list.map(item => this.write(item.filePath, item.content)))
            .then(() => { });
    }
    removeFile(filePath) {
        return this.__removeFile(filePath)
            .then(() => {
            this.emitListChanged();
        });
    }
    removeEmptyDirectory(directoryPath) {
        return this.__removeEmptyDirectory(directoryPath)
            .then(() => {
            this.emitListChanged();
        });
    }
    removeDirectory(directoryPath) {
        return this.remove(directoryPath, true);
    }
    remove(path, isDirectory) {
        return this.stat(path, isDirectory)
            .then((entry) => {
            if (entry.isFile) {
                return this.removeFile(entry.fullPath);
            }
            if (entry.isDirectory) {
                return this.list(entry.fullPath)
                    .then((entries) => {
                    return Promise.all(entries.map((item) => this.remove(item.fullPath, item.isDirectory)))
                        .then(() => this.removeEmptyDirectory(entry.fullPath));
                });
            }
            throw new Error('Not file or directory');
        });
    }
    clear() {
        return this.list('/')
            .then((entries) => {
            return Promise.all(entries.map((entry) => this.remove(entry.fullPath)))
                .then(() => { });
        });
    }
    moveFile(filePath, newPath) {
        return this.__moveFile(filePath, newPath)
            .then(() => {
            this.emitListChanged();
        });
    }
    copyFile(filePath, newPath) {
        return this.__copyFile(filePath, newPath)
            .then(() => {
            this.emitListChanged();
        });
    }
    moveDirectory(directoryPath, newPath) {
        return this.move(directoryPath, newPath, true, true);
    }
    copyDirectory(directoryPath, newPath) {
        return this.copy(directoryPath, newPath, true, true);
    }
    move(src, dst, isSourceDirectory, isTargetDirectory) {
        const absSrc = this.entryPath(src, isSourceDirectory);
        const absDst = this.entryPath(dst, isTargetDirectory);
        if (absSrc === absDst) {
            throw new Error('move: src should not be the same as dst');
        }
        if (this.getPathLib().dirname(absSrc) === absDst) {
            throw new Error('move: cannot move to original dir');
        }
        if (isSourceDirectory && isTargetDirectory && this.isTargetInSourceDirectory(dst, src)) {
            throw new Error('Cannot move a directory into its sub directory');
        }
        // It's slow to copy then remove. Subclass should definitely
        // override this method if it has native support for move operation
        return this.copy(src, dst, isSourceDirectory, isTargetDirectory)
            .then(() => this.remove(src, isSourceDirectory));
    }
    copy(src, dst, isSourceDirectory, isTargetDirectory) {
        const srcDir = this.getPathLib().dirname(src);
        const dstDir = this.getPathLib().dirname(dst);
        const isSameDir = srcDir === dstDir;
        if (src === dst) {
            throw new Error('copy: dst should not be the same as src');
        }
        return Promise.all([
            this.getEntryStatus(src, isSourceDirectory),
            this.getEntryStatus(dst, isTargetDirectory),
            isSameDir ? Promise.resolve(EntryStatus.Directory) : this.getEntryStatus(this.getPathLib().dirname(dst), true)
        ])
            .then((triple) => {
            const [srcStatus, dstStatus, dstDirStatus] = triple;
            if (dstDirStatus !== EntryStatus.Directory) {
                throw new error_1.ENOTDIR(this.getPathLib().dirname(dst));
            }
            switch (srcStatus) {
                case EntryStatus.NonExistent:
                    throw new error_1.ENOENT(src);
                case EntryStatus.Unknown:
                    throw new Error(`source (${src}) exists but is neither a file nor a directory`);
                case EntryStatus.File: {
                    switch (dstStatus) {
                        case EntryStatus.File:
                            throw new error_1.EEXIST(dst);
                        case EntryStatus.Unknown:
                            throw new Error(`dst '${dst}' is neither a file nor directory`);
                        case EntryStatus.Directory: {
                            const dstFilePath = this.getPathLib().resolve(dst, this.getPathLib().basename(src));
                            return this.copyFile(src, dstFilePath);
                        }
                        case EntryStatus.NonExistent: {
                            return this.copyFile(src, dst);
                        }
                    }
                }
                case EntryStatus.Directory: {
                    switch (dstStatus) {
                        case EntryStatus.File:
                            throw new Error(`dst '${dst}' is an existing file, but src '${src}' is a directory`);
                        case EntryStatus.Unknown:
                            throw new Error(`dst '${dst}' is neither a file nor directory`);
                        case EntryStatus.Directory: {
                            if (this.isTargetInSourceDirectory(dst, src)) {
                                throw new Error('Cannot copy a directory into its sub directory');
                            }
                            const dstDir = this.getPathLib().resolve(dst, this.getPathLib().basename(src));
                            return this.ensureDirectory(dstDir)
                                .then(() => this.copyAllInDirectory(src, dstDir));
                        }
                        case EntryStatus.NonExistent: {
                            return this.ensureDirectory(dst)
                                .then(() => this.copyAllInDirectory(src, dst));
                        }
                    }
                }
            }
        });
    }
    createDirectory(directoryPath) {
        return this.mkdir(directoryPath, false);
    }
    ensureDirectory(directoryPath) {
        return this.getEntryStatus(directoryPath, true)
            .then((status) => {
            switch (status) {
                case EntryStatus.File:
                case EntryStatus.Unknown:
                    throw new error_1.EEXIST();
                case EntryStatus.Directory:
                    return;
                case EntryStatus.NonExistent:
                    return this.mkdir(directoryPath, true);
            }
        });
    }
    ensureDir() {
        return this.ensureDirectory('/');
    }
    rename(filePath, newPath) {
        return this.move(filePath, newPath);
    }
    readAll(readFileType = 'Text', onErrorFiles) {
        return this.list('/')
            .then((items) => {
            return Promise.all(items
                .filter(item => item.isFile)
                .map(item => {
                return this.read(item.fullPath, readFileType)
                    .then(content => ({
                    content,
                    fileName: item.name
                }))
                    // Note: Whenever there is error in reading file,
                    // return null
                    .catch(e => {
                    return {
                        fileName: item.name,
                        fullFilePath: item.fullPath,
                        error: new Error(`Error in parsing ${item.fullPath}:\n${e.message}`)
                    };
                });
            }))
                .then(list => {
                const errorFiles = list.filter(item => item.error);
                if (onErrorFiles)
                    onErrorFiles(errorFiles);
                return list.filter((item) => item.content);
            });
        });
    }
    isTargetInSourceDirectory(targetPath, sourcePath) {
        const dstPath = this.dirPath(targetPath);
        const srcPath = this.dirPath(sourcePath);
        const sep = this.getPathLib().sep;
        const relativePath = this.getPathLib().relative(srcPath, dstPath);
        const parts = relativePath.split(sep);
        return parts.indexOf('..') === -1;
    }
    sortEntries(entries) {
        // Sort entries in this order
        // 1. Directories come before files
        // 2. Inside directories or files, sort it alphabetically a-z (ignore case)
        const items = [...entries];
        items.sort((a, b) => {
            if (a.isDirectory && b.isFile) {
                return -1;
            }
            if (a.isFile && b.isDirectory) {
                return 1;
            }
            const aName = a.name.toLowerCase();
            const bName = b.name.toLowerCase();
            if (aName < bName)
                return -1;
            if (aName > bName)
                return 1;
            return 0;
        });
        return items;
    }
    copyAllInDirectory(srcDir, dstDir) {
        return this.list(srcDir)
            .then((entries) => {
            return Promise.all(entries.map((entry) => {
                if (entry.isFile) {
                    return this.copyFile(entry.fullPath, this.getPathLib().resolve(dstDir, entry.name));
                }
                if (entry.isDirectory) {
                    const dstSubDir = this.getPathLib().resolve(dstDir, entry.name);
                    return this.ensureDirectory(dstSubDir)
                        .then(() => this.copyAllInDirectory(entry.fullPath, dstSubDir));
                }
                return Promise.resolve();
            }))
                .then(() => { });
        });
    }
    mkdir(dir, sureAboutNonExistent = false) {
        const makeSureNonExistent = () => {
            if (sureAboutNonExistent) {
                return Promise.resolve();
            }
            return this.getEntryStatus(dir, true)
                .then((status) => {
                if (status !== EntryStatus.NonExistent) {
                    throw new error_1.EEXIST(dir);
                }
            });
        };
        return makeSureNonExistent()
            .then(() => {
            const parentDir = this.getPathLib().dirname(dir);
            if (parentDir === '/') {
                return this.__createDirectory(dir);
            }
            return this.getEntryStatus(parentDir, true)
                .then((status) => {
                switch (status) {
                    case EntryStatus.File:
                    case EntryStatus.Unknown:
                        throw new error_1.EEXIST(parentDir);
                    case EntryStatus.Directory:
                        return this.__createDirectory(dir);
                    case EntryStatus.NonExistent:
                        return this.mkdir(parentDir, true)
                            .then(() => this.__createDirectory(dir));
                }
            });
        })
            .then(() => {
            this.emitListChanged();
        });
    }
    getEntryStatus(path, isDirectory) {
        return this.stat(path, isDirectory)
            .then((entry) => {
            if (entry.isFile)
                return EntryStatus.File;
            if (entry.isDirectory)
                return EntryStatus.Directory;
            return EntryStatus.NonExistent;
        }, (e) => {
            return EntryStatus.NonExistent;
        });
    }
    // Note: files changed event is for write file only  (rename excluded)
    emitFilesChanged(fileNames) {
        this.changedFileNames = fileNames.reduce((prev, fileName) => {
            if (prev.indexOf(fileName) === -1)
                prev.push(fileName);
            return prev;
        }, this.changedFileNames);
        this.__emitFilesChanged();
    }
}
exports.StandardStorage = StandardStorage;


/***/ }),

/***/ 90:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const storage_1 = __importDefault(__webpack_require__(36));
var XModuleTypes;
(function (XModuleTypes) {
    XModuleTypes["XFile"] = "xFile";
    XModuleTypes["XUserIO"] = "xClick";
    XModuleTypes["XDesktop"] = "xDesktop";
    XModuleTypes["XScreenCapture"] = "xScreenCapture";
})(XModuleTypes = exports.XModuleTypes || (exports.XModuleTypes = {}));
class XModule {
    constructor() {
        this.cachedConfig = {};
        this.initConfig();
    }
    getVersion() {
        return this.getAPI()
            .reconnect()
            .catch(e => {
            throw new Error(`${this.getName()} is not installed yet`);
        })
            .then(api => {
            return api.getVersion()
                .then(version => ({
                version,
                installed: true
            }));
        })
            .catch(e => ({
            installed: false
        }));
    }
    setConfig(config) {
        this.cachedConfig = Object.assign(Object.assign({}, this.cachedConfig), config);
        return this.getConfig()
            .then(oldConfig => {
            const nextConfig = Object.assign(Object.assign({}, oldConfig), config);
            return storage_1.default.set(this.getStoreKey(), nextConfig)
                .then(success => {
                if (success) {
                    this.cachedConfig = nextConfig;
                }
                return success;
            });
        });
    }
    getConfig() {
        return storage_1.default.get(this.getStoreKey())
            .then(data => {
            this.cachedConfig = data || {};
            return this.cachedConfig;
        });
    }
    getCachedConfig() {
        return this.cachedConfig;
    }
    getStoreKey() {
        return this.getName().toLowerCase();
    }
}
exports.XModule = XModule;


/***/ }),

/***/ 91:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = __webpack_require__(344);
const ts_utils_1 = __webpack_require__(12);
const kantu_cv_host_1 = __webpack_require__(345);
const base64_1 = __webpack_require__(346);
const utils_1 = __webpack_require__(4);
const dom_utils_1 = __webpack_require__(22);
const log_1 = __importDefault(__webpack_require__(11));
const path_1 = __importDefault(__webpack_require__(27));
exports.getNativeCVAPI = ts_utils_1.singletonGetter(() => {
    const nativeHost = new kantu_cv_host_1.KantuCVHost();
    let pReady = nativeHost.connectAsync().catch(e => {
        log_1.default.warn('pReady - error', e);
        throw e;
    });
    const api = constants_1.MethodTypeInvocationNames.reduce((prev, method) => {
        const camel = ts_utils_1.snakeToCamel(method);
        prev[camel] = (() => {
            const fn = (params) => pReady.then(() => {
                return nativeHost.invokeAsync(method, params)
                    .catch(e => {
                    // Note: Looks like for now whenever there is an error, you have to reconnect native host
                    // otherwise, all commands return "Disconnected" afterwards
                    const typeSafeAPI = api;
                    typeSafeAPI.reconnect().catch(() => { });
                    // Note: For now, native host doesn't provide any useful error message if captureDesktop fails
                    // but for most cases it's due to directory not exist
                    if (camel === 'captureDesktop') {
                        const filePath = params.path;
                        if (filePath && /[\\/]/.test(filePath)) {
                            throw new Error(`Failed to captureDesktop, please confirm directory exists at '${path_1.default.dirname(filePath)}'`);
                        }
                    }
                    throw e;
                });
            });
            return fn;
        })();
        return prev;
    }, {
        reconnect: () => {
            nativeHost.disconnect();
            pReady = nativeHost.connectAsync();
            return pReady.then(() => api);
        },
        searchDesktopWithGuard: (params) => {
            const typeSafeAPI = api;
            return typeSafeAPI.searchDesktop(params).then(guardSearchResult);
        },
        getImageFromDataUrl: (dataUrl, dpi) => {
            const typeSafeAPI = api;
            const removeBase64Prefix = (str) => {
                const b64 = 'base64,';
                const i = str.indexOf(b64);
                if (i === -1)
                    return str;
                return str.substr(i + b64.length);
            };
            return typeSafeAPI.getImageInfo({ content: removeBase64Prefix(dataUrl) })
                .then(info => {
                const DEFAULT_DPI = 96;
                const dpiX = info.dpiX || dpi || DEFAULT_DPI;
                const dpiY = info.dpiY || dpi || DEFAULT_DPI;
                return serializeDataUrl(dataUrl, dpiX, dpiY);
            });
        },
        readFileAsArrayBuffer: (filePath) => {
            const typeSafeAPI = api;
            const readMore = (filePath, totalSize = Infinity, rangeStart = 0, dataUrls = []) => {
                return typeSafeAPI.readFileRange({
                    rangeStart,
                    path: filePath
                })
                    .then(range => {
                    const result = range.rangeEnd > range.rangeStart ? dataUrls.concat([range.buffer]) : dataUrls;
                    if (range.rangeEnd >= totalSize || range.rangeEnd <= range.rangeStart)
                        return result;
                    return readMore(filePath, totalSize, range.rangeEnd, result);
                });
            };
            return typeSafeAPI.getFileSize({ path: filePath })
                .then(fileSize => readMore(filePath, fileSize, 0, []))
                .then(dataUrls => {
                const arr = ts_utils_1.concatUint8Array(...dataUrls.map(dataUrl => new Uint8Array(utils_1.dataURItoArrayBuffer(dataUrl))));
                return arr.buffer;
            });
        },
        readFileAsBlob: (filePath) => {
            const typeSafeAPI = api;
            return typeSafeAPI.readFileAsArrayBuffer(filePath)
                .then(buffer => new Blob([buffer]));
        },
        readFileAsDataURL: (filePath, withBase64Prefix = true) => {
            const typeSafeAPI = api;
            return typeSafeAPI.readFileAsBlob(filePath)
                .then(blob => utils_1.blobToDataURL(blob, withBase64Prefix));
        },
        readFileAsText: (filePath) => {
            const typeSafeAPI = api;
            return typeSafeAPI.readFileAsBlob(filePath)
                .then(blob => utils_1.blobToText(blob));
        },
        readFileAsBinaryString: (filePath) => {
            const typeSafeAPI = api;
            return typeSafeAPI.readFileAsArrayBuffer(filePath)
                .then(buffer => utils_1.arrayBufferToString(buffer));
        }
    });
    return api;
});
function guardSearchResult(result) {
    switch (result.errorCode) {
        case 0 /* Ok */:
            return result;
        case 2 /* NoGreenPinkBoxes */:
            throw new Error('Cannot find green and/or pink boxes');
        case 3 /* NoPinkBox */:
            throw new Error('Pattern image contains green box but does not contain pink box');
        case 4 /* TooManyGreenBox */:
            throw new Error('Pattern image contains more than one green box');
        case 5 /* TooManyPinkBox */:
            throw new Error('Pattern image contains more than one pink box');
        case 1 /* Fail */:
            throw new Error('Unspecified error has occured');
        default:
            throw new Error(`Unknown error code ${result.errorCode}`);
    }
}
exports.guardSearchResult = guardSearchResult;
function convertImageSearchResult(result, scale = 1, searchArea) {
    const { errorCode, containsGreenPinkBoxes, regions } = result;
    const convert = (region) => {
        var _a, _b;
        const searchAreaX = (_a = searchArea === null || searchArea === void 0 ? void 0 : searchArea.x) !== null && _a !== void 0 ? _a : 0;
        const searchAreaY = (_b = searchArea === null || searchArea === void 0 ? void 0 : searchArea.y) !== null && _b !== void 0 ? _b : 0;
        // All x, y in relativeRect and matchedRect are relatve to the whole screen
        if (!region.relativeRect) {
            return {
                matched: {
                    offsetLeft: scale * region.matchedRect.x - scale * searchAreaX,
                    offsetTop: scale * region.matchedRect.y - scale * searchAreaY,
                    viewportLeft: scale * region.matchedRect.x,
                    viewportTop: scale * region.matchedRect.y,
                    pageLeft: scale * region.matchedRect.x,
                    pageTop: scale * region.matchedRect.y,
                    width: scale * region.matchedRect.width,
                    height: scale * region.matchedRect.height,
                    score: region.score
                },
                reference: null
            };
        }
        else {
            return {
                matched: {
                    offsetLeft: scale * region.relativeRect.x - scale * searchAreaX,
                    offsetTop: scale * region.relativeRect.y - scale * searchAreaY,
                    viewportLeft: scale * region.relativeRect.x,
                    viewportTop: scale * region.relativeRect.y,
                    pageLeft: scale * region.relativeRect.x,
                    pageTop: scale * region.relativeRect.y,
                    width: scale * region.relativeRect.width,
                    height: scale * region.relativeRect.height,
                    score: region.score
                },
                reference: {
                    offsetLeft: scale * region.matchedRect.x - scale * searchAreaX,
                    offsetTop: scale * region.matchedRect.y - scale * searchAreaY,
                    viewportLeft: scale * region.matchedRect.x,
                    viewportTop: scale * region.matchedRect.y,
                    pageLeft: scale * region.matchedRect.x,
                    pageTop: scale * region.matchedRect.y,
                    width: scale * region.matchedRect.width,
                    height: scale * region.matchedRect.height,
                    score: region.score
                }
            };
        }
    };
    return regions.map(r => convert(r));
}
exports.convertImageSearchResult = convertImageSearchResult;
function serializeImageData(imageData, dpiX, dpiY) {
    // Convert RGBA -> RGB -> Base64
    const w = imageData.width;
    const h = imageData.height;
    const src = imageData.data;
    const rgb = new Uint8Array(w * h * 3);
    for (let y = 0; y < h; ++y) {
        for (let x = 0; x < w; ++x) {
            const base = y * w + x;
            const k = 3 * base;
            const j = 4 * base;
            rgb[k + 0] = src[j + 0];
            rgb[k + 1] = src[j + 1];
            rgb[k + 2] = src[j + 2];
        }
    }
    const data = base64_1.base64.encode(rgb);
    return {
        width: w,
        height: h,
        dpiX,
        dpiY,
        data
    };
}
exports.serializeImageData = serializeImageData;
function serializeDataUrl(dataUrl, dpiX, dpiY) {
    return dom_utils_1.imageDataFromUrl(dataUrl)
        .then(imageData => serializeImageData(imageData, dpiX, dpiY));
}
exports.serializeDataUrl = serializeDataUrl;


/***/ }),

/***/ 92:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var dexie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(395);
/* harmony import */ var dexie__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dexie__WEBPACK_IMPORTED_MODULE_0__);


var db = new dexie__WEBPACK_IMPORTED_MODULE_0___default.a('selenium-ide');

db.version(1).stores({
  testCases: 'id,name,updateTime'
});

db.version(2).stores({
  testCases: 'id,name,updateTime',
  testSuites: 'id,name,updateTime'
});

db.open();

/* harmony default export */ __webpack_exports__["default"] = (db);

/***/ }),

/***/ 95:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MacroInspector;
(function (MacroInspector) {
    MacroInspector["Timer"] = "timer";
    MacroInspector["LoopTimer"] = "loop_timer";
    MacroInspector["Countdown"] = "countdown";
})(MacroInspector = exports.MacroInspector || (exports.MacroInspector = {}));


/***/ }),

/***/ 96:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = __webpack_require__(95);
const monitor_1 = __webpack_require__(1030);
const timer_1 = __webpack_require__(1031);
const countdown_1 = __webpack_require__(1032);
const ts_utils_1 = __webpack_require__(12);
var MacroParamsProviderType;
(function (MacroParamsProviderType) {
    MacroParamsProviderType[MacroParamsProviderType["Constructor"] = 0] = "Constructor";
    MacroParamsProviderType[MacroParamsProviderType["Restart"] = 1] = "Restart";
})(MacroParamsProviderType = exports.MacroParamsProviderType || (exports.MacroParamsProviderType = {}));
class MacroMonitor extends monitor_1.Monitor {
    constructor(paramsProvider) {
        super({
            [types_1.MacroInspector.Timer]: (id) => {
                return new timer_1.Timer();
            },
            [types_1.MacroInspector.LoopTimer]: (id) => {
                return new timer_1.Timer();
            },
            [types_1.MacroInspector.Countdown]: (id) => {
                const args = paramsProvider(MacroParamsProviderType.Constructor, types_1.MacroInspector.Countdown, id, false);
                const callback = args[0];
                return new countdown_1.Countdown(callback);
            }
        }, (name, id, notBatch) => {
            return paramsProvider(MacroParamsProviderType.Restart, name, id, notBatch);
        });
    }
}
exports.MacroMonitor = MacroMonitor;
exports.getMacroMonitor = ts_utils_1.singletonGetter((paramsProvider) => {
    return new MacroMonitor(paramsProvider);
});


/***/ }),

/***/ 97:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/// <reference types="chrome"/>
Object.defineProperty(exports, "__esModule", { value: true });
class InvocationQueueItem {
    constructor(id, method, params, callback) {
        this.requestObject = {
            id,
            method,
            params
        };
        this.callback = callback;
    }
    get request() {
        return this.requestObject;
    }
}
class NativeMessagingHost {
    constructor(hostName) {
        this.internalHostName = hostName;
        this.nextInvocationId = 1;
        this.queue = new Array();
        this.handleMessage = this.handleMessage.bind(this);
        this.handleDisconnect = this.handleDisconnect.bind(this);
    }
    processResponse(id, result, error) {
        let callback = undefined;
        for (let i = 0; i < this.queue.length; ++i) {
            const entry = this.queue[i];
            if (entry.request.id === id) {
                callback = entry.callback;
                this.queue.splice(i, 1);
                break;
            }
        }
        if (callback) {
            callback(result, error);
        }
    }
    handleMessage(message) {
        const response = message;
        if (typeof response.id !== "number") {
            return;
        }
        this.processResponse(response.id, response.result, response.error);
    }
    handleDisconnect() {
        this.disconnect();
    }
    get hostName() {
        return this.internalHostName;
    }
    connectAsync() {
        if (this.port) {
            return this.invokeAsync("get_version", undefined);
        }
        this.port = chrome.runtime.connectNative(this.hostName);
        this.port.onMessage.addListener(this.handleMessage);
        this.port.onDisconnect.addListener(this.handleDisconnect);
        return this.invokeAsync("get_version", undefined);
    }
    disconnect() {
        const message = chrome.runtime.lastError && chrome.runtime.lastError.message || "Disconnected";
        if (this.port) {
            this.port.disconnect();
            this.port = undefined;
        }
        // Discard all queued invocations
        const invocationIdArray = this.queue.map(x => x.request.id);
        for (const id of invocationIdArray) {
            this.processResponse(id, undefined, { message });
        }
        this.queue = new Array();
    }
    invoke(method, params, callback) {
        if (!this.port) {
            callback(undefined, {
                message: "Disconnected"
            });
            return;
        }
        const id = this.nextInvocationId++;
        const item = new InvocationQueueItem(id, method, params, callback);
        this.queue.push(item);
        this.port.postMessage(item.request);
    }
    invokeAsync(method, params) {
        return new Promise((resolve, reject) => {
            this.invoke(method, params, (result, error) => {
                if (chrome.runtime.lastError) {
                    error = new Error(chrome.runtime.lastError.message);
                }
                if (error) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            });
        });
    }
}
exports.NativeMessagingHost = NativeMessagingHost;


/***/ }),

/***/ 972:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(0));
const prop_types_1 = __importDefault(__webpack_require__(1));
const utils_1 = __webpack_require__(4);
const ts_utils_1 = __webpack_require__(12);
const tree_file_1 = __webpack_require__(137);
class TreeNode extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.state = {};
        this.onClick = (e) => {
            const { data, onClick, paths, foldOnClickTitle } = this.props;
            if (onClick) {
                onClick(data, paths, e);
            }
            if (foldOnClickTitle && data.type === tree_file_1.FileNodeType.Folder) {
                this.onToggle(e);
            }
        };
        this.onDoubleClick = (e) => {
            const { data, onDoubleClick, paths } = this.props;
            if (onDoubleClick) {
                onDoubleClick(data, paths, e);
            }
        };
        this.onContextMenu = (e) => {
            const { data, onContextMenu, paths } = this.props;
            if (onContextMenu) {
                onContextMenu(data, paths, e);
            }
        };
        this.onToggle = (e) => {
            e.stopPropagation();
            const { data, onToggle, paths } = this.props;
            if (onToggle) {
                onToggle(data, paths, e);
            }
        };
    }
    render() {
        const { decorate = (x) => x } = this.props;
        return decorate(react_1.default.createElement("div", { id: ts_utils_1.normalizeHtmlId(this.props.data.id), className: utils_1.cn('tree-node', this.props.commonClass, this.props.data.className) },
            react_1.default.createElement("div", { className: "tree-node-content", onClick: this.onClick, onDoubleClick: this.onDoubleClick, onContextMenu: this.onContextMenu },
                react_1.default.createElement("div", { className: "tree-node-icon-wrapper", onClick: this.onToggle }, this.renderIcon()),
                react_1.default.createElement("div", { className: "tree-node-item-wrapper" }, this.renderItem()),
                this.renderItemExtra()),
            react_1.default.createElement("div", { className: "tree-node-children" }, this.renderSubnodes())));
    }
    renderIcon() {
        const { renderIcon, data, paths } = this.props;
        if (typeof renderIcon === 'function') {
            return renderIcon(data, paths);
        }
        else {
            return this.defaultRenderIcon(data);
        }
    }
    renderItem() {
        const { renderItem, data, paths } = this.props;
        if (typeof renderItem === 'function') {
            return renderItem(data, paths);
        }
        else {
            return this.defaultRenderItem(data);
        }
    }
    renderItemExtra() {
        const { renderItemExtra, data, paths } = this.props;
        if (typeof renderItemExtra === 'function') {
            return renderItemExtra(data, paths);
        }
        else {
            return null;
        }
    }
    defaultRenderIcon(data) {
        return (react_1.default.createElement("div", { className: utils_1.cn('node-icon') }, !data.folded ? 'O' : 'C'));
    }
    defaultRenderItem(data) {
        return data.text || `node at level ${data.level}`;
    }
    renderSubnodes() {
        const { data, paths, subnodeComponent = () => TreeNode } = this.props;
        const props = ts_utils_1.without(['data', 'paths'], this.props);
        if (data.type !== tree_file_1.FileNodeType.Folder || data.folded) {
            return null;
        }
        return (data.children || []).map((subnode, i) => {
            const SubNode = subnodeComponent(subnode, [...paths, i]);
            return (react_1.default.createElement(SubNode, Object.assign({ key: i }, props, { data: subnode, paths: [...paths, i] })));
        });
    }
}
exports.TreeNode = TreeNode;
TreeNode.propTypes = {
    data: prop_types_1.default.object.isRequired,
    renderItem: prop_types_1.default.func.isRequired,
    renderIcon: prop_types_1.default.func.isRequired,
    renderItemExtra: prop_types_1.default.func,
    decorate: prop_types_1.default.func,
    onClick: prop_types_1.default.func.isRequired,
    onDoubleClick: prop_types_1.default.func.isRequired,
    onContextMenu: prop_types_1.default.func.isRequired,
    onToggle: prop_types_1.default.func.isRequired,
    className: prop_types_1.default.string
};


/***/ }),

/***/ 973:
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(974);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(133)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 974:
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(132)(undefined);
// imports


// module
exports.push([module.i, ".file-root{padding-top:10px;font-size:14px;line-height:18px}.file-root.drag-over{background:#d5d6f9}.file-root .tree-node-content{position:relative;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:5px 10px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.file-root .tree-node-content,.file-root .tree-node-content .tree-node-icon-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.file-root .tree-node-content .tree-node-icon-wrapper{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:5px;width:20px}.file-root .tree-node-content .more-button{display:none;position:absolute;top:50%;right:10px;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.file-root .tree-node-content:hover .more-button{display:block}.file-root .file-node.drag-over{background:#d5d6f9}.file-root .file-node.success>.tree-node-content{background:#d1ffd8}.file-root .file-node.success.blur>.tree-node-content{background:rgba(209,255,216,.6)}.file-root .file-node.error>.tree-node-content{background:#f7c1c1}.file-root .file-node.error.blur>.tree-node-content{background:hsla(0,77%,86%,.6)}.file-root .file-node.error-in-sub>.tree-node-content{background:#f8cf9d}.file-root .file-node.error-in-sub.blur>.tree-node-content{background:hsla(33,87%,79%,.6)}.file-root .file-node.selected>.tree-node-content{background:#fdffd1}.file-root .file-node.selected.blur>.tree-node-content{background:rgba(253,255,209,.6)}.file-root .file-node.selected.error-in-sub>.tree-node-content,.file-root .file-node.selected.error>.tree-node-content,.file-root .file-node.selected.success>.tree-node-content{position:relative}.file-root .file-node.selected.error-in-sub>.tree-node-content:after,.file-root .file-node.selected.error>.tree-node-content:after,.file-root .file-node.selected.success>.tree-node-content:after{content:\"\";position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:none}.file-root .file-node.selected.error>.tree-node-content:after{border:4px solid #f7c1c1}.file-root .file-node.selected.error.blur>.tree-node-content:after{border-color:hsla(0,77%,86%,.6)}.file-root .file-node.selected.error-in-sub>.tree-node-content:after{border:4px solid #f8cf9d}.file-root .file-node.selected.error-in-sub.blur>.tree-node-content:after{border-color:hsla(33,87%,79%,.6)}.file-root .file-node.selected.success>.tree-node-content:after{border:4px solid #d1ffd8}.file-root .file-node.selected.success.blur>.tree-node-content:after{border-color:rgba(209,255,216,.6)}.file-root .file-node .file-icon,.file-root .file-node .folder-icon{height:16px}.file-root .tree-node .tree-node .tree-node-content{padding-left:25px}.file-root .tree-node .tree-node .tree-node .tree-node-content{padding-left:40px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:55px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:70px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:85px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:100px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:115px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:130px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:145px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:160px}", ""]);

// exports


/***/ }),

/***/ 976:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class StackError extends Error {
}
exports.StackError = StackError;
class Stack {
    constructor(list) {
        this.list = [];
        if (list && list.length) {
            this.list = list;
        }
    }
    clear() {
        this.list = [];
    }
    toArray() {
        return [...this.list];
    }
    getCount() {
        return this.list.length;
    }
    isEmpty() {
        return this.getCount() === 0;
    }
    contains(item) {
        return !!this.list.find((el) => el === item);
    }
    push(item) {
        this.list.push(item);
    }
    peek() {
        this.guardNotEmpty();
        return this.list[this.getCount() - 1];
    }
    bottom() {
        this.guardNotEmpty();
        return this.list[0];
    }
    pop() {
        this.guardNotEmpty();
        return this.list.pop();
    }
    guardNotEmpty() {
        if (this.isEmpty()) {
            throw new StackError('empty stack');
        }
    }
}
exports.Stack = Stack;


/***/ }),

/***/ 99:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getSaveTestCase; });
/* harmony import */ var antd_lib_modal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);
/* harmony import */ var antd_lib_modal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(antd_lib_modal__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var antd_lib_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);
/* harmony import */ var antd_lib_message__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(antd_lib_message__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var antd_lib_input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29);
/* harmony import */ var antd_lib_input__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(antd_lib_input__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _actions_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(16);
/* harmony import */ var _recomputed__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(23);
/* harmony import */ var _recomputed__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_recomputed__WEBPACK_IMPORTED_MODULE_6__);






var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var SaveAsModal = function (_React$Component) {
  _inherits(SaveAsModal, _React$Component);

  function SaveAsModal() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, SaveAsModal);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = SaveAsModal.__proto__ || Object.getPrototypeOf(SaveAsModal)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      name: null
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(SaveAsModal, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      if (this.props.name) {
        this.setState({ name: this.props.name });
      }

      setTimeout(function () {
        var input = _this2.inputSaveTestCase.refs.input;
        input.focus();
        input.selectionStart = input.selectionEnd = input.value.length;
      }, 100);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      return react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(
        antd_lib_modal__WEBPACK_IMPORTED_MODULE_0___default.a,
        {
          title: 'Save macro as..',
          okText: 'Save',
          cancelText: 'Cancel',
          visible: true,
          onOk: function onOk() {
            return _this3.props.onOk(_this3.state.name);
          },
          onCancel: this.props.onCancel,
          className: 'save-modal'
        },
        react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(antd_lib_input__WEBPACK_IMPORTED_MODULE_2___default.a, {
          style: { width: '100%' },
          onKeyDown: function onKeyDown(e) {
            e.keyCode === 13 && _this3.props.onOk(_this3.state.name);
          },
          onChange: function onChange(e) {
            return _this3.setState({ name: e.target.value });
          },
          value: this.state.name || '',
          placeholder: 'macro name',
          ref: function ref(el) {
            _this3.inputSaveTestCase = el;
          }
        })
      );
    }
  }]);

  return SaveAsModal;
}(react__WEBPACK_IMPORTED_MODULE_3___default.a.Component);

var getContainer = function getContainer() {
  var id = 'save_test_case_container';
  var $el = document.getElementById(id);

  if ($el) return $el;

  var $new = document.createElement('div');
  $new.id = id;
  document.body.appendChild($new);
  return $new;
};

var getTestCaseName = function getTestCaseName(state) {
  var src = state.editor.editing.meta.src;

  return src && src.name && src.name.length ? src.name : 'Untitled';
};

var tryToSave = function tryToSave(store, testCaseName) {
  var $container = getContainer();
  var state = store.getState();
  var existed = !!state.editor.editing.meta.src;

  if (existed) {
    return store.dispatch(Object(_actions_index__WEBPACK_IMPORTED_MODULE_5__["saveEditingAsExisted"])()).then(function () {
      return true;
    });
  }

  return new Promise(function (resolve, reject) {
    var onSave = function onSave(name) {
      return store.dispatch(Object(_actions_index__WEBPACK_IMPORTED_MODULE_5__["saveEditingAsNew"])(name)).then(function () {
        antd_lib_message__WEBPACK_IMPORTED_MODULE_1___default.a.success('successfully saved!', 1.5);
        resolve(true);
      }, function (e) {
        antd_lib_message__WEBPACK_IMPORTED_MODULE_1___default.a.error(e.message, 1.5);
        reject(e);
      });
    };

    react_dom__WEBPACK_IMPORTED_MODULE_4___default.a.render(react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(SaveAsModal, {
      name: testCaseName,
      onOk: onSave,
      onCancel: function onCancel() {
        return resolve(false);
      }
    }), $container);
    // TODO
  }).then(function (saved) {
    react_dom__WEBPACK_IMPORTED_MODULE_4___default.a.unmountComponentAtNode($container);
    return saved;
  }).catch(function (e) {
    console.error(e.message);
    throw e;
  });
};

var factory = function factory(store) {
  var withIsSaving = function withIsSaving(fn) {
    store.dispatch(Object(_actions_index__WEBPACK_IMPORTED_MODULE_5__["updateUI"])({ isSaving: true }));

    return new Promise(function (resolve) {
      resolve(fn());
    }).finally(function () {
      store.dispatch(Object(_actions_index__WEBPACK_IMPORTED_MODULE_5__["updateUI"])({ isSaving: false }));
    });
  };

  return {
    saveOrNot: function saveOrNot() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var state = store.getState();
      var hasUnsaved = Object(_recomputed__WEBPACK_IMPORTED_MODULE_6__["hasUnsavedMacro"])(state);
      var isExisting = !!state.editor.editing.meta.src;
      var opts = _extends({
        getTitle: function getTitle(data) {
          return 'Unsaved changes in macro "' + data.macroName + '"';
        },
        getContent: function getContent(data) {
          return 'Do you want to discard or save these changes?';
        },
        okText: 'Save',
        cancelText: 'Discard'
      }, options || {});

      return withIsSaving(function () {
        if (!hasUnsaved) return Promise.resolve(true);

        if (isExisting && options.autoSaveExisting) {
          return tryToSave(store);
        }

        return new Promise(function (resolve, reject) {
          var macroName = getTestCaseName(state);

          antd_lib_modal__WEBPACK_IMPORTED_MODULE_0___default.a.confirm({
            title: opts.getTitle({ macroName: macroName }),
            content: opts.getContent({ macroName: macroName }),
            okText: opts.okText,
            cancelText: opts.cancelText,
            onOk: function onOk() {
              tryToSave(store).then(resolve, reject);
              return Promise.resolve(true);
            },
            onCancel: function onCancel() {
              resolve(false);
              return Promise.resolve(true);
            }
          });
        });
      });
    },
    save: function save(defaultName) {
      var state = store.getState();
      var hasUnsaved = Object(_recomputed__WEBPACK_IMPORTED_MODULE_6__["hasUnsavedMacro"])(state);

      return withIsSaving(function () {
        if (!hasUnsaved) return Promise.resolve(true);
        return tryToSave(store, defaultName);
      });
    }
  };
};

var api = void 0;

function getSaveTestCase(store) {
  if (api) return api;
  if (!store) throw new Error('must provide store');

  api = factory(store);
  return api;
}

/***/ })

/******/ });