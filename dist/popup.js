/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 8588:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Actions = exports.ActionTypes = exports.ActionFactories = void 0;
exports.checkNodeShowUp = checkNodeShowUp;
exports.createAction = createAction;
exports.createThunkAction = createThunkAction;
exports.fileFolderNotShown = fileFolderNotShown;
exports.getMacroIdChanges = getMacroIdChanges;
exports.withMacroIdChanges = withMacroIdChanges;
var _react = _interopRequireDefault(__webpack_require__(96540));
var _antd = __webpack_require__(33061);
var _scrollIntoViewIfNeeded = _interopRequireDefault(__webpack_require__(46558));
var _ts_utils = __webpack_require__(1601);
var _storage = __webpack_require__(97467);
var _prompt = __webpack_require__(10409);
var _log = _interopRequireDefault(__webpack_require__(89130));
var _storage2 = _interopRequireDefault(__webpack_require__(88555));
var _index = __webpack_require__(35127);
var _recomputed = __webpack_require__(87307);
var _tree_file = __webpack_require__(78290);
var _test_suite_extra_data = __webpack_require__(86379);
var _test_suite_model = __webpack_require__(38117);
var _utils = __webpack_require__(46580);
var _convert_utils = __webpack_require__(75852);
var _state = __webpack_require__(78493);
var _misc_data = __webpack_require__(90429);
var _constant = __webpack_require__(95902);
var _save_test_case = _interopRequireDefault(__webpack_require__(64305));
var _file_saver = _interopRequireDefault(__webpack_require__(50261));
var _command = __webpack_require__(85393);
var _jszip = _interopRequireDefault(__webpack_require__(71710));
var _config = _interopRequireDefault(__webpack_require__(8747));
var _license = __webpack_require__(12277);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function getMacroIdChanges(options) {
  var entryPath = options.entryPath,
    isDirectory = options.isDirectory,
    getNewFilePath = options.getNewFilePath;
  var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
  var entryFullPath = macroStorage.entryPath(entryPath, isDirectory);
  if (!isDirectory) {
    return Promise.resolve(_defineProperty({}, entryFullPath, getNewFilePath(entryFullPath)));
  }
  return macroStorage.listR(entryFullPath).then(function (entryNodes) {
    var listOfNodes = entryNodes.map(function (node) {
      return (0, _ts_utils.flatternTree)(node);
    });
    var nodes = (0, _ts_utils.flatten)(listOfNodes);
    return nodes.map(function (node) {
      return node.fullPath;
    }).reduce(function (prev, oldMacroPath) {
      prev[oldMacroPath] = getNewFilePath(oldMacroPath);
      return prev;
    }, {});
  });
}
function withMacroIdChanges(options) {
  return getMacroIdChanges(options).then(function (macroIdChanges) {
    return Promise.resolve(options.run())
    // Note: the delay is waiting for macro ids updated in state
    .then(function () {
      return (0, _ts_utils.delay)(function () {}, 1000);
    }).then(function () {
      options.dispatch(Actions.updateMacroIdsInTestSuites(macroIdChanges));
    });
  });
}
function checkNodeShowUp(params) {
  var dispatch = params.dispatch,
    getState = params.getState,
    fullPath = params.fullPath,
    message = params.message,
    _params$switchToIt = params.switchToIt,
    switchToIt = _params$switchToIt === void 0 ? true : _params$switchToIt;
  return (0, _ts_utils.until)('node shows up', function () {
    var state = getState();
    var macroFolderStructure = getState().editor.macroFolderStructure;
    var macroNodes = (0, _recomputed.getMacroFileNodeList)(state);
    var nodes = (0, _ts_utils.flatten)(macroFolderStructure.map(_ts_utils.flatternTree));
    var found = nodes.find(function (item) {
      return item.fullPath === fullPath;
    });
    var foundInTestCases = macroNodes.find(function (item) {
      return item.fullPath === fullPath;
    });

    // Note: testCases are slower than macorFolderStructure, because testCases need to read file
    // So have to wait for both
    return {
      pass: !!found && !!foundInTestCases,
      result: found
    };
  }, 100, 10 * 1000).then(function () {
    if (switchToIt) {
      dispatch((0, _index.editTestCase)(fullPath));
    }
    dispatch(Actions.ensureTreeNodeUnfoldedForCurrentMacroNode());
  }, function (e) {
    _log["default"].error(e);
    fileFolderNotShown({
      dispatch: dispatch,
      getState: getState,
      message: message
    });
  });
}
function fileFolderNotShown(params) {
  var dispatch = params.dispatch,
    getState = params.getState,
    message = params.message;
  var _getState = getState(),
    config = _getState.config;
  var storageMode = config.storageMode,
    _config$xmodulesStatu = config.xmodulesStatus,
    xmodulesStatus = _config$xmodulesStatu === void 0 ? 'unregistered' : _config$xmodulesStatu;
  if (storageMode !== _storage.StorageStrategyType.XFile) {
    return;
  }
  if ((0, _license.getLicenseService)().isProLicense() || (0, _license.getLicenseService)().isPlayerLicense()) {
    return;
  }
  var reason = function () {
    if ((0, _license.getLicenseService)().hasNoLicense()) {
      return "".concat((0, _license.getLicenseService)().getMaxXFileMacros(), " macro/folder limit in free version");
    }
    if ((0, _license.getLicenseService)().isPersonalLicense()) {
      return "".concat((0, _license.getLicenseService)().getMaxXFileMacros(), " macro/folder limit in Free Edition. Please use the PRO or ENTERPRISE Edition for unlimited direct file access.");
    }
    throw new Error('Unknown cases');
  }();
  _antd.Modal.warn({
    title: 'Please upgrade your XModule plan',
    content: "".concat(message, ", but not displayed due to ").concat(reason),
    okText: 'OK',
    onOk: function onOk() {
      dispatch((0, _index.updateUI)({
        showSettings: true,
        settingsTab: 'register'
      }));
    }
  });
}
var ActionFactories = exports.ActionFactories = {
  setNoDisplayInPlay: function setNoDisplayInPlay(name) {
    return function (noDisplayInPlay) {
      return createAction(name, noDisplayInPlay);
    };
  },
  setOcrInDesktopMode: function setOcrInDesktopMode(name) {
    return function (ocrInDesktopMode) {
      return createAction(name, ocrInDesktopMode);
    };
  },
  setReplaySpeedOverrideToFastMode: function setReplaySpeedOverrideToFastMode(name) {
    return function (replaySpeedOverrideToFastMode) {
      return createAction(name, replaySpeedOverrideToFastMode);
    };
  },
  setFrom: function setFrom(name) {
    return function (from) {
      return createThunkAction(function (dispatch, getState) {
        var _getState2 = getState(),
          oldFrom = _getState2.from;
        if (from === _state.RunBy.Manual && oldFrom !== _state.RunBy.Manual) {
          (0, _storage.getStorageManager)().emit(_storage.StorageManagerEvent.ForceReload);
        }
        dispatch(createAction(name, from));
      });
    };
  },
  setIsLoadingMacros: function setIsLoadingMacros(name) {
    return function (isLoading) {
      return createAction(name, isLoading);
    };
  },
  setCurrentMacro: function setCurrentMacro(name) {
    return function (macro) {
      return createAction(name, macro);
    };
  },
  copyCurrentCommand: function copyCurrentCommand(name) {
    return function () {
      return createThunkAction(function (dispatch, getState) {
        var selectedIndex = getState().editor.editing.meta.selectedIndex;
        if (selectedIndex === -1) {
          return;
        }
        dispatch((0, _index.copyCommand)(selectedIndex));
      });
    };
  },
  cutCurrentCommand: function cutCurrentCommand(name) {
    return function () {
      return createThunkAction(function (dispatch, getState) {
        var selectedIndex = getState().editor.editing.meta.selectedIndex;
        if (selectedIndex === -1) {
          return;
        }
        dispatch((0, _index.cutCommand)(selectedIndex));
      });
    };
  },
  pasteAtCurrentCommand: function pasteAtCurrentCommand(name) {
    return function () {
      return createThunkAction(function (dispatch, getState) {
        var selectedIndex = getState().editor.editing.meta.selectedIndex;
        if (selectedIndex === -1) {
          return;
        }
        dispatch((0, _index.pasteCommand)(selectedIndex));
      });
    };
  },
  selectNextCommand: function selectNextCommand(name) {
    return function () {
      return createThunkAction(function (dispatch, getState) {
        var _getState$editor$edit = getState().editor.editing,
          meta = _getState$editor$edit.meta,
          commands = _getState$editor$edit.commands;
        var selectedIndex = meta.selectedIndex;
        if (selectedIndex < commands.length - 1) {
          dispatch((0, _index.selectCommand)(selectedIndex + 1, true));
        }
      });
    };
  },
  selectPrevCommand: function selectPrevCommand(name) {
    return function () {
      return createThunkAction(function (dispatch, getState) {
        var _getState$editor$edit2 = getState().editor.editing,
          meta = _getState$editor$edit2.meta,
          commands = _getState$editor$edit2.commands;
        var selectedIndex = meta.selectedIndex;
        if (selectedIndex > 0) {
          dispatch((0, _index.selectCommand)(selectedIndex - 1, true));
        }
      });
    };
  },
  moveCommands: function moveCommands(name) {
    return function (startIndex, endIndex) {
      return createAction(name, {
        startIndex: startIndex,
        endIndex: endIndex
      });
    };
  },
  setIsDraggingCommand: function setIsDraggingCommand(name) {
    return function (isDraggingCommand) {
      return createAction(name, isDraggingCommand);
    };
  },
  setMacroFolderStructure: function setMacroFolderStructure(name) {
    return function (entryNodes) {
      return createAction(name, entryNodes);
    };
  },
  setTestSuiteFolderStructure: function setTestSuiteFolderStructure(name) {
    return function (entryNodes) {
      return createAction(name, entryNodes);
    };
  },
  macroCreateFolder: function macroCreateFolder(name) {
    return function (options) {
      return createThunkAction(function (dispatch, getState) {
        var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
        var path = macroStorage.getPathLib();
        var parentDir = macroStorage.dirPath(options.dir);
        return (0, _prompt.prompt)({
          width: 400,
          title: 'Create folder as..',
          message: '',
          value: '',
          placeholder: 'Folder name',
          selectionStart: 0,
          selectionEnd: 0,
          okText: 'Create',
          cancelText: 'Cancel',
          onCancel: function onCancel() {
            return Promise.resolve(true);
          },
          onOk: function onOk(newName) {
            var newFullPath = path.join(parentDir, (0, _utils.sanitizeFileName)(newName));
            return macroStorage.directoryExists(newFullPath).then(function (exists) {
              if (exists) {
                var msg = "'".concat(newName, "' already exists");
                _antd.message.error(msg);
                throw new Error(msg);
              }
              return (0, _storage.getStorageManager)().getMacroStorage().createDirectory(newFullPath).then(function () {
                _antd.message.success("Created folder '".concat(newName, "'"));
                checkNodeShowUp({
                  getState: getState,
                  dispatch: dispatch,
                  fullPath: newFullPath,
                  switchToIt: false,
                  message: 'Folder created'
                });
                return true;
              }, function (e) {
                _log["default"].error(e);
                var msg = 'Failed to create folder: ' + e.message;
                _antd.message.error(msg);
                throw new Error(msg);
              });
            });
          }
        });
      });
    };
  },
  macroDeleteFolder: function macroDeleteFolder(name) {
    return function (options) {
      // TODO: check if any macro is in use of some test suite

      return createThunkAction(function (dispatch, getState) {
        var dir = options.dir;
        var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
        var assertNoMacroInUse = function assertNoMacroInUse() {
          return getMacroIdChanges({
            entryPath: macroStorage.dirPath(dir),
            isDirectory: true,
            getNewFilePath: function getNewFilePath(str) {
              return str;
            }
          }).then(function (macroIdChanges) {
            var state = getState();
            var testSuites = (0, _recomputed.getTestSuitesWithAllInfo)(state);
            var oldMacroIds = Object.keys(macroIdChanges);
            var problems = [];
            oldMacroIds.forEach(function (oldMacroId) {
              testSuites.forEach(function (ts) {
                if (ts.cases.find(function (obj) {
                  return obj.testCaseId === oldMacroId;
                })) {
                  problems.push({
                    macroPath: macroStorage.relativePath(oldMacroId),
                    testSuiteName: ts.name
                  });
                }
              });
            });
            if (problems.length > 0) {
              var cnt = 3;
              var main = problems.slice(0, cnt).map(function (obj) {
                return "\"".concat(obj.macroPath, "\" is still used in test suite \"").concat(obj.testSuiteName, "\"");
              }).join('\n');
              var extra = problems.length <= cnt ? '' : "\n...\n(And ".concat(problems.length - 1, " more macro references)");
              var msg = main + extra;
              throw new Error(msg);
            }
          });
        };
        if (confirm("Sure to delete ".concat(dir, " and all its content?"))) {
          return assertNoMacroInUse().then(function () {
            return macroStorage.remove(dir, true);
          })["catch"](function (e) {
            _antd.Modal.warn({
              title: 'Failed to delete folder',
              content: e.message.split('\n').map(function (str) {
                return /*#__PURE__*/_react["default"].createElement('li', null, str);
              }),
              okText: 'OK'
            });
          });
        }
      });
    };
  },
  macroMoveEntry: function macroMoveEntry(name) {
    return function (data) {
      return createThunkAction(function (dispatch, getState) {
        var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
        var path = macroStorage.getPathLib();
        var getNewFilePath = function getNewFilePath(oldMacroPath) {
          var dirName = path.basename(data.entryId);
          var oldDirFullPath = macroStorage.dirPath(data.entryId);
          var relativePath = path.relative(oldMacroPath, oldDirFullPath);
          return path.join(data.dirId, dirName, relativePath);
        };
        var moveEntry = function moveEntry() {
          return macroStorage.move(data.entryId, data.dirId, data.isSourceDirectory, true);
        };
        return withMacroIdChanges({
          dispatch: dispatch,
          getNewFilePath: getNewFilePath,
          run: moveEntry,
          entryPath: data.entryId,
          isDirectory: data.isSourceDirectory
        })["catch"](function (e) {
          _antd.message.error(e.message);
        });
      });
    };
  },
  macroRenameFolder: function macroRenameFolder(name) {
    return function (options) {
      return createThunkAction(function (dispatch, getState) {
        var dir = options.dir;
        var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
        var path = macroStorage.getPathLib();
        var dirFullPath = macroStorage.dirPath(dir);
        var folderName = path.basename(dirFullPath);
        var parentDir = path.dirname(dirFullPath);
        var editingId = getState().editor.editing.meta.src.id;
        var isEditingCur = editingId.indexOf(dirFullPath + path.sep) === 0;
        return (0, _prompt.prompt)({
          width: 400,
          title: 'Rename the folder as..',
          message: '',
          value: folderName,
          placeholder: 'Folder name',
          selectionStart: 0,
          selectionEnd: folderName.length,
          okText: 'Rename',
          cancelText: 'Cancel',
          onCancel: function onCancel() {
            return Promise.resolve(true);
          },
          onOk: function onOk(newName) {
            var newFullPath = path.join(parentDir, (0, _utils.sanitizeFileName)(newName));
            return macroStorage.directoryExists(newFullPath).then(function (exists) {
              if (exists) {
                var msg = "'".concat(newName, "' already exists");
                _antd.message.error(msg);
                throw new Error(msg);
              }
              return withMacroIdChanges({
                dispatch: dispatch,
                isDirectory: true,
                entryPath: dirFullPath,
                getNewFilePath: function getNewFilePath(oldMacroPath) {
                  var relativePath = path.relative(oldMacroPath, dirFullPath);
                  return path.join(newFullPath, relativePath);
                },
                run: function run() {
                  return macroStorage.moveDirectory(dirFullPath, newFullPath).then(function () {
                    _antd.message.success("Renamed to '".concat(newName, "'"));
                    checkNodeShowUp({
                      getState: getState,
                      dispatch: dispatch,
                      fullPath: newFullPath,
                      switchToIt: false,
                      message: 'Folder renamed'
                    });
                    if (isEditingCur) {
                      var newMacroPath = editingId.replace(dirFullPath, newFullPath);
                      dispatch((0, _index.editTestCase)(newMacroPath));
                    }
                  }, function (e) {
                    _log["default"].error(e);
                    var msg = 'Failed to rename: ' + e.message;
                    _antd.message.error(msg);
                    throw new Error(msg);
                  });
                }
              }).then(function () {
                return true;
              });
            });
          }
        });
      });
    };
  },
  macroCreateFile: function macroCreateFile(name) {
    return function (options) {
      return createThunkAction(function (dispatch, getState) {
        var dir = options.dir;
        var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
        var path = macroStorage.getPathLib();
        return (0, _prompt.prompt)({
          width: 400,
          title: 'Create new macro as..',
          message: '',
          value: '',
          placeholder: 'Macro name',
          selectionStart: 0,
          selectionEnd: 0,
          okText: 'Confirm',
          cancelText: 'Cancel',
          onCancel: function onCancel() {
            return Promise.resolve(true);
          },
          onOk: function onOk(macroName) {
            var filePath = path.join(dir, "".concat((0, _utils.sanitizeFileName)(macroName), ".json"));
            var fullPath = macroStorage.filePath(filePath);
            return macroStorage.fileExists(fullPath).then(function (exists) {
              if (exists) {
                var msg = "'".concat(macroName, "' already exists");
                _antd.message.error(msg);
                throw new Error(msg);
              }
              return macroStorage.write(filePath, {
                name: macroName,
                data: {
                  commands: []
                }
              }).then(function () {
                _antd.message.success("Created macro '".concat(macroName, "'"));
                checkNodeShowUp({
                  getState: getState,
                  dispatch: dispatch,
                  fullPath: fullPath,
                  message: 'New macro created'
                });
                return true;
              }, function (e) {
                _log["default"].error(e);
                var msg = 'Failed to create macro: ' + e.message;
                _antd.message.error(msg);
                throw new Error(msg);
              });
            });
          }
        });
      });
    };
  },
  ensureTreeNodeUnfoldedForCurrentMacroNode: function ensureTreeNodeUnfoldedForCurrentMacroNode(name) {
    return function (options) {
      var opts = _objectSpread({
        scrollIntoView: true
      }, options || {});
      return createThunkAction(function (dispatch, getState) {
        var state = getState();
        var macroId = (0, _recomputed.getCurrentMacroId)(state);
        var macrosExtra = (0, _recomputed.getMacrosExtra)(state);
        var fileNodes = (0, _recomputed.getMacroFileNodeData)(state);
        var ancestors = (0, _ts_utils.ancestorsInNodesList)(function (node) {
          return node.id === macroId;
        }, fileNodes);
        var scrollIfNeeded = function scrollIfNeeded() {
          if (opts.scrollIntoView) {
            setTimeout(function () {
              var id = (0, _ts_utils.normalizeHtmlId)(macroId);
              var $el = document.getElementById(id);
              if ($el) {
                (0, _scrollIntoViewIfNeeded["default"])($el, {
                  behavior: 'smooth',
                  block: 'nearest'
                });
              }
            }, 100);
          }
        };
        if (!ancestors || !ancestors.length) {
          return scrollIfNeeded();
        }
        var updates = ancestors.map(function (node) {
          return (0, _ts_utils.safeUpdateIn)([node.id], function (data) {
            return _objectSpread(_objectSpread({}, data || {}), {}, {
              folded: false
            });
          });
        });
        var newMacrosExtra = _ts_utils.compose.apply(void 0, _toConsumableArray(updates))(macrosExtra);
        dispatch((0, _index.setMacrosExtra)(newMacrosExtra, {
          shouldPersist: true
        }));
        scrollIfNeeded();
      });
    };
  },
  updateMacroIdsInTestSuites: function updateMacroIdsInTestSuites(name) {
    return function (macroIdChanges) {
      return createThunkAction(function (dispatch, getState) {
        var state = getState();
        var testSuites = (0, _recomputed.getTestSuitesWithAllInfo)(state);
        var oldMacroIds = Object.keys(macroIdChanges);
        oldMacroIds.forEach(function (oldMacroId) {
          var newMacroId = macroIdChanges[oldMacroId];
          //dispatch(saveEditingAsExisted());
          var state = getState();
          var _state$editor = state.editor,
            editing = _state$editor.editing,
            isDraggingCommand = _state$editor.isDraggingCommand;
          _storage2["default"].set('editing', editing);
          //document.querySelector('.select-case button').click()

          testSuites.forEach(function (ts) {
            var indices = ts.cases.reduce(function (prev, obj, i) {
              if (obj.testCaseId === oldMacroId) {
                prev.push(i);
              }
              return prev;
            }, []);
            if (indices.length === 0) {
              return;
            }
            var cases = _ts_utils.compose.apply(void 0, _toConsumableArray(indices.map(function (i) {
              return (0, _ts_utils.setIn)([i, 'testCaseId'], newMacroId);
            })))(ts.cases);
            dispatch(Actions.updateTestSuite(ts.id, {
              cases: cases
            }));
          });
        });
      });
    };
  },
  updateTestSuite: function updateTestSuite(name) {
    return function (id, data) {
      return createThunkAction(function (dispatch, getState) {
        var state = getState();
        var testSuites = (0, _recomputed.getTestSuitesWithAllInfo)(state);
        var ts = testSuites.find(function (ts) {
          return ts.id === id;
        });
        if (!ts) {
          return;
        }
        var realData = typeof data === 'function' ? data(ts) : data;
        var hasRename = realData.name && ts.name !== realData.name;
        if (hasRename) {
          var hasDuplciateName = !!testSuites.find(function (ts) {
            return ts.id !== id && ts.name === realData.name;
          });
          if (hasDuplciateName) {
            return Promise.reject(new Error("The test suite name '".concat(realData.name, "' already exists!")));
          }
        }

        // Note: revised may contain `playStatus`
        var revised = _objectSpread(_objectSpread({}, ts), realData);
        var suiteStorage = (0, _storage.getStorageManager)().getTestSuiteStorage();
        var suiteName = hasRename ? realData.name : ts.name;
        var pRename = hasRename ? suiteStorage.rename(ts.name, realData.name) : Promise.resolve();
        var pStoreExtra = hasRename && (0, _storage.getStorageManager)().isXFileMode() ? (0, _test_suite_extra_data.getTestSuiteExtraKeyValueData)().set(id, {
          fold: false,
          playStatus: {}
        }) : (0, _test_suite_extra_data.getTestSuiteExtraKeyValueData)().set(id, {
          fold: revised.fold,
          playStatus: revised.playStatus || {}
        });
        dispatch({
          type: name,
          data: {
            id: id,
            updated: (0, _test_suite_model.normalizeTestSuite)(revised)
          }
        });
        if (hasRename && (0, _storage.getStorageManager)().isXFileMode()) {
          // Reset test suite status
          dispatch({
            type: 'UPDATE_TEST_SUITE_STATUS',
            data: {
              id: id,
              extra: {
                fold: false,
                playStatus: {}
              }
            }
          });
        } else {
          dispatch({
            type: 'UPDATE_TEST_SUITE_STATUS',
            data: {
              id: id,
              extra: {
                fold: revised.fold,
                playStatus: revised.playStatus || {}
              }
            }
          });
        }
        return Promise.all([pRename, pStoreExtra]).then(function () {
          return suiteStorage.write(suiteName, revised);
        });
      });
    };
  },
  renameTestCase: function renameTestCase(name) {
    return function (newName, fullPath) {
      return createThunkAction(function (dispatch, getState) {
        var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
        var path = macroStorage.getPathLib();
        var state = getState();
        var editingId = state.editor.editing.meta.src.id;
        var newPath = macroStorage.filePath(path.join(path.dirname(fullPath), (0, _utils.sanitizeFileName)(newName)));
        return macroStorage.fileExists(fullPath).then(function (exists) {
          if (!exists) {
            throw new Error("No macro found with id '".concat(fullPath, "'!"));
          }
          return macroStorage.fileExists(newPath).then(function (exists) {
            if (exists) {
              throw new Error('The macro name already exists!');
            }
          });
        }).then(function () {
          if ((0, _storage.getStorageManager)().isXFileMode()) {
            // Reset test case status
            dispatch((0, _index.updateMacroPlayStatus)(fullPath, null));
          }
          return withMacroIdChanges({
            dispatch: dispatch,
            entryPath: fullPath,
            isDirectory: false,
            getNewFilePath: function getNewFilePath(_) {
              return newPath;
            },
            run: function run() {
              return (0, _storage.getStorageManager)().getMacroStorage().rename(fullPath, newPath).then(function () {
                if (editingId === fullPath) {
                  dispatch({
                    type: name,
                    data: newName,
                    post: _index.saveEditing
                  });
                }
              });
            }
          }).then(function () {
            var isRenamingCurrentMacro = editingId === fullPath;
            if (isRenamingCurrentMacro) {
              dispatch((0, _index.editTestCase)(newPath));
            }
            checkNodeShowUp({
              getState: getState,
              dispatch: dispatch,
              fullPath: newPath,
              switchToIt: false,
              message: 'Macro renamed'
            });
          });
        });
      });
    };
  },
  duplicateTestCase: function duplicateTestCase(name) {
    return function (macro) {
      return createThunkAction(function (dispatch, getState) {
        var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
        var path = macroStorage.getPathLib();
        var dirPath = path.dirname(macro.fullPath);
        var getNewPath = function getNewPath(newName) {
          return path.join(dirPath, "".concat(newName, ".json"));
        };
        var getNewName = function getNewName() {
          return (0, _utils.uniqueName)(macro.name, {
            generate: function generate(old) {
              var step = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
              var reg = /-(\d+)$/;
              var m = old.match(reg);
              if (!m) return "".concat(old, "-").concat(step);
              return old.replace(reg, function (_, n) {
                return "-".concat(parseInt(n, 10) + step);
              });
            },
            check: function check(fileName) {
              return macroStorage.fileExists(getNewPath(fileName)).then(function (exists) {
                return !exists;
              });
            }
          });
        };
        return getNewName().then(function (newMacroName) {
          return (0, _prompt.prompt)({
            width: 400,
            title: 'Duplicate macro as..',
            message: '',
            value: newMacroName,
            placeholder: 'Macro name',
            selectionStart: 0,
            selectionEnd: newMacroName.length,
            okText: 'Duplicate',
            cancelText: 'Cancel',
            onCancel: function onCancel() {
              return Promise.resolve(true);
            },
            onOk: function onOk(macroName) {
              var fullPath = macroStorage.filePath(getNewPath((0, _utils.sanitizeFileName)(macroName)));
              return macroStorage.fileExists(fullPath).then(function (exists) {
                if (exists) {
                  var msg = "'".concat(macroName, "' already exists");
                  _antd.message.error(msg);
                  throw new Error(msg);
                }
                return macroStorage.copy(macro.fullPath, fullPath, false, false).then(function () {
                  _antd.message.success("Successfully duplicated as '".concat(macroName, "'"));

                  // Note: need to wait until it's reflected in redux
                  checkNodeShowUp({
                    getState: getState,
                    dispatch: dispatch,
                    fullPath: fullPath,
                    message: 'Macro duplicated'
                  });
                  return true;
                }, function (e) {
                  _log["default"].error(e);
                  var msg = 'Failed to duplicate macro: ' + e.message;
                  _antd.message.error(msg);
                  throw new Error(msg);
                });
              });
            }
          });
        });
      });
    };
  },
  duplicateVisionImage: function duplicateVisionImage(name) {
    return function (imageName) {
      return createThunkAction(function (dispatch, getState) {
        var visionStorage = (0, _storage.getStorageManager)().getVisionStorage();
        var path = visionStorage.getPathLib();
        var dirPath = path.dirname(imageName);
        var getNewPath = function getNewPath(newName) {
          return path.join(dirPath, newName);
        };
        var getNewName = function getNewName() {
          return (0, _utils.uniqueName)(imageName, {
            generate: function generate(old) {
              var step = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
              var reg = /-(\d+)$/;
              var m = old.match(reg);
              if (!m) return "".concat(old, "-").concat(step);
              return old.replace(reg, function (_, n) {
                return "-".concat(parseInt(n, 10) + step);
              });
            },
            check: function check(fileName) {
              return visionStorage.fileExists(getNewPath(fileName)).then(function (exists) {
                return !exists;
              });
            }
          });
        };
        return getNewName().then(function (newImageName) {
          return (0, _prompt.prompt)({
            width: 400,
            title: 'Duplicate vision image as..',
            message: '',
            value: newImageName,
            placeholder: 'Macro name',
            selectionStart: 0,
            selectionEnd: newImageName.length,
            okText: 'Duplicate',
            cancelText: 'Cancel',
            onCancel: function onCancel() {
              return Promise.resolve(true);
            },
            onOk: function onOk(finalImageName) {
              var fullPath = visionStorage.filePath(getNewPath((0, _utils.sanitizeFileName)(finalImageName)));
              return visionStorage.fileExists(fullPath).then(function (exists) {
                if (exists) {
                  var msg = "'".concat(finalImageName, "' already exists");
                  _antd.message.error(msg);
                  throw new Error(msg);
                }
                return visionStorage.copy(imageName, fullPath, false, false).then(function () {
                  _antd.message.success("Successfully duplicated as '".concat(finalImageName, "'"));
                  dispatch((0, _index.listVisions)());
                  return true;
                }, function (e) {
                  _log["default"].error(e);
                  var msg = 'Failed to duplicate vision image: ' + e.message;
                  _antd.message.error(msg);
                  throw new Error(msg);
                });
              });
            }
          });
        });
      });
    };
  },
  selectInitialMacro: function selectInitialMacro(name) {
    return function (mode) {
      return createThunkAction(function (dispatch, getState) {
        var key = function () {
          switch (mode) {
            case _storage.StorageStrategyType.Browser:
              return _misc_data.MiscKey.BrowserModeLastMacroId;
            case _storage.StorageStrategyType.XFile:
              return _misc_data.MiscKey.XFileModeLastMacroId;
            default:
              throw new Error("Invalid mode: ".concat(mode));
          }
        }();
        return (0, _misc_data.getMiscData)().get(key).then(function (macroFullPath) {
          var state = getState();
          var found = macroFullPath ? (0, _recomputed.findMacroNodeWithCaseInsensitiveFullPath)(state, macroFullPath) : null;
          (0, _log["default"])('selectInitialMacro', key, macroFullPath, found, state);
          if (found) {
            return macroFullPath;
          }
          var rootNodes = (0, _recomputed.getMacroFolderNodeList)(state);
          var first = (0, _ts_utils.findNodeInForest)(function (node) {
            return node.isFile;
          }, rootNodes);
          return first ? first.fullPath : null;
        }).then(function (macroFullPath) {
          if (macroFullPath) {
            dispatch((0, _index.editTestCase)(macroFullPath));
          } else {
            dispatch((0, _index.editNewTestCase)());
          }
        });
      });
    };
  },
  editMacroByOffset: function editMacroByOffset(name) {
    return function (offset) {
      return createThunkAction(function (dispatch, getState) {
        var state = getState();
        if (state.ui.isSaving) {
          return;
        }
        var trees = (0, _recomputed.getFilteredMacroFileNodeData)(state);
        var macroId = (0, _recomputed.getCurrentMacroId)(state);
        if (macroId === _constant.UNTITLED_ID) {
          return;
        }
        var found = (0, _ts_utils.nodeByOffset)({
          offset: offset,
          tree: trees,
          isTargetQualified: function isTargetQualified(node) {
            return node.id === macroId;
          },
          isCandidateQualified: function isCandidateQualified(node) {
            return node.type === _tree_file.FileNodeType.File;
          }
        });
        if (!found) {
          return;
        }
        return dispatch((0, _index.editTestCase)(found.id)).then(function () {
          dispatch(Actions.ensureTreeNodeUnfoldedForCurrentMacroNode({
            scrollIntoView: true
          }));
        });
      });
    };
  },
  setMacroQuery: function setMacroQuery(name) {
    return function (query) {
      return createAction(name, query);
    };
  },
  setIndexToInsertRecorded: function setIndexToInsertRecorded(name) {
    return function (index) {
      return createAction(name, index);
    };
  },
  toggleRecorderSkipOpen: function toggleRecorderSkipOpen(name) {
    return function (force) {
      return createAction(name, force);
    };
  },
  scrollToCommandAtIndex: function scrollToCommandAtIndex(name) {
    return function (commandIndex) {
      return createThunkAction(function () {
        var $tableBody = document.querySelector('.table-wrapper .ReactVirtualized__Table__Grid');
        var itemHeight = _config["default"].ui.commandItemHeight;
        if (!$tableBody) {
          return;
        }
        var totalHeight = $tableBody.clientHeight;
        var scrollTop = $tableBody.scrollTop;
        var isAboveScrollArea = itemHeight * commandIndex < scrollTop;
        var isBelowScrollArea = itemHeight * (commandIndex + 3) > scrollTop + totalHeight;
        if (isAboveScrollArea) {
          $tableBody.scrollTop = itemHeight * commandIndex;
        } else if (isBelowScrollArea) {
          $tableBody.scrollTop = itemHeight * (commandIndex + 3) - totalHeight;
        }
      });
    };
  },
  gotoLineInMacro: function gotoLineInMacro(name) {
    return function (macroId, commandIndex) {
      return createThunkAction(function (dispatch, getState) {
        var state = getState();
        var currentMacroId = (0, _recomputed.getCurrentMacroId)(state);
        var saveMacro = macroId === currentMacroId ? function () {
          return Promise.resolve(true);
        } : function () {
          return (0, _save_test_case["default"])({
            dispatch: dispatch,
            getState: getState
          }).saveOrNot({
            cancelText: 'Cancel'
          });
        };
        var gotoLine = function gotoLine() {
          return Promise.resolve(dispatch((0, _index.editTestCase)(macroId))).then(function () {
            dispatch((0, _index.selectCommand)(commandIndex, true));
            dispatch(Actions.scrollToCommandAtIndex(commandIndex));
          });
        };
        saveMacro().then(function (success) {
          if (success) {
            return gotoLine();
          }
        })["catch"](function (e) {
          _log["default"].warn(e);
        });
      });
    };
  },
  downloadMacroAsJson: function downloadMacroAsJson(name) {
    return function (macroId) {
      return createThunkAction(function (dispatch, getState) {
        return (0, _storage.getStorageManager)().getMacroStorage().read(macroId, 'Text').then(function (content) {
          var macro = content;
          var downloadJson = function downloadJson() {
            var str = (0, _convert_utils.toJSONString)({
              name: macro.name,
              commands: macro.data.commands
            }, {
              ignoreTargetOptions: (0, _recomputed.getShouldIgnoreTargetOptions)(getState())
            });
            var blob = new Blob([str], {
              type: 'text/plain;charset=utf-8'
            });
            _file_saver["default"].saveAs(blob, "".concat(macro.name, ".json"), true);
          };
          var involveOtherResources = function involveOtherResources() {
            var imageRelatedCommands = macro.data.commands.filter(function (command) {
              var _parseImageTarget;
              return !(0, _command.canCommandReadImage)(command.cmd) ? false : (_parseImageTarget = (0, _command.parseImageTarget)(command.target)) === null || _parseImageTarget === void 0 ? void 0 : _parseImageTarget.fileName;
            });
            var csvRelatedCommands = macro.data.commands.filter(function (cmd) {
              return (0, _command.canCommandReadCsv)(cmd.cmd);
            });
            var macroRelatedCommands = macro.data.commands.filter(function (cmd) {
              return (0, _command.canCommandRunMacro)(cmd.cmd);
            });
            if (imageRelatedCommands.length === 0 && csvRelatedCommands.length === 0 && macroRelatedCommands.length === 0) {
              return false;
            }
            return true;
          };
          if (!involveOtherResources()) {
            return downloadJson();
          }
          return (0, _prompt.prompt)({
            width: 400,
            title: 'Export as zip instead?',
            message: 'This macro contains images/csv.\nDo you want to use the ZIP export option instead?',
            noInput: true,
            closable: false,
            okText: 'ZIP',
            cancelText: 'JSON',
            onCancel: function onCancel() {
              downloadJson();
              return Promise.resolve(true);
            },
            onOk: function onOk() {
              dispatch(Actions.downloadMacroAsZip(macroId));
              return Promise.resolve(true);
            }
          }).then(function () {});
        });
      });
    };
  },
  downloadMacroAsHTML: function downloadMacroAsHTML(name) {
    return function (macroId) {
      return createThunkAction(function (dispatch, getState) {
        return (0, _storage.getStorageManager)().getMacroStorage().read(macroId, 'Text').then(function (content) {
          var macro = content;
          var str = (0, _convert_utils.toHtml)({
            name: macro.name,
            commands: macro.data.commands
          });
          var blob = new Blob([str], {
            type: 'text/plain;charset=utf-8'
          });
          _file_saver["default"].saveAs(blob, "".concat(macro.name, ".html"), true);
        });
      });
    };
  },
  downloadMacroAsZip: function downloadMacroAsZip(name) {
    return function (macroId) {
      return createThunkAction(function (dispatch, getState) {
        var zip = new _jszip["default"]();
        var warn = function warn(msg) {
          return dispatch((0, _index.addLog)('warning', msg));
        };
        var imageDict = {};
        var csvDict = {};
        var macroDict = {};
        var bundleMacroIntoZip = function bundleMacroIntoZip(macroId, isSubMacro) {
          var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
          var path = macroStorage.getPathLib();
          return macroStorage.read(macroId, 'Text').then(function (content) {
            var macro = content;
            var macroToSave = (0, _ts_utils.clone)(macro);
            var imageRelatedCommands = macro.data.commands.filter(function (cmd) {
              return (0, _command.canCommandReadImage)(cmd.cmd);
            });
            var csvRelatedCommands = macro.data.commands.filter(function (cmd) {
              return (0, _command.canCommandReadCsv)(cmd.cmd);
            });
            var macroRelatedCommands = [];

            // Since all macros are saved in the same folder now,
            // macro paths in `run` commands should be changed accordingly
            macro.data.commands.forEach(function (cmd, i) {
              if ((0, _command.canCommandRunMacro)(cmd.cmd)) {
                macroRelatedCommands.push(cmd);
                macroToSave.data.commands[i].target = path.basename(cmd.target);
              }
            });
            Promise.all([].concat(_toConsumableArray(imageRelatedCommands.map(function (command) {
              var _parseImageTarget2;
              var imageFileName = (_parseImageTarget2 = (0, _command.parseImageTarget)(command.target)) === null || _parseImageTarget2 === void 0 ? void 0 : _parseImageTarget2.fileName;
              if (!imageFileName || imageDict[imageFileName]) {
                return Promise.resolve();
              }
              imageDict[imageFileName] = true;
              return (0, _storage.getStorageManager)().getVisionStorage().read(imageFileName, 'ArrayBuffer').then(function (buffer) {
                zip.file(imageFileName, buffer, {
                  binary: true
                });
              })["catch"](function (e) {
                warn("Failed to add ".concat(imageFileName, " into zip: ").concat(e.message));
              });
            })), _toConsumableArray(csvRelatedCommands.map(function (command) {
              var csvFileName = command.target;
              if (!csvFileName || csvDict[csvFileName]) {
                return Promise.resolve();
              }
              csvDict[csvFileName] = true;
              return (0, _storage.getStorageManager)().getCSVStorage().read(csvFileName, 'Text').then(function (text) {
                zip.file(csvFileName, text);
              })["catch"](function (e) {
                warn("Failed to add ".concat(csvFileName, " into zip: ").concat(e.message));
              });
            })), _toConsumableArray(macroRelatedCommands.map(function (command) {
              var subMacroRelativePath = (0, _ts_utils.resolvePath)(macroStorage.getPathLib(), macroStorage.relativePath(macroId), command.target);
              var subMacroNode = (0, _recomputed.findMacroNodeWithCaseInsensitiveRelativePath)(getState(), subMacroRelativePath);
              var subMacroId = subMacroNode ? subMacroNode.fullPath : subMacroRelativePath;
              if (macroDict[subMacroId]) {
                return Promise.resolve();
              }
              return bundleMacroIntoZip(subMacroId, true);
            })))).then(function () {
              zip.file(macroToSave.name + '.json', (0, _convert_utils.toJSONString)({
                name: macroToSave.name,
                commands: macroToSave.data.commands
              }));
              if (isSubMacro) {
                return;
              }
              return zip.generateAsync({
                type: 'blob'
              }).then(function (blob) {
                return _file_saver["default"].saveAs(blob, "".concat(macroToSave.name, ".zip"));
              });
            });
          });
        };
        return bundleMacroIntoZip(macroId)["catch"](function (e) {
          warn("Failed to save zip file: ".concat(e.message));
        });
      });
    };
  },
  readFilesAndImportTestCases: function readFilesAndImportTestCases(name) {
    return function (params) {
      var type = params.type,
        process = params.process,
        folder = params.folder,
        rawFiles = params.files;
      return createThunkAction(function (dispatch, getState) {
        var files = Array.from(rawFiles);
        if (!files || !files.length) {
          return;
        }
        var read = function read(file) {
          return new Promise(function (resolve, reject) {
            var reader = new FileReader();
            reader.onload = function (event) {
              var _event$target;
              var content = (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result;
              new Promise(function (resolve) {
                return resolve(process(content, file.name, file));
              }).then(function (result) {
                if (!result || !result.macros.length) {
                  return resolve({
                    err: new Error('Failed to parse macro'),
                    fileName: file.name
                  });
                }
                var macros = result.macros,
                  _result$images = result.images,
                  images = _result$images === void 0 ? [] : _result$images,
                  _result$csvs = result.csvs,
                  csvs = _result$csvs === void 0 ? [] : _result$csvs;
                resolve({
                  data: {
                    macros: macros,
                    images: images,
                    csvs: csvs
                  }
                });
              })["catch"](function (e) {
                resolve({
                  err: e,
                  fileName: file.name
                });
              });
            };
            switch (type) {
              case 'text':
                return reader.readAsText(file);
              case 'data_url':
                return reader.readAsDataURL(file);
              case 'binary_string':
                return reader.readAsBinaryString(file);
              case 'array_buffer':
                return reader.readAsArrayBuffer(file);
            }
          });
        };
        var saveResource = function saveResource(storage, fileName, type, content) {
          var blob = type === 'text' ? new Blob([content]) : content;
          return storage.fileExists(fileName).then(function (exists) {
            if (exists) {
              return {
                error: "".concat(fileName, " already exists")
              };
            }
            return storage.write(fileName, blob).then(function () {
              return {
                fileName: fileName
              };
            })["catch"](function (e) {
              return {
                error: "Failed to save ".concat(fileName, ": ").concat(e.message)
              };
            });
          });
        };
        var saveAllForMacro = function saveAllForMacro(item) {
          return Promise.all([Promise.all(item.csvs.map(function (csv) {
            return saveResource((0, _storage.getStorageManager)().getCSVStorage(), csv.fileName, 'text', csv.content);
          })), Promise.all(item.images.map(function (csv) {
            return saveResource((0, _storage.getStorageManager)().getVisionStorage(), csv.fileName, 'blob', csv.content);
          }))]).then(function (tuple) {
            var _tuple = _slicedToArray(tuple, 2),
              csvResult = _tuple[0],
              pngResult = _tuple[1];
            return Promise.resolve({
              macros: item.macros,
              csvImported: csvResult.filter(function (x) {
                return x.fileName;
              }).map(function (x) {
                return x.fileName;
              }),
              pngImported: pngResult.filter(function (x) {
                return x.fileName;
              }).map(function (x) {
                return x.fileName;
              }),
              errors: [].concat(_toConsumableArray(csvResult.filter(function (x) {
                return x.error;
              }).map(function (x) {
                return x.error;
              })), _toConsumableArray(pngResult.filter(function (x) {
                return x.error;
              }).map(function (x) {
                return x.error;
              })))
            });
          });
        };
        Promise.all(files.map(read)).then(function (list) {
          var doneList = list.filter(function (x) {
            return x.data;
          });
          var failList = list.filter(function (x) {
            return x.err;
          });
          return Promise.all(doneList.map(function (item) {
            return saveAllForMacro(item.data);
          })).then(function (saveResourceResults) {
            return dispatch((0, _index.addTestCases)({
              folder: folder,
              macros: (0, _ts_utils.flatten)(doneList.map(function (x) {
                return x.data.macros;
              }))
            })).then(function (_ref) {
              var passCount = _ref.passCount,
                failCount = _ref.failCount,
                failTcs = _ref.failTcs;
              _antd.message.info(["".concat(passCount, " macro").concat(passCount > 1 ? 's' : '', " imported!"), "".concat(failList.length + failCount, " macro").concat(failList.length + failCount > 1 ? 's' : '', " failed!")].join(', '), 3);
              failList.forEach(function (fail) {
                dispatch((0, _index.addLog)('error', "in parsing ".concat(fail.fileName, ": ").concat(fail.err.message)));
              });
              failTcs.forEach(function (fail) {
                dispatch((0, _index.addLog)('error', "duplicated macro name: ".concat(fail.name), {
                  noStack: true
                }));
              });
              var allCsvs = (0, _ts_utils.flatten)(saveResourceResults.map(function (item) {
                return item.csvImported;
              }));
              var allPngs = (0, _ts_utils.flatten)(saveResourceResults.map(function (item) {
                return item.pngImported;
              }));
              var allErrors = (0, _ts_utils.flatten)(saveResourceResults.map(function (item) {
                return item.errors;
              }));
              var allMacroNames = (0, _ts_utils.flatten)(saveResourceResults.map(function (item) {
                return item.macros;
              })).filter(function (item) {
                return !failTcs.find(function (fail) {
                  return fail.name == item.name;
                });
              }).map(function (item) {
                return item.name;
              });
              if (allMacroNames.length > 0) {
                dispatch((0, _index.addLog)('info', "".concat(allMacroNames.length, " ").concat(allMacroNames.length > 1 ? 'macros' : 'macro', " imported:\n").concat(allMacroNames.join('\n'))));
              }
              if (allCsvs.length > 0) {
                dispatch((0, _index.addLog)('info', "".concat(allCsvs.length, " CSV imported:\n").concat(allCsvs.join('\n'))));
                dispatch((0, _index.listCSV)());
              }
              if (allPngs.length > 0) {
                dispatch((0, _index.addLog)('info', "".concat(allPngs.length, " PNG imported:\n").concat(allPngs.join('\n'))));
                dispatch((0, _index.listVisions)());
              }
              if (allErrors.length > 0) {
                dispatch((0, _index.addLog)('error', "".concat(allErrors.length, " ").concat(allErrors.length > 1 ? 'errors' : 'error', " in importing csv/png:\n").concat(allErrors.join('\n'))));
              }
            });
          })["catch"](function (e) {
            dispatch((0, _index.addLog)('error', e.message, {
              noStack: true
            }));
          });
        });
      });
    };
  },
  importMacroHtml: function importMacroHtml(name) {
    return function (files, folder) {
      return createThunkAction(function (dispatch, getState) {
        var process = function process(content, fileName) {
          return {
            macros: [(0, _convert_utils.fromHtml)(content)],
            csvs: [],
            images: []
          };
        };
        dispatch(Actions.readFilesAndImportTestCases({
          folder: folder,
          files: files,
          process: process,
          type: 'text'
        }));
      });
    };
  },
  importMacroJsonOrZipFiles: function importMacroJsonOrZipFiles(name) {
    return function (files, folder) {
      return createThunkAction(function (dispatch, getState) {
        var process = function process(content, fileName, file) {
          if (/.json$/i.test(fileName)) {
            var str = (0, _utils.arrayBufferToString)(content);
            return Promise.resolve({
              macros: [(0, _convert_utils.fromJSONString)(str, fileName)],
              csvs: [],
              images: []
            });
          }
          return _jszip["default"].loadAsync(content).then(function (zip) {
            var pJsonList = [];
            var pCsvList = [];
            var pPngList = [];
            zip.forEach(function (relativePath, file) {
              var extName = (0, _ts_utils.getExtName)(relativePath).toLowerCase();
              switch (extName) {
                case '.csv':
                  pCsvList.push(file.async('text').then(function (content) {
                    return {
                      content: content,
                      fileName: relativePath
                    };
                  }));
                  break;
                case '.png':
                  pPngList.push(file.async('blob').then(function (content) {
                    return {
                      content: content,
                      fileName: relativePath
                    };
                  }));
                  break;
                case '.json':
                  pJsonList.push(file.async('text').then(function (content) {
                    return {
                      content: content,
                      fileName: relativePath
                    };
                  }));
                  break;
              }
            });
            if (pJsonList.length === 0) {
              throw new Error('No json file found in zip');
            }
            return Promise.all([Promise.all(pJsonList), Promise.all(pCsvList), Promise.all(pPngList)]).then(function (triple) {
              var macros = triple[0].map(function (obj) {
                return (0, _convert_utils.fromJSONString)(obj.content, obj.fileName);
              });
              return {
                macros: macros,
                csvs: triple[1],
                images: triple[2]
              };
            });
          });
        };
        dispatch(Actions.readFilesAndImportTestCases({
          files: files,
          folder: folder,
          process: process,
          type: 'array_buffer'
        }));
      });
    };
  }
};
var ActionTypes = exports.ActionTypes = (0, _ts_utils.objMap)(function (_, key) {
  return key;
}, ActionFactories);
var Actions = exports.Actions = (0, _ts_utils.objMap)(function (factory, key, i) {
  return factory(ActionTypes[key]);
}, ActionFactories);
function createAction(type, data) {
  return {
    type: type,
    data: data
  };
}
function createThunkAction(thunk) {
  return thunk;
}

// Note: type safe action and reducer
// reference: https://medium.com/@martin_hotell/improved-redux-type-safety-with-typescript-2-8-2c11a8062575

/***/ }),

/***/ 6329:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.captureClientAPI = exports.CaptureScreenshotService = void 0;
exports.getScreenshotRatio = getScreenshotRatio;
exports.imageSizeFromDataURI = imageSizeFromDataURI;
exports.scaleDataURI = scaleDataURI;
var _web_extension = _interopRequireDefault(__webpack_require__(41953));
var _utils = __webpack_require__(46580);
var _ts_utils = __webpack_require__(1601);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; } /* globals chrome */
function imageSizeFromDataURI(dataURI) {
  return createImageBitmap((0, _utils.dataURItoBlob)(dataURI)).then(function (img) {
    return {
      width: img.width,
      height: img.height
    };
  });
}
function getScreenshotRatio(dataURI, tabId, devicePixelRatio) {
  return Promise.all([imageSizeFromDataURI(dataURI), _web_extension["default"].tabs.get(tabId)]).then(function (tuple) {
    var _tuple = _slicedToArray(tuple, 2),
      size = _tuple[0],
      tab = _tuple[1];
    return tab.width * devicePixelRatio / size.width;
  });
}
function scaleDataURI(dataURI, scale) {
  if (scale === 1) return Promise.resolve(dataURI);
  return imageSizeFromDataURI(dataURI).then(function (size) {
    var canvas = createCanvas(size.width, size.height, scale);
    return drawOnCanvas({
      canvas: canvas,
      dataURI: dataURI,
      x: 0,
      y: 0,
      width: size.width * scale,
      height: size.height * scale
    }).then(function () {
      return canvas.toDataURL();
    });
  });
}
function pCompose(list) {
  return list.reduce(function (prev, fn) {
    return prev.then(fn);
  }, Promise.resolve());
}
var CaptureScreenshotService = exports.CaptureScreenshotService = /*#__PURE__*/function () {
  function CaptureScreenshotService(params) {
    _classCallCheck(this, CaptureScreenshotService);
    this.params = params;
    this.captureVisibleTab = typeof chrome !== 'undefined' && typeof chrome.tabs !== 'undefined' && typeof chrome.tabs.MAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND === 'number' ? (0, _ts_utils.throttlePromiseFunc)(this.params.captureVisibleTab, chrome.tabs.MAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND * 1000 + 100) : this.params.captureVisibleTab;
  }
  _createClass(CaptureScreenshotService, [{
    key: "saveScreen",
    value: function saveScreen(screenshotStorage, tabId, fileName, devicePixelRatio) {
      return this.captureScreenBlob(tabId, devicePixelRatio).then(function (screenBlob) {
        return screenshotStorage.overwrite(fileName, screenBlob).then(function () {
          return screenshotStorage.getLink(fileName);
        }).then(function (url) {
          return {
            url: url,
            fileName: fileName
          };
        }, function (e) {
          return Promise.reject(e);
        });
      });
    }
  }, {
    key: "saveFullScreen",
    value: function saveFullScreen(screenshotStorage, tabId, fileName, clientAPI) {
      return this.captureFullScreen(tabId, clientAPI, {
        blob: true
      }).then(function (screenBlob) {
        return screenshotStorage.overwrite(fileName, screenBlob).then(function () {
          return screenshotStorage.getLink(fileName);
        }).then(function (url) {
          return {
            url: url,
            fileName: fileName
          };
        });
      });
    }
  }, {
    key: "captureScreen",
    value: function captureScreen(tabId, devicePixelRatio, presetScreenshotRatio) {
      var is2ndArgFunction = typeof presetScreenshotRatio === 'function';
      var hasScreenshotRatio = !!presetScreenshotRatio && !is2ndArgFunction;
      var pDataURI = this.captureVisibleTab(null, {
        format: 'png'
      });
      var pRatio = hasScreenshotRatio ? Promise.resolve(presetScreenshotRatio) : pDataURI.then(function (dataURI) {
        return getScreenshotRatio(dataURI, tabId, devicePixelRatio);
      });
      return Promise.all([pDataURI, pRatio]).then(function (tuple) {
        var _tuple2 = _slicedToArray(tuple, 2),
          dataURI = _tuple2[0],
          screenshotRatio = _tuple2[1];
        // Note: leak the info about screenshotRatio on purpose
        if (!hasScreenshotRatio && is2ndArgFunction) presetScreenshotRatio(screenshotRatio);
        if (screenshotRatio === 1) return dataURI;
        return scaleDataURI(dataURI, screenshotRatio);
      });
    }
  }, {
    key: "captureFullScreen",
    value: function captureFullScreen(tabId) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : captureClientAPI,
        startCapture = _ref.startCapture,
        scrollPage = _ref.scrollPage,
        endCapture = _ref.endCapture;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var opts = _objectSpread({
        blob: false
      }, options);
      return withPageInfo(startCapture, endCapture, function (pageInfo) {
        var devicePixelRatio = pageInfo.devicePixelRatio;

        // Note: cut down page width and height
        // reference: https://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element/11585939#11585939
        var maxSide = Math.floor(32767 / devicePixelRatio);
        pageInfo.pageWidth = Math.min(maxSide, pageInfo.pageWidth);
        pageInfo.pageHeight = Math.min(maxSide, pageInfo.pageHeight);
        var captureScreen = _this.createCaptureScreenWithCachedScreenshotRatio(devicePixelRatio);
        var canvas = createCanvas(pageInfo.pageWidth, pageInfo.pageHeight, devicePixelRatio);
        var scrollOffsets = getAllScrollOffsets(pageInfo);
        var todos = scrollOffsets.map(function (offset, i) {
          return function () {
            return scrollPage(offset, {
              index: i,
              total: scrollOffsets.length
            }).then(function (realOffset) {
              return captureScreen(tabId).then(function (dataURI) {
                return drawOnCanvas({
                  canvas: canvas,
                  dataURI: dataURI,
                  x: realOffset.x * devicePixelRatio,
                  y: realOffset.y * devicePixelRatio,
                  width: pageInfo.windowWidth * devicePixelRatio,
                  height: pageInfo.windowHeight * devicePixelRatio
                });
              });
            });
          };
        });
        var convert = opts.blob ? _utils.dataURItoBlob : function (x) {
          return x;
        };
        return pCompose(todos).then(function () {
          return convert(canvas.toDataURL());
        });
      });
    }
  }, {
    key: "captureScreenInSelectionSimple",
    value: function captureScreenInSelectionSimple(tabId, _ref2) {
      var rect = _ref2.rect,
        devicePixelRatio = _ref2.devicePixelRatio;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var opts = _objectSpread({
        blob: false
      }, options);
      var convert = opts.blob ? _utils.dataURItoBlob : function (x) {
        return x;
      };
      var canvas = createCanvas(rect.width, rect.height, devicePixelRatio);
      return this.captureScreen(tabId, devicePixelRatio).then(function (dataURI) {
        return drawOnCanvas({
          canvas: canvas,
          dataURI: dataURI,
          x: -1 * rect.x * devicePixelRatio,
          y: -1 * rect.y * devicePixelRatio
        });
      }).then(function () {
        return convert(canvas.toDataURL());
      });
    }
  }, {
    key: "captureScreenInSelection",
    value: function captureScreenInSelection(tabId, _ref3, _ref4) {
      var _this2 = this;
      var rect = _ref3.rect,
        devicePixelRatio = _ref3.devicePixelRatio;
      var startCapture = _ref4.startCapture,
        scrollPage = _ref4.scrollPage,
        endCapture = _ref4.endCapture;
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var opts = _objectSpread({
        blob: false
      }, options);
      var convert = opts.blob ? _utils.dataURItoBlob : function (x) {
        return x;
      };
      return withPageInfo(startCapture, endCapture, function (pageInfo) {
        var maxSide = Math.floor(32767 / devicePixelRatio);
        pageInfo.pageWidth = Math.min(maxSide, pageInfo.pageWidth);
        pageInfo.pageHeight = Math.min(maxSide, pageInfo.pageHeight);
        var captureScreen = _this2.createCaptureScreenWithCachedScreenshotRatio(devicePixelRatio);
        var canvas = createCanvas(rect.width, rect.height, devicePixelRatio);
        var scrollOffsets = getAllScrollOffsetsForRect(rect, pageInfo);
        var todos = scrollOffsets.map(function (offset, i) {
          return function () {
            return scrollPage(offset, {
              index: i,
              total: scrollOffsets.length
            }).then(function (realOffset) {
              return captureScreen(tabId).then(function (dataURI) {
                return drawOnCanvas({
                  canvas: canvas,
                  dataURI: dataURI,
                  x: (realOffset.x - rect.x) * devicePixelRatio,
                  y: (realOffset.y - rect.y) * devicePixelRatio,
                  width: pageInfo.windowWidth * devicePixelRatio,
                  height: pageInfo.windowHeight * devicePixelRatio
                });
              });
            });
          };
        });
        return pCompose(todos).then(function () {
          return convert(canvas.toDataURL());
        });
      });
    }
  }, {
    key: "createCaptureScreenWithCachedScreenshotRatio",
    value: function createCaptureScreenWithCachedScreenshotRatio(devicePixelRatio) {
      var _this3 = this;
      var screenshotRatio;
      return function (tabId) {
        return _this3.captureScreen(tabId, devicePixelRatio, screenshotRatio || function (ratio) {
          screenshotRatio = ratio;
        });
      };
    }
  }, {
    key: "captureScreenBlob",
    value: function captureScreenBlob(tabId, devicePixelRatio) {
      return this.captureScreen(tabId, devicePixelRatio).then(_utils.dataURItoBlob);
    }
  }]);
  return CaptureScreenshotService;
}();
function getAllScrollOffsets(_ref5) {
  var pageWidth = _ref5.pageWidth,
    pageHeight = _ref5.pageHeight,
    windowWidth = _ref5.windowWidth,
    windowHeight = _ref5.windowHeight,
    _ref5$topPadding = _ref5.topPadding,
    topPadding = _ref5$topPadding === void 0 ? 150 : _ref5$topPadding;
  var topPad = windowHeight > topPadding ? topPadding : 0;
  var xStep = windowWidth;
  var yStep = windowHeight - topPad;
  var result = [];

  // Note: bottom comes first so that when we render those screenshots one by one to the final canvas,
  // those at top will overwrite top padding part of those at bottom, it is useful if that page has some fixed header
  for (var y = pageHeight - windowHeight; y > -1 * yStep; y -= yStep) {
    for (var x = 0; x < pageWidth; x += xStep) {
      result.push({
        x: x,
        y: y
      });
    }
  }
  return result;
}
function getAllScrollOffsetsForRect(_ref6, _ref7) {
  var x = _ref6.x,
    y = _ref6.y,
    width = _ref6.width,
    height = _ref6.height;
  var windowWidth = _ref7.windowWidth,
    windowHeight = _ref7.windowHeight,
    _ref7$topPadding = _ref7.topPadding,
    topPadding = _ref7$topPadding === void 0 ? 150 : _ref7$topPadding;
  var topPad = windowHeight > topPadding ? topPadding : 0;
  var xStep = windowWidth;
  var yStep = windowHeight - topPad;
  var result = [];
  for (var sy = y + height - windowHeight; sy > y - yStep; sy -= yStep) {
    for (var sx = x; sx < x + width; sx += xStep) {
      result.push({
        x: sx,
        y: sy
      });
    }
  }
  if (result.length === 0) {
    result.push({
      x: x,
      y: y + height - windowHeight
    });
  }
  return result;
}
function createCanvas(width, height) {
  var pixelRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  if (typeof window === 'undefined') {
    return new self.OffscreenCanvas(width * pixelRatio, height * pixelRatio);
  }
  var canvas = document.createElement('canvas');
  canvas.width = width * pixelRatio;
  canvas.height = height * pixelRatio;
  return canvas;
}
function drawOnCanvas(_ref8) {
  var canvas = _ref8.canvas,
    dataURI = _ref8.dataURI,
    x = _ref8.x,
    y = _ref8.y,
    width = _ref8.width,
    height = _ref8.height;
  return createImageBitmap((0, _utils.dataURItoBlob)(dataURI)).then(function (image) {
    canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height, x, y, width || image.width, height || image.height);
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  });
}
function withPageInfo(startCapture, endCapture, callback) {
  return startCapture().then(function (pageInfo) {
    // Note: in case sender contains any non-serializable data
    delete pageInfo.sender;
    return callback(pageInfo).then(function (result) {
      endCapture(pageInfo);
      return result;
    });
  });
}
var captureClientAPI = exports.captureClientAPI = {
  getPageInfo: function getPageInfo() {
    var body = document.body;
    var widths = [document.documentElement.clientWidth, document.documentElement.scrollWidth, document.documentElement.offsetWidth, body ? body.scrollWidth : 0, body ? body.offsetWidth : 0];
    var heights = [document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight, body ? body.scrollHeight : 0, body ? body.offsetHeight : 0];
    var data = {
      pageWidth: Math.max.apply(Math, widths),
      pageHeight: Math.max.apply(Math, heights),
      windowWidth: window.innerWidth,
      windowHeight: window.innerHeight,
      hasBody: !!body,
      originalX: window.scrollX,
      originalY: window.scrollY,
      originalOverflowStyle: document.documentElement.style.overflow,
      originalBodyOverflowYStyle: body && body.style.overflowY,
      devicePixelRatio: window.devicePixelRatio
    };
    return data;
  },
  startCapture: function startCapture() {
    var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref9$hideScrollbar = _ref9.hideScrollbar,
      hideScrollbar = _ref9$hideScrollbar === void 0 ? true : _ref9$hideScrollbar;
    var body = document.body;
    var pageInfo = captureClientAPI.getPageInfo();

    // Note: try to make pages with bad scrolling work, e.g., ones with
    // `body { overflow-y: scroll; }` can break `window.scrollTo`
    if (body) {
      body.style.overflowY = 'visible';
    }
    if (hideScrollbar) {
      // Disable all scrollbars. We'll restore the scrollbar state when we're done
      // taking the screenshots.
      document.documentElement.style.overflow = 'hidden';
    }
    return Promise.resolve(pageInfo);
  },
  scrollPage: function scrollPage(_ref10, opts) {
    var x = _ref10.x,
      y = _ref10.y;
    window.scrollTo(x, y);
    return (0, _utils.delay)(function () {
      return {
        x: window.scrollX,
        y: window.scrollY
      };
    }, 100);
  },
  endCapture: function endCapture(pageInfo) {
    var originalX = pageInfo.originalX,
      originalY = pageInfo.originalY,
      hasBody = pageInfo.hasBody,
      originalOverflowStyle = pageInfo.originalOverflowStyle,
      originalBodyOverflowYStyle = pageInfo.originalBodyOverflowYStyle;
    if (hasBody) {
      document.body.style.overflowY = originalBodyOverflowYStyle !== null && originalBodyOverflowYStyle !== void 0 ? originalBodyOverflowYStyle : '';
    }
    document.documentElement.style.overflow = originalOverflowStyle;
    window.scrollTo(originalX, originalY);
    return Promise.resolve(true);
  }
};

/***/ }),

/***/ 92642:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
function setStyle($dom, obj) {
  Object.keys(obj).forEach(function (key) {
    $dom.style[key] = obj[key];
  });
}
function createTextarea() {
  // [legacy code] Used to use textarea for copy/paste
  //
  // const $input = document.createElement('textarea')
  // // Note: Firefox requires 'contenteditable' attribute, even on textarea element
  // // without it, execCommand('paste') won't work in Firefox
  // // reference: https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Interact_with_the_clipboard#Browser-specific_considerations_2
  // $input.setAttribute('contenteditable', true)
  // $input.id = 'clipboard_textarea'

  // Note: 2018-09-01, Firefox 61.0.2: Only able to paste clipboard into textarea for one time.
  // Switching to contenteditable div works fine
  var $input = document.createElement('div');
  $input.setAttribute('contenteditable', 'true');
  $input.id = 'clipboard_textarea';
  setStyle($input, {
    position: 'aboslute',
    top: '-9999px',
    left: '-9999px'
  });
  (document.body || document.documentElement).appendChild($input);
  return $input;
}
function getTextArea() {
  var $el = document.getElementById('clipboard_textarea');
  if ($el) return $el;
  return createTextarea();
}
function withInput(fn) {
  var $input = getTextArea();
  var ret;
  try {
    ret = fn($input);
  } catch (e) {
    console.error(e);
  } finally {
    $input.innerHTML = '';
  }
  return ret;
}
var api = {
  set: function set(text) {
    withInput(function ($input) {
      $input.innerText = text;
      $input.focus();
      document.execCommand('selectAll', false, null);
      document.execCommand('copy');
    });
  },
  get: function get() {
    return withInput(function ($input) {
      $input.blur();
      $input.focus();
      var res = document.execCommand('paste');
      if (res) {
        return $input.innerText;
      }
      return 'no luck';
    });
  }
};
var _default = exports["default"] = api;

/***/ }),

/***/ 80199:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Counter = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Counter = exports.Counter = /*#__PURE__*/function () {
  function Counter() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Counter);
    _defineProperty(this, "n", 0);
    var initial = options.initial,
      getMax = options.getMax,
      onMax = options.onMax;
    if (typeof getMax !== 'function') throw new Error("'getMax' function is required");
    if (typeof onMax !== 'function') throw new Error("onMax callback is required");
    this.initial = initial || 0;
    this.getMax = getMax;
    this.onMax = onMax;
    this.reset();
  }
  _createClass(Counter, [{
    key: "reset",
    value: function reset() {
      this.n = this.initial;
    }
  }, {
    key: "get",
    value: function get() {
      return this.n;
    }
  }, {
    key: "getMaximum",
    value: function getMaximum() {
      return this.getMax();
    }
  }, {
    key: "check",
    value: function check() {
      var max = this.getMax();
      if (this.n + 1 > max) {
        this.onMax(this.n, max, this.initial);
        return false;
      }
      return true;
    }
  }, {
    key: "inc",
    value: function inc() {
      var max = this.getMax();
      if (this.n < max) {
        this.n += 1;
        return true;
      } else {
        this.onMax(this.n, max, this.initial);
        return false;
      }
    }
  }]);
  return Counter;
}();

/***/ }),

/***/ 90385:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PersistentCounter = void 0;
var _counter = __webpack_require__(80199);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var PersistentCounter = exports.PersistentCounter = /*#__PURE__*/function (_Counter) {
  _inherits(PersistentCounter, _Counter);
  function PersistentCounter(options) {
    var _this;
    _classCallCheck(this, PersistentCounter);
    _this = _callSuper(this, PersistentCounter, [options]);
    _defineProperty(_assertThisInitialized(_this), "ready", false);
    _this.read = options.read;
    _this.write = options.write;
    return _this;
  }
  _createClass(PersistentCounter, [{
    key: "reset",
    value: function reset() {
      var _this2 = this;
      _get(_getPrototypeOf(PersistentCounter.prototype), "reset", this).call(this);
      this.ready = false;
      setTimeout(function () {
        _this2.read().then(function (n) {
          _this2.ready = true;
          _this2.n = n;
        });
      }, 0);
    }
  }, {
    key: "inc",
    value: function inc() {
      if (!this.ready) {
        throw new Error('counter not ready yet');
      }
      var result = _get(_getPrototypeOf(PersistentCounter.prototype), "inc", this).call(this);
      this.write(this.n);
      return result;
    }
  }]);
  return PersistentCounter;
}(_counter.Counter);

/***/ }),

/***/ 7345:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ComputerVisionType = void 0;
exports.isCVTypeForDesktop = isCVTypeForDesktop;
var ComputerVisionType = exports.ComputerVisionType = /*#__PURE__*/function (ComputerVisionType) {
  ComputerVisionType["Browser"] = "browser";
  ComputerVisionType["Desktop"] = "desktop";
  ComputerVisionType["DesktopScreenCapture"] = "desktop_screen_capture";
  return ComputerVisionType;
}({});
function isCVTypeForDesktop(type) {
  return type === ComputerVisionType.Desktop || type === ComputerVisionType.DesktopScreenCapture;
}

/***/ }),

/***/ 36447:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = interceptLog;
/**
 * 
 * @description 
 * it is used to intercept log in production environment
 */
function interceptLog() {
  var isProduction = "production" === 'production';
  if (isProduction) {
    var noop = function noop() {};
    console.log = noop;
    console.info = noop;
    console.warn = noop;
    console.error = noop;
  }
}

/***/ }),

/***/ 91433:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.renderLogType = exports.renderLog = void 0;
var renderLogType = exports.renderLogType = function renderLogType(log) {
  switch (log.type) {
    case 'reflect':
      return '[info]';
    case 'error':
      return log.options && log.options.ignored ? '[error][ignored]' : '[error]';
    default:
      return "[".concat(log.type, "]");
  }
};
var renderLog = exports.renderLog = function renderLog(log) {
  var withTimestamp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var prefix = withTimestamp ? log.createTime.toISOString() + ' - ' : '';
  return prefix + renderLogType(log) + ' ' + log.text;
};

/***/ }),

/***/ 6866:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = exports["default"] = {
  proxy: {
    notControllable: 'The proxy settings are controlled by other app(s) or extension(s). Please disable or uninstall the apps or extensions in conflict'
  },
  contentHidden: 'Content is hidden during replay'
};

/***/ }),

/***/ 50149:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Registry = void 0;
exports.createListenerRegistry = createListenerRegistry;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Registry = exports.Registry = /*#__PURE__*/function () {
  function Registry(_ref) {
    var process = _ref.process,
      onZero = _ref.onZero,
      onOne = _ref.onOne;
    _classCallCheck(this, Registry);
    this.cache = {};
    this.process = process;
    this.onZero = onZero || function () {};
    this.onOne = onOne || function () {};
  }
  _createClass(Registry, [{
    key: "add",
    value: function add(id, obj) {
      this.cache[id] = this.cache[id] || [];
      this.cache[id].push(obj);
      if (this.cache[id].length === 1) {
        try {
          this.onOne(id);
        } catch (e) {
          // tslint:disable-next-line
          console.error('in onOne, ' + e.message);
        }
      }
      return true;
    }
  }, {
    key: "remove",
    value: function remove(id, obj) {
      if (!this.cache[id]) {
        return false;
      }
      this.cache[id] = this.cache[id].filter(function (item) {
        return item !== obj;
      });
      if (this.cache[id].length === 0) {
        try {
          this.onZero(id);
        } catch (e) {
          // tslint:disable-next-line
          console.error('in onZero, ' + e.message);
        }
      }
      return true;
    }
  }, {
    key: "removeAllWithData",
    value: function removeAllWithData(obj) {
      var _this = this;
      Object.keys(this.cache).forEach(function (id) {
        for (var i = _this.cache[id].length - 1; i >= 0; i--) {
          if (_this.cache[id][i] === obj) {
            _this.remove(id, _this.cache[id][i]);
          }
        }
      });
    }
  }, {
    key: "fire",
    value: function fire(id, data) {
      var _this2 = this;
      if (!this.cache[id]) {
        return false;
      }
      this.cache[id].forEach(function (item) {
        try {
          _this2.process(item, data, id);
        } catch (e) {
          // tslint:disable-next-line
          console.error('in process, ' + e.message);
        }
      });
      return true;
    }
  }, {
    key: "has",
    value: function has(id) {
      return this.cache[id] && this.cache[id].length > 0;
    }
  }, {
    key: "keys",
    value: function keys() {
      var _this3 = this;
      return Object.keys(this.cache).filter(function (key) {
        return _this3.cache[key] && _this3.cache[key].length > 0;
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this4 = this;
      Object.keys(this.cache).forEach(function (id) {
        try {
          _this4.onZero(id);
        } catch (e) {
          // tslint:disable-next-line
          console.error('in onZero, ' + e.message);
        }
      });
      this.cache = {};
    }
  }]);
  return Registry;
}();
function createListenerRegistry() {
  return new Registry({
    process: function process(fn, data, id) {
      fn(data);
    }
  });
}

/***/ }),

/***/ 20041:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createTab = exports.activateTab = void 0;
exports.getAllTabs = getAllTabs;
exports.getAllTabsInWindow = getAllTabsInWindow;
exports.getAllWindows = getAllWindows;
exports.getTab = exports.getCurrentTab = void 0;
exports.updateUrlForTab = updateUrlForTab;
var _ts_utils = __webpack_require__(1601);
var _web_extension = _interopRequireDefault(__webpack_require__(41953));
var _global_state = __webpack_require__(8327);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var createTab = exports.createTab = function createTab(url) {
  return _web_extension["default"].tabs.create({
    url: url,
    active: true
  });
};
var activateTab = exports.activateTab = function activateTab(tabId) {
  var focusWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return _web_extension["default"].tabs.get(tabId).then(function (tab) {
    var p = focusWindow ? _web_extension["default"].windows.update(tab.windowId, {
      focused: true
    }) : Promise.resolve();
    return p.then(function () {
      return _web_extension["default"].tabs.update(tab.id, {
        active: true
      });
    }).then(function () {
      return tab;
    });
  });
};
var getTab = exports.getTab = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tabId) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          return _context.abrupt("return", _web_extension["default"].tabs.get(tabId));
        case 4:
          _context.prev = 4;
          _context.t0 = _context["catch"](0);
          return _context.abrupt("return", _web_extension["default"].tabs.query({
            active: true
          }));
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[0, 4]]);
  }));
  return function getTab(_x) {
    return _ref.apply(this, arguments);
  };
}();
var getCurrentTab = exports.getCurrentTab = function getCurrentTab(winId) {
  var pWin = winId ? _web_extension["default"].windows.get(winId) : _web_extension["default"].windows.getLastFocused();
  return pWin.then(function (win) {
    return _web_extension["default"].tabs.query({
      active: true,
      windowId: win.id
    }).then(function (tabs) {
      return tabs[0];
    });
  });
};
function updateUrlForTab(_x2, _x3, _x4) {
  return _updateUrlForTab.apply(this, arguments);
}
function _updateUrlForTab() {
  _updateUrlForTab = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tabId, url, cmd) {
    var _newUrl$hash;
    var tab, tabUrl, newUrl, isSamePath, noReload, state, bwindowId, doFlag, wTabs, i, winTab, wTab, targetTabId;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (!(typeof tabId === "number")) {
            _context2.next = 6;
            break;
          }
          _context2.next = 3;
          return _web_extension["default"].tabs.get(tabId);
        case 3:
          _context2.t0 = _context2.sent;
          _context2.next = 7;
          break;
        case 6:
          _context2.t0 = tabId;
        case 7:
          tab = _context2.t0;
          tabUrl = new URL(tab.url);
          newUrl = new URL(url);
          isSamePath = tabUrl.origin + tabUrl.pathname === newUrl.origin + tabUrl.pathname; // Browsers won't reload the page if the new url is only different in hash
          noReload = isSamePath && !!((_newUrl$hash = newUrl.hash) !== null && _newUrl$hash !== void 0 && _newUrl$hash.length);
          _context2.next = 14;
          return (0, _global_state.getState)();
        case 14:
          state = _context2.sent;
          bwindowId = state.tabIds.bwindowId;
          doFlag = [];
          _context2.next = 19;
          return _web_extension["default"].windows.getAll();
        case 19:
          wTabs = _context2.sent;
          i = wTabs.length - 1;
        case 21:
          if (!(i >= 0)) {
            _context2.next = 28;
            break;
          }
          if (!(wTabs[i].id === bwindowId)) {
            _context2.next = 25;
            break;
          }
          doFlag = wTabs[i];
          return _context2.abrupt("break", 28);
        case 25:
          i--;
          _context2.next = 21;
          break;
        case 28:
          if (!(cmd == "openBrowser" && doFlag.length == 0)) {
            _context2.next = 42;
            break;
          }
          _context2.next = 31;
          return _web_extension["default"].windows.create({
            url: url
          });
        case 31:
          _context2.next = 33;
          return getCurrentTab();
        case 33:
          winTab = _context2.sent;
          bwindowId = winTab.windowId;
          _context2.next = 37;
          return (0, _global_state.updateState)(function (state) {
            return _objectSpread(_objectSpread({}, state), {}, {
              tabIds: _objectSpread(_objectSpread({}, state.tabIds), {}, {
                lastPlay: state.tabIds.toPlay,
                toPlay: winTab.id,
                firstPlay: winTab.id,
                bwindowId: winTab.windowId
              })
            });
          });
        case 37:
          _context2.next = 39;
          return getTab(winTab.id);
        case 39:
          return _context2.abrupt("return", _context2.sent);
        case 42:
          if (!(doFlag.length != 0)) {
            _context2.next = 48;
            break;
          }
          _context2.next = 45;
          return getCurrentTab(doFlag.id);
        case 45:
          _context2.t1 = _context2.sent;
          _context2.next = 49;
          break;
        case 48:
          _context2.t1 = '';
        case 49:
          wTab = _context2.t1;
          //const targetTabId = wTab !="" && cmd == "openBrowser" ? wTab.id : tab.id;
          targetTabId = tab.id;
          if (!noReload) {
            _context2.next = 56;
            break;
          }
          _context2.next = 54;
          return _web_extension["default"].tabs.update(targetTabId, {
            url: "about:blank"
          });
        case 54:
          _context2.next = 56;
          return (0, _ts_utils.delay)(function () {}, 100);
        case 56:
          _context2.next = 58;
          return _web_extension["default"].tabs.update(targetTabId, {
            url: url
          });
        case 58:
          _context2.next = 60;
          return getTab(targetTabId);
        case 60:
          return _context2.abrupt("return", _context2.sent);
        case 61:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _updateUrlForTab.apply(this, arguments);
}
function getAllWindows() {
  return _web_extension["default"].windows.getAll();
}
function getAllTabsInWindow(windowId) {
  return _web_extension["default"].windows.get(windowId, {
    populate: true
  }).then(function (win) {
    var _win$tabs;
    return (_win$tabs = win === null || win === void 0 ? void 0 : win.tabs) !== null && _win$tabs !== void 0 ? _win$tabs : [];
  });
}
function getAllTabs() {
  return _getAllTabs.apply(this, arguments);
}
function _getAllTabs() {
  _getAllTabs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    var _ref2;
    var wins, list;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return getAllWindows();
        case 2:
          wins = _context3.sent;
          _context3.next = 5;
          return Promise.all(wins.map(function (win) {
            return getAllTabsInWindow(win.id);
          }));
        case 5:
          list = _context3.sent;
          return _context3.abrupt("return", (_ref2 = []).concat.apply(_ref2, _toConsumableArray(list)));
        case 7:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _getAllTabs.apply(this, arguments);
}

/***/ }),

/***/ 10409:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Prompt = void 0;
exports.prompt = prompt;
var _react = _interopRequireDefault(__webpack_require__(96540));
var _reactDom = _interopRequireDefault(__webpack_require__(40961));
var _propTypes = _interopRequireDefault(__webpack_require__(5556));
var _antd = __webpack_require__(33061);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Prompt = exports.Prompt = /*#__PURE__*/function (_React$Component) {
  _inherits(Prompt, _React$Component);
  function Prompt() {
    var _this;
    _classCallCheck(this, Prompt);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, Prompt, [].concat(args));
    _defineProperty(_assertThisInitialized(_this), "state", {
      value: '',
      visible: true
    });
    _defineProperty(_assertThisInitialized(_this), "onOk", function () {
      return _this.props.onOk(_this.state.value).then(function () {
        return _this.hide();
      });
    });
    _defineProperty(_assertThisInitialized(_this), "onCancel", function () {
      return _this.props.onCancel().then(function () {
        return _this.hide();
      });
    });
    return _this;
  }
  _createClass(Prompt, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;
      this.setState({
        value: this.props.value
      });
      setTimeout(function () {
        return _this2.focus();
      }, 200);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(newProps) {
      var _this3 = this;
      if (newProps.value !== this.props.value) {
        this.setState({
          value: newProps.value
        });
        setTimeout(function () {
          return _this3.focus();
        }, 100);
      }
    }
  }, {
    key: "focus",
    value: function focus() {
      var input = this.input;
      if (input) {
        var $input = input.input;
        $input.focus();
        if (this.props.inputType === 'text') {
          $input.selectionStart = this.props.selectionStart !== undefined ? this.props.selectionStart : 0;
          $input.selectionEnd = this.props.selectionEnd !== undefined ? this.props.selectionEnd : $input.value.length;
        }
      }
    }
  }, {
    key: "hide",
    value: function hide() {
      this.setState({
        visible: false
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;
      return /*#__PURE__*/_react["default"].createElement(_antd.Modal, {
        ref: function ref(_ref2) {
          _this4.modal = _ref2;
        },
        open: this.state.visible,
        align: 'left',
        title: this.props.title,
        width: this.props.width,
        closable: this.props.closable,
        maskClosable: this.props.closable,
        okText: this.props.okText,
        cancelText: this.props.cancelText,
        onOk: this.onOk,
        onCancel: this.onCancel
      }, this.props.message && this.props.message.length ? /*#__PURE__*/_react["default"].createElement("pre", {
        style: {
          fontFamily: 'inherit',
          marginBottom: '10px',
          whiteSpace: 'pre-wrap'
        }
      }, this.props.message) : null, this.props.noInput ? null : /*#__PURE__*/_react["default"].createElement(_antd.Input, {
        defaultValue: "",
        ref: function ref(_ref) {
          return _this4.input = _ref;
        },
        type: this.props.inputType,
        autosize: false,
        placeholder: this.props.placeholder,
        value: this.state.value,
        onChange: function onChange(e) {
          return _this4.setState({
            value: e.target.value
          });
        },
        onKeyDown: function onKeyDown(e) {
          if (e.keyCode === 13) _this4.onOk();
        }
      }));
    }
  }]);
  return Prompt;
}(_react["default"].Component);
_defineProperty(Prompt, "propTypes", {
  onOk: _propTypes["default"].func.isRequired,
  onCancel: _propTypes["default"].func.isRequired,
  title: _propTypes["default"].string,
  width: _propTypes["default"].number,
  message: _propTypes["default"].string,
  value: _propTypes["default"].string,
  noInput: _propTypes["default"].bool,
  inputType: _propTypes["default"].string,
  selectionStart: _propTypes["default"].number,
  selectionEnd: _propTypes["default"].number,
  placeholder: _propTypes["default"].string,
  okText: _propTypes["default"].string,
  cancelText: _propTypes["default"].string,
  keepOpenOnError: _propTypes["default"].bool
});
_defineProperty(Prompt, "defaultProps", {
  width: 350,
  title: 'Please input',
  message: '',
  value: '',
  placeholder: '',
  selectionStart: 0,
  selectionEnd: 0,
  noInput: false,
  closable: true,
  inputType: 'text',
  okText: 'Confirm',
  cancelText: 'Cancel',
  keepOpenOnError: false
});
function prompt(props) {
  return new Promise(function (resolve, reject) {
    var wrappedProps = _objectSpread(_objectSpread({}, props), {}, {
      onOk: function onOk(str) {
        var go = function go() {
          resolve(str);
          destroy();
          return Promise.resolve(true);
        };
        return new Promise(function (resolve) {
          resolve(props.onOk ? props.onOk(str) : true);
        }).then(go, function (e) {
          if (props.keepOpenOnError) {
            return Promise.reject(e);
          }
          reject(e);
          return true;
        });
      },
      onCancel: function onCancel() {
        var go = function go() {
          resolve(null);
          destroy();
          return Promise.resolve(true);
        };
        return new Promise(function (resolve) {
          resolve(props.onCancel ? props.onCancel() : true);
        }).then(go, function (e) {
          if (props.keepOpenOnError) {
            return Promise.reject(e);
          }
          reject(e);
          return true;
        });
      }
    });
    var $root = document.createElement('div');
    var $el = document.createElement('div');
    var destroy = function destroy() {
      return setTimeout(function () {
        $root.remove();
      }, 1000);
    };
    document.body.appendChild($root);
    $root.appendChild($el);
    _reactDom["default"].render( /*#__PURE__*/_react["default"].createElement(Prompt, wrappedProps), $el);
  });
}

/***/ }),

/***/ 98791:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TreeNode = void 0;
var _react = _interopRequireDefault(__webpack_require__(96540));
var _propTypes = _interopRequireDefault(__webpack_require__(5556));
var _utils = __webpack_require__(46580);
var _ts_utils = __webpack_require__(1601);
var _tree_file = __webpack_require__(78290);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var TreeNode = exports.TreeNode = /*#__PURE__*/function (_React$Component) {
  _inherits(TreeNode, _React$Component);
  function TreeNode() {
    var _this;
    _classCallCheck(this, TreeNode);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, TreeNode, [].concat(args));
    _defineProperty(_assertThisInitialized(_this), "state", {});
    _defineProperty(_assertThisInitialized(_this), "onClick", function (e) {
      var _this$props = _this.props,
        data = _this$props.data,
        onClick = _this$props.onClick,
        paths = _this$props.paths,
        foldOnClickTitle = _this$props.foldOnClickTitle;
      if (onClick) {
        onClick(data, paths, e);
      }
      if (foldOnClickTitle && data.type === _tree_file.FileNodeType.Folder) {
        _this.onToggle(e);
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onDoubleClick", function (e) {
      var _this$props2 = _this.props,
        data = _this$props2.data,
        onDoubleClick = _this$props2.onDoubleClick,
        paths = _this$props2.paths;
      if (onDoubleClick) {
        onDoubleClick(data, paths, e);
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onContextMenu", function (e) {
      var _this$props3 = _this.props,
        data = _this$props3.data,
        onContextMenu = _this$props3.onContextMenu,
        paths = _this$props3.paths;
      if (onContextMenu) {
        onContextMenu(data, paths, e);
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onToggle", function (e) {
      e.stopPropagation();
      var _this$props4 = _this.props,
        data = _this$props4.data,
        onToggle = _this$props4.onToggle,
        paths = _this$props4.paths;
      if (onToggle) {
        onToggle(data, paths, e);
      }
    });
    return _this;
  }
  _createClass(TreeNode, [{
    key: "render",
    value: function render() {
      var _this$props$decorate = this.props.decorate,
        decorate = _this$props$decorate === void 0 ? function (x) {
          return x;
        } : _this$props$decorate;
      return decorate( /*#__PURE__*/_react["default"].createElement("div", {
        id: (0, _ts_utils.normalizeHtmlId)(this.props.data.id),
        className: (0, _utils.cn)('tree-node', this.props.commonClass, this.props.data.className)
      }, /*#__PURE__*/_react["default"].createElement("div", {
        className: "tree-node-content",
        onClick: this.onClick,
        onDoubleClick: this.onDoubleClick,
        onContextMenu: this.onContextMenu
      }, /*#__PURE__*/_react["default"].createElement("div", {
        className: "tree-node-icon-wrapper",
        onClick: this.onToggle
      }, this.renderIcon()), /*#__PURE__*/_react["default"].createElement("div", {
        className: "tree-node-item-wrapper"
      }, this.renderItem()), this.renderItemExtra()), /*#__PURE__*/_react["default"].createElement("div", {
        className: "tree-node-children"
      }, this.renderSubnodes())));
    }
  }, {
    key: "renderIcon",
    value: function renderIcon() {
      var _this$props5 = this.props,
        renderIcon = _this$props5.renderIcon,
        data = _this$props5.data,
        paths = _this$props5.paths;
      if (typeof renderIcon === 'function') {
        return renderIcon(data, paths);
      } else {
        return this.defaultRenderIcon(data);
      }
    }
  }, {
    key: "renderItem",
    value: function renderItem() {
      var _this$props6 = this.props,
        renderItem = _this$props6.renderItem,
        data = _this$props6.data,
        paths = _this$props6.paths;
      if (typeof renderItem === 'function') {
        return renderItem(data, paths);
      } else {
        return this.defaultRenderItem(data);
      }
    }
  }, {
    key: "renderItemExtra",
    value: function renderItemExtra() {
      var _this$props7 = this.props,
        renderItemExtra = _this$props7.renderItemExtra,
        data = _this$props7.data,
        paths = _this$props7.paths;
      if (typeof renderItemExtra === 'function') {
        return renderItemExtra(data, paths);
      } else {
        return null;
      }
    }
  }, {
    key: "defaultRenderIcon",
    value: function defaultRenderIcon(data) {
      return /*#__PURE__*/_react["default"].createElement("div", {
        className: (0, _utils.cn)('node-icon')
      }, !data.folded ? 'O' : 'C');
    }
  }, {
    key: "defaultRenderItem",
    value: function defaultRenderItem(data) {
      return data.text || "node at level ".concat(data.level);
    }
  }, {
    key: "renderSubnodes",
    value: function renderSubnodes() {
      var _this$props8 = this.props,
        data = _this$props8.data,
        paths = _this$props8.paths,
        _this$props8$subnodeC = _this$props8.subnodeComponent,
        subnodeComponent = _this$props8$subnodeC === void 0 ? function () {
          return TreeNode;
        } : _this$props8$subnodeC;
      var props = (0, _ts_utils.without)(['data', 'paths'], this.props);
      if (data.type !== _tree_file.FileNodeType.Folder || data.folded) {
        return null;
      }
      return (data.children || []).map(function (subnode, i) {
        var SubNode = subnodeComponent(subnode, [].concat(_toConsumableArray(paths), [i]));
        return /*#__PURE__*/_react["default"].createElement(SubNode, _extends({
          key: i
        }, props, {
          data: subnode,
          paths: [].concat(_toConsumableArray(paths), [i])
        }));
      });
    }
  }]);
  return TreeNode;
}(_react["default"].Component);
_defineProperty(TreeNode, "propTypes", {
  data: _propTypes["default"].object.isRequired,
  renderItem: _propTypes["default"].func.isRequired,
  renderIcon: _propTypes["default"].func.isRequired,
  renderItemExtra: _propTypes["default"].func,
  decorate: _propTypes["default"].func,
  onClick: _propTypes["default"].func.isRequired,
  onDoubleClick: _propTypes["default"].func.isRequired,
  onContextMenu: _propTypes["default"].func.isRequired,
  onToggle: _propTypes["default"].func.isRequired,
  className: _propTypes["default"].string
});

/***/ }),

/***/ 78290:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.InternalFileTree = exports.FileTree = exports.FileNodeType = void 0;
var _react = _interopRequireDefault(__webpack_require__(96540));
var _propTypes = _interopRequireDefault(__webpack_require__(5556));
var _reactDnd = __webpack_require__(81592);
var _icons = __webpack_require__(29937);
var _utils = __webpack_require__(46580);
var _tree = __webpack_require__(98791);
var _ts_utils = __webpack_require__(1601);
var _path = __webpack_require__(26513);
__webpack_require__(15822);
var _code = _interopRequireDefault(__webpack_require__(91021));
var _folder_expanded = _interopRequireDefault(__webpack_require__(51802));
var _folder = _interopRequireDefault(__webpack_require__(51158));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } // import { Icon } from 'antd'
var FileNodeType = exports.FileNodeType = /*#__PURE__*/function (FileNodeType) {
  FileNodeType["File"] = "file";
  FileNodeType["Folder"] = "folder";
  return FileNodeType;
}({});
var InternalFileTree = exports.InternalFileTree = /*#__PURE__*/function (_React$Component) {
  _inherits(InternalFileTree, _React$Component);
  function InternalFileTree() {
    var _this;
    _classCallCheck(this, InternalFileTree);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, InternalFileTree, [].concat(args));
    _defineProperty(_assertThisInitialized(_this), "onToggle", function (data, paths) {
      if (data.type !== FileNodeType.Folder) {
        return;
      }
      _this.props.onToggle(data, paths);
    });
    _defineProperty(_assertThisInitialized(_this), "subnodeComponent", function () {
      var _dndComponentsFactory = dndComponentsFactory({
          move: function move(sourceId, targetId, isDirectory) {
            _this.props.onMove(sourceId, targetId, isDirectory);
          }
        }),
        DndFileNode = _dndComponentsFactory.DndFileNode,
        DndFolderNode = _dndComponentsFactory.DndFolderNode;
      return function (data, paths) {
        switch (data.type) {
          case FileNodeType.File:
            return DndFileNode;
          case FileNodeType.Folder:
            return DndFolderNode;
        }
      };
    }());
    _defineProperty(_assertThisInitialized(_this), "renderFileIcon", function (data) {
      switch (data.type) {
        case FileNodeType.File:
          return (
            /*#__PURE__*/
            // <img
            //   src="./img/code.svg"
            //   className="file-node-icon file-icon"
            // />
            _react["default"].createElement(_code["default"], {
              className: "file-node-icon file-icon"
            })
          );
        case FileNodeType.Folder:
          if (!data.folded) {
            return (
              /*#__PURE__*/
              // <img
              //   src="./img/folder_expanded.svg"
              //   className="file-node-icon folder-icon expanded"
              // />
              _react["default"].createElement(_folder_expanded["default"], {
                className: "file-node-icon folder-icon expanded"
              })
            );
          } else {
            return (
              /*#__PURE__*/
              // <img
              //   src="./img/folder.svg"
              //   className="file-node-icon folder-icon"
              // />
              _react["default"].createElement(_folder["default"], {
                className: "file-node-icon folder-icon"
              })
            );
          }
      }
    });
    _defineProperty(_assertThisInitialized(_this), "renderFileItem", function (data, paths) {
      return /*#__PURE__*/_react["default"].createElement("div", {
        className: "file-node-title"
      }, /*#__PURE__*/_react["default"].createElement("span", null, data.name));
    });
    _defineProperty(_assertThisInitialized(_this), "renderFileItemExtra", function (data, paths) {
      return /*#__PURE__*/_react["default"].createElement(_icons.MenuFoldOutlined, {
        className: "more-button",
        onClick: function onClick(e) {
          return _this.props.onContextMenu(data, paths, e);
        }
      });
    });
    return _this;
  }
  _createClass(InternalFileTree, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      return !(0, _ts_utils.isForestEqual)(function (a, b) {
        var result = a.entryPath === b.entryPath && a.folded === b.folded && a.type === b.type && a.className === b.className;
        return result;
      }, this.props.nodes, nextProps.nodes);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var nodes = this.props.nodes;
      var _ref = this.props,
        connectDropTarget = _ref.connectDropTarget,
        highlighted = _ref.highlighted;
      return connectDropTarget( /*#__PURE__*/_react["default"].createElement("div", {
        className: (0, _utils.cn)('file-root', {
          'drag-over': highlighted
        })
      }, nodes.map(function (data, i) {
        var Node = _this2.subnodeComponent(data, [i]);
        return /*#__PURE__*/_react["default"].createElement(Node, {
          key: data.id,
          data: data,
          paths: [i],
          commonClass: "file-node",
          renderIcon: _this2.renderFileIcon,
          renderItem: _this2.renderFileItem,
          renderItemExtra: _this2.renderFileItemExtra,
          subnodeComponent: _this2.subnodeComponent,
          onClick: _this2.props.onClick,
          onDoubleClick: _this2.props.onDoubleClick,
          onContextMenu: _this2.props.onContextMenu,
          onToggle: _this2.onToggle,
          foldOnClickTitle: true
        });
      })));
    }
  }]);
  return InternalFileTree;
}(_react["default"].Component);
_defineProperty(InternalFileTree, "propTypes", {
  nodes: _propTypes["default"].array.isRequired,
  onMove: _propTypes["default"].func.isRequired,
  onClick: _propTypes["default"].func.isRequired,
  onDoubleClick: _propTypes["default"].func.isRequired,
  onContextMenu: _propTypes["default"].func.isRequired
});
var FileTree = exports.FileTree = (0, _reactDnd.DropTarget)([FileNodeType.Folder, FileNodeType.File], {
  drop: function drop(props, monitor, component) {
    var folderId = props.rootPath;
    var srcItem = monitor.getItem();
    props.onMove(srcItem.id, folderId, srcItem.isDirectory);
  },
  canDrop: function canDrop(props, monitor) {
    var folderId = props.rootPath;
    var _ref2 = monitor.getItem(),
      entryId = _ref2.id;
    if (folderId === entryId) {
      return false;
    }
    if (folderId === _path.posix.dirname(entryId)) {
      return false;
    }
    return monitor.isOver({
      shallow: true
    });
  }
}, function (connect, monitor) {
  return {
    connectDropTarget: connect.dropTarget(),
    highlighted: monitor.isOver({
      shallow: true
    }) && monitor.canDrop()
  };
})(InternalFileTree);
function dndComponentsFactory(opts) {
  var applyDragSource = function applyDragSource(itemType) {
    return function (comp) {
      return (0, _reactDnd.DragSource)(itemType, {
        beginDrag: function beginDrag(props) {
          var result = {
            id: props.data.id,
            isDirectory: props.data.type === FileNodeType.Folder
          };
          return result;
        }
      }, function (connect, monitor) {
        return {
          connectDragSource: connect.dragSource(),
          isDragging: monitor.isDragging()
        };
      })(comp);
    };
  };
  var applyDropTarget = function applyDropTarget(itemType) {
    return function (comp) {
      return (0, _reactDnd.DropTarget)(itemType, {
        drop: function drop(props, monitor, component) {
          var folderId = props.data.id;
          var srcItem = monitor.getItem();
          opts.move(srcItem.id, folderId, srcItem.isDirectory);
        },
        canDrop: function canDrop(props, monitor) {
          var folderId = props.data.id;
          var _ref3 = monitor.getItem(),
            entryId = _ref3.id;
          if (folderId === entryId) {
            return false;
          }
          if (folderId === _path.posix.dirname(entryId)) {
            return false;
          }
          return monitor.isOver({
            shallow: true
          });
        }
      }, function (connect, monitor) {
        return {
          connectDropTarget: connect.dropTarget(),
          highlighted: monitor.isOver({
            shallow: true
          }) && monitor.canDrop()
        };
      })(comp);
    };
  };
  var DndFileNode = applyDragSource(FileNodeType.File)(function InternalFileNode(props) {
    return /*#__PURE__*/_react["default"].createElement(_tree.TreeNode, _extends({}, props, {
      decorate: (0, _ts_utils.compose)(props.connectDragSource, track)
    }));
  });
  var DndFolderNode = (0, _ts_utils.compose)(applyDragSource(FileNodeType.Folder), applyDropTarget([FileNodeType.Folder, FileNodeType.File]))(function InternalFolderNode(props) {
    return /*#__PURE__*/_react["default"].createElement(_tree.TreeNode, _extends({}, props, {
      decorate: (0, _ts_utils.compose)(props.connectDragSource, props.connectDropTarget, track),
      data: (0, _ts_utils.safeUpdateIn)(['className'], function () {
        var oldClassName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        return (0, _utils.cn)(oldClassName, {
          'drag-over': props.highlighted
        });
      }, props.data)
    }));
  });
  var track = function track(x) {
    return x;
  };
  return {
    DndFolderNode: DndFolderNode,
    DndFileNode: DndFileNode
  };
}

/***/ }),

/***/ 17767:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.checkIfSidePanelOpen = void 0;
var _ipc_bg_cs = __webpack_require__(59711);
var _global_state = __webpack_require__(8327);
var _tab = __webpack_require__(13755);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var checkIfSidePanelOpen = exports.checkIfSidePanelOpen = function checkIfSidePanelOpen() {
  return (0, _tab.getPanelTabIpc)().then(function (panelIpc) {
    var isActivePromise = panelIpc.ask("IS_ACTIVE");
    // Timeout promise to reject if the panel doesn't respond in 1.5 seconds
    var timeoutPromise = new Promise(function (resolve, reject) {
      setTimeout(function () {
        // console.error("Error:>> Panel did not respond in time. It is considered to be closed.");
        reject(false);
      }, 1500);
    });
    var racePromise = Promise.race([isActivePromise, timeoutPromise]);
    return racePromise;
  }).then(function (isPanelActive) {
    console.log("isPanelActive:>>", isPanelActive);
    return (0, _global_state.getState)().then(function (state) {
      return [isPanelActive, state];
    });
  }).then(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      isPanelActive = _ref2[0],
      state = _ref2[1];
    var isSidePanelOpen = isPanelActive && state.tabIds.panel === _ipc_bg_cs.SIDEPANEL_TAB_ID;
    return isSidePanelOpen;
  })["catch"](function (err) {
    console.error("Error in checkIfSidePanelOpen:>>", err);
    return false;
  });
};

/***/ }),

/***/ 13755:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.genGetTabIpc = genGetTabIpc;
exports.getActiveTab = getActiveTab;
exports.getActiveTabId = getActiveTabId;
exports.getPanelTabIpc = exports.getInspectTabIpc = void 0;
exports.getPlayTab = getPlayTab;
exports.getPlayTabIpc = void 0;
exports.getPlayTabOpenB = getPlayTabOpenB;
exports.getRecordTabIpc = void 0;
exports.showPanelWindow = showPanelWindow;
exports.withPanelIpc = withPanelIpc;
var _web_extension = _interopRequireDefault(__webpack_require__(41953));
var _ts_utils = __webpack_require__(1601);
var _ipc_cache = __webpack_require__(75866);
var _global_state = __webpack_require__(8327);
var _tab_utils = __webpack_require__(20041);
var _storage = _interopRequireDefault(__webpack_require__(88555));
var _ipc_bg_cs = __webpack_require__(59711);
var _sidepanel = __webpack_require__(17767);
var _utils = __webpack_require__(46580);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
// Generate function to get ipc based on tabIdName and some error message
function genGetTabIpc(tabIdName, purpose) {
  return function () {
    var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
    var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
    return (0, _ts_utils.retry)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var state, tabId;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _global_state.getState)();
          case 2:
            state = _context.sent;
            tabId = state.tabIds[tabIdName];
            if (tabId) {
              _context.next = 6;
              break;
            }
            return _context.abrupt("return", Promise.reject(new Error("Error #150: No tab for ".concat(purpose, " yet"))));
          case 6:
            if (!(tabId === _ipc_bg_cs.SIDEPANEL_TAB_ID)) {
              _context.next = 10;
              break;
            }
            return _context.abrupt("return", {
              id: _ipc_bg_cs.SIDEPANEL_TAB_ID
            });
          case 10:
            return _context.abrupt("return", _web_extension["default"].tabs.get(tabId));
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee);
    })), {
      timeout: timeout,
      retryInterval: 100,
      shouldRetry: function shouldRetry() {
        return true;
      }
    })().then(function (tab) {
      if (!tab) {
        throw new Error("Error #160: The ".concat(purpose, " tab seems to be closed"));
      }
      return (0, _ipc_cache.getIpcCache)().get(tab.id, timeout, before)["catch"](function (e) {
        throw new Error("Error #170: No ipc available for the ".concat(purpose, " tab"));
      });
    });
  };
}
var getRecordTabIpc = exports.getRecordTabIpc = genGetTabIpc('toRecord', 'recording');
var getPlayTabIpc = exports.getPlayTabIpc = genGetTabIpc('toPlay', 'playing commands');
var getInspectTabIpc = exports.getInspectTabIpc = genGetTabIpc('toInspect', 'inspect');
var getPanelTabIpc = exports.getPanelTabIpc = genGetTabIpc('panel', 'dashboard');
function showPanelWindow() {
  return _showPanelWindow.apply(this, arguments);
}
function _showPanelWindow() {
  _showPanelWindow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    var _ref2,
      params,
      showSettingsOnStart,
      selectCommandIndex,
      state,
      panelTabId,
      _args3 = arguments;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _ref2 = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {}, params = _ref2.params, showSettingsOnStart = _ref2.showSettingsOnStart, selectCommandIndex = _ref2.selectCommandIndex;
          _context3.next = 3;
          return (0, _global_state.getState)();
        case 3:
          state = _context3.sent;
          if (!showSettingsOnStart) {
            _context3.next = 9;
            break;
          }
          _context3.next = 7;
          return _storage["default"].get('config').then(function (config) {
            _storage["default"].set('config', _objectSpread(_objectSpread({}, config), {}, {
              showSettingsOnStart: true
            }));
          });
        case 7:
          _context3.next = 11;
          break;
        case 9:
          _context3.next = 11;
          return _storage["default"].get('config').then(function (config) {
            _storage["default"].set('config', _objectSpread(_objectSpread({}, config), {}, {
              showSettingsOnStart: false,
              selectCommandIndex: selectCommandIndex
            }));
          });
        case 11:
          panelTabId = (0, _utils.isSidePanelWindow)() ? state.tabIds.lastPanelWindow : state.tabIds.panel;
          console.log('panelTabId :>> ', panelTabId);
          return _context3.abrupt("return", (0, _tab_utils.activateTab)(panelTabId, true).then(function () {
            return false;
          }, function () {
            console.log('activateTab failed, :>> ');
            return _storage["default"].get('config').then(function (config) {
              config = config || {};
              return (config.size || {})[config.showSidebar ? 'with_sidebar' : 'standard'];
            }).then( /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(size) {
                var urlQuery, base, url;
                return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                  while (1) switch (_context2.prev = _context2.next) {
                    case 0:
                      size = size || {
                        width: 850,
                        height: 775
                      };
                      urlQuery = Object.keys(params || {}).map(function (key) {
                        return "".concat(key, "=").concat(params[key]);
                      }).join('&');
                      base = _web_extension["default"].runtime.getURL('popup.html');
                      url = urlQuery.length > 0 ? "".concat(base, "?").concat(urlQuery) : base;
                      _context2.next = 6;
                      return (0, _global_state.updateState)({
                        closingAllWindows: false
                      });
                    case 6:
                      return _context2.abrupt("return", _web_extension["default"].windows.create({
                        url: url,
                        type: 'popup',
                        width: size.width,
                        height: size.height
                      }).then(function (win) {
                        // because closing of sidepanel sends the IDE to background
                        var isEdge = navigator.userAgent.includes('Edg');
                        if (isEdge) {
                          _web_extension["default"].runtime.sendMessage({
                            type: 'BringIDEToFront',
                            windowId: win.id,
                            delay: 2500 // 500ms + the delay in the next line   
                          });
                        }
                        if (!_web_extension["default"].isFirefox()) return;

                        // Refer to https://bugzilla.mozilla.org/show_bug.cgi?id=1425829
                        // Firefox New popup window appears blank until right-click
                        return (0, _ts_utils.delay)(function () {
                          return _web_extension["default"].windows.update(win.id, {
                            width: size.width + 1,
                            height: size.height + 1
                          });
                        }, 1000);
                      }).then(function () {
                        return (0, _ts_utils.delay)(function () {
                          return true;
                        }, 2000);
                      }));
                    case 7:
                    case "end":
                      return _context2.stop();
                  }
                }, _callee2);
              }));
              return function (_x3) {
                return _ref3.apply(this, arguments);
              };
            }());
          }));
        case 14:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _showPanelWindow.apply(this, arguments);
}
function withPanelIpc(options) {
  return (0, _sidepanel.checkIfSidePanelOpen)().then(function (isSidePanelOpen) {
    if (isSidePanelOpen) {
      return getPanelTabIpc(6 * 1000);
    } else {
      return showPanelWindow(options).then(function () {
        return getPanelTabIpc(6 * 1000);
      });
    }
  });
}

// Get the current tab for play, if url provided, it will be loaded in the tab
function getPlayTab(_x) {
  return _getPlayTab.apply(this, arguments);
} // Get the current tab for play, if url provided, it will be loaded in the tab
function _getPlayTab() {
  _getPlayTab = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(url) {
    var theError, createOne, runRealLogic, state;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          // Note: update error message to be more user friendly. But the original message is kept as comment
          // const theError  = new Error('Either a played tab or a url must be provided to start playing')
          theError = new Error('Error #180: No connection to browser tab');
          createOne = /*#__PURE__*/function () {
            var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(url) {
              var tab;
              return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                while (1) switch (_context4.prev = _context4.next) {
                  case 0:
                    if (url) {
                      _context4.next = 2;
                      break;
                    }
                    throw theError;
                  case 2:
                    _context4.next = 4;
                    return (0, _tab_utils.createTab)(url);
                  case 4:
                    tab = _context4.sent;
                    _context4.next = 7;
                    return (0, _global_state.updateState)(function (state) {
                      return _objectSpread(_objectSpread({}, state), {}, {
                        tabIds: _objectSpread(_objectSpread({}, state.tabIds), {}, {
                          lastPlay: state.tabIds.toPlay,
                          toPlay: tab.id,
                          firstPlay: tab.id
                        })
                      });
                    });
                  case 7:
                    return _context4.abrupt("return", tab);
                  case 8:
                  case "end":
                    return _context4.stop();
                }
              }, _callee4);
            }));
            return function createOne(_x4) {
              return _ref4.apply(this, arguments);
            };
          }();
          runRealLogic = function runRealLogic(state) {
            if (!state.tabIds.toPlay && !url) {
              throw theError;
            }
            if (!state.tabIds.toPlay) {
              return createOne(url);
            }
            return (0, _tab_utils.getTab)(state.tabIds.toPlay).then(function (tab) {
              if (!url) {
                return tab;
              }

              // Note: must disable ipcCache manually here, so that further messages
              // won't be sent the old ipc
              (0, _ipc_cache.getIpcCache)().disable(tab.id);
              var finalUrl = function () {
                try {
                  var u = new URL(url, tab.url);
                  return u.toString();
                } catch (e) {
                  return url;
                }
              }();
              return (0, _tab_utils.updateUrlForTab)(tab, finalUrl, 'open');
            }, function () {
              return createOne(url);
            });
          };
          _context5.next = 5;
          return (0, _global_state.getState)();
        case 5:
          state = _context5.sent;
          if (!state.pendingPlayingTab) {
            _context5.next = 9;
            break;
          }
          _context5.next = 9;
          return (0, _ts_utils.until)('pendingPlayingTab reset', function () {
            return {
              pass: !state.pendingPlayingTab,
              result: true
            };
          }, 100, 5000);
        case 9:
          return _context5.abrupt("return", runRealLogic(state));
        case 10:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return _getPlayTab.apply(this, arguments);
}
function getPlayTabOpenB(_x2) {
  return _getPlayTabOpenB.apply(this, arguments);
}
function _getPlayTabOpenB() {
  _getPlayTabOpenB = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(url) {
    var theError, createOne, runRealLogic, state;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          // Note: update error message to be more user friendly. But the original message is kept as comment
          // const theError  = new Error('Either a played tab or a url must be provided to start playing')
          theError = new Error('Error #180: No connection to browser tab');
          createOne = /*#__PURE__*/function () {
            var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(url) {
              var tab;
              return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                while (1) switch (_context6.prev = _context6.next) {
                  case 0:
                    if (url) {
                      _context6.next = 2;
                      break;
                    }
                    throw theError;
                  case 2:
                    _context6.next = 4;
                    return (0, _tab_utils.createTab)(url);
                  case 4:
                    tab = _context6.sent;
                    _context6.next = 7;
                    return (0, _global_state.updateState)(function (state) {
                      return _objectSpread(_objectSpread({}, state), {}, {
                        tabIds: _objectSpread(_objectSpread({}, state.tabIds), {}, {
                          lastPlay: state.tabIds.toPlay,
                          toPlay: tab.id,
                          firstPlay: tab.id
                        })
                      });
                    });
                  case 7:
                    return _context6.abrupt("return", tab);
                  case 8:
                  case "end":
                    return _context6.stop();
                }
              }, _callee6);
            }));
            return function createOne(_x5) {
              return _ref5.apply(this, arguments);
            };
          }();
          runRealLogic = function runRealLogic(state) {
            if (!state.tabIds.toPlay && !url) {
              throw theError;
            }
            if (!state.tabIds.toPlay) {
              return createOne(url);
            }
            return (0, _tab_utils.getTab)(state.tabIds.toPlay).then(function (tab) {
              if (!url) {
                return tab;
              }

              // Note: must disable ipcCache manually here, so that further messages
              // won't be sent the old ipc
              (0, _ipc_cache.getIpcCache)().disable(tab.id);
              var finalUrl = function () {
                try {
                  var u = new URL(url, tab.url);
                  return u.toString();
                } catch (e) {
                  return url;
                }
              }();
              return (0, _tab_utils.updateUrlForTab)(tab, finalUrl, 'openBrowser');
            }, function () {
              return createOne(url);
            });
          };
          _context7.next = 5;
          return (0, _global_state.getState)();
        case 5:
          state = _context7.sent;
          if (!state.pendingPlayingTab) {
            _context7.next = 9;
            break;
          }
          _context7.next = 9;
          return (0, _ts_utils.until)('pendingPlayingTab reset', function () {
            return {
              pass: !state.pendingPlayingTab,
              result: true
            };
          }, 100, 5000);
        case 9:
          return _context7.abrupt("return", runRealLogic(state));
        case 10:
        case "end":
          return _context7.stop();
      }
    }, _callee7);
  }));
  return _getPlayTabOpenB.apply(this, arguments);
}
function getActiveTab() {
  return _getActiveTab.apply(this, arguments);
}
function _getActiveTab() {
  _getActiveTab = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
    var tabs;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          _context8.next = 2;
          return _web_extension["default"].tabs.query({
            active: true,
            currentWindow: true
          });
        case 2:
          tabs = _context8.sent;
          return _context8.abrupt("return", tabs && tabs[0]);
        case 4:
        case "end":
          return _context8.stop();
      }
    }, _callee8);
  }));
  return _getActiveTab.apply(this, arguments);
}
function getActiveTabId() {
  return _getActiveTabId.apply(this, arguments);
}
function _getActiveTabId() {
  _getActiveTabId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
    var tab;
    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) switch (_context9.prev = _context9.next) {
        case 0:
          _context9.next = 2;
          return getActiveTab();
        case 2:
          tab = _context9.sent;
          return _context9.abrupt("return", tab && tab.id);
        case 4:
        case "end":
          return _context9.stop();
      }
    }, _callee9);
  }));
  return _getActiveTabId.apply(this, arguments);
}

/***/ }),

/***/ 7030:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.runCommandInPlayTab = runCommandInPlayTab;
var _global_state = __webpack_require__(8327);
var _web_extension = _interopRequireDefault(__webpack_require__(41953));
var _log = _interopRequireDefault(__webpack_require__(89130));
var _ipc_cs = _interopRequireDefault(__webpack_require__(96571));
var C = _interopRequireWildcard(__webpack_require__(95902));
var _ts_utils = __webpack_require__(1601);
var _timeout_counter = __webpack_require__(83945);
var _utils = __webpack_require__(46580);
var _tab = __webpack_require__(13755);
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
// Note: There are several versions of runCommandXXX here. One by one, they have a better tolerence of error
// 1. runCommand:
//      Run a command, and wait until we can confirm that command is completed (e.g.  xxxAndWait)
//
// 2. runCommandWithRetry:
//      Enhance runCommand with retry mechanism, only retry when element is not found
//
// 3. runCommandWithClosureAndErrorProcess:
//      Include `args` in closure, and take care of `errorIgnore`
//
// 4. runWithHeartBeat:
//      Run a heart beat check along with `runCommandWithClosureAndErrorProcess`.
//      Heart beat check requires cs Ipc must be created before heart beat check starts.
//      With this, we can ensure the page is not closed or refreshed
//
// 5. runWithRetryOnLostHeartBeat:
//      Run `runWithHeartBeat` with retry mechanism. only retry when it's a 'lost heart beat' error
//      When closed/refresh is detected, it will try to send same command to that tab again.
function runCommandInPlayTab(_x) {
  return _runCommandInPlayTab.apply(this, arguments);
}
function _runCommandInPlayTab() {
  _runCommandInPlayTab = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(command) {
    var _command$extra5;
    var superFast, shouldSkipCommandRun, e;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          (0, _log["default"])('2. runCommandInPlayTab:>> command:', command);
          (0, _timeout_counter.clearTimerForTimeoutStatus)();
          superFast = ((_command$extra5 = command.extra) === null || _command$extra5 === void 0 ? void 0 : _command$extra5.superFast) && !['open'].includes(command.cmd) || false; // Note: `disableHeartBeat` is only set to true when current tab will
          // be closed ("reload tab" / "change url" excluded).
          // For exmaple `selectWindow tab=close`
          // TODO: maybe omit it?? it takes 15ms.
          if (superFast) {
            _context5.next = 6;
            break;
          }
          _context5.next = 6;
          return (0, _global_state.updateState)({
            disableHeartBeat: false
          });
        case 6:
          if (!superFast) {
            _context5.next = 10;
            break;
          }
          _context5.t0 = false;
          _context5.next = 13;
          break;
        case 10:
          _context5.next = 12;
          return preparePlayTab(command);
        case 12:
          _context5.t0 = _context5.sent;
        case 13:
          shouldSkipCommandRun = _context5.t0;
          if (!shouldSkipCommandRun) {
            _context5.next = 16;
            break;
          }
          return _context5.abrupt("return", {});
        case 16:
          _context5.prev = 16;
          _context5.next = 19;
          return runWithRetryOnLostHeartBeat(command);
        case 19:
          return _context5.abrupt("return", _context5.sent);
        case 22:
          _context5.prev = 22;
          _context5.t1 = _context5["catch"](16);
          e = _context5.t1;
          _log["default"].error('catched in runCommandInPlayTab', e.stack);
          if (!(e && e.message && (e.message.indexOf('lost heart beat when running command') !== -1 || e.message.indexOf('Could not establish connection') !== -1))) {
            _context5.next = 30;
            break;
          }
          _context5.next = 29;
          return runWithRetryOnLostHeartBeat(command);
        case 29:
          return _context5.abrupt("return", _context5.sent);
        case 30:
          return _context5.abrupt("return", Promise.reject(e));
        case 31:
        case "end":
          return _context5.stop();
      }
    }, _callee5, null, [[16, 22]]);
  }));
  return _runCommandInPlayTab.apply(this, arguments);
}
function updateHeartBeatSecret(options) {
  if (options !== null && options !== void 0 && options.disabled) {
    return (0, _global_state.updateState)({
      heartBeatSecret: -1
    });
  } else {
    return (0, _global_state.updateState)(function (state) {
      var oldHeartBeatSecret = state.heartBeatSecret || 0;
      return _objectSpread(_objectSpread({}, state), {}, {
        heartBeatSecret: (Math.max(0, oldHeartBeatSecret) + 1) % 10000
      });
    });
  }
}
function callPlayTab(params) {
  var _params$tabIpcTimeout, _params$tabIpcNoLater, _params$ipcCallTimeou;
  var defaultTimeout = 100;
  // Default expired at is infinity, but to make it easy to pass it via ipc,
  // use the double of current timestamp
  var defaultNoLaterThan = Date.now() * 2;
  var defaultIpcCallTimeout = -1;
  var ipcTimeout = (_params$tabIpcTimeout = params.tabIpcTimeout) !== null && _params$tabIpcTimeout !== void 0 ? _params$tabIpcTimeout : defaultTimeout;
  var ipcNoLaterThan = (_params$tabIpcNoLater = params.tabIpcNoLaterThan) !== null && _params$tabIpcNoLater !== void 0 ? _params$tabIpcNoLater : defaultNoLaterThan;
  var ipcCallTimeout = (_params$ipcCallTimeou = params.ipcCallTimeout) !== null && _params$ipcCallTimeou !== void 0 ? _params$ipcCallTimeou : defaultIpcCallTimeout;
  return _ipc_cs["default"].ask('PANEL_CALL_PLAY_TAB', {
    ipcTimeout: ipcTimeout,
    ipcNoLaterThan: ipcNoLaterThan,
    payload: {
      command: params.command,
      args: params.args
    }
  }, ipcCallTimeout);
}
function checkHeartBeat(_x2, _x3) {
  return _checkHeartBeat.apply(this, arguments);
}
function _checkHeartBeat() {
  _checkHeartBeat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(tabIpcTimeout, tabIpcExpiredAt) {
    var disableHeartBeat;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          _context6.next = 2;
          return (0, _global_state.getState)('disableHeartBeat');
        case 2:
          disableHeartBeat = _context6.sent;
          if (!disableHeartBeat) {
            _context6.next = 5;
            break;
          }
          return _context6.abrupt("return", {
            secret: "heart_beat_disabled"
          });
        case 5:
          _context6.next = 7;
          return updateHeartBeatSecret();
        case 7:
          return _context6.abrupt("return", callPlayTab({
            tabIpcTimeout: tabIpcTimeout,
            tabIpcNoLaterThan: tabIpcExpiredAt,
            command: 'HEART_BEAT',
            args: {}
          })["catch"](function (e) {
            _log["default"].error('at least I catched it', e.message);
            throw new Error('heart beat error thrown');
          }));
        case 8:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
  return _checkHeartBeat.apply(this, arguments);
}
function shouldWaitForDownloadAfterRun(command) {
  // log('shouldWaitForDownloadAfterRun', command)
  return command.cmd === 'click';
}
function shoudWaitForCommand(command) {
  // log('shoudWaitForCommand', command)
  return /andWait/i.test(command.cmd) || ['open', 'refresh'].indexOf(command.cmd) !== -1;
}
function getCommandTimeout(command) {
  var defaultTimeout = command.extra.timeoutElement * 1000;
  switch (command.cmd) {
    case 'waitForElementVisible':
    case 'waitForElementNotVisible':
    case 'waitForElementPresent':
    case 'waitForElementNotPresent':
      {
        var timeout = parseInt(command.value, 10);
        return !isNaN(timeout) ? timeout : defaultTimeout;
      }
    default:
      return defaultTimeout;
  }
}

// Note: -1 will disable ipc timeout for 'pause', and 'onDownload' command
function getIpcTimeout(command) {
  var _command$extra;
  var pageLoadTimeout = ((command === null || command === void 0 || (_command$extra = command.extra) === null || _command$extra === void 0 ? void 0 : _command$extra.timeoutPageLoad) || 60) * 1000;
  switch (command.cmd) {
    case 'open':
    case 'openBrowser':
    case 'clickAndWait':
    case 'selectAndWait':
      return pageLoadTimeout;
    case 'selectWindow':
      {
        var target = command.target;
        var isTabOpen = (target && target.toUpperCase()) === 'TAB=OPEN';
        return isTabOpen ? pageLoadTimeout : getCommandTimeout(command);
      }
    case 'pause':
    case 'onDownload':
    case 'captureEntirePageScreenshot':
      return -1;
    default:
      return getCommandTimeout(command);
  }
}
function getTimeoutPageLoad(command) {
  var _command$extra2;
  return ((command === null || command === void 0 || (_command$extra2 = command.extra) === null || _command$extra2 === void 0 ? void 0 : _command$extra2.timeoutPageLoad) || 60) * 1000;
}
function withPageLoadCheck(command, timeoutPageLoad, promiseFunc) {
  var shouldWait = shoudWaitForCommand(command);
  if (!shouldWait) {
    return promiseFunc();
  }

  // Note: send timeout status to dashboard once "xxxWait" and "open" returns
  var clear = (0, _timeout_counter.startSendingTimeoutStatus)(timeoutPageLoad);
  return Promise.race([promiseFunc().then(function (data) {
    clear();
    return data;
  }, function (e) {
    clear();
    throw e;
  }), (0, _ts_utils.delay)(function () {
    throw new Error("Error #230: Page load ".concat(timeoutPageLoad / 1000, " seconds time out"));
  }, timeoutPageLoad)]);
}
function waitForCommandToComplete(command, res) {
  var _res$data;
  var timeoutPageLoad = getTimeoutPageLoad(command);
  var timeoutHeartbeat = ((res === null || res === void 0 || (_res$data = res.data) === null || _res$data === void 0 || (_res$data = _res$data.extra) === null || _res$data === void 0 ? void 0 : _res$data.timeoutElement) || 10) * 1000;
  var shouldWait = shoudWaitForCommand(command);
  if (!shouldWait) {
    return Promise.resolve();
  }
  return (0, _ts_utils.delay)(function () {}, 2000).then(function () {
    // Note: After refresh/redirect, ipc secret in content script changes,
    // use this fact to tell whether a page is loaded or not
    return (0, _ts_utils.retry)(function () {
      return checkHeartBeat().then( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(heartBeatResult) {
          var lastSecret, heartBeatSecret;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return (0, _global_state.getState)('lastCsIpcSecret');
              case 2:
                lastSecret = _context.sent;
                heartBeatSecret = heartBeatResult.secret;
                if (!(lastSecret === heartBeatSecret)) {
                  _context.next = 6;
                  break;
                }
                throw new Error('Error #220: Still same ipc secret');
              case 6:
                return _context.abrupt("return", true);
              case 7:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function (_x4) {
          return _ref.apply(this, arguments);
        };
      }());
    }, {
      shouldRetry: function shouldRetry() {
        return true;
      },
      timeout: timeoutHeartbeat,
      retryInterval: 250
    })();
  })["catch"](function (e) {
    var cmd = command.cmd;
    var isAndWait = /AndWait/.test(cmd);
    console.warn(e);
    if (isAndWait) {
      var instead = cmd.replace('AndWait', '');
      throw new Error("Error #200: '".concat(cmd, "' failed. No page load event detected after ").concat(timeoutHeartbeat / 1000, " seconds. Try '").concat(instead, "' instead. Error details: ") + e.message);
    } else {
      throw new Error("Error #210: '".concat(cmd, "' failed. No page load event detected after ").concat(timeoutHeartbeat / 1000, "s (!TIMEOUT_WAIT). Error details: ") + e.message);
    }
  }).then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return callPlayTab({
            command: 'DOM_READY',
            args: {},
            ipcCallTimeout: timeoutPageLoad
          });
        case 2:
          _context2.next = 4;
          return callPlayTab({
            command: 'HACK_ALERT',
            args: {},
            ipcCallTimeout: C.CS_IPC_TIMEOUT
          });
        case 4:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  })));
}
function runCommand(_x5, _x6) {
  return _runCommand.apply(this, arguments);
}
function _runCommand() {
  _runCommand = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(command, retryInfo) {
    var _command$extra6, _res$data2;
    var state, ipcTimeout, superFast, res, secret;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          _context7.next = 2;
          return (0, _global_state.getState)();
        case 2:
          state = _context7.sent;
          ipcTimeout = getIpcTimeout(command);
          superFast = ((_command$extra6 = command.extra) === null || _command$extra6 === void 0 ? void 0 : _command$extra6.superFast) && !['open'].includes(command.cmd) || false;
          if (!(state.status !== C.APP_STATUS.PLAYER)) {
            _context7.next = 7;
            break;
          }
          throw new Error("can't run command when it's not in player mode");
        case 7:
          // Note: clear timer whenever we execute a new command, and it's not a retry
          if (retryInfo.retryCount === 0) {
            (0, _timeout_counter.clearTimerForTimeoutStatus)();
          }

          // TODO: re-consider this, it takes 80+ms
          // Note: each command keeps target page's status as PLAYING
          if (superFast) {
            _context7.next = 11;
            break;
          }
          _context7.next = 11;
          return callPlayTab({
            command: 'SET_STATUS',
            args: {
              status: C.CONTENT_SCRIPT_STATUS.PLAYING
            }
          });
        case 11:
          if (superFast) {
            _context7.next = 14;
            break;
          }
          _context7.next = 14;
          return callPlayTab({
            command: 'DOM_READY',
            args: {},
            ipcCallTimeout: ipcTimeout
          });
        case 14:
          _context7.next = 16;
          return callPlayTab({
            command: 'RUN_COMMAND',
            args: {
              command: _objectSpread(_objectSpread({}, command), {}, {
                extra: _objectSpread(_objectSpread({}, command.extra || {}), {}, {
                  retryInfo: retryInfo
                })
              })
            },
            ipcCallTimeout: ipcTimeout
          });
        case 16:
          res = _context7.sent;
          _context7.next = 19;
          return withPageLoadCheck(command, getTimeoutPageLoad(command), function () {
            return waitForCommandToComplete(command, res);
          });
        case 19:
          secret = (_res$data2 = res.data) === null || _res$data2 === void 0 ? void 0 : _res$data2.secret;
          if (!secret) {
            _context7.next = 23;
            break;
          }
          _context7.next = 23;
          return (0, _global_state.updateState)({
            lastCsIpcSecret: secret
          });
        case 23:
          return _context7.abrupt("return", res.data);
        case 24:
        case "end":
          return _context7.stop();
      }
    }, _callee7);
  }));
  return _runCommand.apply(this, arguments);
}
function isTimeoutError(msg) {
  return !!msg && (msg.indexOf('timeout reached when looking for') !== -1 || msg.indexOf('timeout reached when waiting for') !== -1 || msg.indexOf('element is found but not visible yet') !== -1 || msg.indexOf('IPC Promise has been destroyed') !== -1);
}
function runCommandWithRetry(_x7) {
  return _runCommandWithRetry.apply(this, arguments);
}
function _runCommandWithRetry() {
  _runCommandWithRetry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(command) {
    var timerSecret, commandTimeout, maxRetryOnIpcTimeout, retryCountOnIpcTimeout, fn, e;
    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) switch (_context9.prev = _context9.next) {
        case 0:
          // Note: add timerSecret to ensure it won't clear timer that is not created by this function call
          timerSecret = Math.random();
          _context9.next = 3;
          return (0, _global_state.updateState)({
            timerSecret: timerSecret
          });
        case 3:
          commandTimeout = getCommandTimeout(command);
          maxRetryOnIpcTimeout = 1;
          retryCountOnIpcTimeout = 0;
          fn = (0, _ts_utils.retry)(runCommand, {
            timeout: commandTimeout,
            shouldRetry: function shouldRetry(e) {
              (0, _log["default"])('runCommandWithRetry - shouldRetry', e.message);

              // Note: for rare cases when guest page doesn't respond to RUN_COMMAND, it will timeout for `timeoutElement`
              // And we should retry RUN_COMMAND for only once in that case, and also show this as warning to users
              // related issue: #513
              if (/ipcPromise.*timeout/i.test(e.message)) {
                if (retryCountOnIpcTimeout < maxRetryOnIpcTimeout) {
                  callPlayTab({
                    command: 'ADD_LOG',
                    args: {
                      warning: 'Warning #300: Web page connection issue. Retrying last command.'
                    }
                  });
                  retryCountOnIpcTimeout++;
                  return true;
                } else {
                  return false;
                }
              }
              return isTimeoutError(e.message);
            },
            onFirstFail: function onFirstFail(e) {
              var title = e && e.message && e.message.indexOf('element is found but not visible yet') !== -1 ? 'Tag waiting' // All use Tag Waiting for now  // 'Visible waiting'
              : 'Tag waiting';
              (0, _timeout_counter.startSendingTimeoutStatus)(commandTimeout, title);
            },
            onFinal: function () {
              var _onFinal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(err, data) {
                var state;
                return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                  while (1) switch (_context8.prev = _context8.next) {
                    case 0:
                      _context8.next = 2;
                      return (0, _global_state.getState)();
                    case 2:
                      state = _context8.sent;
                      (0, _log["default"])('onFinal', err, data);
                      if (state.timer && state.timerSecret === timerSecret) {
                        clearInterval(state.timer);
                      }
                    case 5:
                    case "end":
                      return _context8.stop();
                  }
                }, _callee8);
              }));
              function onFinal(_x11, _x12) {
                return _onFinal.apply(this, arguments);
              }
              return onFinal;
            }()
          });
          _context9.prev = 7;
          _context9.next = 10;
          return fn(command);
        case 10:
          return _context9.abrupt("return", _context9.sent);
        case 13:
          _context9.prev = 13;
          _context9.t0 = _context9["catch"](7);
          e = _context9.t0;
          if (isTimeoutError(e.message)) {
            _context9.next = 18;
            break;
          }
          return _context9.abrupt("return", Promise.reject(e));
        case 18:
          if (!(command.targetOptions && command.targetOptions.length)) {
            _context9.next = 20;
            break;
          }
          return _context9.abrupt("return", runCommand(command, {
            "final": true
          }));
        case 20:
          return _context9.abrupt("return", Promise.reject(e));
        case 21:
        case "end":
          return _context9.stop();
      }
    }, _callee9, null, [[7, 13]]);
  }));
  return _runCommandWithRetry.apply(this, arguments);
}
function runCommandWithClosureAndErrorProcess(command) {
  return runCommandWithRetry(command)["catch"](function (e) {
    var _command$extra3;
    // Return default value for storeXXX commands
    if (['storeText', 'storeValue', 'storeChecked', 'storeAttribute'].indexOf(command.cmd) !== -1) {
      var value = command.value;
      var LOCATOR_NOT_FOUND = '#LNF';
      return {
        vars: _defineProperty({}, value, LOCATOR_NOT_FOUND),
        log: {
          error: e.message
        }
      };
    }

    // Note: if variable !ERRORIGNORE is set to true,
    // it will just log errors instead of a stop of whole macro
    if ((_command$extra3 = command.extra) !== null && _command$extra3 !== void 0 && _command$extra3.errorIgnore) {
      return {
        log: {
          error: e.message
        }
      };
    }
    throw e;
  });
}
function runWithHeartBeat(command) {
  var _command$extra4;
  var isTabOpenForSelectWindow = command.cmd === 'selectWindow' && /^\s*tab=open\s*$/i.test(command.target);
  var superFast = ((_command$extra4 = command.extra) === null || _command$extra4 === void 0 ? void 0 : _command$extra4.superFast) && !['open'].includes(command.cmd) || false;
  console.log('2a. runWithHeartBeat:>> superFast:', superFast);
  var neverResolvePromise = new Promise(function () {});
  var _ref3 = function () {
      var startTime = new Date().getTime();
      var stop = false;
      var check = function check() {
        // log('starting heart beat')
        // Note: do not check heart beat when
        // 1. it's a 'open' command, which is supposed to reconnect ipc
        // 2. it's going to download files, which will kind of reload page and reconnect ipc

        var pNoNeedForHearBeat = function () {
          if (shoudWaitForCommand(command)) {
            return Promise.resolve(true);
          }
          return _ipc_cs["default"].ask('PANEL_HAS_PENDING_DOWNLOAD', {});
        }();
        return pNoNeedForHearBeat.then(function (noNeedForHeartBeat) {
          if (noNeedForHeartBeat) {
            updateHeartBeatSecret({
              disabled: true
            });
            return neverResolvePromise;
          }
          if (stop) {
            return Promise.resolve();
          }
          return checkHeartBeat(100, startTime).then(function () {
            return (0, _ts_utils.delay)(check, 1000);
          }, function (e) {
            _log["default"].error('lost heart beart!!', e.stack);
            throw new Error('lost heart beat when running command');
          });
        });
      };
      var stopIt = function stopIt() {
        // log('stopping heart beat')
        stop = true;
      };
      return [check, stopIt];
    }(),
    _ref4 = _slicedToArray(_ref3, 2),
    infiniteCheckHeartBeat = _ref4[0],
    stopInfiniteCheck = _ref4[1];
  return Promise.race([runCommandWithClosureAndErrorProcess(command).then(function (data) {
    stopInfiniteCheck();
    return data;
  })["catch"](function (e) {
    stopInfiniteCheck();
    return Promise.reject(e);
  }), superFast ? new Promise(function () {}) : isTabOpenForSelectWindow ? new Promise(function () {}) : infiniteCheckHeartBeat()]);
}
function runWithRetryOnLostHeartBeat(_x8) {
  return _runWithRetryOnLostHeartBeat.apply(this, arguments);
}
function _runWithRetryOnLostHeartBeat() {
  _runWithRetryOnLostHeartBeat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(command) {
    var _command$extra7, _command$extra8;
    var runWithHeartBeatRetry, superFast, result, hasOnDownloadCmd, state, tab;
    return _regeneratorRuntime().wrap(function _callee10$(_context10) {
      while (1) switch (_context10.prev = _context10.next) {
        case 0:
          runWithHeartBeatRetry = (0, _ts_utils.retry)(runWithHeartBeat, {
            timeout: getCommandTimeout(command),
            shouldRetry: function shouldRetry(e) {
              (0, _log["default"])('runWithHeartBeatRetry - shouldRetry', e.message);
              return !!e && !!e.message && e.message.indexOf('lost heart beat when running command') !== -1;
            },
            retryInterval: function retryInterval(retryCount, lastRetryInterval) {
              return Math.max(1 * 1000, Math.min(5 * 1000, lastRetryInterval * 1.2));
            }
          });
          superFast = ((_command$extra7 = command.extra) === null || _command$extra7 === void 0 ? void 0 : _command$extra7.superFast) && !['open'].includes(command.cmd) || false;
          console.log('2b. runWithRetryOnLostHeartBeat:>> superFast', superFast);
          _context10.next = 5;
          return runWithHeartBeatRetry(command);
        case 5:
          result = _context10.sent;
          hasOnDownloadCmd = (_command$extra8 = command.extra) === null || _command$extra8 === void 0 ? void 0 : _command$extra8.hasOnDownloadCmd; // TODO: it takes some considerable amount of time in case of 'click' command, try to optimize it
          if (!(hasOnDownloadCmd && shouldWaitForDownloadAfterRun(command))) {
            _context10.next = 11;
            break;
          }
          console.log('waiting for download:>>');
          // Note: wait for download to either be create or completed
          _context10.next = 11;
          return _ipc_cs["default"].ask('PANEL_WAIT_FOR_ANY_DOWNLOAD', {});
        case 11:
          _context10.next = 13;
          return (0, _global_state.getState)();
        case 13:
          state = _context10.sent;
          _context10.prev = 14;
          _context10.next = 17;
          return _web_extension["default"].tabs.get(state.tabIds.toPlay);
        case 17:
          tab = _context10.sent;
          return _context10.abrupt("return", _objectSpread(_objectSpread({}, result), {}, {
            pageUrl: tab.url
          }));
        case 21:
          _context10.prev = 21;
          _context10.t0 = _context10["catch"](14);
          _log["default"].error('Error in fetching play tab url');
          return _context10.abrupt("return", result);
        case 25:
        case "end":
          return _context10.stop();
      }
    }, _callee10, null, [[14, 21]]);
  }));
  return _runWithRetryOnLostHeartBeat.apply(this, arguments);
}
function openNewUrlInPlayTab(_x9, _x10) {
  return _openNewUrlInPlayTab.apply(this, arguments);
}
function _openNewUrlInPlayTab() {
  _openNewUrlInPlayTab = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(command, startPageLoadCountDown) {
    var cmd, target, value, _ref9, _ref10, isOpenCommand, shouldSkipCommandRun, url;
    return _regeneratorRuntime().wrap(function _callee11$(_context11) {
      while (1) switch (_context11.prev = _context11.next) {
        case 0:
          cmd = command.cmd, target = command.target, value = command.value;
          _ref9 = function () {
            if (cmd === 'open' || cmd === 'openBrowser') {
              return [true, false, target];
            }
            if (cmd === 'selectWindow' && target && target.toLowerCase().trim() === 'tab=open') {
              return [true, true, value];
            }
            return [false, false, null];
          }(), _ref10 = _slicedToArray(_ref9, 3), isOpenCommand = _ref10[0], shouldSkipCommandRun = _ref10[1], url = _ref10[2];
          if (isOpenCommand) {
            _context11.next = 4;
            break;
          }
          throw new Error('Error #101: Ui.Vision is not connected to a browser tab');
        case 4:
          startPageLoadCountDown();
          if (!(cmd === 'openBrowser')) {
            _context11.next = 9;
            break;
          }
          return _context11.abrupt("return", (0, _tab.getPlayTabOpenB)(url).then(function (tab) {
            return {
              tab: tab,
              shouldSkipCommandRun: shouldSkipCommandRun,
              hasOpenedUrl: true
            };
          }));
        case 9:
          return _context11.abrupt("return", (0, _tab.getPlayTab)(url).then(function (tab) {
            return {
              tab: tab,
              shouldSkipCommandRun: shouldSkipCommandRun,
              hasOpenedUrl: true
            };
          }));
        case 10:
        case "end":
          return _context11.stop();
      }
    }, _callee11);
  }));
  return _openNewUrlInPlayTab.apply(this, arguments);
}
function preparePlayTabIPC(command, tab, startCountDown, stopCountDown) {
  return _ipc_cs["default"].ask('PANEL_CS_IPC_READY', {
    tabId: tab.id,
    timeout: 100
  }).then(function () {
    return {
      tab: tab,
      hasOpenedUrl: false
    };
  }, function () {
    return openNewUrlInPlayTab(command, startCountDown);
  }).then(function (_ref5) {
    var tab = _ref5.tab,
      hasOpenedUrl = _ref5.hasOpenedUrl,
      shouldSkipCommandRun = _ref5.shouldSkipCommandRun;
    return callPlayTab({
      command: 'HEART_BEAT',
      args: '',
      tabIpcTimeout: getTimeoutPageLoad(command)
    }).then(function () {
      stopCountDown();
      return {
        tab: tab,
        hasOpenedUrl: hasOpenedUrl,
        shouldSkipCommandRun: shouldSkipCommandRun
      };
    });
  });
}
function ensurePlayTabIPC(command, tab, startCountDown, stopCountDown) {
  // Note: in case the playing tab exists but not has a broken page, and is not reachable by tabs.sendMessage
  // We should try to run open command again if any
  var timeout = getTimeoutPageLoad(command);
  return (0, _utils.withTimeout)(timeout, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    var e, newTabResult;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.prev = 0;
          _context3.next = 3;
          return preparePlayTabIPC(command, tab, startCountDown, stopCountDown);
        case 3:
          return _context3.abrupt("return", _context3.sent);
        case 6:
          _context3.prev = 6;
          _context3.t0 = _context3["catch"](0);
          e = _context3.t0;
          if (/Could not establish connection/.test(e.message)) {
            _context3.next = 11;
            break;
          }
          return _context3.abrupt("return", Promise.reject(e));
        case 11:
          _context3.next = 13;
          return openNewUrlInPlayTab(command, startCountDown);
        case 13:
          newTabResult = _context3.sent;
          _context3.next = 16;
          return preparePlayTabIPC(command, newTabResult.tab, startCountDown, stopCountDown);
        case 16:
          return _context3.abrupt("return", _context3.sent);
        case 17:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[0, 6]]);
  })))["catch"](function (e) {
    if (/withTimeout/.test(e.message)) {
      throw new Error("Ui.Vision fails to open this url");
    }
    if (e.message === 'timeout') {
      throw new Error("Error #230: Page load ".concat(timeout / 1000, " seconds time out"));
    }
    throw e;
  });
}
function createCountDown(timeout) {
  var stopPageLoadCountDown = function stopPageLoadCountDown() {};
  var startPageLoadCountDown = function startPageLoadCountDown() {
    stopPageLoadCountDown();
    stopPageLoadCountDown = (0, _timeout_counter.startSendingTimeoutStatus)(timeout);
  };
  return [startPageLoadCountDown, stopPageLoadCountDown];
}
function isChromeSpecialPage(url) {
  return url.startsWith('chrome://') || url.startsWith('chrome-error://');
}
function waitForPageLoadComplete(tab) {
  return new Promise(function (resolve, reject) {
    var timeout = 60 * 1000;
    var interval = 300;
    var elapsed = 0;
    var timer = setInterval(function () {
      elapsed += interval;
      if (elapsed > timeout) {
        clearInterval(timer);
        reject(new Error('timeout'));
      }
      _web_extension["default"].scripting.executeScript({
        target: {
          tabId: tab.id
        },
        func: function func() {
          return document.readyState;
        }
      }).then(function (result) {
        // wait for document ready 
        if (result && result[0].result === 'complete') {
          clearInterval(timer);
          resolve(true);
        }
      })["catch"](function (e) {
        console.log('executeScript err:>> ', e);
        if (timeout < elapsed) {
          reject(new Error('E231: Page load error'));
        }
      });
    }, interval);
  });
}
function preparePlayTab(command) {
  var _createCountDown = createCountDown(getTimeoutPageLoad(command)),
    _createCountDown2 = _slicedToArray(_createCountDown, 2),
    startPageLoadCountDown = _createCountDown2[0],
    stopPageLoadCountDown = _createCountDown2[1];
  return (0, _tab.getPlayTab)()
  // Note: catch any error, and make it run 'getPlayTab(args.url)' instead
  ["catch"](function (e) {
    return {
      id: -1
    };
  }).then(function (tab) {
    // to check if the playTab window is closed
    var windowId = tab.windowId;
    // check if window is closed
    return _web_extension["default"].windows.get(windowId, {
      populate: true
    }).then(function (win) {
      // when window is closed, it will return a popup window
      if (win && win.type == 'popup' && win.tabs.length === 1 && (win.tabs[0].url.startsWith("chrome-extension://".concat(_web_extension["default"].runtime.id)) || win.tabs[0].url.match(/moz-extension:\/\/[a-z0-9-]+\//))) {
        throw new Error('E530: No browser open. Please close the IDE and then start the browser.');
      }
      return tab;
    });
  }).then(function (tab) {
    // log('after first getPlayTab', tab)

    // On Firefox, it does get ipc from "about:blank", but somehow the connection is not good
    // it's always reconnecting. so instead of trying to run command on "about:blank",
    // redirect it to meaningful url
    var nonresponsiveFirefoxURLs = ['about:home', 'about:blank', 'about:config', 'about:debugging'];

    // if tab.url starts with any of the nonresponsiveFirefoxURLs
    if (_web_extension["default"].isFirefox() && nonresponsiveFirefoxURLs.some(function (url) {
      return tab.url.startsWith(url);
    })) {
      return openNewUrlInPlayTab(command, startPageLoadCountDown).then(function () {
        return waitForPageLoadComplete(tab);
      });
    }

    // For chrome special URLs like "chrome://extensions/", "chrome://settings/" etc,
    // if command is "open", we should open it in the same tab
    // and wait for it to be ready
    // in some uncertain cases url property in tab object is turned out not to be available
    if (!tab.url || isChromeSpecialPage(tab.url)) {
      return openNewUrlInPlayTab(command, startPageLoadCountDown).then(function () {
        return waitForPageLoadComplete(tab);
      });
    }
    return ensurePlayTabIPC(command, tab, startPageLoadCountDown, stopPageLoadCountDown).then(function (_ref7) {
      var tab = _ref7.tab,
        hasOpenedUrl = _ref7.hasOpenedUrl,
        shouldSkipCommandRun = _ref7.shouldSkipCommandRun;
      // const p = args.shouldNotActivateTab ? Promise.resolve() : activateTab(tab.id, true)
      var p = Promise.resolve();

      // Note: wait for tab to confirm it has loaded
      return p.then(function () {
        return _ipc_cs["default"].ask('PANEL_CS_IPC_READY', {
          tabId: tab.id,
          timeout: 6000 * 10
        });
      }).then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!hasOpenedUrl) {
                _context4.next = 3;
                break;
              }
              _context4.next = 3;
              return callPlayTab({
                command: 'MARK_NO_COMMANDS_YET',
                args: {},
                ipcCallTimeout: C.CS_IPC_TIMEOUT
              });
            case 3:
              _context4.next = 5;
              return callPlayTab({
                command: 'SET_STATUS',
                args: {
                  status: C.CONTENT_SCRIPT_STATUS.PLAYING
                },
                ipcCallTimeout: C.CS_IPC_TIMEOUT
              });
            case 5:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }))).then(function () {
        return shouldSkipCommandRun;
      });
    });
  });
}

/***/ }),

/***/ 83945:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.clearTimerForTimeoutStatus = clearTimerForTimeoutStatus;
exports.onTimeoutStatus = onTimeoutStatus;
exports.startSendingTimeoutStatus = startSendingTimeoutStatus;
var _registry = __webpack_require__(50149);
var registry = (0, _registry.createListenerRegistry)();
var keyTimeoutStatus = 'TIMEOUT_STATUS';
var timer;
function startSendingTimeoutStatus(timeout) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'wait';
  var interval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
  if (timer) {
    clearInterval(timer);
  }
  var past = 0;
  timer = setInterval(function () {
    past += interval;
    registry.fire(keyTimeoutStatus, {
      type: type,
      past: past,
      total: timeout
    });
    if (past >= timeout) {
      clearInterval(timer);
    }
  }, interval);
  return function () {
    clearInterval(timer);
  };
}
function clearTimerForTimeoutStatus() {
  clearInterval(timer);
}
function onTimeoutStatus(callback) {
  registry.add(keyTimeoutStatus, callback);
}

/***/ }),

/***/ 87307:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.editorCommandCount = editorCommandCount;
exports.editorSelectedCommand = editorSelectedCommand;
exports.editorSelectedCommandIndex = editorSelectedCommandIndex;
exports.entryNodeToFileNodeData = entryNodeToFileNodeData;
exports.findMacroFolderWithCaseInsensitiveRelativePath = findMacroFolderWithCaseInsensitiveRelativePath;
exports.findMacroNodeWithCaseInsensitiveField = findMacroNodeWithCaseInsensitiveField;
exports.findMacroNodeWithCaseInsensitiveFullPath = findMacroNodeWithCaseInsensitiveFullPath;
exports.findMacroNodeWithCaseInsensitiveRelativePath = findMacroNodeWithCaseInsensitiveRelativePath;
exports.getBreakpoints = void 0;
exports.getBreakpointsByMacroId = getBreakpointsByMacroId;
exports.getWarningCommandIndices = exports.getTestSuitesWithAllInfo = exports.getStatus = exports.getShowSidePanel = exports.getShouldSaveAlternativeLocators = exports.getShouldLoadResources = exports.getShouldIgnoreTargetOptions = exports.getMacrosExtra = exports.getMacroFolderStructure = exports.getMacroFolderNodeList = exports.getMacroFileNodeList = exports.getMacroFileNodeData = exports.getIndexToInsertRecorded = exports.getFilteredMacroFileNodeData = exports.getErrorCommandIndices = exports.getEditor = exports.getDoneCommandIndices = exports.getCurrentMacroId = exports.getConfig = void 0;
exports.hasUnsavedMacro = hasUnsavedMacro;
exports.isReplaySpeedOverrideToFastMode = exports.isPlaying = exports.isOcrInDesktopMode = exports.isNoDisplay = exports.isMacroFolderNodeListEmpty = exports.isFocusOnSidebar = exports.isFocusOnCommandTable = void 0;
var _reselect = __webpack_require__(42885);
var _constant = __webpack_require__(95902);
var _macro_extra_data = __webpack_require__(3112);
var _tree_file = __webpack_require__(78290);
var _ts_utils = __webpack_require__(1601);
var _state = __webpack_require__(78493);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var getTestSuitesWithAllInfo = exports.getTestSuitesWithAllInfo = (0, _reselect.createSelector)([function (state) {
  return state.editor.testSuites;
}, function (state) {
  return state.editor.testSuitesExtra;
}], function (testSuites, testSuitesExtra) {
  var getKey = function getKey(ts) {
    return ts.id;
  };
  return testSuites.map(function (ts) {
    var key = getKey(ts);
    var extra = testSuitesExtra[key || ''];
    return _objectSpread(_objectSpread({}, ts), extra || {});
  });
});
var getCurrentMacroId = exports.getCurrentMacroId = (0, _reselect.createSelector)([function (state) {
  return state.editor.editing.meta.src;
}], function (src) {
  return src ? src.id : _constant.UNTITLED_ID;
});
var getBreakpoints = exports.getBreakpoints = (0, _reselect.createSelector)([function (state) {
  return state.editor.macrosExtra;
}, getCurrentMacroId], function (macrosExtra, macroId) {
  var extra = macrosExtra[macroId] || {};
  return extra.breakpointIndices || [];
});
function getBreakpointsByMacroId(state, macroId) {
  var macrosExtra = state.editor.macrosExtra;
  var extra = macrosExtra[macroId] || {};
  return extra.breakpointIndices || [];
}
var getDoneCommandIndices = exports.getDoneCommandIndices = (0, _reselect.createSelector)([function (state) {
  return state.editor.macrosExtra;
}, getCurrentMacroId], function (macrosExtra, macroId) {
  var extra = macrosExtra[macroId] || {};
  return extra.doneCommandIndices || [];
});
var getWarningCommandIndices = exports.getWarningCommandIndices = (0, _reselect.createSelector)([function (state) {
  return state.editor.macrosExtra;
}, getCurrentMacroId], function (macrosExtra, macroId) {
  var extra = macrosExtra[macroId] || {};
  return extra.warningCommandIndices || [];
});
var getErrorCommandIndices = exports.getErrorCommandIndices = (0, _reselect.createSelector)([function (state) {
  return state.editor.macrosExtra;
}, getCurrentMacroId], function (macrosExtra, macroId) {
  var extra = macrosExtra[macroId] || {};
  return extra.errorCommandIndices || [];
});
var isFocusOnCommandTable = exports.isFocusOnCommandTable = (0, _reselect.createSelector)([function (state) {
  return state;
}], function (state) {
  return state.ui.focusArea === _state.FocusArea.CommandTable;
});
var isFocusOnSidebar = exports.isFocusOnSidebar = (0, _reselect.createSelector)([function (state) {
  return state;
}], function (state) {
  return state.ui.focusArea === _state.FocusArea.Sidebar;
});
var getConfig = exports.getConfig = (0, _reselect.createSelector)([function (state) {
  return state.config;
}], _ts_utils.id);
var getShouldSaveAlternativeLocators = exports.getShouldSaveAlternativeLocators = (0, _reselect.createSelector)([getConfig], function (config) {
  return !!config.saveAlternativeLocators;
});
var getShouldIgnoreTargetOptions = exports.getShouldIgnoreTargetOptions = (0, _reselect.createSelector)([getConfig], function (config) {
  return !config.saveAlternativeLocators;
});
function hasUnsavedMacro(state) {
  var editor = state.editor;
  var editing = editor.editing,
    editingSource = editor.editingSource,
    activeTab = editor.activeTab;
  if (editing.meta.src == null) return false;
  if (!editing.meta.src && editing.meta.src != null) return true;
  switch (activeTab) {
    case 'table_view':
      {
        var _ref = editing.meta || {},
          hasUnsaved = _ref.hasUnsaved;
        return hasUnsaved;
      }
    case 'source_view':
      {
        return editingSource.original !== editingSource.current;
      }
    default:
      throw new Error('Unknown activeTab');
  }
}
function findMacroNodeWithCaseInsensitiveField(state, field, value) {
  var isDirectory = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var nodes = isDirectory ? getMacroFolderNodeList(state) : getMacroFileNodeList(state);
  var transform = function transform(path) {
    return path.toLowerCase().replace(/\\/g, '/').replace(/\.json$/i, '');
  };
  var toMatch = transform(value);
  return nodes.find(function (node) {
    if (isDirectory !== node.isDirectory) {
      return false;
    }
    return transform(node.fullPath) === toMatch || transform(node[field]) === toMatch;
  });
}
function findMacroNodeWithCaseInsensitiveFullPath(state, fullPath) {
  return findMacroNodeWithCaseInsensitiveField(state, 'fullPath', fullPath);
}
function findMacroNodeWithCaseInsensitiveRelativePath(state, relativePath) {
  return findMacroNodeWithCaseInsensitiveField(state, 'relativePath', relativePath);
}
function findMacroFolderWithCaseInsensitiveRelativePath(state, relativePath) {
  return findMacroNodeWithCaseInsensitiveField(state, 'relativePath', relativePath, true);
}
function editorSelectedCommand(state) {
  var _state$editor$editing = state.editor.editing,
    meta = _state$editor$editing.meta,
    commands = _state$editor$editing.commands;
  if (!meta || meta.selectedIndex === -1) return null;
  return commands[meta.selectedIndex] || null;
}
function editorSelectedCommandIndex(state) {
  var meta = state.editor.editing.meta;
  return meta ? meta.selectedIndex : null;
}
function editorCommandCount(state) {
  var commands = state.editor.editing.commands;
  return commands.length;
}
function entryNodeToFileNodeData(entryNode, getClassName, getFolded) {
  return (0, _ts_utils.treeMap)(function (entryData, paths) {
    return {
      id: entryData.fullPath,
      type: entryData.isFile ? _tree_file.FileNodeType.File : _tree_file.FileNodeType.Folder,
      level: paths.length,
      selected: false,
      name: entryData.name,
      entryPath: entryData.fullPath,
      folded: getFolded(entryData),
      className: getClassName(entryData)
    };
  }, entryNode);
}
var getEditor = exports.getEditor = function getEditor(state) {
  return state.editor;
};
var getMacroFolderStructure = exports.getMacroFolderStructure = (0, _reselect.createSelector)([getEditor], function (editor) {
  return editor.macroFolderStructure;
});
var getMacrosExtra = exports.getMacrosExtra = (0, _reselect.createSelector)([getEditor], function (editor) {
  return editor.macrosExtra;
});
var getMacroFileNodeData = exports.getMacroFileNodeData = (0, _reselect.createSelector)([getMacroFolderStructure, getMacrosExtra, getCurrentMacroId, isFocusOnSidebar], function (macroFolderStructure, macrosExtra, macroId, sidebarFocused) {
  var getClassName = function getClassName(data) {
    var klasses = [];
    var id = data.fullPath;
    var status = macrosExtra[id] && macrosExtra[id].status;
    klasses.push(function () {
      switch (status) {
        case _macro_extra_data.MacroResultStatus.Success:
          return 'success';
        case _macro_extra_data.MacroResultStatus.Error:
          return 'error';
        case _macro_extra_data.MacroResultStatus.ErrorInSub:
          return 'error-in-sub';
        default:
          return 'normal';
      }
    }());
    if (macroId === id) {
      klasses.push('selected');
    }
    if (!sidebarFocused) {
      klasses.push('blur');
    }
    return klasses.join(' ');
  };
  var getFolded = function getFolded(data) {
    var id = data.fullPath;
    var folded = macrosExtra[id] && macrosExtra[id].folded || false;
    return folded;
  };
  return macroFolderStructure.map(function (node) {
    return entryNodeToFileNodeData(node, getClassName, getFolded);
  });
});
var getFilteredMacroFileNodeData = exports.getFilteredMacroFileNodeData = (0, _reselect.createSelector)([getMacroFileNodeData, function (state) {
  return state.macroQuery;
}], function (macroFileNodeData, searchText) {
  var trimSearchText = searchText.trim().toLowerCase();
  var filteredFileNodeData = function () {
    if (trimSearchText.length === 0) {
      return macroFileNodeData;
    }
    return macroFileNodeData.map(function (node) {
      var filteredNode = (0, _ts_utils.treeFilter)(function (data) {
        return data.name.toLowerCase().indexOf(trimSearchText) !== -1;
      }, node);
      if (!filteredNode) {
        return null;
      }
      return (0, _ts_utils.treeMap)(function (data) {
        return _objectSpread(_objectSpread({}, data), {}, {
          folded: false
        });
      }, filteredNode);
    }).filter(function (node) {
      return node;
    });
  }();
  return filteredFileNodeData;
});
var getMacroFileNodeList = exports.getMacroFileNodeList = (0, _reselect.createSelector)([getMacroFolderStructure], function (macroFolderStructure) {
  var findAllMacros = function findAllMacros(root) {
    var result = [];
    (0, _ts_utils.traverseTree)(function (node) {
      if (node.isFile) {
        result.push(node);
      }
      return _ts_utils.TraverseTreeResult.Normal;
    }, root);
    return result;
  };
  return (0, _ts_utils.flatten)(macroFolderStructure.map(findAllMacros));
});
var getMacroFolderNodeList = exports.getMacroFolderNodeList = (0, _reselect.createSelector)([getMacroFolderStructure], function (macroFolderStructure) {
  var findAllFolders = function findAllFolders(root) {
    var result = [];
    (0, _ts_utils.traverseTree)(function (node) {
      if (node.isDirectory) {
        result.push(node);
      }
      return _ts_utils.TraverseTreeResult.Normal;
    }, root);
    return result;
  };
  return (0, _ts_utils.flatten)(macroFolderStructure.map(findAllFolders));
});
var isMacroFolderNodeListEmpty = exports.isMacroFolderNodeListEmpty = (0, _reselect.createSelector)([getMacroFolderNodeList], function (entries) {
  return entries.length === 0;
});
var getIndexToInsertRecorded = exports.getIndexToInsertRecorded = (0, _reselect.createSelector)([function (state) {
  return state.editor.editing.meta.indexToInsertRecorded;
}], _ts_utils.id);
var getStatus = exports.getStatus = (0, _reselect.createSelector)([function (state) {
  return state.status;
}], _ts_utils.id);
var getShouldLoadResources = exports.getShouldLoadResources = (0, _reselect.createSelector)([function (state) {
  return state.from;
}], function (from) {
  return from === _state.RunBy.Manual;
});
var getShowSidePanel = exports.getShowSidePanel = (0, _reselect.createSelector)([function (state) {
  return state.config.showSidePanel;
}], _ts_utils.id);
var isPlaying = exports.isPlaying = (0, _reselect.createSelector)([getStatus, _ts_utils.id], function (appStatus, state) {
  return appStatus === _constant.APP_STATUS.PLAYER && state.player.status === _constant.PLAYER_STATUS.PLAYING;
});
var isNoDisplay = exports.isNoDisplay = (0, _reselect.createSelector)([isPlaying, _ts_utils.id], function (isPlaying, state) {
  return isPlaying && state.noDisplayInPlay;
});
var isOcrInDesktopMode = exports.isOcrInDesktopMode = (0, _reselect.createSelector)([isPlaying, _ts_utils.id], function (isPlaying, state) {
  return state.ocrInDesktopMode;
});
var isReplaySpeedOverrideToFastMode = exports.isReplaySpeedOverrideToFastMode = (0, _reselect.createSelector)([isPlaying, _ts_utils.id], function (isPlaying, state) {
  return isPlaying && state.replaySpeedOverrideToFastMode;
});

/***/ }),

/***/ 78493:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.newTestCaseEditing = exports.initialState = exports.RunBy = exports.FocusArea = void 0;
exports.stringForRunBy = stringForRunBy;
var C = _interopRequireWildcard(__webpack_require__(95902));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var RunBy = exports.RunBy = /*#__PURE__*/function (RunBy) {
  RunBy["Html"] = "html";
  RunBy["Bookmark"] = "bookmark";
  RunBy["Manual"] = "manual";
  return RunBy;
}({});
function stringForRunBy(type) {
  switch (type) {
    case RunBy.Bookmark:
      return 'bookmark';
    case RunBy.Html:
      return 'command line';
    case RunBy.Manual:
      return 'manual';
  }
}
var FocusArea = exports.FocusArea = /*#__PURE__*/function (FocusArea) {
  FocusArea["Unknown"] = "unknown";
  FocusArea["Sidebar"] = "sidebar";
  FocusArea["CommandTable"] = "command_table";
  FocusArea["CodeSource"] = "code_source";
  return FocusArea;
}({});
var newTestCaseEditing = exports.newTestCaseEditing = {
  commands: [],
  meta: {
    src: null,
    hasUnsaved: true,
    selectedIndex: -1
  }
};

// * editor
//    * testCases:          all test cases stored in indexedDB
//    * editing:            the current test cases being edited
//    * clipbard            for copy / cut / paste
//
// * player                 the state for player
//    * nextCommandIndex    the current command beging executed
//    * currentLoop         the current round
//    * loops               how many rounds to run totally

var initialState = exports.initialState = {
  count: 0,
  // test value
  status: C.APP_STATUS.NORMAL,
  recorderStatus: C.RECORDER_STATUS.STOPPED,
  inspectorStatus: C.INSPECTOR_STATUS.STOPPED,
  isLoadingMacros: false,
  from: RunBy.Manual,
  noDisplayInPlay: false,
  ocrInDesktopMode: false,
  replaySpeedOverrideToFastMode: false,
  editor: {
    testSuites: [],
    testCases: [],
    currentMacro: null,
    // macrosExtra is used to store:
    // * status
    // * breakpoints
    // * doneCommandIndices
    // * errorCommandIndices
    // * warningCommandIndices
    macrosExtra: {},
    // `macroFolderStructure` just holds folder and path info,
    // while macro content is still in `testCases`.
    // Similar case for `testSuitesFolderStructure`
    macroFolderStructure: [],
    testSuitesExtra: {},
    testSuitesFolderStructure: [],
    editing: _objectSpread({}, newTestCaseEditing),
    editingSource: {
      // Saved version
      original: null,
      // Version before editing
      pure: null,
      // Version keeping track of any editing
      current: null,
      error: null
    },
    clipboard: {
      commands: []
    },
    activeTab: 'table_view',
    isDraggingCommand: false
  },
  player: {
    mode: C.PLAYER_MODE.TEST_CASE,
    status: C.PLAYER_STATUS.STOPPED,
    stopReason: null,
    currentLoop: 0,
    loops: 0,
    nextCommandIndex: null,
    playInterval: 0,
    timeoutStatus: {
      type: null,
      total: null,
      past: null
    }
  },
  recorder: {
    skipOpen: false
  },
  variables: [],
  logs: [],
  screenshots: [],
  csvs: [],
  visions: [],
  config: {},
  proxy: null,
  ui: {
    focusArea: FocusArea.Unknown
  },
  macroQuery: ''
};

/***/ }),

/***/ 16977:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getScreenshotInSearchArea = getScreenshotInSearchArea;
exports.saveDataUrlToLastDesktopScreenshot = saveDataUrlToLastDesktopScreenshot;
exports.saveDataUrlToLastScreenshot = saveDataUrlToLastScreenshot;
exports.saveDataUrlToScreenshot = saveDataUrlToScreenshot;
exports.searchVision = searchVision;
var _utils = __webpack_require__(46580);
var _cv_utils = __webpack_require__(7345);
var _tab_utils = __webpack_require__(20041);
var _storage = __webpack_require__(97467);
var _xdesktop = __webpack_require__(14683);
var _desktop = __webpack_require__(14406);
var _types = __webpack_require__(76701);
var _capture_screenshot = __webpack_require__(6329);
var C = _interopRequireWildcard(__webpack_require__(95902));
var _global_state = __webpack_require__(8327);
var _tab = __webpack_require__(13755);
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function searchVision(args) {
  var visionFileName = args.visionFileName,
    minSimilarity = args.minSimilarity,
    _args$searchArea = args.searchArea,
    searchArea = _args$searchArea === void 0 ? 'full' : _args$searchArea,
    storedImageRect = args.storedImageRect,
    command = args.command,
    cvScope = args.cvScope,
    devicePixelRatio = args.devicePixelRatio,
    captureScreenshotService = args.captureScreenshotService;
  var commandExtra = command.extra || {};
  var requireGreenPinkBoxes = !!commandExtra.relativeVisual;
  var enableGreenPinkBoxes = typeof commandExtra.relativeVisual === 'boolean' ? commandExtra.relativeVisual : /_relative\.png$/i.test(visionFileName);
  var patternDpi = (0, _utils.dpiFromFileName)(visionFileName) || 96;
  var pageDpi = (0, _utils.getPageDpi)();
  var pStorageMan = Promise.resolve((0, _storage.getStorageManager)());
  var getPatternImage = function getPatternImage(fileName) {
    return pStorageMan.then(function (storageMan) {
      var visionStorage = storageMan.getVisionStorage();
      return visionStorage.exists(fileName).then(function (existed) {
        if (!existed) throw new Error("Error #121: ".concat(command.cmd, ": No input image found for file name '").concat(fileName, "'"));
        return visionStorage.read(fileName, 'DataURL');
      });
    });
  };
  if (minSimilarity < 0.1 || minSimilarity > 1.0) {
    throw new Error('confidence should be between 0.1 and 1.0');
  }
  var isFullScreenshot = searchArea !== 'rect' && !/\.png/i.test(searchArea) || !storedImageRect;
  // Note: storedImageRect is supposed to be also returned by this API call
  // thus it is scaled down by (1 / window.devicePixelRatio),
  // we should recover coordiates to screen pixels
  var searchAreaRect = isFullScreenshot ? undefined : {
    x: window.devicePixelRatio * storedImageRect.x,
    y: window.devicePixelRatio * storedImageRect.y,
    width: window.devicePixelRatio * storedImageRect.width,
    height: window.devicePixelRatio * storedImageRect.height
  };
  var pRegions = function () {
    switch (cvScope) {
      case 'desktop':
        {
          return (0, _xdesktop.getXDesktop)().sanityCheck().then(function () {
            return getPatternImage(visionFileName);
          }).then(function (dataUrl) {
            return (0, _desktop.getNativeCVAPI)().getImageFromDataUrl(dataUrl, patternDpi);
          }).then(function (imageObj) {
            return (0, _desktop.getNativeCVAPI)().searchDesktopWithGuard({
              pattern: imageObj,
              options: {
                minSimilarity: minSimilarity,
                enableGreenPinkBoxes: enableGreenPinkBoxes,
                requireGreenPinkBoxes: requireGreenPinkBoxes,
                searchArea: searchAreaRect,
                enableHighDpi: true,
                allowSizeVariation: true,
                saveCaptureOnDisk: true,
                limitSearchArea: !isFullScreenshot
              }
            }).then(function (result) {
              return (0, _desktop.getNativeCVAPI)().readFileAsDataURL(result.capturePath, true).then(function (dataUrl) {
                return saveDataUrlToLastDesktopScreenshot(dataUrl)
                // Note: convert coordinates to CSS pixels
                .then(function () {
                  return (0, _desktop.convertImageSearchResultIfAllCoordiatesBasedOnTopLeftScreen)(result, 1 / window.devicePixelRatio, searchAreaRect);
                });
              });
            });
          });
        }
      case 'browser':
      default:
        return (0, _xdesktop.getXDesktop)().sanityCheck().then(function () {
          return Promise.all([
          // DPI is bound to window.devicePixelRatio, here scale both pattern image and screenshot image to the page DPI
          // so if it's a retina device, the image sizes here are 2x of the css size
          getPatternImage(visionFileName).then(function (dataUrl) {
            return (0, _capture_screenshot.scaleDataURI)(dataUrl, pageDpi / patternDpi);
          }), getScreenshotInSearchArea({
            searchArea: searchArea,
            storedImageRect: storedImageRect,
            devicePixelRatio: devicePixelRatio,
            captureScreenshotService: captureScreenshotService,
            dpiScale: 1
          })]);
        }).then( /*#__PURE__*/function () {
          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
            var _ref3, patternImageUrl, targetImageInfo, targetImageUrl, pageOffset, viewportOffset, patternImage, screenshotImage, searchResult;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _ref3 = _slicedToArray(_ref, 2), patternImageUrl = _ref3[0], targetImageInfo = _ref3[1];
                  targetImageUrl = targetImageInfo.dataUrl;
                  pageOffset = targetImageInfo.offset;
                  viewportOffset = targetImageInfo.viewportOffset;
                  _context.next = 6;
                  return (0, _desktop.getNativeCVAPI)().getImageFromDataUrl(patternImageUrl, patternDpi);
                case 6:
                  patternImage = _context.sent;
                  _context.next = 9;
                  return (0, _desktop.getNativeCVAPI)().getImageFromDataUrl(targetImageUrl, patternDpi);
                case 9:
                  screenshotImage = _context.sent;
                  _context.next = 12;
                  return (0, _desktop.getNativeCVAPI)().searchImageWithGuard({
                    image: screenshotImage,
                    pattern: patternImage,
                    options: {
                      minSimilarity: minSimilarity,
                      enableGreenPinkBoxes: enableGreenPinkBoxes,
                      requireGreenPinkBoxes: requireGreenPinkBoxes,
                      searchArea: searchAreaRect,
                      enableHighDpi: true,
                      allowSizeVariation: true,
                      saveCaptureOnDisk: true,
                      limitSearchArea: !isFullScreenshot
                    }
                  });
                case 12:
                  searchResult = _context.sent;
                  return _context.abrupt("return", (0, _desktop.convertImageSearchResultForPage)(searchResult, 1 / window.devicePixelRatio, pageOffset, viewportOffset));
                case 14:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function (_x) {
            return _ref2.apply(this, arguments);
          };
        }());
    }
  }();
  return pRegions.then(function (regions) {
    return {
      regions: regions,
      imageInfo: {
        source: _types.DesktopScreenshot.ImageSource.Storage,
        path: (0, _utils.ensureExtName)('.png', (0, _cv_utils.isCVTypeForDesktop)(cvScope) ? C.LAST_DESKTOP_SCREENSHOT_FILE_NAME : C.LAST_SCREENSHOT_FILE_NAME)
      }
    };
  });
}
function saveDataUrlToScreenshot(fileName, dataUrl) {
  return (0, _storage.getStorageManager)().getScreenshotStorage().overwrite((0, _utils.ensureExtName)('.png', fileName), (0, _utils.dataURItoBlob)(dataUrl));
  // TODO:
  // getPanelTabIpc()
  // .then(panelIpc => {
  //   return panelIpc.ask('RESTORE_SCREENSHOTS')
  // })
}
function saveDataUrlToLastScreenshot(dataUrl) {
  return saveDataUrlToScreenshot(C.LAST_SCREENSHOT_FILE_NAME, dataUrl);
}
function saveDataUrlToLastDesktopScreenshot(dataUrl) {
  return saveDataUrlToScreenshot(C.LAST_DESKTOP_SCREENSHOT_FILE_NAME, dataUrl);
}
function getScreenshotInSearchArea(_ref4) {
  var searchArea = _ref4.searchArea,
    storedImageRect = _ref4.storedImageRect,
    dpiScale = _ref4.dpiScale,
    devicePixelRatio = _ref4.devicePixelRatio,
    captureScreenshotService = _ref4.captureScreenshotService;
  // Take png searh area as rect, it should have set `storedImageRect` in advance
  if (/\.png/.test(searchArea)) {
    searchArea = 'rect';
  }
  var capture = function capture(ipc, tabId) {
    switch (searchArea) {
      case 'viewport':
        return Promise.all([ipc.ask('SCREENSHOT_PAGE_INFO', {}, C.CS_IPC_TIMEOUT), captureScreenshotService.captureScreen(tabId, devicePixelRatio)]).then(function (_ref5) {
          var _ref6 = _slicedToArray(_ref5, 2),
            pageInfo = _ref6[0],
            dataUrl = _ref6[1];
          saveDataUrlToLastScreenshot(dataUrl);
          return {
            offset: {
              x: pageInfo.originalX,
              y: pageInfo.originalY
            },
            viewportOffset: {
              x: 0,
              y: 0
            },
            dataUrl: dataUrl
          };
        });
      case 'full':
        {
          return Promise.all([ipc.ask('SCREENSHOT_PAGE_INFO', {}, C.CS_IPC_TIMEOUT), captureScreenshotService.captureFullScreen(tabId, {
            startCapture: function startCapture() {
              return ipc.ask('START_CAPTURE_FULL_SCREENSHOT', {}, C.CS_IPC_TIMEOUT);
            },
            endCapture: function endCapture(pageInfo) {
              return ipc.ask('END_CAPTURE_FULL_SCREENSHOT', {
                pageInfo: pageInfo
              }, C.CS_IPC_TIMEOUT);
            },
            scrollPage: function scrollPage(offset) {
              return ipc.ask('SCROLL_PAGE', {
                offset: offset
              }, C.CS_IPC_TIMEOUT);
            }
          })]).then(function (_ref7) {
            var _ref8 = _slicedToArray(_ref7, 2),
              pageInfo = _ref8[0],
              dataUrl = _ref8[1];
            saveDataUrlToLastScreenshot(dataUrl);
            return {
              dataUrl: dataUrl,
              offset: {
                x: 0,
                y: 0
              },
              viewportOffset: {
                x: -1 * pageInfo.originalX,
                y: -1 * pageInfo.originalY
              }
            };
          });
        }
      case 'rect':
        {
          // Note: in this mode, `storedImageRect` is viewport based coordinates
          if (!storedImageRect) {
            throw new Error('rect mode: !storedImageRect should not be empty');
          }
          return ipc.ask('SCREENSHOT_PAGE_INFO').then(function (pageInfo) {
            return captureScreenshotService.captureScreenInSelectionSimple(tabId, {
              rect: storedImageRect,
              devicePixelRatio: pageInfo.devicePixelRatio
            }).then(function (dataUrl) {
              saveDataUrlToLastScreenshot(dataUrl);
              return {
                dataUrl: dataUrl,
                offset: {
                  x: storedImageRect.x + pageInfo.originalX,
                  y: storedImageRect.y + pageInfo.originalY
                },
                viewportOffset: {
                  x: storedImageRect.x,
                  y: storedImageRect.y
                }
              };
            });
          });
        }
      default:
        {
          if (/^element:/i.test(searchArea)) {
            // Note: in this mode, `storedImageRect` is document based coordinates
            if (!storedImageRect) {
              throw new Error('!storedImageRect should not be empty');
            }
            var fileName = (0, _utils.ensureExtName)('.png', C.LAST_SCREENSHOT_FILE_NAME);
            return Promise.all([ipc.ask('SCREENSHOT_PAGE_INFO', {}, C.CS_IPC_TIMEOUT), (0, _storage.getStorageManager)().getScreenshotStorage().read(fileName, 'DataURL')]).then(function (_ref9) {
              var _ref10 = _slicedToArray(_ref9, 2),
                pageInfo = _ref10[0],
                dataUrl = _ref10[1];
              return {
                dataUrl: dataUrl,
                offset: {
                  x: storedImageRect.x,
                  y: storedImageRect.y
                },
                viewportOffset: {
                  x: storedImageRect.x - pageInfo.originalX,
                  y: storedImageRect.y - pageInfo.originalY
                }
              };
            });
          }
          throw new Error("Unsupported searchArea '".concat(searchArea, "'"));
        }
    }
  };
  return Promise.all([(0, _tab.getPlayTabIpc)(), (0, _global_state.getState)()]).then(function (_ref11) {
    var _ref12 = _slicedToArray(_ref11, 2),
      ipc = _ref12[0],
      state = _ref12[1];
    var toPlayTabId = state.tabIds.toPlay;
    return (0, _tab_utils.activateTab)(toPlayTabId, true).then(function () {
      return (0, _utils.delay)(function () {}, C.SCREENSHOT_DELAY);
    }).then(function () {
      return capture(ipc, toPlayTabId);
    }).then(function (obj) {
      return (0, _capture_screenshot.scaleDataURI)(obj.dataUrl, dpiScale).then(function (dataUrl) {
        return {
          dataUrl: dataUrl,
          offset: obj.offset,
          viewportOffset: obj.viewportOffset
        };
      });
    });
  });
}

/***/ }),

/***/ 5239:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.checkLicense = checkLicense;
exports.convertToLicenseInfo = convertToLicenseInfo;
exports.isNetworkError = isNetworkError;
var _axios = _interopRequireDefault(__webpack_require__(86425));
var _config = _interopRequireDefault(__webpack_require__(8747));
var _ts_utils = __webpack_require__(1601);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function isNetworkError(error) {
  return error.message === 'Network Error';
}
function convertToLicenseInfo(result, licenseKey) {
  switch (result.status) {
    case 'key_not_found':
      return {
        licenseKey: licenseKey,
        status: 'key_not_found'
      };
    case 'off':
      return {
        licenseKey: licenseKey,
        status: 'off',
        type: result.product
      };
    case 'on':
      return {
        licenseKey: licenseKey,
        status: 'on',
        type: result.product,
        name: result.data1a,
        upgradeUrl: result.data1b,
        maxOcrCalls: parseInt(result.data2b)
      };
  }
}
function checkLicense(params) {
  var url = (0, _ts_utils.urlWithQueries)(_config["default"].license.api.url, {
    version: params.version,
    licensekey: params.licenseKey
  });
  return _axios["default"].get(url).then(function (res) {
    var result = res.data;
    return convertToLicenseInfo(result, params.licenseKey);
  })["catch"](function (e) {
    if (e.response) {
      throw new Error(e.response.data);
    }
    return Promise.reject(e);
  });
}

/***/ }),

/***/ 12084:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.backup = backup;
var _file_saver = _interopRequireDefault(__webpack_require__(50261));
var _jszip = _interopRequireDefault(__webpack_require__(71710));
var _utils = __webpack_require__(46580);
var _convert_utils = __webpack_require__(75852);
var _convert_suite_utils = __webpack_require__(35379);
var _storage = __webpack_require__(97467);
var _path = __webpack_require__(26513);
var _common = __webpack_require__(68279);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function backup(options) {
  var backup = options.backup,
    macroNodes = options.macroNodes,
    testSuites = options.testSuites,
    screenshots = options.screenshots,
    csvs = options.csvs,
    visions = options.visions;
  var zip = new _jszip["default"]();
  var ps = [];
  var getFolder = function getFolder(relativePath, zipRoot) {
    if (relativePath === '.') {
      return zipRoot;
    }
    var dirs = relativePath.split(_path.posix.sep);
    return dirs.reduce(function (prev, dir) {
      return prev.folder(dir);
    }, zipRoot);
  };
  if (backup.testCase && macroNodes && macroNodes.length) {
    var rootFolder = zip.folder(_common.ZipFolders.Macros);
    macroNodes.forEach(function (node) {
      var dirPath = _path.posix.dirname(node.relativePath);
      var fileName = _path.posix.basename(node.relativePath);
      var folder = getFolder(dirPath, rootFolder);
      ps.push((0, _storage.getStorageManager)().getMacroStorage().read(node.fullPath, 'Text').then(function (data) {
        var macro = data;
        folder.file(fileName, (0, _convert_utils.toJSONString)({
          name: macro.name,
          commands: macro.data.commands
        }, {
          ignoreTargetOptions: !!options.ignoreMacroTargetOptions
        }));
      }));
    });
  }
  if (backup.testSuite && testSuites && testSuites.length) {
    var folder = zip.folder(_common.ZipFolders.TestSuites);
    var genName = (0, _utils.nameFactory)();
    testSuites.forEach(function (ts) {
      var name = genName(ts.name);
      folder.file("".concat(name, ".json"), (0, _convert_suite_utils.stringifyTestSuite)(ts));
    });
  }
  if (backup.screenshot && screenshots && screenshots.length) {
    var _folder = zip.folder(_common.ZipFolders.Screenshots);
    var ssStorage = (0, _storage.getStorageManager)().getScreenshotStorage();
    screenshots.forEach(function (ss) {
      ps.push(ssStorage.read(ss.fullPath, 'ArrayBuffer').then(function (buffer) {
        _folder.file(ss.name, buffer, {
          binary: true
        });
      }));
    });
  }
  if (backup.vision && visions && visions.length) {
    var _folder2 = zip.folder(_common.ZipFolders.Visions);
    var visionStorage = (0, _storage.getStorageManager)().getVisionStorage();
    visions.forEach(function (vision) {
      ps.push(visionStorage.read(vision.fullPath, 'ArrayBuffer').then(function (buffer) {
        _folder2.file(vision.name, buffer, {
          binary: true
        });
      }));
    });
  }
  if (backup.csv && csvs && csvs.length) {
    var _folder3 = zip.folder(_common.ZipFolders.Csvs);
    var csvStorage = (0, _storage.getStorageManager)().getCSVStorage();
    csvs.forEach(function (csv) {
      ps.push(csvStorage.read(csv.fullPath, 'Text').then(function (text) {
        return _folder3.file(csv.name, text);
      }));
    });
  }
  return Promise.all(ps).then(function () {
    zip.generateAsync({
      type: 'blob'
    }).then(function (blob) {
      _file_saver["default"].saveAs(blob, 'uivision_backup.zip');
    });
  });
}

/***/ }),

/***/ 68279:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ZipFolders = void 0;
var ZipFolders = exports.ZipFolders = /*#__PURE__*/function (ZipFolders) {
  ZipFolders["Macros"] = "macros";
  ZipFolders["TestSuites"] = "testsuites";
  ZipFolders["Screenshots"] = "screenshots";
  ZipFolders["Csvs"] = "datasources";
  ZipFolders["Visions"] = "images";
  return ZipFolders;
}({});

/***/ }),

/***/ 88311:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.KeyValueData = void 0;
exports.parseKey = parseKey;
var _storage = _interopRequireDefault(__webpack_require__(88555));
var _ts_utils = __webpack_require__(1601);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function parseKey(key) {
  return key.split('::').filter(function (s) {
    return s.length > 0;
  });
}
var KeyValueData = exports.KeyValueData = /*#__PURE__*/function () {
  function KeyValueData() {
    _classCallCheck(this, KeyValueData);
    _defineProperty(this, "withOneLock", (0, _ts_utils.concurrent)(1)(function (run) {
      return new Promise(function (resolve, reject) {
        try {
          Promise.resolve(run()).then(resolve, reject);
        } catch (e) {
          reject(e);
        }
      });
    }));
  }
  _createClass(KeyValueData, [{
    key: "get",
    value: function get(key) {
      var _this$getMainKeyAndSu = this.getMainKeyAndSubKeys(key),
        _this$getMainKeyAndSu2 = _slicedToArray(_this$getMainKeyAndSu, 2),
        mainKey = _this$getMainKeyAndSu2[0],
        subKeys = _this$getMainKeyAndSu2[1];
      return _storage["default"].get(mainKey).then(function () {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var result = (0, _ts_utils.getIn)(subKeys, data);
        return result;
      });
    }
  }, {
    key: "set",
    value: function set(key, value) {
      var _this = this;
      return this.withOneLock(function () {
        var _this$getMainKeyAndSu3 = _this.getMainKeyAndSubKeys(key),
          _this$getMainKeyAndSu4 = _slicedToArray(_this$getMainKeyAndSu3, 2),
          mainKey = _this$getMainKeyAndSu4[0],
          subKeys = _this$getMainKeyAndSu4[1];
        return _storage["default"].get(mainKey).then(function () {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var updated = (0, _ts_utils.safeSetIn)(subKeys, value, data);
          return _storage["default"].set(mainKey, updated).then(function () {
            return (0, _ts_utils.getIn)(subKeys, updated);
          });
        });
      });
    }
  }, {
    key: "update",
    value: function update(key, updater) {
      var _this2 = this;
      return this.withOneLock(function () {
        var _this2$getMainKeyAndS = _this2.getMainKeyAndSubKeys(key),
          _this2$getMainKeyAndS2 = _slicedToArray(_this2$getMainKeyAndS, 2),
          mainKey = _this2$getMainKeyAndS2[0],
          subKeys = _this2$getMainKeyAndS2[1];
        return _storage["default"].get(mainKey).then(function () {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var updated = (0, _ts_utils.safeUpdateIn)(subKeys, updater, data);
          return _storage["default"].set(mainKey, updated).then(function () {
            return (0, _ts_utils.getIn)(subKeys, updated);
          });
        });
      });
    }
  }, {
    key: "getMainKeyAndSubKeys",
    value: function getMainKeyAndSubKeys(key) {
      var keys = parseKey(key);
      var mainKey = keys[0];
      var subKeys = keys.slice(1);
      return [mainKey, subKeys];
    }
  }]);
  return KeyValueData;
}();

/***/ }),

/***/ 3112:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getMacroExtraKeyValueData = exports.MacroResultStatus = exports.MacroExtraKeyValueData = void 0;
var _common = __webpack_require__(88311);
var _ts_utils = __webpack_require__(1601);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var MacroResultStatus = exports.MacroResultStatus = /*#__PURE__*/function (MacroResultStatus) {
  MacroResultStatus["Normal"] = "NORMAL";
  MacroResultStatus["Success"] = "SUCCESS";
  MacroResultStatus["Error"] = "ERROR";
  MacroResultStatus["ErrorInSub"] = "ERROR_IN_SUB";
  return MacroResultStatus;
}({});
var MacroExtraKeyValueData = exports.MacroExtraKeyValueData = /*#__PURE__*/function (_KeyValueData) {
  _inherits(MacroExtraKeyValueData, _KeyValueData);
  function MacroExtraKeyValueData() {
    _classCallCheck(this, MacroExtraKeyValueData);
    return _callSuper(this, MacroExtraKeyValueData, arguments);
  }
  _createClass(MacroExtraKeyValueData, [{
    key: "getAll",
    value: function getAll() {
      return _get(_getPrototypeOf(MacroExtraKeyValueData.prototype), "get", this).call(this, "");
    }
  }, {
    key: "getMainKeyAndSubKeys",
    value: function getMainKeyAndSubKeys(key) {
      var _get$call = _get(_getPrototypeOf(MacroExtraKeyValueData.prototype), "getMainKeyAndSubKeys", this).call(this, key),
        _get$call2 = _slicedToArray(_get$call, 2),
        mainKey = _get$call2[0],
        subKeys = _get$call2[1];
      return [MacroExtraKeyValueData.STORAGE_KEY, [mainKey].concat(subKeys).filter(function (x) {
        return x && x.length;
      })];
    }
  }]);
  return MacroExtraKeyValueData;
}(_common.KeyValueData);
_defineProperty(MacroExtraKeyValueData, "STORAGE_KEY", 'macro_extra');
var getMacroExtraKeyValueData = exports.getMacroExtraKeyValueData = (0, _ts_utils.singletonGetter)(function () {
  return new MacroExtraKeyValueData();
});

/***/ }),

/***/ 31963:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getMigrationKeyValueData = exports.MigrationKeyValueData = void 0;
var _common = __webpack_require__(88311);
var _ts_utils = __webpack_require__(1601);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var MigrationKeyValueData = exports.MigrationKeyValueData = /*#__PURE__*/function (_KeyValueData) {
  _inherits(MigrationKeyValueData, _KeyValueData);
  function MigrationKeyValueData() {
    _classCallCheck(this, MigrationKeyValueData);
    return _callSuper(this, MigrationKeyValueData, arguments);
  }
  _createClass(MigrationKeyValueData, [{
    key: "getAll",
    value: function getAll() {
      return _get(_getPrototypeOf(MigrationKeyValueData.prototype), "get", this).call(this, "");
    }
  }, {
    key: "getMainKeyAndSubKeys",
    value: function getMainKeyAndSubKeys(key) {
      var _get$call = _get(_getPrototypeOf(MigrationKeyValueData.prototype), "getMainKeyAndSubKeys", this).call(this, key),
        _get$call2 = _slicedToArray(_get$call, 2),
        mainKey = _get$call2[0],
        subKeys = _get$call2[1];
      return [MigrationKeyValueData.STORAGE_KEY, [mainKey].concat(subKeys).filter(function (x) {
        return x && x.length;
      })];
    }
  }]);
  return MigrationKeyValueData;
}(_common.KeyValueData);
_defineProperty(MigrationKeyValueData, "STORAGE_KEY", 'migration_records');
var getMigrationKeyValueData = exports.getMigrationKeyValueData = (0, _ts_utils.singletonGetter)(function () {
  return new MigrationKeyValueData();
});

/***/ }),

/***/ 90429:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getMiscData = exports.MiscKey = exports.MiscData = void 0;
var _common = __webpack_require__(88311);
var _ts_utils = __webpack_require__(1601);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var MiscKey = exports.MiscKey = /*#__PURE__*/function (MiscKey) {
  MiscKey["BrowserModeLastMacroId"] = "browser_mode_last_macro_id";
  MiscKey["XFileModeLastMacroId"] = "xfile_mode_last_macro_id";
  return MiscKey;
}({});
var MiscData = exports.MiscData = /*#__PURE__*/function (_KeyValueData) {
  _inherits(MiscData, _KeyValueData);
  function MiscData() {
    _classCallCheck(this, MiscData);
    return _callSuper(this, MiscData, arguments);
  }
  _createClass(MiscData, [{
    key: "getMainKeyAndSubKeys",
    value: function getMainKeyAndSubKeys(key) {
      var _get$call = _get(_getPrototypeOf(MiscData.prototype), "getMainKeyAndSubKeys", this).call(this, key),
        _get$call2 = _slicedToArray(_get$call, 2),
        mainKey = _get$call2[0],
        subKeys = _get$call2[1];
      return [MiscData.STORAGE_KEY, [mainKey].concat(subKeys).filter(function (x) {
        return x && x.length;
      })];
    }
  }]);
  return MiscData;
}(_common.KeyValueData);
_defineProperty(MiscData, "STORAGE_KEY", 'misc_data');
var getMiscData = exports.getMiscData = (0, _ts_utils.singletonGetter)(function () {
  return new MiscData();
});

/***/ }),

/***/ 86379:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getTestSuiteExtraKeyValueData = exports.TestSuiteExtraKeyValueData = void 0;
var _common = __webpack_require__(88311);
var _ts_utils = __webpack_require__(1601);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var TestSuiteExtraKeyValueData = exports.TestSuiteExtraKeyValueData = /*#__PURE__*/function (_KeyValueData) {
  _inherits(TestSuiteExtraKeyValueData, _KeyValueData);
  function TestSuiteExtraKeyValueData() {
    _classCallCheck(this, TestSuiteExtraKeyValueData);
    return _callSuper(this, TestSuiteExtraKeyValueData, arguments);
  }
  _createClass(TestSuiteExtraKeyValueData, [{
    key: "getAll",
    value: function getAll() {
      return _get(_getPrototypeOf(TestSuiteExtraKeyValueData.prototype), "get", this).call(this, "");
    }
  }, {
    key: "getMainKeyAndSubKeys",
    value: function getMainKeyAndSubKeys(key) {
      var _get$call = _get(_getPrototypeOf(TestSuiteExtraKeyValueData.prototype), "getMainKeyAndSubKeys", this).call(this, key),
        _get$call2 = _slicedToArray(_get$call, 2),
        mainKey = _get$call2[0],
        subKeys = _get$call2[1];
      return [TestSuiteExtraKeyValueData.STORAGE_KEY, [mainKey].concat(subKeys).filter(function (x) {
        return x && x.length;
      })];
    }
  }]);
  return TestSuiteExtraKeyValueData;
}(_common.KeyValueData);
_defineProperty(TestSuiteExtraKeyValueData, "STORAGE_KEY", 'test_suite_extra');
var getTestSuiteExtraKeyValueData = exports.getTestSuiteExtraKeyValueData = (0, _ts_utils.singletonGetter)(function () {
  return new TestSuiteExtraKeyValueData();
});

/***/ }),

/***/ 12277:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getLicenseService = void 0;
var _web_extension = _interopRequireDefault(__webpack_require__(41953));
var _storage = _interopRequireDefault(__webpack_require__(88555));
var _ts_utils = __webpack_require__(1601);
var _service = __webpack_require__(91586);
var _actions = __webpack_require__(35127);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var getLicenseService = exports.getLicenseService = (0, _ts_utils.singletonGetter)(function () {
  return new _service.LicenseService({
    getVersion: function getVersion() {
      return Promise.resolve(_web_extension["default"].runtime.getManifest().version);
    },
    getLegacyXModuleStatus: function getLegacyXModuleStatus() {
      return window['store'].getState().config.xmodulesStatus;
    },
    setLegacyXModuleStatus: function setLegacyXModuleStatus(status) {
      return Promise.resolve(window['store'].dispatch((0, _actions.updateConfig)({
        xmodulesStatus: status
      })));
    },
    save: function save(license) {
      return _storage["default"].set(_service.LicenseService.StorageKey, license).then(function () {});
    },
    read: function read() {
      return _storage["default"].get(_service.LicenseService.StorageKey).then(function (license) {
        return license !== null && license !== void 0 ? license : null;
      });
    }
  });
});

/***/ }),

/***/ 91586:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LicenseService = void 0;
var _types = __webpack_require__(58704);
var HttpAPI = _interopRequireWildcard(__webpack_require__(5239));
var _config = _interopRequireDefault(__webpack_require__(8747));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var LicenseService = exports.LicenseService = /*#__PURE__*/function () {
  function LicenseService(params) {
    _classCallCheck(this, LicenseService);
    _defineProperty(this, "license", null);
    this.params = params;
    this.getLatestInfo();
  }
  _createClass(LicenseService, [{
    key: "legacyXModuleStatus",
    get: function get() {
      return this.params.getLegacyXModuleStatus();
    }
  }, {
    key: "checkLicense",
    value: function checkLicense(licenseKey) {
      var _this = this;
      return this.params.getVersion().then(function (version) {
        return HttpAPI.checkLicense({
          licenseKey: licenseKey,
          version: version
        });
      }).then(function (license) {
        // Only persist valid license
        if (license.status === 'key_not_found') {
          return license;
        }
        _this.license = license;
        return Promise.all([_this.params.save(license), _this.params.setLegacyXModuleStatus('checked_by_remote')]).then(function () {
          return license;
        });
      });
    }
  }, {
    key: "recheckLicenseIfPossible",
    value: function recheckLicenseIfPossible() {
      var _this$license;
      if (this.legacyXModuleStatus !== 'checked_by_remote' || !this.license) {
        return Promise.resolve(false);
      }
      return this.checkLicense((_this$license = this.license) === null || _this$license === void 0 ? void 0 : _this$license.licenseKey).then(function () {
        return true;
      });
    }
  }, {
    key: "getLatestInfo",
    value: function getLatestInfo() {
      var _this2 = this;
      return Promise.all([this.params.read()]).then(function (tuple) {
        _this2.license = tuple[0];
        return tuple[0];
      });
    }
  }, {
    key: "canPerform",
    value: function canPerform(feature) {
      var _type;
      if (this.legacyXModuleStatus !== 'checked_by_remote') {
        return true;
      }
      var licenseType = (_type = this.license.type) !== null && _type !== void 0 ? _type : _types.LicenseType.Personal;
      switch (licenseType) {
        case _types.LicenseType.Enterprise:
        case _types.LicenseType.Personal:
        case _types.LicenseType.Pro:
          return true;
        case _types.LicenseType.Player:
          return feature === _types.Feature.Replay;
      }
    }
  }, {
    key: "isProLicense",
    value: function isProLicense() {
      var _this$license2;
      switch (this.legacyXModuleStatus) {
        case 'pro':
          return true;
        case 'checked_by_remote':
          return ((_this$license2 = this.license) === null || _this$license2 === void 0 ? void 0 : _this$license2.status) === 'on' && (this.license.type === _types.LicenseType.Pro || this.license.type === _types.LicenseType.Enterprise);
        default:
          return false;
      }
    }
  }, {
    key: "isPersonalLicense",
    value: function isPersonalLicense() {
      var _this$license3;
      switch (this.legacyXModuleStatus) {
        case 'free':
          return true;
        case 'checked_by_remote':
          return ((_this$license3 = this.license) === null || _this$license3 === void 0 ? void 0 : _this$license3.status) === 'on' && this.license.type === _types.LicenseType.Personal;
        default:
          return false;
      }
    }
  }, {
    key: "isPlayerLicense",
    value: function isPlayerLicense() {
      var _this$license4;
      switch (this.legacyXModuleStatus) {
        case 'checked_by_remote':
          return ((_this$license4 = this.license) === null || _this$license4 === void 0 ? void 0 : _this$license4.status) === 'on' && this.license.type === _types.LicenseType.Player;
        default:
          return false;
      }
    }
  }, {
    key: "hasNoLicense",
    value: function hasNoLicense() {
      switch (this.legacyXModuleStatus) {
        case 'unregistered':
          return true;
        case 'checked_by_remote':
          return !this.license || this.license.status !== 'on';
        default:
          return false;
      }
    }
  }, {
    key: "isLicenseExpired",
    value: function isLicenseExpired() {
      var _this$license5;
      return this.legacyXModuleStatus === 'checked_by_remote' && ((_this$license5 = this.license) === null || _this$license5 === void 0 ? void 0 : _this$license5.status) === 'off';
    }
  }, {
    key: "getEditionName",
    value: function getEditionName() {
      var _this$license6;
      if (this.legacyXModuleStatus === 'checked_by_remote' && ((_this$license6 = this.license) === null || _this$license6 === void 0 ? void 0 : _this$license6.status) === 'on') {
        return this.license.name;
      }
      switch (this.legacyXModuleStatus) {
        case 'free':
          return 'Personal Edition';
        case 'pro':
          return 'PRO Edition';
        case 'unregistered':
        case 'checked_by_remote':
        default:
          return 'Free Edition';
      }
    }
  }, {
    key: "getUpgradeUrl",
    value: function getUpgradeUrl() {
      var _this$license7;
      if (this.legacyXModuleStatus === 'checked_by_remote' && ((_this$license7 = this.license) === null || _this$license7 === void 0 ? void 0 : _this$license7.status) === 'on') {
        return this.license.upgradeUrl;
      }
      switch (this.legacyXModuleStatus) {
        case 'free':
          return _config["default"].xmodulesLimit.free.upgradeUrl;
        case 'pro':
          return _config["default"].xmodulesLimit.pro.upgradeUrl;
        case 'unregistered':
        case 'checked_by_remote':
        default:
          return _config["default"].xmodulesLimit.unregistered.upgradeUrl;
      }
    }
  }, {
    key: "getMaxOcrCalls",
    value: function getMaxOcrCalls() {
      var _this$license8;
      if (this.legacyXModuleStatus === 'checked_by_remote' && ((_this$license8 = this.license) === null || _this$license8 === void 0 ? void 0 : _this$license8.status) === 'on') {
        return this.license.maxOcrCalls;
      }
      switch (this.legacyXModuleStatus) {
        case 'free':
          return _config["default"].xmodulesLimit.free.ocrCommandCount;
        case 'pro':
          return _config["default"].xmodulesLimit.pro.ocrCommandCount;
        case 'checked_by_remote':
        case 'unregistered':
        default:
          return _config["default"].xmodulesLimit.unregistered.ocrCommandCount;
      }
    }
  }, {
    key: "getMaxXCommandCalls",
    value: function getMaxXCommandCalls() {
      var status = this.convertToLegacyStatus();
      switch (status) {
        case 'free':
          return _config["default"].xmodulesLimit.free.xCommandCount;
        case 'pro':
          return _config["default"].xmodulesLimit.pro.xCommandCount;
        case 'unregistered':
        default:
          return _config["default"].xmodulesLimit.unregistered.xCommandCount;
      }
    }
  }, {
    key: "getMaxProxyCalls",
    value: function getMaxProxyCalls() {
      var status = this.convertToLegacyStatus();
      switch (status) {
        case 'free':
          return _config["default"].xmodulesLimit.free.proxyExecCount;
        case 'pro':
          return _config["default"].xmodulesLimit.pro.proxyExecCount;
        case 'unregistered':
        default:
          return _config["default"].xmodulesLimit.unregistered.proxyExecCount;
      }
    }
  }, {
    key: "getMaxXFileMacros",
    value: function getMaxXFileMacros() {
      var status = this.convertToLegacyStatus();
      switch (status) {
        case 'free':
          return _config["default"].xmodulesLimit.free.xFileMacroCount;
        case 'pro':
          return _config["default"].xmodulesLimit.pro.xFileMacroCount;
        case 'unregistered':
        default:
          return _config["default"].xmodulesLimit.unregistered.xFileMacroCount;
      }
    }
  }, {
    key: "convertToLegacyStatus",
    value: function convertToLegacyStatus() {
      var _this$license9;
      if (this.legacyXModuleStatus && this.legacyXModuleStatus !== 'checked_by_remote') {
        return this.legacyXModuleStatus;
      }
      if (((_this$license9 = this.license) === null || _this$license9 === void 0 ? void 0 : _this$license9.status) !== 'on') {
        return 'unregistered';
      }
      switch (this.license.type) {
        case _types.LicenseType.Player:
        case _types.LicenseType.Enterprise:
        case _types.LicenseType.Pro:
          return 'pro';
        case _types.LicenseType.Personal:
          return 'free';
      }
    }
  }]);
  return LicenseService;
}();
_defineProperty(LicenseService, "StorageKey", 'a9t9');

/***/ }),

/***/ 58704:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LicenseType = exports.Feature = void 0;
var LicenseType = exports.LicenseType = /*#__PURE__*/function (LicenseType) {
  LicenseType["Enterprise"] = "ui-ee";
  LicenseType["Personal"] = "ui-personal";
  LicenseType["Player"] = "ui-player";
  LicenseType["Pro"] = "ui-pro";
  return LicenseType;
}({});
var Feature = exports.Feature = /*#__PURE__*/function (Feature) {
  Feature[Feature["Replay"] = 0] = "Replay";
  Feature[Feature["Record"] = 1] = "Record";
  Feature[Feature["Edit"] = 2] = "Edit";
  return Feature;
}({});

/***/ }),

/***/ 26480:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getLogService = exports.LogService = void 0;
var _filesystem = __webpack_require__(89937);
var _xfile = __webpack_require__(63109);
var _path = _interopRequireDefault(__webpack_require__(26513));
var _log2 = _interopRequireDefault(__webpack_require__(89130));
var _ts_utils = __webpack_require__(1601);
var _storage = __webpack_require__(97467);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var LogService = exports.LogService = /*#__PURE__*/function () {
  function LogService() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, LogService);
    _defineProperty(this, "pDirReady", Promise.resolve(false));
    _defineProperty(this, "logsDir", '');
    _defineProperty(this, "fileName", 'log.txt');
    _defineProperty(this, "waitForStorageManager", function () {
      return Promise.resolve((0, _storage.getStorageManager)());
    });
    this.check();
    this.updateLogFileName();
    if (params.waitForStorageManager) {
      this.waitForStorageManager = params.waitForStorageManager;
    }
  }
  _createClass(LogService, [{
    key: "updateLogFileName",
    value: function updateLogFileName() {
      var now = new Date();
      var dateStr = "".concat(now.getFullYear()).concat((0, _ts_utils.pad2digits)(now.getMonth() + 1)).concat((0, _ts_utils.pad2digits)(now.getDate()));
      var timeStr = [now.getHours(), now.getMinutes(), now.getSeconds()].map(function (n) {
        return (0, _ts_utils.pad2digits)(n);
      }).join('');
      this.fileName = "log-".concat(dateStr, "-").concat(timeStr, ".txt");
    }
  }, {
    key: "check",
    value: function check() {
      var _this = this;
      this.pDirReady = (0, _xfile.getXFile)().sanityCheck(true).then(function (isSane) {
        if (!isSane) {
          return false;
        }
        var _getXFile$getCachedCo = (0, _xfile.getXFile)().getCachedConfig(),
          rootDir = _getXFile$getCachedCo.rootDir;
        if (!rootDir) {
          return false;
        }
        _this.logsDir = _path["default"].join(rootDir, 'logs');
        return (0, _filesystem.getNativeFileSystemAPI)().ensureDir({
          path: _this.logsDir
        });
      });
      return this.pDirReady;
    }
  }, {
    key: "log",
    value: function log(str) {
      var _this2 = this;
      return this.waitForStorageManager().then(function (storageManager) {
        if (!storageManager.isXFileMode()) {
          return false;
        }
        return (0, _xfile.getXFile)().sanityCheck(true).then(function () {
          return _this2.pDirReady;
        }).then(function (ready) {
          if (!ready) {
            return false;
          }
          return (0, _filesystem.getNativeFileSystemAPI)().appendAllText({
            path: _path["default"].join(_this2.logsDir, _this2.fileName),
            content: ensureLineBreak(str)
          });
        }, function (e) {
          _log2["default"].warn('Failed to log: ', e.message);
          return false;
        });
      });
    }
  }, {
    key: "logWithTime",
    value: function logWithTime(str) {
      return this.log("".concat(new Date().toISOString(), " - ").concat(str));
    }
  }, {
    key: "logTo",
    value: function logTo(filePath, str) {
      return this.waitForStorageManager().then(function (storageManager) {
        if (!storageManager.isXFileMode()) {
          return false;
        }
        return (0, _xfile.getXFile)().sanityCheck(true).then(function (ready) {
          if (!ready) {
            return false;
          }
          var dirPath = _path["default"].dirname(filePath);
          return (0, _filesystem.getNativeFileSystemAPI)().ensureDir({
            path: dirPath
          }).then(function (dirReady) {
            if (!dirReady) {
              return false;
            }
            return (0, _filesystem.getNativeFileSystemAPI)().appendAllText({
              path: filePath,
              content: ensureLineBreak(str)
            });
          });
        }, function (e) {
          _log2["default"].warn('Failed to log: ', e.message);
          return false;
        });
      });
    }
  }]);
  return LogService;
}();
var getLogService = exports.getLogService = (0, _ts_utils.singletonGetter)(function () {
  return new LogService();
});
function ensureLineBreak(str) {
  if (str.length === 0) {
    return str;
  }
  if (str.charAt(str.length - 1) !== '\n') {
    return str + '\n';
  }
  return str;
}

/***/ }),

/***/ 36877:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MigrationService = void 0;
var _semver = _interopRequireDefault(__webpack_require__(99589));
var _types = __webpack_require__(37915);
var _ts_utils = __webpack_require__(1601);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var MigrationService = exports.MigrationService = /*#__PURE__*/function () {
  function MigrationService(options) {
    _classCallCheck(this, MigrationService);
    this.storage = options.storage;
    this.jobs = options.jobs;
  }
  _createClass(MigrationService, [{
    key: "isMigrated",
    value: function isMigrated(type) {
      return this.storage.get(type).then(function (record) {
        return !!record;
      });
    }
  }, {
    key: "getRecords",
    value: function getRecords() {
      return this.storage.getAll();
    }
  }, {
    key: "runType",
    value: function runType(type) {
      var _this = this;
      return this.isMigrated(type).then(function (migrated) {
        if (migrated) {
          return _types.MigrationResult.AlreadyMigrated;
        }
        var job = _this.findJob(type);
        if (!job) {
          return _types.MigrationResult.JobUnknown;
        }
        return job.shouldMigrate().then(function (pass) {
          if (!pass) {
            return _types.MigrationResult.NotQualified;
          }
          return job.migrate().then(function () {
            return _types.MigrationResult.Success;
          });
        });
      })["catch"](function (e) {
        console.error(e);
        return _types.MigrationResult.Error;
      }).then(function (result) {
        if (result !== _types.MigrationResult.Success) {
          return Promise.resolve(result);
        }
        return _this.storage.set(type, {
          result: result,
          id: (0, _ts_utils.uid)(),
          runAt: new Date().getTime(),
          jobType: type
        }).then(function () {
          return result;
        });
      });
    }
  }, {
    key: "runAll",
    value: function runAll(previousVersion, currentVersion) {
      var _this2 = this;
      var validJobs = this.jobs.filter(function (job) {
        return _semver["default"].satisfies(previousVersion, job.previousVersionRange());
      });
      return _ts_utils.flow.apply(void 0, _toConsumableArray(validJobs.map(function (job) {
        var type = job.getType();
        return function () {
          return _this2.runType(type).then(function (result) {
            return {
              type: type,
              result: result
            };
          });
        };
      }))).then(function (list) {
        var result = list.reduce(function (prev, cur) {
          prev[cur.type] = cur.result;
          return prev;
        }, {});
        return result;
      });
    }
  }, {
    key: "findJob",
    value: function findJob(type) {
      return this.jobs.find(function (item) {
        return item.getType() === type;
      });
    }
  }]);
  return MigrationService;
}();

/***/ }),

/***/ 78954:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getKantuMigrationService = exports.KantuMigrationService = void 0;
var _common = __webpack_require__(36877);
var _migration_data = __webpack_require__(31963);
var _04_01_macro_suite_storage = __webpack_require__(37740);
var _ts_utils = __webpack_require__(1601);
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var KantuMigrationService = exports.KantuMigrationService = /*#__PURE__*/function (_MigrationService) {
  _inherits(KantuMigrationService, _MigrationService);
  function KantuMigrationService() {
    _classCallCheck(this, KantuMigrationService);
    return _callSuper(this, KantuMigrationService, [{
      storage: {
        get: function get(type) {
          return (0, _migration_data.getMigrationKeyValueData)().get(type);
        },
        set: function set(type, data) {
          return (0, _migration_data.getMigrationKeyValueData)().set(type, data).then(function () {
            return true;
          });
        },
        getAll: function getAll() {
          return (0, _migration_data.getMigrationKeyValueData)().getAll().then(function (dict) {
            return Object.keys(dict).map(function (key) {
              return dict[key];
            });
          });
        }
      },
      jobs: [(0, _04_01_macro_suite_storage.getMigrateMacroTestSuiteToBrowserFileSystem)()]
    }]);
  }
  return _createClass(KantuMigrationService);
}(_common.MigrationService);
var getKantuMigrationService = exports.getKantuMigrationService = (0, _ts_utils.singletonGetter)(function () {
  return new KantuMigrationService();
});

/***/ }),

/***/ 37740:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getMigrateMacroTestSuiteToBrowserFileSystem = exports.MigrateMacroTestSuiteToBrowserFileSystem = void 0;
var _types = __webpack_require__(37915);
var _indexeddb_storage = __webpack_require__(64582);
var _storage = __webpack_require__(97467);
var _macro_extra_data = __webpack_require__(3112);
var _filesystem = _interopRequireDefault(__webpack_require__(61222));
var _backup = __webpack_require__(12084);
var _ts_utils = __webpack_require__(1601);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var MigrateMacroTestSuiteToBrowserFileSystem = exports.MigrateMacroTestSuiteToBrowserFileSystem = /*#__PURE__*/function () {
  function MigrateMacroTestSuiteToBrowserFileSystem() {
    _classCallCheck(this, MigrateMacroTestSuiteToBrowserFileSystem);
    _defineProperty(this, "oldMacros", []);
  }
  _createClass(MigrateMacroTestSuiteToBrowserFileSystem, [{
    key: "getMeta",
    value: function getMeta() {
      return {
        createdAt: new Date('2019-04-01').getTime(),
        goal: ["Migrate macros and test suites from indexedDB storage to Browser File System storage", "In order to prepare for an easy support for deep folder structure", "Note: the old indexedDB storage WILL NOT be cleared, just in case any user loses his data during migration", "The real clean up could be done in future releases, in the form of another migration job"].join('. ')
      };
    }
  }, {
    key: "getType",
    value: function getType() {
      return _types.MigrationJobType.MigrateMacroTestSuiteToBrowserFileSystem;
    }
  }, {
    key: "previousVersionRange",
    value: function previousVersionRange() {
      return '<=4.0.1';
    }
  }, {
    key: "shouldMigrate",
    value: function shouldMigrate() {
      var oldMacroStorage = this.getOldMacroStorage();
      var oldTestSuiteStorage = this.getOldTestSuiteStorage();
      return Promise.all([oldMacroStorage.list().then(function (list) {
        return list.length;
      }), oldTestSuiteStorage.list().then(function (list) {
        return list.length;
      })]).then(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          macroCount = _ref2[0],
          testSuiteCount = _ref2[1];
        return macroCount > 0 || testSuiteCount > 0;
      });
    }
  }, {
    key: "migrate",
    value: function migrate() {
      var _this = this;
      var migrateMacros = function migrateMacros() {
        return _this.getOldMacroStorage().readAll().then(function (fileObjs) {
          console.log('this.getOldMacroStorage().readAll()', fileObjs);
          _this.oldMacros = fileObjs.map(function (obj) {
            return obj.content;
          });
          return _filesystem["default"].ensureDirectory('/macros').then(function () {
            return _this.getNewMacroStorage().bulkWrite(fileObjs);
          });
        }).then(function () {
          return true;
        });
      };
      var migrateTestSuites = function migrateTestSuites() {
        return _this.getOldTestSuiteStorage().readAll().then(function (fileObjs) {
          console.log('this.getOldTestSuiteStorage().readAll()', fileObjs);
          return _filesystem["default"].ensureDirectory('/testsuites').then(function () {
            return _this.getNewTestSuiteStorage().bulkWrite(fileObjs);
          });
        }).then(function () {
          return true;
        });
      };
      var migrateMacroExtra = function migrateMacroExtra() {
        return (0, _macro_extra_data.getMacroExtraKeyValueData)().getAll().then(function (allMacroExtra) {
          _this.oldMacros.forEach(function (macro) {
            var newId = _this.getNewMacroStorage().filePath(macro.name);
            var oldId = macro.id;
            if (allMacroExtra[oldId]) {
              allMacroExtra[newId] = allMacroExtra[oldId];
            }
          });
          return (0, _macro_extra_data.getMacroExtraKeyValueData)().set('', allMacroExtra);
        });
      };
      return migrateMacros().then(function () {
        return migrateTestSuites();
      }).then(function () {
        return migrateMacroExtra();
      }).then(function () {
        return true;
      });
    }
  }, {
    key: "remedy",
    value: function remedy() {
      var _this2 = this;
      // Download the old macros and test suites in zip
      var readOldMacros = function readOldMacros() {
        return _this2.getOldMacroStorage().readAll().then(function (fileObjs) {
          _this2.oldMacros = fileObjs.map(function (obj) {
            return obj.content;
          });
          return _this2.oldMacros;
        });
      };
      var readOldTestSuites = function readOldTestSuites() {
        return _this2.getOldTestSuiteStorage().readAll().then(function (fileObjs) {
          return fileObjs.map(function (obj) {
            return obj.content;
          });
        });
      };
      return readOldMacros().then(function (macros) {
        return readOldTestSuites().then(function (testSuites) {
          return (0, _backup.backup)({
            backup: {
              testCase: true,
              testSuite: true
            },
            macroNodes: macros,
            testSuites: testSuites
          });
        });
      });
    }
  }, {
    key: "getOldMacroStorage",
    value: function getOldMacroStorage() {
      return (0, _indexeddb_storage.getIndexeddbFlatStorage)({
        table: 'testCases'
      });
    }
  }, {
    key: "getOldTestSuiteStorage",
    value: function getOldTestSuiteStorage() {
      return (0, _indexeddb_storage.getIndexeddbFlatStorage)({
        table: 'testSuites'
      });
    }
  }, {
    key: "getNewMacroStorage",
    value: function getNewMacroStorage() {
      return this.getStorageManager().getStorageForTarget(_storage.StorageTarget.Macro, _storage.StorageStrategyType.Browser);
    }
  }, {
    key: "getNewTestSuiteStorage",
    value: function getNewTestSuiteStorage() {
      return this.getStorageManager().getStorageForTarget(_storage.StorageTarget.TestSuite, _storage.StorageStrategyType.Browser);
    }
  }, {
    key: "getStorageManager",
    value: function getStorageManager() {
      var _this3 = this;
      return new _storage.StorageManager(_storage.StorageStrategyType.Browser, {
        getMacros: function getMacros() {
          return _this3.oldMacros;
        },
        getMaxMacroCount: function getMaxMacroCount() {
          return Promise.resolve(Infinity);
        }
      });
    }
  }]);
  return MigrateMacroTestSuiteToBrowserFileSystem;
}();
var getMigrateMacroTestSuiteToBrowserFileSystem = exports.getMigrateMacroTestSuiteToBrowserFileSystem = (0, _ts_utils.singletonGetter)(function () {
  return new MigrateMacroTestSuiteToBrowserFileSystem();
});

/***/ }),

/***/ 37915:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MigrationResult = exports.MigrationJobType = void 0;
var MigrationJobType = exports.MigrationJobType = /*#__PURE__*/function (MigrationJobType) {
  MigrationJobType["MigrateMacroTestSuiteToBrowserFileSystem"] = "20190401_macro_test_suite_to_browser_fs";
  return MigrationJobType;
}({});
var MigrationResult = exports.MigrationResult = /*#__PURE__*/function (MigrationResult) {
  MigrationResult[MigrationResult["AlreadyMigrated"] = 0] = "AlreadyMigrated";
  MigrationResult[MigrationResult["NotQualified"] = 1] = "NotQualified";
  MigrationResult[MigrationResult["Success"] = 2] = "Success";
  MigrationResult[MigrationResult["Error"] = 3] = "Error";
  MigrationResult[MigrationResult["JobUnknown"] = 4] = "JobUnknown";
  return MigrationResult;
}({});

/***/ }),

/***/ 38268:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getOcrCommandCounter = void 0;
var _storage = _interopRequireDefault(__webpack_require__(88555));
var _persistent_counter = __webpack_require__(90385);
var _ts_utils = __webpack_require__(1601);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var STORAGE_KEY = 'OCR_CONVERSIONS_PER_DAY';
var today = function today() {
  var d = new Date();
  return {
    year: d.getFullYear(),
    month: d.getMonth() + 1,
    date: d.getDate()
  };
};
var isSameDay = function isSameDay(a, b) {
  return a.year === b.year && a.month === b.month && a.date === b.date;
};
var getOcrCommandCounter = exports.getOcrCommandCounter = (0, _ts_utils.singletonGetter)(function (options) {
  var read = function read() {
    // log('getOcrCommandCounter - read')

    return _storage["default"].get(STORAGE_KEY).then(function (val) {
      if (!val) return options.initial;
      if (!isSameDay(today(), val.day)) return options.initial;
      return val.count;
    });
  };
  var write = function write(n) {
    // log('getOcrCommandCounter - write', n)

    return _storage["default"].set(STORAGE_KEY, {
      day: today(),
      count: n
    }).then(function () {});
  };
  return new _persistent_counter.PersistentCounter(_objectSpread(_objectSpread({}, options), {}, {
    read: read,
    write: write
  }));
});

/***/ }),

/***/ 30502:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getOcrEndpointPicker = void 0;
var _common = __webpack_require__(88311);
var _ts_utils = __webpack_require__(1601);
var _config = _interopRequireDefault(__webpack_require__(8747));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var OcrServerKeyValueData = /*#__PURE__*/function (_KeyValueData) {
  _inherits(OcrServerKeyValueData, _KeyValueData);
  function OcrServerKeyValueData() {
    _classCallCheck(this, OcrServerKeyValueData);
    return _callSuper(this, OcrServerKeyValueData, arguments);
  }
  _createClass(OcrServerKeyValueData, [{
    key: "getAll",
    value: function getAll() {
      return _get(_getPrototypeOf(OcrServerKeyValueData.prototype), "get", this).call(this, "").then(function (data) {
        return data || {};
      });
    }
  }, {
    key: "getMainKeyAndSubKeys",
    value: function getMainKeyAndSubKeys(key) {
      var _get$call = _get(_getPrototypeOf(OcrServerKeyValueData.prototype), "getMainKeyAndSubKeys", this).call(this, key),
        _get$call2 = _slicedToArray(_get$call, 2),
        mainKey = _get$call2[0],
        subKeys = _get$call2[1];
      return [OcrServerKeyValueData.STORAGE_KEY, [mainKey].concat(subKeys).filter(function (x) {
        return x && x.length;
      })];
    }
  }]);
  return OcrServerKeyValueData;
}(_common.KeyValueData);
_defineProperty(OcrServerKeyValueData, "STORAGE_KEY", 'ocr_server_data');
var getOcrServerKeyValueData = (0, _ts_utils.singletonGetter)(function () {
  return new OcrServerKeyValueData();
});
var OcrEndpointPicker = /*#__PURE__*/function () {
  function OcrEndpointPicker(options) {
    _classCallCheck(this, OcrEndpointPicker);
    this.servers = options.servers;
    this.resetTime = options.resetTime;
    this.lastId = null;
  }
  _createClass(OcrEndpointPicker, [{
    key: "all",
    value: function all() {
      return Promise.resolve(this.servers);
    }
  }, {
    key: "isAllDown",
    value: function isAllDown() {
      return this.validServers().then(function (_ref) {
        var servers = _ref.servers;
        return servers.length === 0;
      });
    }
  }, {
    key: "randomPick",
    value: function randomPick() {
      return this.validServers().then(function (_ref2) {
        var servers = _ref2.servers,
          serverInfos = _ref2.serverInfos;
        return servers[randomIndex(servers.length)];
      });
    }
  }, {
    key: "bestPick",
    value: function bestPick() {
      return this.validServers().then(function (_ref3) {
        var servers = _ref3.servers,
          serverInfos = _ref3.serverInfos;
        var getTime = function getTime(server) {
          return serverInfos[server.id] ? serverInfos[server.id].lastTotalMilliseconds : 0;
        };
        return servers.reduce(function (prev, server) {
          if (!prev) return server;
          // Note: These two lines are used to avoid using the same endpoint on two consecutive runs
          // That's not what we want at this comment, so comment it out
          //
          // if (prev.id === this.lastId)    return server
          // if (server.id === this.lastId)  return prev

          var timeA = getTime(prev);
          var timeB = getTime(server);
          switch (Math.sign(timeA - timeB)) {
            case 0:
              return Math.random() > 0.5 ? prev : server;
            case 1:
              return server;
            case -1:
            default:
              return prev;
          }
        });
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      // Note: reset server sanity to null when all servers are down,
      // so that it will check all servers again on next request
      return _ts_utils.flow.apply(void 0, _toConsumableArray(this.servers.map(function (server) {
        return function () {
          return getOcrServerKeyValueData().set(server.id, null);
        };
      }))).then(function () {});
    }
  }, {
    key: "use",
    value: function use(id) {
      var found = this.servers.find(function (item) {
        return item.id === id;
      });
      if (!found) throw new Error("No server found with id '".concat(id, "'"));
      this.lastId = id;
    }
  }, {
    key: "setSingleServerInstance",
    value: function setSingleServerInstance(server) {
      if (!server.id) {
        throw new Error('Server id is required');
      }
      if (!server.url) {
        throw new Error('Server url is required');
      }
      if (!server.key) {
        throw new Error('Server key is required');
      }
      // remove all servers
      this.servers = [];
      // add new server
      this.servers.push(server);
      return Promise.resolve(server);
    }
  }, {
    key: "report",
    value: function report(id, sanityInfo) {
      return getOcrServerKeyValueData().set(id, sanityInfo).then(function () {
        return true;
      });
    }
  }, {
    key: "validServers",
    value: function validServers() {
      var _this = this;
      return getOcrServerKeyValueData().getAll().then(function (serverInfos) {
        var now = new Date().getTime();
        var servers = _this.servers.filter(function (server) {
          var info = serverInfos[server.id];
          if (!info) return true;
          if (now - info.lastResponseTimestamp > _this.resetTime) return true;
          if (info.lastError) return false;
          return info.lastTotalMilliseconds <= _config["default"].ocr.apiHealthyResponseTime;
        });
        if (servers.length === 0) {
          throw new Error('invalid API key'); //('All OCR servers are down')
        }
        return {
          servers: servers,
          serverInfos: serverInfos
        };
      });
    }
  }]);
  return OcrEndpointPicker;
}();
function randomIndex(count) {
  return Math.round(Math.random() * count);
}
var getOcrEndpointPicker = exports.getOcrEndpointPicker = (0, _ts_utils.singletonGetter)(function () {
  return new OcrEndpointPicker({
    servers: [],
    resetTime: _config["default"].ocr.resetTime
  });
});

/***/ }),

/***/ 41488:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MacroCallStack = exports.CallStack = void 0;
exports.createMacroCallStack = createMacroCallStack;
exports.getMacroCallStack = void 0;
var _types = __webpack_require__(95022);
var _stack = __webpack_require__(47447);
var _macro = __webpack_require__(9599);
var _ts_utils = __webpack_require__(1601);
var _registry = __webpack_require__(50149);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var CallStack = exports.CallStack = /*#__PURE__*/function (_ref) {
  _inherits(CallStack, _ref);
  function CallStack(options) {
    var _this;
    _classCallCheck(this, CallStack);
    _this = _callSuper(this, CallStack);
    _this.opts = options;
    _this.registry = (0, _registry.createListenerRegistry)();
    return _this;
  }
  _createClass(CallStack, [{
    key: "on",
    value: function on(eventName, listener) {
      var _this2 = this;
      this.registry.add(eventName, listener);
      return function () {
        return _this2.registry.remove(eventName, listener);
      };
    }
  }, {
    key: "off",
    value: function off() {
      this.registry.destroy();
    }
  }, {
    key: "call",
    value: function call(resource, runningStatus) {
      var _this3 = this;
      if (!this.isEmpty()) {
        this.updatePeek(function (element) {
          return {
            id: element.id,
            resource: element.resource,
            runningStatus: _objectSpread(_objectSpread({}, _this3.opts.updateRunningStatusForCaller(element.runningStatus, element.resource)), {}, {
              status: _macro.MacroStatus.Calling
            })
          };
        });
      }
      this.push({
        resource: resource,
        id: (0, _ts_utils.uid)(),
        runningStatus: runningStatus || this.opts.getInitialRunningStatus(resource)
      });
      this.registry.fire(_types.CallStackEvent.BeforeRun, this.callStackSnapshot());
      return this.runPeek();
    }
  }, {
    key: "runPeek",
    value: function runPeek() {
      var _this4 = this;
      var isResume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.opts.prepareContext(this.peek(), this.getFrameStatus(this.peek(), isResume)).then(function () {
        var item = _this4.peek();

        // ** HERE is where macro starts to run
        return _this4.opts.run(item, _this4.getFrameStatus(item, isResume)).then(function () {
          var snapshot = _this4.callStackSnapshot();
          var latestFrameId = _this4.opts.getLatestFrameIdFromSnapshot(snapshot);

          // FIXME: There is a kind of design error here. This callback after runPeek could be run twice
          // for a single macro.
          //
          // For exmaple, Run A => A calls B => B returns to A => A continues
          // 1) Run A: runPeek is called for A for first time
          // 2) A calls B: runPeek is called for B for first time
          // 3) B returns to A: The call to runPeek below is run, so runPeek is called for A for second time
          //
          // As a temporary fix, I have to check if snapshot's last element is the same as the one being run
          if (latestFrameId !== item.id) {
            return;
          }
          _this4.registry.fire(_types.CallStackEvent.AfterReturn, snapshot);
          _this4.pop();
          if (_this4.isEmpty()) {
            return;
          }
          _this4.updatePeekAfterResume();
          _this4.registry.fire(_types.CallStackEvent.BeforeResume, _this4.callStackSnapshot());
          return _this4.runPeek(true);
        });
      });
    }
  }, {
    key: "updatePeek",
    value: function updatePeek(updater) {
      this.guardNotEmpty();
      var index = this.getCount() - 1;
      this.list[index] = updater(this.list[index]);
    }
  }, {
    key: "getFrameStatus",
    value: function getFrameStatus(element, isResume) {
      return {
        isResume: isResume,
        isBottom: this.getCount() === 1,
        frameId: element.id
      };
    }
  }, {
    key: "updatePeekAfterResume",
    value: function updatePeekAfterResume() {
      this.updatePeek(function (element) {
        return element;
      });
    }
  }, {
    key: "callStackSnapshot",
    value: function callStackSnapshot() {
      return this.list.map(function (item) {
        return item.resource;
      });
    }
  }]);
  return CallStack;
}(_stack.Stack);
var MacroCallStack = exports.MacroCallStack = /*#__PURE__*/function (_CallStack) {
  _inherits(MacroCallStack, _CallStack);
  function MacroCallStack() {
    _classCallCheck(this, MacroCallStack);
    return _callSuper(this, MacroCallStack, arguments);
  }
  _createClass(MacroCallStack, [{
    key: "isAtBottom",
    value: function isAtBottom() {
      return this.getCount() === 1;
    }
  }, {
    key: "callStackSnapshot",
    value: function callStackSnapshot() {
      return this.list.map(function (item) {
        return {
          id: item.resource.id,
          name: item.resource.name,
          frameId: item.id
        };
      });
    }
  }, {
    key: "updatePeekAfterResume",
    value: function updatePeekAfterResume() {
      this.updatePeek(function (element) {
        var curIndex = element.runningStatus.nextIndex;
        var nextIndex = curIndex + 1;
        var commandResults = _toConsumableArray(element.runningStatus.commandResults);
        commandResults[curIndex] = _macro.CommandRunningStatus.Success;
        return {
          id: element.id,
          resource: element.resource,
          runningStatus: {
            nextIndex: nextIndex,
            commandResults: commandResults,
            status: _macro.MacroStatus.Running,
            playerState: _objectSpread(_objectSpread({}, element.runningStatus.playerState), {}, {
              nextIndex: nextIndex,
              doneIndices: [].concat(_toConsumableArray(element.runningStatus.playerState.doneIndices), [curIndex])
            }),
            interpreterState: element.runningStatus.interpreterState
          }
        };
      });
    }
  }]);
  return MacroCallStack;
}(CallStack);
var getMacroCallStack = exports.getMacroCallStack = (0, _ts_utils.singletonGetter)(function (callStackOptions) {
  if (!callStackOptions) {
    throw new Error('macro call stack options is required');
  }
  return new MacroCallStack(callStackOptions);
});
function createMacroCallStack(options) {
  return getMacroCallStack({
    getInitialRunningStatus: function getInitialRunningStatus(macro) {
      return {
        nextIndex: 0,
        status: _macro.MacroStatus.Running,
        commandResults: [],
        playerState: {},
        interpreterState: {}
      };
    },
    getLatestFrameIdFromSnapshot: function getLatestFrameIdFromSnapshot(snapshot) {
      var last = snapshot[snapshot.length - 1];
      return last ? last.frameId : null;
    },
    updateRunningStatusForCaller: function updateRunningStatusForCaller(runningStatus, macro) {
      return options.getCurrentMacroRunningStatus();
    },
    prepareContext: function prepareContext(resourceAndStatus, frameStatus) {
      var macro = resourceAndStatus.resource;
      var status = resourceAndStatus.runningStatus;
      return (0, _ts_utils.withPromise)(function () {
        return options.updateSelectedMacro(macro, status, frameStatus);
      }).then(function () {
        return (0, _ts_utils.withPromise)(function () {
          return options.restorePlayerState(macro, status, frameStatus);
        });
      });
    },
    // ** This is where the macro starts to run
    run: function run(resourceAndStatus, frameStatus) {
      // Steps
      // * Update selected macro
      // * Restore commandResults
      // * Restore tcPlayer state
      // * Start to play
      // Filter out empty commands
      var opt = resourceAndStatus.runningStatus.playerState;
      var opts = _objectSpread(_objectSpread({}, opt), {}, {
        resources: (opt.resources || []).filter(function (res) {
          return res.cmd && res.cmd.length > 0;
        })
      });
      resourceAndStatus.runningStatus.playerState = opts;
      var macro = resourceAndStatus.resource;
      var status = resourceAndStatus.runningStatus;
      return (0, _ts_utils.withPromise)(function () {
        return options.playMacro(macro, status, frameStatus);
      });
    }
  });
}

/***/ }),

/***/ 47447:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StackError = exports.Stack = void 0;
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var StackError = exports.StackError = /*#__PURE__*/function (_Error) {
  _inherits(StackError, _Error);
  function StackError() {
    _classCallCheck(this, StackError);
    return _callSuper(this, StackError, arguments);
  }
  return _createClass(StackError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var Stack = exports.Stack = /*#__PURE__*/function () {
  function Stack(list) {
    _classCallCheck(this, Stack);
    _defineProperty(this, "list", []);
    if (list && list.length) {
      this.list = list;
    }
  }
  _createClass(Stack, [{
    key: "clear",
    value: function clear() {
      this.list = [];
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return _toConsumableArray(this.list);
    }
  }, {
    key: "getCount",
    value: function getCount() {
      return this.list.length;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.getCount() === 0;
    }
  }, {
    key: "contains",
    value: function contains(item) {
      return !!this.list.find(function (el) {
        return el === item;
      });
    }
  }, {
    key: "push",
    value: function push(item) {
      this.list.push(item);
    }
  }, {
    key: "peek",
    value: function peek() {
      this.guardNotEmpty();
      return this.list[this.getCount() - 1];
    }
  }, {
    key: "bottom",
    value: function bottom() {
      this.guardNotEmpty();
      return this.list[0];
    }
  }, {
    key: "pop",
    value: function pop() {
      this.guardNotEmpty();
      return this.list.pop();
    }
  }, {
    key: "guardNotEmpty",
    value: function guardNotEmpty() {
      if (this.isEmpty()) {
        throw new StackError('empty stack');
      }
    }
  }]);
  return Stack;
}();

/***/ }),

/***/ 95022:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CallStackEvent = void 0;
var CallStackEvent = exports.CallStackEvent = /*#__PURE__*/function (CallStackEvent) {
  CallStackEvent["BeforeRun"] = "before_run";
  CallStackEvent["BeforeResume"] = "before_resume";
  CallStackEvent["AfterReturn"] = "after_return";
  return CallStackEvent;
}({});

/***/ }),

/***/ 9599:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MacroStatus = exports.CommandRunningStatus = void 0;
exports.getCommandResults = getCommandResults;
exports.getDoneErrorIndices = getDoneErrorIndices;
var CommandRunningStatus = exports.CommandRunningStatus = /*#__PURE__*/function (CommandRunningStatus) {
  CommandRunningStatus[CommandRunningStatus["Pending"] = 0] = "Pending";
  CommandRunningStatus[CommandRunningStatus["Success"] = 1] = "Success";
  CommandRunningStatus[CommandRunningStatus["Failure"] = 2] = "Failure";
  CommandRunningStatus[CommandRunningStatus["Warning"] = 3] = "Warning";
  return CommandRunningStatus;
}({});
var MacroStatus = exports.MacroStatus = /*#__PURE__*/function (MacroStatus) {
  MacroStatus[MacroStatus["Idle"] = 0] = "Idle";
  MacroStatus[MacroStatus["Running"] = 1] = "Running";
  MacroStatus[MacroStatus["Calling"] = 2] = "Calling";
  MacroStatus[MacroStatus["Finished"] = 3] = "Finished";
  MacroStatus[MacroStatus["Error"] = 4] = "Error";
  return MacroStatus;
}({});
function getCommandResults(data) {
  var doneIndices = data.doneIndices,
    errorIndices = data.errorIndices,
    warningIndices = data.warningIndices,
    count = data.count;
  var result = [];
  for (var i = 0; i < count; i++) {
    if (doneIndices.indexOf(i) !== -1) {
      result.push(CommandRunningStatus.Success);
    } else if (errorIndices.indexOf(i) !== -1) {
      result.push(CommandRunningStatus.Failure);
    } else if (warningIndices.indexOf(i) !== -1) {
      result.push(CommandRunningStatus.Warning);
    } else {
      result.push(CommandRunningStatus.Pending);
    }
  }
  return result;
}
function getDoneErrorIndices(commandResults) {
  var doneIndices = [];
  var errorIndices = [];
  var warningIndices = [];
  commandResults.forEach(function (r, i) {
    switch (r) {
      case CommandRunningStatus.Failure:
        return errorIndices.push(i);
      case CommandRunningStatus.Warning:
        return warningIndices.push(i);
      case CommandRunningStatus.Success:
        return doneIndices.push(i);
    }
  });
  return {
    doneIndices: doneIndices,
    errorIndices: errorIndices,
    warningIndices: warningIndices,
    count: commandResults.length
  };
}

/***/ }),

/***/ 269:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Countdown = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Countdown = exports.Countdown = /*#__PURE__*/function () {
  function Countdown(callback) {
    _classCallCheck(this, Countdown);
    _defineProperty(this, "startTime", null);
    _defineProperty(this, "timeout", null);
    _defineProperty(this, "timer", null);
    this.callback = callback;
  }
  _createClass(Countdown, [{
    key: "restart",
    value: function restart(newTimeout) {
      var _this = this;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      clearTimeout(this.timer);
      if (force || this.timeout === null || !this.startTime) {
        this.timeout = newTimeout;
        this.startTime = new Date();
        if (newTimeout !== 0) {
          this.timer = setTimeout(function () {
            return _this.runCallback();
          }, this.timeout);
        }
      } else {
        var past = new Date().getTime() - this.startTime.getTime();
        var rest = newTimeout - past;
        this.timeout = newTimeout;
        if (newTimeout !== 0) {
          if (rest < 0) {
            return this.callback();
          } else {
            this.timer = setTimeout(function () {
              return _this.runCallback();
            }, rest);
          }
        }
      }
    }
  }, {
    key: "pause",
    value: function pause() {
      clearTimeout(this.timer);
      if (!this.startTime || !this.timeout) {
        return;
      }
      var past = new Date().getTime() - this.startTime.getTime();
      var rest = this.timeout - past;
      this.timeout = rest;
    }
  }, {
    key: "resume",
    value: function resume() {
      var _this2 = this;
      if (!this.timeout) {
        return;
      }
      this.startTime = new Date();
      this.timer = setTimeout(function () {
        return _this2.runCallback();
      }, this.timeout);
    }
  }, {
    key: "stop",
    value: function stop() {
      clearTimeout(this.timer);
      this.clearState();
    }
  }, {
    key: "output",
    value: function output() {
      // return nothing
    }
  }, {
    key: "clearState",
    value: function clearState() {
      this.timer = null;
      this.timeout = null;
      this.startTime = null;
    }
  }, {
    key: "runCallback",
    value: function runCallback() {
      try {
        this.callback();
      } catch (e) {
        console.error(e);
      } finally {
        this.clearState();
      }
    }
  }]);
  return Countdown;
}();

/***/ }),

/***/ 78799:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getMacroMonitor = exports.MacroParamsProviderType = exports.MacroMonitor = void 0;
var _types = __webpack_require__(6351);
var _monitor = __webpack_require__(18436);
var _timer = __webpack_require__(23183);
var _countdown = __webpack_require__(269);
var _ts_utils = __webpack_require__(1601);
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var MacroParamsProviderType = exports.MacroParamsProviderType = /*#__PURE__*/function (MacroParamsProviderType) {
  MacroParamsProviderType[MacroParamsProviderType["Constructor"] = 0] = "Constructor";
  MacroParamsProviderType[MacroParamsProviderType["Restart"] = 1] = "Restart";
  return MacroParamsProviderType;
}({});
var MacroMonitor = exports.MacroMonitor = /*#__PURE__*/function (_Monitor) {
  _inherits(MacroMonitor, _Monitor);
  function MacroMonitor(paramsProvider) {
    _classCallCheck(this, MacroMonitor);
    return _callSuper(this, MacroMonitor, [_defineProperty(_defineProperty(_defineProperty({}, _types.MacroInspector.Timer, function (id) {
      return new _timer.Timer();
    }), _types.MacroInspector.LoopTimer, function (id) {
      return new _timer.Timer();
    }), _types.MacroInspector.Countdown, function (id) {
      var args = paramsProvider(MacroParamsProviderType.Constructor, _types.MacroInspector.Countdown, id, false);
      var callback = args[0];
      return new _countdown.Countdown(callback);
    }), function (name, id, notBatch) {
      return paramsProvider(MacroParamsProviderType.Restart, name, id, notBatch);
    }]);
  }
  return _createClass(MacroMonitor);
}(_monitor.Monitor);
var getMacroMonitor = exports.getMacroMonitor = (0, _ts_utils.singletonGetter)(function (paramsProvider) {
  return new MacroMonitor(paramsProvider);
});

/***/ }),

/***/ 18436:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Monitor = void 0;
var _ts_utils = __webpack_require__(1601);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Monitor = exports.Monitor = /*#__PURE__*/function () {
  function Monitor(inspectorConstructors, paramsProvider) {
    _classCallCheck(this, Monitor);
    _defineProperty(this, "inspectorConstructors", {});
    _defineProperty(this, "targets", {});
    this.paramsProvider = paramsProvider;
    this.inspectorConstructors = inspectorConstructors;
  }
  _createClass(Monitor, [{
    key: "addTarget",
    value: function addTarget(id) {
      var _this = this;
      var autoStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.targets[id] = (0, _ts_utils.objMap)(function (factory, key) {
        var inspector = factory(id);
        if (autoStart) {
          inspector.restart.apply(inspector, _toConsumableArray(_this.paramsProvider(key)));
        }
        return inspector;
      }, this.inspectorConstructors);
    }
  }, {
    key: "removeTarget",
    value: function removeTarget(id) {
      if (!this.targets[id]) {
        return;
      }
      (0, _ts_utils.objMap)(function (inspector) {
        inspector.stop();
      }, this.targets[id]);
      delete this.targets[id];
    }
  }, {
    key: "clear",
    value: function clear() {
      var _this2 = this;
      Object.keys(this.targets).map(function (id) {
        _this2.removeTarget(id);
      });
    }
  }, {
    key: "restart",
    value: function restart() {
      var _this3 = this;
      this.traverseAllInspectors(function (inspector, key, id) {
        inspector.restart.apply(inspector, _toConsumableArray(_this3.paramsProvider(key, id)));
      });
    }
  }, {
    key: "pause",
    value: function pause() {
      this.traverseAllInspectors(function (inspector) {
        inspector.pause();
      });
    }
  }, {
    key: "resume",
    value: function resume() {
      this.traverseAllInspectors(function (inspector) {
        inspector.resume();
      });
    }
  }, {
    key: "stop",
    value: function stop() {
      this.traverseAllInspectors(function (inspector) {
        inspector.stop();
      });
    }
  }, {
    key: "restartInspector",
    value: function restartInspector(id, inspectorName) {
      var _this$getInspector;
      (_this$getInspector = this.getInspector(id, inspectorName)).restart.apply(_this$getInspector, _toConsumableArray(this.paramsProvider(inspectorName, id, true)));
    }
  }, {
    key: "pauseInspector",
    value: function pauseInspector(id, inspectorName) {
      this.getInspector(id, inspectorName).pause();
    }
  }, {
    key: "resumeInspector",
    value: function resumeInspector(id, inspectorName) {
      this.getInspector(id, inspectorName).resume();
    }
  }, {
    key: "stopInspector",
    value: function stopInspector(id, inspectorName) {
      this.getInspector(id, inspectorName).stop();
    }
  }, {
    key: "getDataFromInspector",
    value: function getDataFromInspector(id, inspectorName) {
      return this.getInspector(id, inspectorName).output();
    }
  }, {
    key: "traverseAllInspectors",
    value: function traverseAllInspectors(fn) {
      (0, _ts_utils.objMap)(function (inspectors, id) {
        (0, _ts_utils.objMap)(function (inspector, key) {
          try {
            fn(inspector, key, id);
          } catch (e) {
            console.error(e);
          }
        }, inspectors);
      }, this.targets);
    }
  }, {
    key: "getInspector",
    value: function getInspector(id, inspectorName) {
      var inspectors = this.targets[id];
      if (!inspectors) {
        throw new Error("Can't find monitor target with id '".concat(id, "'"));
      }
      var inspector = inspectors[inspectorName];
      if (!inspector) {
        throw new Error("Can't find inspector with name '".concat(inspectorName, "' for target id '").concat(id, "'"));
      }
      return inspector;
    }
  }]);
  return Monitor;
}();

/***/ }),

/***/ 23183:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Timer = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Timer = exports.Timer = /*#__PURE__*/function () {
  function Timer() {
    _classCallCheck(this, Timer);
    this.startTime = new Date();
    this.acc = 0;
  }
  _createClass(Timer, [{
    key: "restart",
    value: function restart() {
      this.startTime = new Date();
      this.acc = 0;
    }
  }, {
    key: "pause",
    value: function pause() {
      var now = new Date();
      this.acc += now.getTime() - this.startTime.getTime();
    }
  }, {
    key: "resume",
    value: function resume() {
      this.startTime = new Date();
    }
  }, {
    key: "stop",
    value: function stop() {
      // do nothing
    }
  }, {
    key: "output",
    value: function output() {
      return this.elapsed();
    }
  }, {
    key: "elapsed",
    value: function elapsed() {
      return this.acc + (new Date().getTime() - this.startTime.getTime());
    }
  }, {
    key: "elapsedInSeconds",
    value: function elapsedInSeconds() {
      var diff = this.elapsed();
      return (diff / 1000).toFixed(2) + 's';
    }
  }]);
  return Timer;
}();

/***/ }),

/***/ 6351:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MacroInspector = void 0;
var MacroInspector = exports.MacroInspector = /*#__PURE__*/function (MacroInspector) {
  MacroInspector["Timer"] = "timer";
  MacroInspector["LoopTimer"] = "loop_timer";
  MacroInspector["Countdown"] = "countdown";
  return MacroInspector;
}({});

/***/ }),

/***/ 51557:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BaseProxyManager = void 0;
var _registry = __webpack_require__(50149);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var BaseProxyManager = exports.BaseProxyManager = /*#__PURE__*/function () {
  function BaseProxyManager() {
    _classCallCheck(this, BaseProxyManager);
    _defineProperty(this, "proxy", null);
    _defineProperty(this, "registry", (0, _registry.createListenerRegistry)());
  }
  _createClass(BaseProxyManager, [{
    key: "getProxy",
    value: function getProxy() {
      return Promise.resolve(this.proxy);
    }
  }, {
    key: "getAuth",
    value: function getAuth(host, port) {
      if (!this.proxy || !this.proxy.username) {
        return null;
      }

      // port could be number, so must convert it to string before compare
      if (this.proxy.host === host && this.proxy.port === '' + port) {
        return {
          username: this.proxy.username,
          password: this.proxy.password
        };
      }
      return null;
    }
  }, {
    key: "onChange",
    value: function onChange(listener) {
      var _this = this;
      this.registry.add('change', listener);
      return function () {
        _this.registry.remove('change', listener);
      };
    }
  }]);
  return BaseProxyManager;
}();

/***/ }),

/***/ 6825:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ProxyHttpAuth = void 0;
var _web_extension = _interopRequireDefault(__webpack_require__(41953));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var ProxyHttpAuth = exports.ProxyHttpAuth = /*#__PURE__*/function () {
  function ProxyHttpAuth(params) {
    _classCallCheck(this, ProxyHttpAuth);
    _defineProperty(this, "unbindListener", function () {});
    _defineProperty(this, "bound", false);
    this.getAuth = params.getAuth;
  }
  _createClass(ProxyHttpAuth, [{
    key: "bind",
    value: function bind() {
      if (this.bound) {
        return;
      }
      this.bound = true;
      var listener = this.onAuthRequired.bind(this);
      _web_extension["default"].webRequest.onAuthRequired.addListener(listener, {
        urls: ['<all_urls>']
      }, ['blocking']);
      this.unbindListener = function () {
        return _web_extension["default"].webRequest.onAuthRequired.removeListener(listener);
      };
    }
  }, {
    key: "unbind",
    value: function unbind() {
      if (!this.bound) {
        return;
      }
      this.unbindListener();
      this.bound = false;
    }
  }, {
    key: "onAuthRequired",
    value: function onAuthRequired(details) {
      if (!details.isProxy) {
        return {};
      }
      var auth = this.getAuth(details.challenger.host, '' + details.challenger.port);
      return auth ? {
        authCredentials: auth
      } : {};
    }
  }]);
  return ProxyHttpAuth;
}();

/***/ }),

/***/ 44790:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getProxyManager = getProxyManager;
exports.parseProxyUrl = parseProxyUrl;
exports.setProxy = setProxy;
var _types = __webpack_require__(78847);
var _listener_api_proxy = __webpack_require__(56584);
var _settings_api_proxy = __webpack_require__(75277);
var _pac_api_proxy = __webpack_require__(12050);
var _http_auth = __webpack_require__(6825);
var _messages = _interopRequireDefault(__webpack_require__(6866));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var allAvailableProxyManagers = [new _listener_api_proxy.ProxyManagerViaListenerAPI(), new _pac_api_proxy.ProxyManagerViaPacAPI(), new _settings_api_proxy.ProxyManagerViaSettingsAPI()];
var proxyHttpAuth = new _http_auth.ProxyHttpAuth({
  getAuth: function getAuth(host, port) {
    return getProxyManager().getAuth(host, port);
  }
});
function getProxyManager() {
  for (var i = 0, len = allAvailableProxyManagers.length; i < len; i++) {
    if (allAvailableProxyManagers[i].isSupported()) {
      return allAvailableProxyManagers[i];
    }
  }
  throw new Error('Unable to use proxy');
}
function setProxy(proxy) {
  return new Promise(function (resolve, reject) {
    var proxyManager = getProxyManager();

    // Default to not incognito mode
    proxyManager.isControllable(false).then(function (controllable) {
      if (!controllable) {
        throw new Error(_messages["default"].proxy.notControllable);
      }
      proxyHttpAuth.bind();
      if (!proxy) {
        return proxyManager.reset();
      }
      return proxyManager.setProxy(proxy);
    }).then(resolve, reject);
  });
}
function parseProxyUrl(proxyUrl, usernameAndPassword) {
  var url = new URL(proxyUrl);
  // URL has problem parsing non-standard url like socks4://0.0.0.0
  // hostname will be empty string, so we have to replace protocol with http
  var httpUrl = new URL(proxyUrl.replace(/\s*socks[45]/i, 'http'));
  var host = httpUrl.hostname;
  var type = function () {
    switch (url.protocol) {
      case 'http:':
        return _types.ProxyScheme.Http;
      case 'https:':
        return _types.ProxyScheme.Https;
      case 'socks4:':
        return _types.ProxyScheme.Socks4;
      case 'socks5:':
        return _types.ProxyScheme.Socks5;
      default:
        throw new Error('Invalid proxy protocol');
    }
  }();
  var port = function () {
    if (httpUrl.port) {
      return httpUrl.port;
    }
    switch (type) {
      case _types.ProxyScheme.Http:
        return '80';
      case _types.ProxyScheme.Https:
        return '443';
      case _types.ProxyScheme.Socks4:
      case _types.ProxyScheme.Socks5:
        return '1080';
    }
  }();
  if (!host || !host.length) {
    throw new Error('No host found in proxy');
  }
  if (!port || isNaN(parseInt(port, 10))) {
    throw new Error('No valid port found in proxy');
  }
  var _ref = function () {
      if (!usernameAndPassword || !usernameAndPassword.length) {
        return {};
      }
      var index = usernameAndPassword.indexOf(',');
      if (index === -1) {
        return {
          username: usernameAndPassword
        };
      }
      return {
        username: usernameAndPassword.substr(0, index),
        password: usernameAndPassword.substr(index + 1)
      };
    }(),
    username = _ref.username,
    password = _ref.password;
  return {
    type: type,
    host: host,
    port: port,
    username: username,
    password: password
  };
}

/***/ }),

/***/ 56584:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ProxyManagerViaListenerAPI = void 0;
exports.convertToFirefoxProxyInfo = convertToFirefoxProxyInfo;
var _types = __webpack_require__(78847);
var _base = __webpack_require__(51557);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function convertToFirefoxProxyInfo(proxy) {
  return _objectSpread(_objectSpread({}, proxy), {}, {
    type: proxy.type === _types.ProxyScheme.Socks5 ? _types.FirefoxProxyType.Socks5 : proxy.type
  });
}
var ProxyManagerViaListenerAPI = exports.ProxyManagerViaListenerAPI = /*#__PURE__*/function (_BaseProxyManager) {
  _inherits(ProxyManagerViaListenerAPI, _BaseProxyManager);
  function ProxyManagerViaListenerAPI() {
    var _this;
    _classCallCheck(this, ProxyManagerViaListenerAPI);
    _this = _callSuper(this, ProxyManagerViaListenerAPI);
    _defineProperty(_assertThisInitialized(_this), "unbind", function () {});
    _defineProperty(_assertThisInitialized(_this), "isBound", false);
    return _this;
  }
  _createClass(ProxyManagerViaListenerAPI, [{
    key: "isSupported",
    value: function isSupported() {
      return typeof browser !== 'undefined' && browser.proxy && browser.proxy.onRequest;
    }
  }, {
    key: "isControllable",
    value: function isControllable(incognito) {
      return Promise.resolve(true);
    }
  }, {
    key: "setProxy",
    value: function setProxy(proxy) {
      this.bind();
      this.proxy = proxy;
      this.notifyProxyChange();
      return Promise.resolve();
    }
  }, {
    key: "reset",
    value: function reset() {
      this.proxy = null;
      this.notifyProxyChange();
      return Promise.resolve();
    }
  }, {
    key: "notifyProxyChange",
    value: function notifyProxyChange() {
      var _this2 = this;
      setTimeout(function () {
        _this2.registry.fire('change', _this2.proxy);
      }, 10);
    }
  }, {
    key: "bind",
    value: function bind() {
      if (this.isBound) {
        return;
      }
      this.isBound = true;
      var listener = this.onProxyRequest.bind(this);
      browser.proxy.onRequest.addListener(listener, {
        urls: ['<all_urls>']
      });
      this.unbind = function () {
        return browser.proxy.onRequest.removeListener(listener);
      };
    }
  }, {
    key: "onProxyRequest",
    value: function onProxyRequest(requestInfo) {
      return this.proxy ? convertToFirefoxProxyInfo(this.proxy) : {
        type: _types.FirefoxProxyType.Direct
      };
    }
  }]);
  return ProxyManagerViaListenerAPI;
}(_base.BaseProxyManager);

/***/ }),

/***/ 12050:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ProxyManagerViaPacAPI = void 0;
var _base = __webpack_require__(51557);
var _listener_api_proxy = __webpack_require__(56584);
var _ipc_cs = _interopRequireDefault(__webpack_require__(96571));
var _log = _interopRequireDefault(__webpack_require__(89130));
var _ts_utils = __webpack_require__(1601);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var ProxyManagerViaPacAPI = exports.ProxyManagerViaPacAPI = /*#__PURE__*/function (_BaseProxyManager) {
  _inherits(ProxyManagerViaPacAPI, _BaseProxyManager);
  function ProxyManagerViaPacAPI() {
    var _this;
    _classCallCheck(this, ProxyManagerViaPacAPI);
    _this = _callSuper(this, ProxyManagerViaPacAPI);
    _defineProperty(_assertThisInitialized(_this), "unbind", function () {});
    _defineProperty(_assertThisInitialized(_this), "isBound", false);
    return _this;
  }
  _createClass(ProxyManagerViaPacAPI, [{
    key: "isSupported",
    value: function isSupported() {
      return typeof browser !== 'undefined' && browser.proxy && browser.proxy.register;
    }
  }, {
    key: "isControllable",
    value: function isControllable() {
      return Promise.resolve(true);
    }
  }, {
    key: "setProxy",
    value: function setProxy(proxy) {
      this.bind();
      this.proxy = proxy;
      this.notifyProxyChange();

      // Not sure if 1s delay could be omitted. Just keep it here in case legacy pac api
      // takes time before proxy takes effect
      return browser.runtime.sendMessage({
        cmd: 'SET_PROXY',
        data: proxy ? (0, _listener_api_proxy.convertToFirefoxProxyInfo)(proxy) : null
      }, {
        toProxyScript: true
      }).then(function () {
        return (0, _ts_utils.delay)(function () {}, 1000);
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this.proxy = null;
      this.notifyProxyChange();
      return _ipc_cs["default"].ask('PANEL_SET_PROXY_FOR_PAC', {
        proxy: null
      }).then(function () {
        return (0, _ts_utils.delay)(function () {}, 1000);
      });
    }
  }, {
    key: "getAuth",
    value: function getAuth(host, port) {
      if (!this.proxy || !this.proxy.username) {
        return null;
      }
      if (this.proxy.host === host && this.proxy.port === port) {
        return {
          username: this.proxy.username,
          password: this.proxy.password
        };
      }
      return null;
    }
  }, {
    key: "notifyProxyChange",
    value: function notifyProxyChange() {
      var _this2 = this;
      setTimeout(function () {
        _this2.registry.fire('change', _this2.proxy);
      }, 10);
    }
  }, {
    key: "bind",
    value: function bind() {
      if (this.isBound) {
        return;
      }
      this.isBound = true;
      var pacListener = function pacListener(data) {
        if (data.type === 'PROXY_LOG') {
          (0, _log["default"])('PROXY_LOG', data);
        }
      };
      browser.proxy.register('firefox_pac.js');
      browser.runtime.onMessage.addListener(pacListener);
      this.unbind = function () {
        browser.proxy.unregister();
        browser.runtime.onMessage.removeListener(pacListener);
      };
    }
  }]);
  return ProxyManagerViaPacAPI;
}(_base.BaseProxyManager);

/***/ }),

/***/ 75277:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ProxyManagerViaSettingsAPI = void 0;
var _base = __webpack_require__(51557);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var ProxyManagerViaSettingsAPI = exports.ProxyManagerViaSettingsAPI = /*#__PURE__*/function (_BaseProxyManager) {
  _inherits(ProxyManagerViaSettingsAPI, _BaseProxyManager);
  function ProxyManagerViaSettingsAPI() {
    var _this;
    _classCallCheck(this, ProxyManagerViaSettingsAPI);
    _this = _callSuper(this, ProxyManagerViaSettingsAPI);
    _defineProperty(_assertThisInitialized(_this), "isBound", false);
    return _this;
  }
  _createClass(ProxyManagerViaSettingsAPI, [{
    key: "isSupported",
    value: function isSupported() {
      return typeof chrome !== 'undefined' && chrome.proxy && chrome.proxy.settings && chrome.proxy.settings.onChange;
    }
  }, {
    key: "isControllable",
    value: function isControllable(incognito) {
      return new Promise(function (resolve, reject) {
        chrome.proxy.settings.get({
          incognito: !!incognito
        }, function (details) {
          if (chrome.runtime.lastError) {
            return reject(chrome.runtime.lastError);
          }
          var levelOfControl = details.levelOfControl;
          var inControl = ['controllable_by_this_extension', 'controlled_by_this_extension'].indexOf(levelOfControl) !== -1;
          resolve(inControl);
        });
      });
    }
  }, {
    key: "setProxy",
    value: function setProxy(proxy) {
      this.bindProxyChange();
      this.proxy = proxy;
      return new Promise(function (resolve, reject) {
        chrome.proxy.settings.set({
          value: {
            mode: 'fixed_servers',
            rules: {
              singleProxy: {
                scheme: proxy.type,
                host: proxy.host,
                port: parseInt(proxy.port, 10)
              }
            }
          }
        }, function () {
          if (chrome.runtime.lastError) {
            return reject(chrome.runtime.lastError);
          }
          resolve();
        });
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      return new Promise(function (resolve, reject) {
        chrome.proxy.settings.set({
          value: {
            mode: 'direct'
          }
        }, function () {
          if (chrome.runtime.lastError) {
            return reject(chrome.runtime.lastError);
          }
          resolve();
        });
      });
    }
  }, {
    key: "bindProxyChange",
    value: function bindProxyChange() {
      var _this2 = this;
      if (this.isBound) {
        return;
      }
      this.isBound = true;
      chrome.proxy.settings.onChange.addListener(function (details) {
        var proxyData = _this2.fromChromeDetails(details);

        // Proxy data returned by fromChromeDetails doesn't contain username/password
        // so must avoid it overwrites the one with auth info
        _this2.setLocalProxyIfIsNew(proxyData);
        _this2.registry.fire('change', proxyData);
      });
    }
  }, {
    key: "fetchProxyFromSettings",
    value: function fetchProxyFromSettings() {
      var _this3 = this;
      return new Promise(function (resolve, reject) {
        chrome.proxy.settings.get({
          incognito: false
        }, function (details) {
          if (chrome.runtime.lastError) {
            return reject(chrome.runtime.lastError);
          }
          var proxyData = _this3.fromChromeDetails(details);
          _this3.setLocalProxyIfIsNew(proxyData);
          _this3.registry.fire('change', proxyData);
          resolve();
        });
      });
    }
  }, {
    key: "fromChromeDetails",
    value: function fromChromeDetails(details) {
      if (details.value.mode !== 'fixed_servers' || !details.value.rules || !details.value.rules.singleProxy) {
        return null;
      }
      var singleProxy = details.value.rules.singleProxy;
      return {
        host: singleProxy.host,
        port: '' + singleProxy.port,
        type: singleProxy.scheme
      };
    }
  }, {
    key: "setLocalProxyIfIsNew",
    value: function setLocalProxyIfIsNew(proxyData) {
      var _this$proxy, _this$proxy2;
      if ((proxyData === null || proxyData === void 0 ? void 0 : proxyData.host) !== ((_this$proxy = this.proxy) === null || _this$proxy === void 0 ? void 0 : _this$proxy.host) || (proxyData === null || proxyData === void 0 ? void 0 : proxyData.port) !== ((_this$proxy2 = this.proxy) === null || _this$proxy2 === void 0 ? void 0 : _this$proxy2.port)) {
        this.proxy = proxyData;
      }
    }
  }]);
  return ProxyManagerViaSettingsAPI;
}(_base.BaseProxyManager);

/***/ }),

/***/ 78847:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ProxyScheme = exports.FirefoxProxyType = void 0;
var ProxyScheme = exports.ProxyScheme = /*#__PURE__*/function (ProxyScheme) {
  ProxyScheme["Http"] = "http";
  ProxyScheme["Https"] = "https";
  ProxyScheme["Socks4"] = "socks4";
  ProxyScheme["Socks5"] = "socks5";
  return ProxyScheme;
}({});
var FirefoxProxyType = exports.FirefoxProxyType = /*#__PURE__*/function (FirefoxProxyType) {
  FirefoxProxyType["Direct"] = "direct";
  FirefoxProxyType["Http"] = "http";
  FirefoxProxyType["Https"] = "https";
  FirefoxProxyType["Socks4"] = "socks4";
  FirefoxProxyType["Socks5"] = "socks";
  return FirefoxProxyType;
}({});

/***/ }),

/***/ 64582:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getIndexeddbFlatStorage = exports.IndexeddbFlatStorage = void 0;
var _storage = __webpack_require__(82798);
var _db = _interopRequireDefault(__webpack_require__(61746));
var _utils = __webpack_require__(46580);
var _ts_utils = __webpack_require__(1601);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var IndexeddbFlatStorage = exports.IndexeddbFlatStorage = /*#__PURE__*/function (_FlatStorage) {
  _inherits(IndexeddbFlatStorage, _FlatStorage);
  function IndexeddbFlatStorage(options) {
    var _this;
    _classCallCheck(this, IndexeddbFlatStorage);
    _this = _callSuper(this, IndexeddbFlatStorage);
    _defineProperty(_assertThisInitialized(_this), "displayedCount", 0);
    _defineProperty(_assertThisInitialized(_this), "totalCount", 0);
    var tableName = options.table;
    if (!_db["default"].tables.find(function (t) {
      return t.name === tableName;
    })) {
      throw new Error("Unknown indexeddb table name '".concat(tableName, "'"));
    }
    _this.table = _db["default"].table(options.table);
    return _this;
  }
  _createClass(IndexeddbFlatStorage, [{
    key: "getDisplayCount",
    value: function getDisplayCount() {
      return this.displayedCount;
    }
  }, {
    key: "getTotalCount",
    value: function getTotalCount() {
      return this.totalCount;
    }
  }, {
    key: "__list",
    value: function __list() {
      var _this2 = this;
      // Note: must wrap dexie's "Promise", as it's dexie's own thenable Promise
      return Promise.resolve(this.table.toArray()).then(function (xs) {
        var convert = function convert(x) {
          return {
            dir: '',
            fileName: x.name,
            lastModified: new Date(),
            size: 'unknown'
          };
        };
        _this2.totalCount = xs.length;
        _this2.displayedCount = xs.length;
        return xs.map(convert);
      });
    }
  }, {
    key: "exists",
    value: function exists(fileName) {
      return Promise.resolve(this.table.where('name').equals(fileName).toArray()).then(function (xs) {
        return xs.length > 0;
      });
    }
  }, {
    key: "read",
    value: function read(fileName, type) {
      if (type !== 'Text') {
        throw new Error("ReadFileType '".concat(type, "' is not supported in indexeddb storage"));
      }
      return this.findByName(fileName);
    }
  }, {
    key: "readAll",
    value: function readAll() {
      var readFileType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Text';
      var onErrorFiles = arguments.length > 1 ? arguments[1] : undefined;
      return Promise.resolve(this.table.toArray()).then(function (items) {
        return items.map(function (item) {
          return {
            fileName: item.name,
            content: item
          };
        });
      });
    }
  }, {
    key: "__write",
    value: function __write(fileName, content) {
      var _this3 = this;
      return this.findByName(fileName)["catch"](function () {
        return null;
      }).then(function (item) {
        if (item) {
          var data = _this3.normalize(_objectSpread(_objectSpread({}, item), content));
          delete data.id;
          return _this3.table.update(item.id, data);
        } else {
          var _data = _this3.normalize(_objectSpread({
            id: (0, _utils.uid)()
          }, content));
          return _this3.table.add(_data);
        }
      }).then(function () {});
    }
  }, {
    key: "__overwrite",
    value: function __overwrite(fileName, content) {
      return this.write(fileName, content);
    }
  }, {
    key: "__clear",
    value: function __clear() {
      return Promise.resolve(this.table.clear());
    }
  }, {
    key: "__remove",
    value: function __remove(fileName) {
      var _this4 = this;
      return this.findByName(fileName).then(function (item) {
        return _this4.table["delete"](item.id);
      });
    }
  }, {
    key: "__rename",
    value: function __rename(fileName, newName) {
      var _this5 = this;
      return this.findByName(fileName).then(function (item) {
        return _this5.table.update(item.id, {
          name: newName
        });
      }).then(function () {});
    }
  }, {
    key: "__copy",
    value: function __copy(fileName, newName) {
      var _this6 = this;
      return this.findByName(fileName).then(function (item) {
        delete item.id;
        item.name = newName;
        return _this6.__write(newName, item);
      });
    }
  }, {
    key: "ensureDir",
    value: function ensureDir() {
      return Promise.resolve();
    }
  }, {
    key: "findByName",
    value: function findByName(name) {
      return Promise.resolve(this.table.where('name').equals(name).first()).then(function (item) {
        if (!item) throw new Error("indexeddb storage: Item with name '".concat(name, "' is not found"));
        return item;
      });
    }
  }, {
    key: "normalize",
    value: function normalize(data) {
      return data;
    }
  }, {
    key: "dataToString",
    value: function dataToString(data) {
      return JSON.stringify(data);
    }
  }]);
  return IndexeddbFlatStorage;
}(_storage.FlatStorage);
var getIndexeddbFlatStorage = exports.getIndexeddbFlatStorage = (0, _ts_utils.singletonGetterByKey)(function (opts) {
  return opts.table;
}, function (opts) {
  return new IndexeddbFlatStorage(opts);
});

/***/ }),

/***/ 4124:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getXUserIO = exports.XUserIO = void 0;
var _common = __webpack_require__(97846);
var _xy = __webpack_require__(10029);
var _ts_utils = __webpack_require__(1601);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var XUserIO = exports.XUserIO = /*#__PURE__*/function (_XModule) {
  _inherits(XUserIO, _XModule);
  function XUserIO() {
    _classCallCheck(this, XUserIO);
    return _callSuper(this, XUserIO, arguments);
  }
  _createClass(XUserIO, [{
    key: "getName",
    value: function getName() {
      return _common.XModuleTypes.XUserIO;
    }
  }, {
    key: "getAPI",
    value: function getAPI() {
      return (0, _xy.getNativeXYAPI)();
    }
  }, {
    key: "initConfig",
    value: function initConfig() {
      return this.getConfig();
    }
  }, {
    key: "sanityCheck",
    value: function sanityCheck() {
      var _this = this;
      return Promise.all([this.getConfig(), this.getAPI().getVersion().then(function () {
        return _this.getAPI();
      }, function () {
        return _this.getAPI().reconnect();
      })["catch"](function (e) {
        throw new Error('Error #301: RealUser Simulation XModule is not installed yet');
      })]).then(function () {
        return true;
      });
    }
  }, {
    key: "checkUpdate",
    value: function checkUpdate() {
      return Promise.reject(new Error('checkUpdate is not implemented yet'));
    }
  }, {
    key: "checkUpdateLink",
    value: function checkUpdateLink(modVersion, extVersion) {
      return "https://goto.ui.vision/x/idehelp?help=xclick_updatecheck&xversion=".concat(modVersion, "&kantuversion=").concat(extVersion);
    }
  }, {
    key: "downloadLink",
    value: function downloadLink() {
      return 'https://goto.ui.vision/x/idehelp?help=xclick_download';
    }
  }, {
    key: "infoLink",
    value: function infoLink() {
      return 'https://goto.ui.vision/x/idehelp?help=xclick';
    }
  }]);
  return XUserIO;
}(_common.XModule);
var getXUserIO = exports.getXUserIO = (0, _ts_utils.singletonGetter)(function () {
  return new XUserIO();
});

/***/ }),

/***/ 14683:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getXDesktop = exports.XDesktop = void 0;
var _common = __webpack_require__(97846);
var _desktop = __webpack_require__(14406);
var _ts_utils = __webpack_require__(1601);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var XDesktop = exports.XDesktop = /*#__PURE__*/function (_XModule) {
  _inherits(XDesktop, _XModule);
  function XDesktop() {
    _classCallCheck(this, XDesktop);
    return _callSuper(this, XDesktop, arguments);
  }
  _createClass(XDesktop, [{
    key: "getName",
    value: function getName() {
      return _common.XModuleTypes.XDesktop;
    }
  }, {
    key: "getAPI",
    value: function getAPI() {
      return (0, _desktop.getNativeCVAPI)();
    }
  }, {
    key: "initConfig",
    value: function initConfig() {
      return this.getConfig();
    }
  }, {
    key: "sanityCheck",
    value: function sanityCheck() {
      var _this = this;
      return Promise.all([this.getConfig(), this.getAPI().getVersion().then(function () {
        return _this.getAPI();
      }, function () {
        return _this.getAPI().reconnect();
      })["catch"](function (e) {
        throw new Error('Error #301: Visual Desktop Automation XModule is not installed yet');
      })]).then(function () {
        return true;
      });
    }
  }, {
    key: "checkUpdate",
    value: function checkUpdate() {
      return Promise.reject(new Error('checkUpdate is not implemented yet'));
    }
  }, {
    key: "checkUpdateLink",
    value: function checkUpdateLink(modVersion, extVersion) {
      return "https://goto.ui.vision/x/idehelp?help=xdesktop_updatecheck&xversion=".concat(modVersion, "&kantuversion=").concat(extVersion);
    }
  }, {
    key: "downloadLink",
    value: function downloadLink() {
      return 'https://goto.ui.vision/x/idehelp?help=xdesktop_download';
    }
  }, {
    key: "infoLink",
    value: function infoLink() {
      return 'https://goto.ui.vision/x/idehelp?help=xdesktop';
    }
  }]);
  return XDesktop;
}(_common.XModule);
var getXDesktop = exports.getXDesktop = (0, _ts_utils.singletonGetter)(function () {
  return new XDesktop();
});

/***/ }),

/***/ 95536:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.xLocal = exports.getXLocal = void 0;
var _common = __webpack_require__(97846);
var _filesystem = __webpack_require__(89937);
var _ts_utils = __webpack_require__(1601);
var _path = _interopRequireDefault(__webpack_require__(26513));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var xLocal = exports.xLocal = /*#__PURE__*/function (_XModule) {
  _inherits(xLocal, _XModule);
  function xLocal() {
    _classCallCheck(this, xLocal);
    return _callSuper(this, xLocal, arguments);
  }
  _createClass(xLocal, [{
    key: "getName",
    value: function getName() {
      return _common.XModuleTypes.XLocal;
    }
  }, {
    key: "getAPI",
    value: function getAPI() {
      return (0, _filesystem.getNativeFileSystemAPI)();
    }
  }, {
    key: "getVersionLocal",
    value: function getVersionLocal() {
      var _this = this;
      return this.getConfig().then(function (config) {
        return _this.getAPI().reconnect()["catch"](function (e) {
          throw new Error("".concat(_this.getName(), " is not installed yet"));
        }).then(function (api) {
          return api.getVersion().then(function (version) {
            return {
              version: version,
              installed: true
            };
          });
        })["catch"](function (e) {
          return {
            installed: false
          };
        });
      });
    }
  }, {
    key: "getLangs",
    value: function getLangs() {
      return this.getConfig().then(function (config) {
        var fsAPI = (0, _filesystem.getNativeFileSystemAPI)();
        return fsAPI.getSpecialFolderPath({
          folder: _filesystem.SpecialFolder.UserProfile
        }).then(function (profilePath) {
          var uivision = _path["default"].join(profilePath, "\\AppData\\Roaming\\UI.Vision\\XModules\\ocr");
          return fsAPI.ensureDir({
            path: uivision
          }).then(function (Opath) {
            var path = uivision;
            var filepath = path + '\\ocrexe\\ocrcl1.exe';
            var Arguments = "get-installed-lng" + " " + path + "\\ocrlang.json";
            var ocrOutputJson = path + "\\ocrlang.json";
            var params = {
              fileName: filepath,
              arguments: Arguments,
              waitForExit: true
            };
            return fsAPI.runProcess(params).then(function (res) {
              if (res != undefined && res.exitCode != null && res.exitCode > 0) {
                var _params = {
                  path: ocrOutputJson,
                  waitForExit: true
                };
                return fsAPI.readAllBytes(_params);
              } else {
                return;
              }
            }).then(function (json) {
              if (json) {
                if (json.errorCode == 0) {
                  console.log(json.content);
                  return json.content;
                } else {
                  return false;
                }
              }
            })["catch"](function () {
              return console.log({
                result: false
              });
            });
          });
        })["catch"](function (e) {
          // Ignore host not found error, `initConfig` is supposed to be called on start
          // But we can't guarantee that native fs module is already installed
          if (!/Specified native messaging host not found/.test(e)) {
            throw e;
          }
        });
      });
    }
  }, {
    key: "initConfig",
    value: function initConfig() {
      var _this2 = this;
      return this.getConfig().then(function (config) {
        if (!config.rootDir) {
          var fsAPI = (0, _filesystem.getNativeFileSystemAPI)();
          return fsAPI.getSpecialFolderPath({
            folder: _filesystem.SpecialFolder.UserDesktop
          }).then(function (profilePath) {
            var kantuDir = _path["default"].join(profilePath, 'uivision');
            return fsAPI.ensureDir({
              path: kantuDir
            }).then(function (done) {
              _this2.setConfig({
                rootDir: done ? kantuDir : profilePath
              });
            });
          })["catch"](function (e) {
            // Ignore host not found error, `initConfig` is supposed to be called on start
            // But we can't guarantee that native fs module is already installed
            if (!/Specified native messaging host not found/.test(e)) {
              throw e;
            }
          });
        }
      });
    }
  }, {
    key: "sanityCheck",
    value: function sanityCheck(simple) {
      var _this3 = this;
      return Promise.all([this.getConfig(), this.getAPI().getVersion().then(function () {
        return _this3.getAPI();
      }, function () {
        return _this3.getAPI().reconnect();
      })["catch"](function (e) {
        throw new Error('xFile is not installed yet');
      })]).then(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          config = _ref2[0],
          api = _ref2[1];
        if (simple) {
          return true;
        }
        if (!config.rootDir) {
          throw new Error('rootDir is not set');
        }
        var checkDirectoryExists = function checkDirectoryExists() {
          return api.directoryExists({
            path: config.rootDir
          }).then(function (existed) {
            if (!existed) throw new Error("Directory '".concat(config.rootDir, "' doesn't exist"));
            return true;
          });
        };
        var checkDirectoryWritable = function checkDirectoryWritable() {
          var testDir = _path["default"].join(config.rootDir, '__kantu__' + Math.round(Math.random() * 100));
          return api.createDirectory({
            path: testDir
          }).then(function (created) {
            if (!created) throw new Error();
            return api.removeDirectory({
              path: testDir
            });
          }).then(function (deleted) {
            if (!deleted) throw new Error();
            return true;
          })["catch"](function (e) {
            throw new Error("Directory '".concat(config.rootDir, "' is not writable"));
          });
        };
        return checkDirectoryExists().then(checkDirectoryWritable);
      });
    }
  }, {
    key: "checkUpdate",
    value: function checkUpdate() {
      return Promise.reject(new Error('checkUpdate is not implemented yet'));
    }
  }, {
    key: "checkUpdateLink",
    value: function checkUpdateLink(modVersion, extVersion) {
      return "https://goto.ui.vision/x/idehelp?help=xmodule-ocr_updatecheck&xversion=".concat(modVersion, "&kantuversion=").concat(extVersion);
    }
  }, {
    key: "downloadLink",
    value: function downloadLink() {
      return 'https://goto.ui.vision/x/idehelp?help=xmodule-ocr_download';
    }
  }, {
    key: "infoLink",
    value: function infoLink() {
      return 'https://goto.ui.vision/x/idehelp?help=xmodule-ocr';
    }
  }]);
  return xLocal;
}(_common.XModule);
var getXLocal = exports.getXLocal = (0, _ts_utils.singletonGetter)(function () {
  return new xLocal();
});

/***/ }),

/***/ 65180:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MethodTypeInvocationNames = exports.MethodTypeFriendlyNames = void 0;
var MethodTypeFriendlyNames = exports.MethodTypeFriendlyNames = ["GetVersion", "SendMouseEvent", "SendMouseWheelEvent", "SendText", "GetActiveBrowserOuterRect", "FindRectangle", "GetScreenBackingScaleFactor"];
var MethodTypeInvocationNames = exports.MethodTypeInvocationNames = ["get_version", "send_mouse_event", "send_mouse_wheel_event", "send_text", "get_active_browser_outer_rect", "find_rectangle", "get_screen_backing_scale_factor"];

/***/ }),

/***/ 10029:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getNativeXYAPI = exports.MouseEventType = exports.MouseButton = void 0;
var _constants = __webpack_require__(65180);
var _ts_utils = __webpack_require__(1601);
var _kantuXyHost = __webpack_require__(32853);
var _resize_window = __webpack_require__(55720);
var _log = _interopRequireDefault(__webpack_require__(89130));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var MouseButton = exports.MouseButton = /*#__PURE__*/function (MouseButton) {
  MouseButton[MouseButton["Left"] = 0] = "Left";
  MouseButton[MouseButton["Right"] = 1] = "Right";
  MouseButton[MouseButton["Middle"] = 2] = "Middle";
  return MouseButton;
}({});
var MouseEventType = exports.MouseEventType = /*#__PURE__*/function (MouseEventType) {
  MouseEventType[MouseEventType["Move"] = 0] = "Move";
  MouseEventType[MouseEventType["Down"] = 1] = "Down";
  MouseEventType[MouseEventType["Up"] = 2] = "Up";
  MouseEventType[MouseEventType["Click"] = 3] = "Click";
  MouseEventType[MouseEventType["DoubleClick"] = 4] = "DoubleClick";
  MouseEventType[MouseEventType["CtrlClick"] = 5] = "CtrlClick";
  MouseEventType[MouseEventType["ShiftClick"] = 6] = "ShiftClick";
  MouseEventType[MouseEventType["TripleClick"] = 7] = "TripleClick";
  return MouseEventType;
}({});
var getNativeXYAPI = exports.getNativeXYAPI = (0, _ts_utils.singletonGetter)(function () {
  var nativeHost = new _kantuXyHost.KantuXYHost();
  var pReady = nativeHost.connectAsync()["catch"](function (e) {
    _log["default"].warn('pReady - error', e);
    throw e;
  });
  var api = _constants.MethodTypeInvocationNames.reduce(function (prev, method) {
    var camel = (0, _ts_utils.snakeToCamel)(method);
    prev[camel] = function () {
      var fn = function fn(params) {
        return pReady.then(function () {
          return nativeHost.invokeAsync(method, params)["catch"](function (e) {
            // Note: Looks like for now whenever there is an error, you have to reconnect native host
            // otherwise, all commands return "Disconnected" afterwards
            var typeSafeAPI = api;
            typeSafeAPI.reconnect()["catch"](function () {});
            throw e;
          });
        });
      };
      return fn;
    }();
    return prev;
  }, {
    reconnect: function reconnect() {
      nativeHost.disconnect();
      pReady = nativeHost.connectAsync();
      return pReady.then(function () {
        return api;
      });
    },
    // Note: This factor equals to ScreenMouseCoornidate / CssMouseCoordinate
    getScalingFactor: function getScalingFactor() {
      var typeSafeAPI = api;
      return typeSafeAPI.getScreenBackingScaleFactor().then(function (screenBackingFactor) {
        return window.devicePixelRatio / screenBackingFactor;
      });
    },
    sendViewportMouseEvent: function sendViewportMouseEvent(event, options) {
      var typeSafeAPI = api;
      return Promise.all([options.getViewportRectInScreen(), (0, _resize_window.getFocusedWindowSize)(), typeSafeAPI.getScalingFactor()]).then(function (tuple) {
        var viewportRect = tuple[0];
        var winSize = tuple[1];
        var scalingFactor = tuple[2];
        var offsetX = viewportRect.x;
        var offsetY = viewportRect.y;
        return typeSafeAPI.sendMouseEvent({
          type: event.type,
          button: event.button,
          x: event.x * scalingFactor + offsetX * scalingFactor,
          y: event.y * scalingFactor + offsetY * scalingFactor
        });
      })["catch"](function (e) {
        console.error(e);
        return false;
      });
    }
  });
  return api;
});

/***/ }),

/***/ 32853:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.KantuXYHost = void 0;
var _native_host = __webpack_require__(39356);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var KantuXYHost = exports.KantuXYHost = /*#__PURE__*/function (_NativeMessagingHost) {
  _inherits(KantuXYHost, _NativeMessagingHost);
  function KantuXYHost() {
    _classCallCheck(this, KantuXYHost);
    return _callSuper(this, KantuXYHost, [KantuXYHost.HOST_NAME]);
  }
  return _createClass(KantuXYHost);
}(_native_host.NativeMessagingHost);
_defineProperty(KantuXYHost, "HOST_NAME", "com.a9t9.kantu.xy");

/***/ }),

/***/ 22023:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.types = exports.type3 = exports.make3 = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// Generate three action types, used in actions that return promises
var make3 = exports.make3 = function make3(name) {
  return [name + '_REQUEST', name + '_SUCCESS', name + '_FAIL'];
};
var type3 = exports.type3 = function type3(name) {
  return make3(name).map(function (key) {
    return types[key];
  });
};
var promiseTypes = ['START_RECORDING', 'STOP_RECORDING', 'START_INSPECTING', 'STOP_INSPECTING'].reduce(function (prev, cur) {
  make3(cur).forEach(function (key) {
    prev[key] = key;
  });
  return prev;
}, {});
var simpleTypes = ['SET_ROUTE', 'SET_EDITOR_ACTIVE_TAB', 'DONE_INSPECTING', 'UPDATE_BASE_URL', 'APPEND_COMMAND', 'DUPLICATE_COMMAND', 'INSERT_COMMAND', 'UPDATE_COMMAND', 'REMOVE_COMMAND', 'SELECT_COMMAND', 'CUT_COMMAND', 'COPY_COMMAND', 'PASTE_COMMAND', 'NORMALIZE_COMMANDS', 'UPDATE_SELECTED_COMMAND', 'UPDATE_EDITING', 'SAVE_EDITING_AS_EXISTED', 'SAVE_EDITING_AS_NEW', 'SET_TEST_CASES', 'SET_EDITING', 'EDIT_TEST_CASE', 'EDIT_NEW_TEST_CASE', 'ADD_TEST_CASES', 'RENAME_TEST_CASE', 'REMOVE_TEST_CASE', 'UPDATE_TEST_SUITE_STATUS', 'UPDATE_ONE_MACRO_EXTRA', 'SET_ONE_MACRO_EXTRA', 'SET_MACROS_EXTRA', 'SET_TEST_SUITES_EXTRA', 'SET_PLAYER_STATE', 'SET_PLAYER_MODE', 'SET_TEST_SUITES', 'UPDATE_TEST_SUITE', 'ADD_LOGS', 'CLEAR_LOGS', 'ADD_SCREENSHOT', 'CLEAR_SCREENSHOTS', 'ADD_VISION', 'CLEAR_VISIONS', 'START_PLAYING', 'STOP_PLAYING', 'SET_CSV_LIST', 'SET_SCREENSHOT_LIST', 'SET_VISION_LIST', 'SET_VARIABLE_LIST', 'SET_SOURCE_ERROR', 'SET_SOURCE_CURRENT', 'UPDATE_CONFIG', 'UPDATE_UI', 'UPDATE_PROXY'].reduce(function (prev, cur) {
  prev[cur] = cur;
  return prev;
}, {});
var types = exports.types = _objectSpread(_objectSpread({}, simpleTypes), promiseTypes);

/***/ }),

/***/ 35127:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.addBreakpoint = addBreakpoint;
exports.addLog = addLog;
exports.addPlayerErrorCommandIndex = addPlayerErrorCommandIndex;
exports.addPlayerWarningCommandIndex = addPlayerWarningCommandIndex;
exports.addScreenshot = addScreenshot;
exports.addTestCases = addTestCases;
exports.addTestSuite = addTestSuite;
exports.addTestSuites = addTestSuites;
exports.addVision = addVision;
exports.appendCommand = appendCommand;
exports.clearLogs = clearLogs;
exports.clearScreenshots = clearScreenshots;
exports.clearVisions = clearVisions;
exports.commonPlayerState = commonPlayerState;
exports.copyCommand = copyCommand;
exports.cutCommand = cutCommand;
exports.doneInspecting = doneInspecting;
exports.duplicateCommand = duplicateCommand;
exports.editNewTestCase = editNewTestCase;
exports.editTestCase = editTestCase;
exports.findMacrosInFolder = findMacrosInFolder;
exports.findSameNameMacro = findSameNameMacro;
exports.findSameNameTestSuite = findSameNameTestSuite;
exports.findSamePathMacro = findSamePathMacro;
exports.increaseRecordedCount = increaseRecordedCount;
exports.increment = void 0;
exports.insertCommand = insertCommand;
exports.listCSV = listCSV;
exports.listScreenshots = listScreenshots;
exports.listVisions = listVisions;
exports.normalizeCommands = normalizeCommands;
exports.pasteCommand = pasteCommand;
exports.playerPlay = playerPlay;
exports.preinstall = preinstall;
exports.removeBreakpoint = removeBreakpoint;
exports.removeCommand = removeCommand;
exports.removeCurrentTestCase = removeCurrentTestCase;
exports.removeTestCase = removeTestCase;
exports.removeTestSuite = removeTestSuite;
exports.renameVisionImage = renameVisionImage;
exports.resetEditing = resetEditing;
exports.resetEditingIfNeeded = resetEditingIfNeeded;
exports.runBackup = runBackup;
exports.saveEditingAsExisted = saveEditingAsExisted;
exports.saveEditingAsNew = saveEditingAsNew;
exports.saveSourceCodeToEditing = saveSourceCodeToEditing;
exports.selectCommand = selectCommand;
exports.setEditing = setEditing;
exports.setEditorActiveTab = setEditorActiveTab;
exports.setMacrosExtra = setMacrosExtra;
exports.setPlayerMode = setPlayerMode;
exports.setPlayerState = setPlayerState;
exports.setRoute = setRoute;
exports.setSourceCurrent = setSourceCurrent;
exports.setSourceError = setSourceError;
exports.setTestCases = setTestCases;
exports.setTestSuites = setTestSuites;
exports.setTestSuitesExtra = setTestSuitesExtra;
exports.setTimeoutStatus = setTimeoutStatus;
exports.setVariables = setVariables;
exports.startInspecting = startInspecting;
exports.startPlaying = startPlaying;
exports.startRecording = startRecording;
exports.stopInspecting = stopInspecting;
exports.stopPlaying = stopPlaying;
exports.stopRecording = stopRecording;
exports.toggleComment = toggleComment;
exports.toggleCommentOnSelectedCommand = toggleCommentOnSelectedCommand;
exports.updateCommand = updateCommand;
exports.updateConfig = updateConfig;
exports.updateEditing = updateEditing;
exports.updateMacroBreakpoints = updateMacroBreakpoints;
exports.updateMacroDoneCommandsIndices = updateMacroDoneCommandsIndices;
exports.updateMacroErrorCommandsIndices = updateMacroErrorCommandsIndices;
exports.updateMacroExtra = updateMacroExtra;
exports.updateMacroPlayStatus = updateMacroPlayStatus;
exports.updateMacroWarningCommandsIndices = updateMacroWarningCommandsIndices;
exports.updateProxy = updateProxy;
exports.updateSelectedCommand = updateSelectedCommand;
exports.updateUI = updateUI;
exports.upsertTestCase = upsertTestCase;
var _antd = __webpack_require__(33061);
var _action_types = __webpack_require__(22023);
var _utils = __webpack_require__(46580);
var _ipc_cs = _interopRequireDefault(__webpack_require__(96571));
var _storage = _interopRequireDefault(__webpack_require__(88555));
var _storage2 = __webpack_require__(97467);
var _test_case_model = __webpack_require__(56109);
var _player = __webpack_require__(18392);
var _backup = __webpack_require__(12084);
var _log = _interopRequireDefault(__webpack_require__(89130));
var _convert_utils = __webpack_require__(75852);
var _config = _interopRequireDefault(__webpack_require__(8747));
var _preinstall_macros = _interopRequireDefault(__webpack_require__(51302));
var _macro_extra_data = __webpack_require__(3112);
var _recomputed = __webpack_require__(87307);
var _prompt = __webpack_require__(10409);
var _command = __webpack_require__(85393);
var _call_stack = __webpack_require__(41488);
var _macro = __webpack_require__(9599);
var _save_test_case = _interopRequireDefault(__webpack_require__(64305));
var _path = __webpack_require__(26513);
var _ts_utils = __webpack_require__(1601);
var _macro_log = __webpack_require__(91433);
var _log2 = __webpack_require__(26480);
var _misc_data = __webpack_require__(90429);
var _reducers = __webpack_require__(50341);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /* global PREINSTALL_CSV_LIST PREINSTALL_VISION_LIST */
var recordedCount = 0;
var saveEditing = function saveEditing(_ref) {
  var dispatch = _ref.dispatch,
    getState = _ref.getState;
  var state = getState();
  var _state$editor = state.editor,
    editing = _state$editor.editing,
    isDraggingCommand = _state$editor.isDraggingCommand;
  if (isDraggingCommand) {
    return;
  }
  _storage["default"].set('editing', editing);
};
var saveMacroExtra = function saveMacroExtra(id) {
  return function (_ref2) {
    var dispatch = _ref2.dispatch,
      getState = _ref2.getState;
    var state = getState();
    if (state.editor.isDraggingCommand) {
      return;
    }
    var macroId = id || (0, _recomputed.getCurrentMacroId)(state);
    var updated = state.editor.macrosExtra[macroId] || {};
    return (0, _macro_extra_data.getMacroExtraKeyValueData)().update(macroId, function (data) {
      return _objectSpread(_objectSpread({}, data), updated);
    });
  };
};
var saveWholeMacrosExtra = function saveWholeMacrosExtra(_ref3) {
  var dispatch = _ref3.dispatch,
    getState = _ref3.getState;
  var state = getState();
  var macrosExtra = (0, _recomputed.getMacrosExtra)(state);
  return (0, _macro_extra_data.getMacroExtraKeyValueData)().set('', macrosExtra);
};
var saveConfig = function () {
  var lastSize = {};
  return function (_ref4) {
    var dispatch = _ref4.dispatch,
      getState = _ref4.getState;
    var _getState = getState(),
      config = _getState.config;
    config = config || {};
    var savedSize = config.size ? config.size[config.showSidebar ? 'with_sidebar' : 'standard'] : null;
    var finalSize = savedSize || (config.showSidebar ? {
      width: 860,
      height: 775
    } : {
      width: 520,
      height: 775
    });
    if (finalSize.width !== lastSize.width || finalSize.height !== lastSize.height) {
      _storage["default"].get('config').then(function (oldConfig) {
        if ((oldConfig && oldConfig.showSidebar) === config.showSidebar) return;
        if (finalSize.width !== window.outerWidth || finalSize.height !== window.outerHeight) {
          _ipc_cs["default"].ask('PANEL_RESIZE_WINDOW', {
            size: finalSize
          });
        }
      });
    }
    _storage["default"].set('config', config);
    lastSize = finalSize;
  };
}();
var toLower = function toLower(str) {
  return (str || '').toLowerCase();
};
function findSameNameMacro(name, macros) {
  return macros.find(function (tc) {
    return toLower(tc.name) === toLower(name);
  });
}
function findSamePathMacro(path, macroNodes) {
  var converPath = function converPath(str) {
    return toLower(str).replace(/.json$/, '');
  };
  return macroNodes.find(function (node) {
    return converPath(node.relativePath) === converPath(path);
  });
}
function findMacrosInFolder(folderPath, macroNodes) {
  var lowerFolderPath = toLower(folderPath);
  return macroNodes.filter(function (macroNode) {
    var lowerMacroFullPath = toLower(macroNode.fullPath);
    if (lowerMacroFullPath.indexOf(lowerFolderPath) !== 0) {
      return false;
    }
    var parts = lowerMacroFullPath.substr(lowerFolderPath.length).split(/\/|\\/g);
    if (parts.length !== 2 || parts[0] !== '') {
      return false;
    }
    return true;
  });
}
function findSameNameTestSuite(name, testSuites) {
  return testSuites.find(function (ts) {
    return toLower(ts.name) === toLower(name);
  });
}
function setRoute(data) {
  return {
    type: _action_types.types.SET_ROUTE,
    data: data
  };
}
function startRecording() {
  recordedCount = 0;
  return {
    types: (0, _action_types.type3)('START_RECORDING'),
    promise: function promise() {
      return _ipc_cs["default"].ask('PANEL_START_RECORDING', {}).then(function () {
        return _ipc_cs["default"].ask('PANEL_TRY_TO_RECORD_OPEN_COMMAND');
      });
    }
  };
}
function stopRecording() {
  return {
    types: (0, _action_types.type3)('STOP_RECORDING'),
    promise: function promise() {
      return _ipc_cs["default"].ask('PANEL_STOP_RECORDING', {});
    }
  };
}
function startInspecting() {
  return {
    types: (0, _action_types.type3)('START_INSPECTING'),
    promise: function promise() {
      return _ipc_cs["default"].ask('PANEL_START_INSPECTING', {});
    }
  };
}
function stopInspecting() {
  return {
    types: (0, _action_types.type3)('STOP_INSPECTING'),
    promise: function promise() {
      return _ipc_cs["default"].ask('PANEL_STOP_INSPECTING', {});
    }
  };
}
function startPlaying() {
  return {
    type: _action_types.types.START_PLAYING,
    data: null
  };
}
function stopPlaying() {
  return {
    type: _action_types.types.STOP_PLAYING,
    data: null
  };
}
function doneInspecting() {
  return {
    type: _action_types.types.DONE_INSPECTING,
    data: {}
  };
}
function increaseRecordedCount() {
  recordedCount += 1;
  // Note: show in badge the recorded count
  _ipc_cs["default"].ask('PANEL_UPDATE_BADGE', {
    type: 'record',
    text: '' + recordedCount
  });
}
function appendCommand(cmdObj) {
  var fromRecord = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (fromRecord) {
    increaseRecordedCount();
  }
  return {
    type: _action_types.types.APPEND_COMMAND,
    data: {
      command: (0, _test_case_model.normalizeCommand)(cmdObj)
    },
    post: [saveEditing, saveMacroExtra()]
  };
}
function duplicateCommand(index) {
  return {
    type: _action_types.types.DUPLICATE_COMMAND,
    data: {
      index: index
    },
    post: [saveEditing, saveMacroExtra()]
  };
}
function insertCommand(cmdObj, index) {
  var fromRecord = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (fromRecord) {
    increaseRecordedCount();
  }
  return {
    type: _action_types.types.INSERT_COMMAND,
    data: {
      index: index,
      command: (0, _test_case_model.normalizeCommand)(cmdObj)
    },
    post: [saveEditing, saveMacroExtra()]
  };
}
function updateCommand(cmdObj, index) {
  return {
    type: _action_types.types.UPDATE_COMMAND,
    data: {
      command: (0, _test_case_model.normalizeCommand)(cmdObj),
      index: index
    },
    post: saveEditing
  };
}
function removeCommand(index) {
  return {
    type: _action_types.types.REMOVE_COMMAND,
    data: {
      index: index
    },
    post: [saveEditing, saveMacroExtra()]
  };
}
function selectCommand(index, forceClick) {
  return {
    type: _action_types.types.SELECT_COMMAND,
    data: {
      index: index,
      forceClick: forceClick
    },
    post: saveEditing
  };
}

// Note: consider this action as patch for updating commands in redux state only
function updateEditing(editing) {
  return {
    type: _action_types.types.UPDATE_EDITING,
    data: {
      editing: editing
    },
    post: []
  };
}
function cutCommand(index) {
  return {
    type: _action_types.types.CUT_COMMAND,
    data: {
      indices: [index]
    },
    post: [saveEditing, saveMacroExtra()]
  };
}
function copyCommand(index) {
  return {
    type: _action_types.types.COPY_COMMAND,
    data: {
      indices: [index]
    }
  };
}
function pasteCommand(index) {
  return {
    type: _action_types.types.PASTE_COMMAND,
    data: {
      index: index
    },
    post: [saveEditing, saveMacroExtra()]
  };
}
function normalizeCommands() {
  return {
    type: _action_types.types.NORMALIZE_COMMANDS,
    data: {},
    post: saveEditing
  };
}
function updateSelectedCommand(obj) {
  return {
    type: _action_types.types.UPDATE_SELECTED_COMMAND,
    data: obj,
    post: saveEditing
  };
}
function toggleComment(commandIndex) {
  return function (dispatch, getState) {
    var state = getState();
    var commands = state.editor.editing.commands;
    var command = commands[commandIndex];
    if (!command || !command.cmd || !command.cmd.length) {
      return;
    }

    // Note: for commented out command, its data looks like:
    // {
    //   cmd:     'comment',
    //   target:  'originalCmd // originalTarget
    //   value:   not touched
    // }
    if (command.cmd === 'comment') {
      var separator = ' // ';
      var index = command.target.indexOf(separator);
      if (index === -1) return;
      var cmd = command.target.substr(0, index);
      if (!(0, _command.isValidCmd)(cmd)) return;
      var target = command.target.substr(index + separator.length);
      return dispatch(updateCommand(_objectSpread(_objectSpread({}, command), {}, {
        cmd: cmd,
        target: target
      }), commandIndex));
    } else {
      return dispatch(updateCommand(_objectSpread(_objectSpread({}, command), {}, {
        cmd: 'comment',
        target: "".concat(command.cmd, " // ").concat(command.target || '')
      }), commandIndex));
    }
  };
}
function toggleCommentOnSelectedCommand() {
  return function (dispatch, getState) {
    var state = getState();
    var index = state.editor.editing.meta.selectedIndex;
    dispatch(toggleComment(index));
  };
}
function setSourceError(error) {
  return {
    type: _action_types.types.SET_SOURCE_ERROR,
    data: error
  };
}
function setSourceCurrent(str) {
  return {
    type: _action_types.types.SET_SOURCE_CURRENT,
    data: str
  };
}
function saveSourceCodeToEditing(str) {
  return function (dispatch, getState) {
    var _getState$editor = getState().editor,
      editing = _getState$editor.editing,
      editingSource = _getState$editor.editingSource;
    if (editingSource.pure === editing.current) return;

    // log('ACTION, saveSourceCodeToEditing', str)

    try {
      var obj = (0, _convert_utils.fromJSONString)(str, 'untitled');
      dispatch(setEditing(_objectSpread(_objectSpread({}, obj.data), {}, {
        meta: editing.meta
      })));
      dispatch(setSourceError(null));
    } catch (e) {
      _antd.message.error('There are errors in the source');
      dispatch(setSourceError(e.message));
    }
  };
}

// In the form of redux-thunnk, it saves current editing test case to local storage
function saveEditingAsExisted() {
  return function (dispatch, getState) {
    var state = getState();
    var src = state.editor.editing.meta.src;
    var macroId = src.id;
    var data = (0, _utils.pick)(['commands'], state.editor.editing);
    var macroStorage = (0, _storage2.getStorageManager)().getMacroStorage();
    if (!macroId) {
      throw new Error("Can't find macro with path '".concat(macroId, "'"));
    }

    // Make sure, only 'cmd', 'value', 'target' are saved in storage
    data.commands = data.commands.map(_test_case_model.normalizeCommand);
    if ((0, _recomputed.hasUnsavedMacro)(state)) {
      // Reset test case status
      dispatch(updateMacroPlayStatus(macroId, null));
    }
    return macroStorage.read(macroId, 'Text').then(function (macro) {
      var updatedMacro = _objectSpread(_objectSpread({}, macro), {}, {
        data: data
      });
      dispatch({
        type: 'setCurrentMacro',
        data: updatedMacro
      });
      return macroStorage.write(macroId, updatedMacro);
    }).then(function () {
      dispatch({
        type: _action_types.types.SAVE_EDITING_AS_EXISTED,
        data: null,
        post: saveEditing
      });
    });
  };
}

// In the form of redux-thunnk, it saves the current editing test case as a new named test case
function saveEditingAsNew(name) {
  return function (dispatch, getState) {
    var state = getState();
    var data = (0, _utils.pick)(['commands'], state.editor.editing);
    var sameName = findSameNameMacro(name, state.editor.testCases);
    if (sameName) {
      return Promise.reject(new Error('The macro name already exists!'));
    }
    var relativePath = '/' + name + '.json';
    var id = (0, _storage2.getStorageManager)().getMacroStorage().filePath(relativePath);
    var newMacro = {
      id: id,
      name: name,
      data: data
    };
    return (0, _storage2.getStorageManager)().getMacroStorage().write(relativePath, newMacro).then(function () {
      dispatch({
        type: 'setCurrentMacro',
        data: newMacro
      });
      return dispatch({
        type: _action_types.types.SAVE_EDITING_AS_NEW,
        data: {
          id: id,
          name: name
        },
        post: saveEditing
      });
    });
  };
}
function setTestCases(testCases) {
  var tcs = testCases.slice();
  tcs.sort(function (a, b) {
    var nameA = a.name.toLowerCase();
    var nameB = b.name.toLowerCase();
    if (nameA < nameB) return -1;
    if (nameA === nameB) return 0;
    return 1;
  });
  return {
    type: _action_types.types.SET_TEST_CASES,
    data: tcs,
    post: function post(_ref5) {
      var dispatch = _ref5.dispatch,
        getState = _ref5.getState;
      var state = getState();
      var macroNodes = (0, _recomputed.getMacroFileNodeList)(state);
      var shouldSelectDefault = macroNodes.length > 0 && !state.editor.editing.meta.src && state.editor.editing.commands.length === 0;
      if (shouldSelectDefault) {
        dispatch(editTestCase(macroNodes[0].fullPath));
      }
    }
  };
}
function resetEditing() {
  return function (dispatch, getState) {
    var state = getState();
    var editing = state.editor.editing;
    var macroNodes = (0, _recomputed.getMacroFileNodeList)(state);

    // Leave it if it's a new macro
    if (editing.meta && !editing.meta.src) return;
    if (macroNodes.length === 0) {
      dispatch(editNewTestCase());
    } else {
      dispatch(editTestCase(macroNodes[0].fullPath));
    }
  };
}
function resetEditingIfNeeded() {
  return function (dispatch, getState) {
    var state = getState();
    var editing = state.editor.editing;
    var lastTcId = editing.meta.src && editing.meta.src.id;
    if (!lastTcId) return resetEditing()(dispatch, getState);
    dispatch(editTestCase(lastTcId));
  };
}
function setEditing(editing) {
  return {
    type: _action_types.types.SET_EDITING,
    data: editing
  };
}
function editTestCase(id) {
  return function (dispatch, getState) {
    return (0, _storage2.getStorageManager)().getMacroStorage().read(id, 'Text').then(function (rawMacro) {
      var macro = (0, _test_case_model.normalizeTestCase)(rawMacro);
      dispatch({
        type: 'setCurrentMacro',
        data: macro
      });
      dispatch({
        type: _action_types.types.EDIT_TEST_CASE,
        data: {
          id: id,
          macro: macro
        },
        post: saveEditing
      });

      // Save last edited macro id for each mode,
      // so that we can recover to it after switching mode
      var mode = (0, _storage2.getStorageManager)().getCurrentStrategyType();
      var key = function () {
        switch (mode) {
          case _storage2.StorageStrategyType.Browser:
            return _misc_data.MiscKey.BrowserModeLastMacroId;
          case _storage2.StorageStrategyType.XFile:
            return _misc_data.MiscKey.XFileModeLastMacroId;
          default:
            throw new Error("Invalid mode: ".concat(mode));
        }
      }();
      (0, _misc_data.getMiscData)().set(key, id);
      return macro;
    });
  };
}
function editNewTestCase() {
  return {
    type: _action_types.types.EDIT_NEW_TEST_CASE,
    data: null,
    post: saveEditing
  };
}
function upsertTestCase(tc) {
  return function (dispatch, getState) {
    return (0, _storage2.getStorageManager)().getMacroStorage().write(tc.name, _objectSpread({
      id: (0, _utils.uid)()
    }, tc));
  };
}
function addTestCases(_ref6) {
  var macros = _ref6.macros,
    _ref6$folder = _ref6.folder,
    folder = _ref6$folder === void 0 ? '/' : _ref6$folder,
    _ref6$overwrite = _ref6.overwrite,
    overwrite = _ref6$overwrite === void 0 ? false : _ref6$overwrite,
    _ref6$storageStrategy = _ref6.storageStrategyType,
    storageStrategyType = _ref6$storageStrategy === void 0 ? null : _ref6$storageStrategy;
  return function (dispatch, getState) {
    var storage = (0, _storage2.getStorageManager)().getStorageForTarget(_storage2.StorageTarget.Macro, storageStrategyType || (0, _storage2.getStorageManager)().getCurrentStrategyType());
    var state = getState();
    var dirToCompare = folder === '/' ? '' : storage.relativePath(folder, true);
    var allMacros = (0, _recomputed.getMacroFileNodeList)(state);
    var macroNodes = allMacros.filter(function (node) {
      var rawDir = storage.getPathLib().dirname(node.fullPath);
      var dir = storage.relativePath(rawDir, true);
      return dirToCompare === dir;
    });
    var failTcs = [];
    var validTcs = [];
    macros.forEach(function (macro) {
      var isValid = overwrite || !macroNodes.find(function (node) {
        return node.name === macro.name;
      });
      if (isValid) {
        validTcs.push(macro);
      } else {
        failTcs.push(macro);
      }
    });
    var passCount = validTcs.length;
    var failCount = macros.length - passCount;
    if (passCount === 0) {
      return Promise.resolve({
        passCount: passCount,
        failCount: failCount,
        failTcs: failTcs
      });
    }
    var macrosToWrite = validTcs.map(function (tc) {
      return {
        filePath: _path.posix.join(folder, "".concat(tc.name, ".json")),
        content: _objectSpread(_objectSpread({}, tc), {}, {
          id: (0, _utils.uid)(),
          udpateTime: new Date() * 1
        })
      };
    });
    return storage.ensureDirectory(folder).then(function () {
      return storage.bulkWrite(macrosToWrite);
    }).then(function () {
      return {
        passCount: passCount,
        failCount: failCount,
        failTcs: failTcs
      };
    });
  };
}
function removeTestCase(macroId) {
  return function (dispatch, getState) {
    var state = getState();
    var curId = state.editor.editing.meta.src && state.editor.editing.meta.src.id;
    var tss = state.editor.testSuites.filter(function (ts) {
      return ts.cases.find(function (m) {
        return m.testCaseId === macroId;
      });
    });
    if (tss.length > 0) {
      return Promise.reject(new Error("Can't delete this macro for now, it's currently used in following test suites: ".concat(tss.map(function (item) {
        return item.name;
      }))));
    }

    // Reset test case status
    dispatch(updateMacroPlayStatus(macroId, null));
    return (0, _storage2.getStorageManager)().getMacroStorage().remove(macroId).then(function () {
      dispatch({
        type: _action_types.types.REMOVE_TEST_CASE,
        data: {
          isCurrent: curId === macroId
        },
        post: saveEditing
      });
    })["catch"](function (e) {
      return _log["default"].error(e.stack);
    });
  };
}
function removeCurrentTestCase() {
  return function (dispatch, getState) {
    var state = getState();
    var id = state.editor.editing.meta.src.id;
    return removeTestCase(id)(dispatch, getState);
  };
}
function setPlayerState(obj) {
  return {
    type: _action_types.types.SET_PLAYER_STATE,
    data: obj
  };
}
function setTimeoutStatus(args) {
  return function (dispatch) {
    dispatch(setPlayerState({
      timeoutStatus: args
    }));

    // Note: show in badge the timeout left
    _ipc_cs["default"].ask('PANEL_UPDATE_BADGE', {
      type: 'play',
      text: (args.total - args.past) / 1000 + 's'
    });
  };
}
function addPlayerWarningCommandIndex(index) {
  return function (dispatch, getState) {
    var state = getState();
    var macroId = (0, _recomputed.getCurrentMacroId)(state);
    var indices = (0, _recomputed.getWarningCommandIndices)(state);
    var warningCommandIndices = indices.indexOf(index) === -1 ? [].concat(_toConsumableArray(indices), [index]) : indices;
    dispatch(updateMacroExtra(macroId, {
      warningCommandIndices: warningCommandIndices
    }));
  };
}
function addPlayerErrorCommandIndex(index) {
  return function (dispatch, getState) {
    var state = getState();
    var macroId = (0, _recomputed.getCurrentMacroId)(state);
    var indices = (0, _recomputed.getErrorCommandIndices)(state);
    var errorCommandIndices = indices.indexOf(index) === -1 ? [].concat(_toConsumableArray(indices), [index]) : indices;
    dispatch(updateMacroExtra(macroId, {
      errorCommandIndices: errorCommandIndices
    }));
  };
}

// test function
var increment = exports.increment = function increment() {
  return {
    type: _reducers.INCREMENT,
    data: 'anything'
  };
};
function addLog(type, text) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return function (dispatch, getState) {
    var state = getState();
    var callStack = options.noStack ? [] : (0, _call_stack.getMacroCallStack)().toArray();
    var logItem = {
      type: type,
      text: text,
      options: options,
      id: (0, _utils.uid)(),
      createTime: new Date(),
      stack: callStack.map(function (item, i) {
        return {
          macroId: item.resource.id,
          macroName: item.resource.name,
          commandIndex: i === callStack.length - 1 ? state.player.nextCommandIndex : item.runningStatus.nextIndex,
          isSubroutine: i !== 0
        };
      })
    };
    if (state.config.logFilter !== 'None') {
      // Also write file to hard drive when it's in xfile mode
      setTimeout(function () {
        if (logItem.type == "report") {
          var report = document.querySelector('.report').textContent;
          logItem.text = report;
        }
        _ipc_cs["default"].ask('PANEL_LOG', {
          log: (0, _macro_log.renderLog)(logItem, true)
        });
      }, 0);
    }
    return dispatch({
      type: _action_types.types.ADD_LOGS,
      data: [logItem]
    });
  };
}
function clearLogs() {
  return {
    type: _action_types.types.CLEAR_LOGS,
    data: null
  };
}
function addScreenshot(screenshot) {
  return {
    type: _action_types.types.ADD_SCREENSHOT,
    data: _objectSpread(_objectSpread({}, screenshot), {}, {
      createTime: new Date()
    })
  };
}
function clearScreenshots() {
  return {
    type: _action_types.types.CLEAR_SCREENSHOTS,
    data: null,
    post: function post() {
      return (0, _storage2.getStorageManager)().getScreenshotStorage().clear();
    }
  };
}
function addVision(vision) {
  return {
    type: _action_types.types.ADD_VISION,
    data: _objectSpread(_objectSpread({}, vision), {}, {
      createTime: new Date()
    })
  };
}
function clearVisions() {
  return {
    type: _action_types.types.CLEAR_VISIONS,
    data: null,
    post: function post() {
      return (0, _storage2.getStorageManager)().getVisionStorage().clear();
    }
  };
}
function updateConfig(data) {
  return {
    type: _action_types.types.UPDATE_CONFIG,
    data: data,
    post: saveConfig
  };
}
function setMacrosExtra(data) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var opts = _objectSpread({
    shouldPersist: false
  }, options);
  return {
    type: _action_types.types.SET_MACROS_EXTRA,
    data: data || {},
    post: opts.shouldPersist ? saveWholeMacrosExtra : function () {}
  };
}
function setTestSuitesExtra(data) {
  return {
    type: _action_types.types.SET_TEST_SUITES_EXTRA,
    data: data || {}
  };
}
function updateMacroExtra(id, extra) {
  // TODO: the key for extra info should be different,
  // something like storage mode + storage path + file name
  return {
    type: _action_types.types.UPDATE_ONE_MACRO_EXTRA,
    data: {
      id: id,
      extra: extra
    },
    post: saveMacroExtra(id)
  };
}
function updateMacroPlayStatus(id, status) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, {
      status: status
    }));
  };
}
function updateMacroBreakpoints(id, breakpointIndices) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, {
      breakpointIndices: breakpointIndices
    }));
  };
}
function updateMacroDoneCommandsIndices(id, doneCommandIndices) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, {
      doneCommandIndices: doneCommandIndices
    }));
  };
}
function updateMacroErrorCommandsIndices(id, errorCommandIndices) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, {
      errorCommandIndices: errorCommandIndices
    }));
  };
}
function updateMacroWarningCommandsIndices(id, warningCommandIndices) {
  return function (dispatch, getState) {
    dispatch(updateMacroExtra(id, {
      warningCommandIndices: warningCommandIndices
    }));
  };
}
function updateProxy(proxy) {
  return {
    type: _action_types.types.UPDATE_PROXY,
    data: proxy
  };
}
function commonPlayerState(state, options, macroId, macroName) {
  var config = state.config;
  var cfg = (0, _utils.pick)(['playHighlightElements', 'playScrollElementsIntoView'], config);
  var finalMacroName = function () {
    if (macroName) {
      return macroName;
    }
    if (!macroId) {
      return state.editor.editing.meta.src ? state.editor.editing.meta.src.name : 'Untitled';
    }
    var macro = (0, _recomputed.getMacroFileNodeList)(state).find(function (node) {
      return node.fullPath === macroId;
    });
    if (!macro) {
      throw new Error("can't find macro with id '".concat(macroId, "'"));
    }
    return macro.name;
  }();
  var scope = _objectSpread({
    '!MACRONAME': finalMacroName,
    '!TIMEOUT_PAGELOAD': parseFloat(config.timeoutPageLoad),
    '!TIMEOUT_WAIT': parseFloat(config.timeoutElement),
    '!TIMEOUT_MACRO': parseFloat(config.timeoutMacro),
    '!TIMEOUT_DOWNLOAD': parseFloat(config.timeoutDownload),
    '!OCRLANGUAGE': config.ocrLanguage,
    '!CVSCOPE': config.cvScope,
    '!REPLAYSPEED': _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
      '0': 'FASTV1'
    }, "0", 'FAST'), '0.3', 'MEDIUMV1'), "0.3", 'MEDIUM'), '2', 'SLOWV1'), "2", 'SLOW')[options.postDelay / 1000] || 'MEDIUM'
  }, options.overrideScope || {});
  var breakpoints = macroId ? (0, _recomputed.getBreakpointsByMacroId)(state, macroId) : (0, _recomputed.getBreakpoints)(state);
  var opts = (0, _utils.compose)((0, _utils.on)('resources'), _utils.map, (0, _utils.on)('extra'))(function () {
    var extra = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return _objectSpread(_objectSpread(_objectSpread({}, extra), cfg), options.commandExtra || {});
  })(options);
  var playerState = _objectSpread(_objectSpread({
    title: finalMacroName
  }, opts), {}, {
    "public": _objectSpread(_objectSpread({}, opts["public"] || {}), {}, {
      scope: scope
    }),
    breakpoints: [].concat(_toConsumableArray(breakpoints), _toConsumableArray(options.breakpoints || []))
  });
  return playerState;
}
function playerPlay(options) {
  // Filter out empty commands
  var opts = _objectSpread(_objectSpread({}, options), {}, {
    resources: (options.resources || []).filter(function (res) {
      return res.cmd && res.cmd.length > 0;
    })
  });
  return function (dispatch, getState) {
    return (0, _save_test_case["default"])().saveOrNot({
      getContent: function getContent(data) {
        return 'You must save macro before replay';
      },
      okText: 'Save',
      cancelText: 'Cancel',
      autoSaveExisting: true
    }).then(function (saved) {
      if (!saved) return;
      var state = getState();
      var playerState = commonPlayerState(state, opts, opts.macroId, opts.title);
      (0, _call_stack.getMacroCallStack)().clear();
      return (0, _call_stack.getMacroCallStack)().call({
        id: opts.macroId,
        name: playerState.title,
        commands: opts.resources
      }, {
        playerState: playerState,
        status: _macro.MacroStatus.Running,
        nextIndex: opts.startIndex,
        commandResults: []
      });
    });
  };
}
function listCSV() {
  return function (dispatch, getState) {
    var csvStorage = (0, _storage2.getStorageManager)().getCSVStorage();
    csvStorage.list().then(function (list) {
      return Promise.all(list.map(function (item) {
        return {
          name: item.name,
          size: item.size,
          fullPath: item.fullPath,
          createTime: new Date(item.lastModified)
        };
      }));
    }).then(function (list) {
      dispatch({
        type: _action_types.types.SET_CSV_LIST,
        data: list
      });
    })["catch"](function (e) {
      _log["default"].error('listCSV error', e);
      return Promise.reject(e);
    });
  };
}
function listScreenshots() {
  return function (dispatch, getState) {
    var man = (0, _storage2.getStorageManager)().getScreenshotStorage();
    return man.list().then(function (list) {
      // log('listScreenshots', list)

      return list.map(function (item) {
        return {
          name: item.name,
          fullPath: item.fullPath,
          createTime: new Date(item.lastModified)
        };
      });
    }).then(function (list) {
      dispatch({
        type: _action_types.types.SET_SCREENSHOT_LIST,
        data: list
      });
    })["catch"](function (e) {
      _log["default"].error('listScreenshots error', e);
      return Promise.reject(e);
    });
  };
}
function listVisions() {
  return function (dispatch, getState) {
    var visionStorage = (0, _storage2.getStorageManager)().getVisionStorage();
    return visionStorage.list().then(function (list) {
      // log('listVisions', list)

      return list.map(function (item) {
        return {
          name: item.name,
          fullPath: item.fullPath,
          createTime: new Date(item.lastModified)
        };
      });
    }).then(function (list) {
      dispatch({
        type: _action_types.types.SET_VISION_LIST,
        data: list
      });
    })["catch"](function (e) {
      _log["default"].error('listVisions error', e);
      return Promise.reject(e);
    });
  };
}
function renameVisionImage(fileName) {
  var shouldUpdateCommand = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return function (dispatch, getState) {
    return (0, _utils.withFileExtension)(fileName, function (baseName, addExtName) {
      return (0, _prompt.prompt)({
        title: 'Image Name',
        message: "Note: Please keep the '_dpi_xx' postfix",
        value: baseName,
        keepOpenOnError: true,
        selectionEnd: function () {
          var m = baseName.match(/_dpi_\d+/i);
          if (!m) return undefined;
          return m.index;
        }(),
        onOk: function onOk(finalBaseName) {
          // Note: a small timeout to prevent "select" button from accepting "enter" keypress
          var timeout = (0, _utils.delay)(function () {
            return true;
          }, 100);
          if (finalBaseName === baseName) return timeout;
          try {
            (0, _utils.validateStandardName)(finalBaseName, true);
          } catch (e) {
            _antd.message.error(e.message);
            throw e;
          }
          return (0, _storage2.getStorageManager)().getVisionStorage().exists(addExtName(finalBaseName)).then(function (result) {
            if (result) {
              var msg = "'".concat(addExtName(finalBaseName), "' already exists");
              _antd.message.error(msg);
              throw new Error(msg);
            }
            return (0, _storage2.getStorageManager)().getVisionStorage().rename(fileName, addExtName(finalBaseName)).then(function () {
              return timeout;
            })["catch"](function (e) {
              // Note: If there is error in renaming like duplicate names,
              // it should show error message and let users try again
              _antd.message.error(e.message);
              throw e;
            });
          });
        }
      }).then(function (finalFullName) {
        // If users click "Cancel" button, we should delete it #479
        // Have to give it private name, since withFileExtenion will try to add '.png'
        if (!finalFullName) {
          return (0, _storage2.getStorageManager)().getVisionStorage().remove(addExtName(baseName)).then(function () {
            return dispatch(listVisions());
          }).then(function () {
            return '__kantu_deleted__';
          });
        }
        return finalFullName;
      });
    }).then(function (finalFullName) {
      // It means it's deleted (user clicks "cancel")
      if (/__kantu_deleted__/.test(finalFullName)) return;
      if (shouldUpdateCommand) {
        dispatch(updateSelectedCommand({
          target: finalFullName
        }));
      }
      dispatch(listVisions());
      _antd.message.success("Saved vision as ".concat(finalFullName));
      return finalFullName;
    });
  };
}
function setTestSuites(tss) {
  return {
    type: _action_types.types.SET_TEST_SUITES,
    data: tss
  };
}
function addTestSuite(ts) {
  return function (dispatch, getState) {
    var state = getState();
    var existingtestSuites = (0, _recomputed.getTestSuitesWithAllInfo)(state);
    var hasDuplicateName = !!existingtestSuites.find(function (item) {
      return ts.name === item.name;
    });
    if (hasDuplicateName) {
      return Promise.reject(new Error("The test suite name '".concat(ts.name, "' already exists!")));
    }
    return (0, _storage2.getStorageManager)().getTestSuiteStorage().write(ts.name, _objectSpread(_objectSpread({}, ts), {}, {
      id: (0, _utils.uid)(),
      updateTime: new Date() * 1
    }));
  };
}
function addTestSuites(tss) {
  var storageStrategyType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (dispatch, getState) {
    var state = getState();
    var existingtestSuites = (0, _recomputed.getTestSuitesWithAllInfo)(state);
    var validTss = tss.filter(function (ts) {
      return !existingtestSuites.find(function (item) {
        return item.name === ts.name;
      });
    });
    var passCount = validTss.length;
    var failCount = tss.length - passCount;
    if (passCount === 0) {
      return Promise.resolve({
        passCount: passCount,
        failCount: failCount,
        failTss: []
      });
    }
    var storage = (0, _storage2.getStorageManager)().getStorageForTarget(_storage2.StorageTarget.TestSuite, storageStrategyType || (0, _storage2.getStorageManager)().getCurrentStrategyType());
    var testSuitesToWrite = validTss.map(function (ts) {
      return {
        filePath: ts.name,
        content: _objectSpread(_objectSpread({}, ts), {}, {
          id: (0, _utils.uid)(),
          updateTime: new Date() * 1
        })
      };
    });
    return storage.ensureDir().then(function () {
      return storage.bulkWrite(testSuitesToWrite);
    }).then(function () {
      return {
        passCount: passCount,
        failCount: failCount,
        failTss: []
      };
    });
  };
}
function removeTestSuite(id) {
  return function (dispatch, getState) {
    var state = getState();
    var ts = state.editor.testSuites.find(function (ts) {
      return ts.id === id;
    });
    if (!ts) throw new Error("can't find test suite with id '".concat(id, "'"));

    // Reset test suite status
    dispatch({
      type: _action_types.types.UPDATE_TEST_SUITE_STATUS,
      data: {
        id: id,
        extra: {
          fold: false,
          playStatus: {}
        }
      }
    });
    return (0, _storage2.getStorageManager)().getTestSuiteStorage().remove(ts.name);
  };
}
function setPlayerMode(mode) {
  return {
    type: _action_types.types.SET_PLAYER_STATE,
    data: {
      mode: mode
    }
  };
}
function runBackup() {
  return function (dispatch, getState) {
    var state = getState();
    var config = state.config,
      editor = state.editor;
    var autoBackupTestCases = config.autoBackupTestCases,
      autoBackupTestSuites = config.autoBackupTestSuites,
      autoBackupScreenshots = config.autoBackupScreenshots,
      autoBackupCSVFiles = config.autoBackupCSVFiles,
      autoBackupVisionImages = config.autoBackupVisionImages;
    var sm = (0, _storage2.getStorageManager)();
    return Promise.all([sm.getCSVStorage().list(), sm.getScreenshotStorage().list(), sm.getVisionStorage().list()]).then(function (_ref7) {
      var _ref8 = _slicedToArray(_ref7, 3),
        csvs = _ref8[0],
        screenshots = _ref8[1],
        visions = _ref8[2];
      return (0, _backup.backup)({
        csvs: csvs,
        screenshots: screenshots,
        visions: visions,
        macroNodes: (0, _recomputed.getMacroFileNodeList)(state),
        testSuites: editor.testSuites,
        backup: {
          testCase: autoBackupTestCases,
          testSuite: autoBackupTestSuites,
          screenshot: autoBackupScreenshots,
          csv: autoBackupCSVFiles,
          vision: autoBackupVisionImages
        }
      });
    })["catch"](function (e) {
      _log["default"].error(e.stack);
    });
  };
}
function setVariables(variables) {
  variables.sort(function (a, b) {
    if (a.key < b.key) return -1;
    if (a.key > b.key) return 1;
    return 0;
  });
  return {
    type: _action_types.types.SET_VARIABLE_LIST,
    data: variables
  };
}
function updateUI(data) {
  return {
    type: _action_types.types.UPDATE_UI,
    data: data
  };
}
function addBreakpoint(macroId, commandIndex) {
  return function (dispatch, getState) {
    var state = getState();
    var extra = state.editor.macrosExtra[macroId] || {};
    var indices = extra.breakpointIndices || [];
    var newIndices = indices.indexOf(commandIndex) === -1 ? [].concat(_toConsumableArray(indices), [commandIndex]) : indices;
    dispatch(updateMacroBreakpoints(macroId, newIndices));
  };
}
function removeBreakpoint(macroId, commandIndex) {
  return function (dispatch, getState) {
    var state = getState();
    var extra = state.editor.macrosExtra[macroId] || {};
    var indices = extra.breakpointIndices || [];
    var newIndices = indices.filter(function (index) {
      return index !== commandIndex;
    });
    dispatch(updateMacroBreakpoints(macroId, newIndices));
  };
}
function setEditorActiveTab(tab) {
  return {
    type: _action_types.types.SET_EDITOR_ACTIVE_TAB,
    data: tab
  };
}
function preinstall() {
  var yesInstall = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  return function (dispatch, getState) {
    var markThisVersion = function markThisVersion() {
      return _storage["default"].get('preinstall_info').then(function () {
        var info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var prevVersions = info.askedVersions || [];
        var thisVersion = _config["default"].preinstall.version;
        var hasThisOne = prevVersions.indexOf(thisVersion) !== -1;
        if (hasThisOne) return true;
        return _storage["default"].set('preinstall_info', _objectSpread(_objectSpread({}, info), {}, {
          askedVersions: [].concat(_toConsumableArray(prevVersions), [thisVersion])
        }));
      });
    };
    if (!yesInstall) return markThisVersion();
    (0, _log["default"])('PREINSTALL_CSV_LIST', ["preinstall/csv/readcsvtestdata.csv"]);
    (0, _log["default"])('PREINSTALL_VISION_LIST', ["preinstall/vision/canvas_3dots_verify_dpi_96.png","preinstall/vision/canvas_hydepark_dpi_96.png","preinstall/vision/canvas_hydepark_extract_dpi_96_relative.png","preinstall/vision/canvas_hydepark_verify_dpi_96.png","preinstall/vision/canvas_wyoming_dpi_96.png","preinstall/vision/canvas_wyoming_verify_dpi_96.png","preinstall/vision/democv_checkoverlay.png","preinstall/vision/democv_ocrdone.png","preinstall/vision/democv_share.png","preinstall/vision/democv_startocr.png","preinstall/vision/desktop_area_bottomright_dpi_96.png","preinstall/vision/desktop_area_topleft3_dpi_96.png","preinstall/vision/desktop_check_v_tab_dpi_96.png","preinstall/vision/desktop_clearbutton_dpi_96.png","preinstall/vision/desktop_logstab_grey_dpi_96.png","preinstall/vision/desktop_logstab_white_dpi_96.png","preinstall/vision/desktop_scrtab_dpi_96.png","preinstall/vision/desktop_searcharea_dpi_96_relative.png","preinstall/vision/desktop_vartab_dpi_96.png","preinstall/vision/desktop_vitab_dpi_96.png","preinstall/vision/draw_canvas_dpi_96.png","preinstall/vision/draw_checkresult1_dpi_96.png","preinstall/vision/draw_pencil_dpi_96.png","preinstall/vision/draw_plus_dpi_96.png","preinstall/vision/draw_redbutton_dpi_96.png","preinstall/vision/draw_startingpoint_dpi_96.png","preinstall/vision/draw_text1_dpi_96.png","preinstall/vision/getquotenumber_dpi_96_relative.png","preinstall/vision/pdftest_salesquote.png","preinstall/vision/slider_handle_dpi_96.png","preinstall/vision/slider_red_dpi_96.png","preinstall/vision/uitest_download_dpi_96.png","preinstall/vision/uitest_hamburger_dpi_96.png","preinstall/vision/uitest_logo_mobile_dpi_96.png","preinstall/vision/uitest_logo_wide_dpi_96.png","preinstall/vision/uitest_share_dpi_96.png","preinstall/vision/youtube_play_button.png","preinstall/vision/youtube_video_content_verify.png"]);
    var installMacrosAndSuites = function installMacrosAndSuites() {
      if (!_preinstall_macros["default"] || !Object.keys(_preinstall_macros["default"]).length) return Promise.resolve();
      var installMacros = function installMacros() {
        var macroStorage = (0, _storage2.getStorageManager)().getMacroStorage();
        var path = macroStorage.getPathLib();
        var folders = Object.keys(_preinstall_macros["default"]).map(function (relativePath) {
          return path.join(_config["default"].preinstall.macroFolder, path.dirname(relativePath));
        });
        var uniqueFolders = _ts_utils.uniqueStrings.apply(void 0, _toConsumableArray(folders));
        return _ts_utils.flow.apply(void 0, _toConsumableArray(uniqueFolders.map(function (dirPath) {
          return function () {
            return macroStorage.ensureDirectory(dirPath);
          };
        }))).then(function () {
          return Promise.all(Object.keys(_preinstall_macros["default"]).map(function (relativePath) {
            var macroName = path.basename(relativePath);
            var filePath = macroStorage.filePath(path.join(_config["default"].preinstall.macroFolder, relativePath));
            var str = JSON.stringify(_preinstall_macros["default"][relativePath]);
            var macro = (0, _convert_utils.fromJSONString)(str, macroName);
            return macroStorage.write(filePath, macro);
          }));
        });
      };
      return (0, _ts_utils.flow)(installMacros);
    };

    // Preinstall csv
    var installCsvs = function installCsvs() {
      var list = ["preinstall/csv/readcsvtestdata.csv"];
      if (list.length === 0) return Promise.resolve();

      // Note: preinstalled resources all go into browser mode
      var csvStorage = (0, _storage2.getStorageManager)().getStorageForTarget(_storage2.StorageTarget.CSV, _storage2.StorageStrategyType.Browser);
      return csvStorage.ensureDir().then(function () {
        var ps = list.map(function (url) {
          var parts = url.split('/');
          var fileName = parts[parts.length - 1];
          return (0, _utils.loadCsv)(url).then(function (text) {
            return csvStorage.write(fileName, new Blob([text]));
          });
        });
        return Promise.resolve(ps)
        // Note: delay needed for Firefox and slow Chrome
        .then(function () {
          return (0, _utils.delay)(function () {}, 3000);
        }).then(function () {
          dispatch(listCSV());
        });
      });
    };

    // Preinstall vision images
    var installVisionImages = function installVisionImages() {
      var list = ["preinstall/vision/canvas_3dots_verify_dpi_96.png","preinstall/vision/canvas_hydepark_dpi_96.png","preinstall/vision/canvas_hydepark_extract_dpi_96_relative.png","preinstall/vision/canvas_hydepark_verify_dpi_96.png","preinstall/vision/canvas_wyoming_dpi_96.png","preinstall/vision/canvas_wyoming_verify_dpi_96.png","preinstall/vision/democv_checkoverlay.png","preinstall/vision/democv_ocrdone.png","preinstall/vision/democv_share.png","preinstall/vision/democv_startocr.png","preinstall/vision/desktop_area_bottomright_dpi_96.png","preinstall/vision/desktop_area_topleft3_dpi_96.png","preinstall/vision/desktop_check_v_tab_dpi_96.png","preinstall/vision/desktop_clearbutton_dpi_96.png","preinstall/vision/desktop_logstab_grey_dpi_96.png","preinstall/vision/desktop_logstab_white_dpi_96.png","preinstall/vision/desktop_scrtab_dpi_96.png","preinstall/vision/desktop_searcharea_dpi_96_relative.png","preinstall/vision/desktop_vartab_dpi_96.png","preinstall/vision/desktop_vitab_dpi_96.png","preinstall/vision/draw_canvas_dpi_96.png","preinstall/vision/draw_checkresult1_dpi_96.png","preinstall/vision/draw_pencil_dpi_96.png","preinstall/vision/draw_plus_dpi_96.png","preinstall/vision/draw_redbutton_dpi_96.png","preinstall/vision/draw_startingpoint_dpi_96.png","preinstall/vision/draw_text1_dpi_96.png","preinstall/vision/getquotenumber_dpi_96_relative.png","preinstall/vision/pdftest_salesquote.png","preinstall/vision/slider_handle_dpi_96.png","preinstall/vision/slider_red_dpi_96.png","preinstall/vision/uitest_download_dpi_96.png","preinstall/vision/uitest_hamburger_dpi_96.png","preinstall/vision/uitest_logo_mobile_dpi_96.png","preinstall/vision/uitest_logo_wide_dpi_96.png","preinstall/vision/uitest_share_dpi_96.png","preinstall/vision/youtube_play_button.png","preinstall/vision/youtube_video_content_verify.png"];
      if (list.length === 0) return Promise.resolve();

      // Note: preinstalled resources all go into browser mode
      var visionStorage = (0, _storage2.getStorageManager)().getStorageForTarget(_storage2.StorageTarget.Vision, _storage2.StorageStrategyType.Browser);
      return visionStorage.ensureDir().then(function () {
        var ps = list.map(function (url) {
          var parts = url.split('/');
          var fileName = parts[parts.length - 1];
          return (0, _utils.loadImage)(url).then(function (blob) {
            return visionStorage.write(fileName, blob);
          });
        });
        return Promise.resolve(ps)
        // Note: delay needed for Firefox and slow Chrome
        .then(function () {
          return (0, _utils.delay)(function () {}, 3000);
        }).then(function () {
          dispatch(listVisions());
        });
      });
    };
    return Promise.all([installMacrosAndSuites(), installCsvs(), installVisionImages()]).then(markThisVersion);
  };
}

/***/ }),

/***/ 5421:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parseFromCSV = parseFromCSV;
exports.stringifyToCSV = stringifyToCSV;
exports.toCsvDataURI = toCsvDataURI;
var _csv = _interopRequireDefault(__webpack_require__(3339));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var csvDataURI = function csvDataURI(csvStr) {
  return 'data:text/csv;base64,' + window.btoa(unescape(encodeURIComponent(csvStr)));
};
function parseFromCSV(text) {
  return new Promise(function (resolve, reject) {
    _csv["default"].parse(text, function (err, data) {
      if (err) return reject(err);
      return resolve(data);
    });
  });
}
function stringifyToCSV(list) {
  return new Promise(function (resolve, reject) {
    _csv["default"].stringify(list, function (err, data) {
      if (err) return reject(err);
      return resolve(data);
    });
  });
}
function toCsvDataURI(list) {
  return stringifyToCSV(list).then(csvDataURI);
}

/***/ }),

/***/ 54138:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getDownloadMan = exports.DownloadMan = void 0;
var _web_extension = _interopRequireDefault(__webpack_require__(41953));
var _log = _interopRequireDefault(__webpack_require__(89130));
var _utils = __webpack_require__(46580);
var _ts_utils = __webpack_require__(1601);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var DownloadMan = exports.DownloadMan = /*#__PURE__*/function () {
  function DownloadMan() {
    var _this = this;
    _classCallCheck(this, DownloadMan);
    _defineProperty(this, "activeDownloads", []);
    _defineProperty(this, "eventsBound", false);
    _defineProperty(this, "filterActiveDownloads", function (predicate) {
      _this.activeDownloads = _this.activeDownloads.filter(predicate);
      if (_this.activeDownloads.length === 0) {
        _this.unbindEvents();
      }
    });
    _defineProperty(this, "createdListener", function (downloadItem) {
      if (!_this.isActive()) return;
      (0, _log["default"])('download on created', downloadItem);
      var item = _this.activeDownloads.find(function (item) {
        return !item.id;
      });
      if (!item) return;

      // Note: 3 things to do on download created
      // 1. record download id
      // 2. Start timer for timeout
      // 3. Start interval timer for count down message
      Object.assign(item, _objectSpread({
        id: downloadItem.id
      }, !item.wait && item.timeout > 0 ? {} : {
        timeoutTimer: setTimeout(function () {
          item.reject(new Error("download timeout ".concat(item.timeout / 1000, "s")));
          _this.filterActiveDownloads(function (d) {
            return item.uid !== d.uid;
          });
        }, item.timeout),
        countDownTimer: setInterval(function () {
          if (!_this.countDownHandler) return;
          var _item$past = item.past,
            past = _item$past === void 0 ? 0 : _item$past;
          var newPast = past + 1000;
          _this.countDownHandler({
            total: item.timeout,
            past: newPast
          });
          Object.assign(item, {
            past: newPast
          });
        }, 1000)
      }));
    });
    _defineProperty(this, "changedListener", function (downloadDelta) {
      if (!_this.isActive()) return;
      (0, _log["default"])('download on changed', downloadDelta);
      var item = _this.findById(downloadDelta.id);
      if (!item) return;
      if (downloadDelta.state) {
        var fn = function fn() {};
        var done = false;
        switch (downloadDelta.state.current) {
          case 'complete':
            fn = function fn() {
              return item.resolve(true);
            };
            done = true;
            if (_this.completeHandler) {
              _web_extension["default"].downloads.search({
                id: item.id
              }).then(function (_ref) {
                var _ref2 = _slicedToArray(_ref, 1),
                  downloadItem = _ref2[0];
                if (downloadItem) {
                  _this.completeHandler(downloadItem);
                }
              });
            }
            break;
          case 'interrupted':
            fn = function fn() {
              return item.reject(new Error('download interrupted'));
            };
            done = true;
            break;
        }

        // Remove this download item from our todo list if it's done
        if (done) {
          clearTimeout(item.timeoutTimer);
          clearInterval(item.countDownTimer);
          _this.filterActiveDownloads(function (item) {
            return item.id !== downloadDelta.id;
          });
        }

        // resolve or reject that promise object
        fn();
      }
    });
    _defineProperty(this, "determineFileNameListener", function (downloadItem, suggest) {
      if (!_this.isActive()) return;
      (0, _log["default"])('download on determine', downloadItem);
      var item = _this.findById(downloadItem.id);
      if (!item) return;
      var tmpName = item.fileName.trim();
      var fileName = tmpName === '' || tmpName === '*' ? null : tmpName;
      if (fileName) {
        return suggest({
          filename: fileName,
          conflictAction: 'uniquify'
        });
      }
    });
  }
  _createClass(DownloadMan, [{
    key: "isActive",
    value:
    /*
     * Private methods
     */

    function isActive() {
      return this.activeDownloads.length > 0;
    }
  }, {
    key: "findById",
    value: function findById(id) {
      return this.activeDownloads.find(function (item) {
        return item.id === id;
      });
    }
  }, {
    key: "bindEvents",
    value: function bindEvents() {
      if (this.eventsBound) return;
      _web_extension["default"].downloads.onCreated.addListener(this.createdListener);
      _web_extension["default"].downloads.onChanged.addListener(this.changedListener);

      // Note: only chrome supports api `chrome.downloads.onDeterminingFilename`
      if (_web_extension["default"].downloads.onDeterminingFilename) {
        _web_extension["default"].downloads.onDeterminingFilename.addListener(this.determineFileNameListener);
      }
      this.eventsBound = true;
    }
  }, {
    key: "unbindEvents",
    value: function unbindEvents() {
      if (!this.eventsBound) return;
      if (_web_extension["default"].downloads.onCreated.removeListener) {
        _web_extension["default"].downloads.onCreated.removeListener(this.createdListener);
      }
      if (_web_extension["default"].downloads.onChanged.removeListener) {
        _web_extension["default"].downloads.onChanged.removeListener(this.changedListener);
      }
      if (_web_extension["default"].downloads.onDeterminingFilename && _web_extension["default"].downloads.onDeterminingFilename.removeListener) {
        _web_extension["default"].downloads.onDeterminingFilename.removeListener(this.determineFileNameListener);
      }
      this.eventsBound = false;
    }

    /*
     * Public methods
     */
  }, {
    key: "reset",
    value: function reset() {
      this.activeDownloads.forEach(function (item) {
        if (item.timeoutTimer) clearTimeout(item.timeoutTimer);
        if (item.countDownTimer) clearInterval(item.countDownTimer);
      });
      this.activeDownloads = [];
      this.unbindEvents();
    }
  }, {
    key: "prepareDownload",
    value: function prepareDownload(fileName) {
      var _this2 = this;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var downloadToCreate = this.activeDownloads.find(function (item) {
        return !item.id;
      });
      if (downloadToCreate) throw new Error('only one not-created download allowed at a time');
      this.bindEvents();
      var opts = Object.assign({
        timeoutForStart: 10000,
        timeout: 60000,
        wait: false
      }, options);
      var promise = new Promise(function (resolve, reject) {
        var uid = Math.floor(Math.random() * 1000) + new Date() * 1;

        // Note: we need to cache promise object, so have to wait for next tick
        setTimeout(function () {
          _this2.activeDownloads.push({
            uid: uid,
            resolve: resolve,
            reject: reject,
            fileName: fileName,
            promise: promise,
            timeoutForStart: opts.timeoutForStart,
            timeout: opts.timeout,
            wait: opts.wait
          });
        }, 0);
      });
      return promise;
    }
  }, {
    key: "waitForDownloadIfAny",
    value: function waitForDownloadIfAny() {
      var _this3 = this;
      var downloadToCreate = this.activeDownloads.find(function (item) {
        return !item.id;
      });
      if (downloadToCreate) {
        return (0, _utils.until)('download start', function () {
          return {
            pass: !!downloadToCreate.id,
            result: true
          };
        }, 50, downloadToCreate.timeoutForStart).then(function () {
          return _this3.waitForDownloadIfAny();
        });
      }

      // Note: check if id exists, because it means this download item is created
      var downloadToComplete = this.activeDownloads.find(function (item) {
        return item.wait && item.id;
      });

      // A short delay after download is complete, so that background has time to send DOWNLOAD_COMPLETE event before it unblocks next command
      if (!downloadToComplete) return (0, _ts_utils.delay)(function () {
        return true;
      }, 500);
      return downloadToComplete.promise.then(function () {
        return _this3.waitForDownloadIfAny();
      });
    }
  }, {
    key: "onCountDown",
    value: function onCountDown(fn) {
      this.countDownHandler = fn;
    }
  }, {
    key: "onDownloadComplete",
    value: function onDownloadComplete(fn) {
      this.completeHandler = fn;
    }
  }, {
    key: "hasPendingDownload",
    value: function hasPendingDownload() {
      var downloadToCreate = this.activeDownloads.find(function (item) {
        return !item.id;
      });
      return !!downloadToCreate;
    }
  }]);
  return DownloadMan;
}();
var getDownloadMan = exports.getDownloadMan = function () {
  var instance;
  return function () {
    if (!instance) {
      instance = new DownloadMan();
    }
    return instance;
  };
}();

/***/ }),

/***/ 21208:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.encryptIfNeeded = exports.encrypt = exports.decryptIfNeeded = exports.decrypt = exports.aesEncrypt = exports.aesDecrypt = void 0;
var _pbkdf = _interopRequireDefault(__webpack_require__(78396));
var _aesJs = _interopRequireDefault(__webpack_require__(33836));
var _web_extension = _interopRequireDefault(__webpack_require__(41953));
var _storage = _interopRequireDefault(__webpack_require__(88555));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var RAW_PREFIX = '@_KANTU_@';
var DEPRECATED_CIPHER_PREFIX = '__KANTU_ENCRYPTED__';
var CIPHER_PREFIX = '__RPA_ENCRYPTED__';
var RAW_PREFIX_REG = new RegExp('^' + RAW_PREFIX);
var CIPHER_PREFIX_REG = new RegExp("^(".concat(CIPHER_PREFIX, "|").concat(DEPRECATED_CIPHER_PREFIX, ")"));
var getEncryptConfig = function getEncryptConfig() {
  return _storage["default"].get('config').then(function (config) {
    return {
      shouldEncrypt: config.shouldEncryptPassword === 'master_password',
      masterPassword: config.masterPassword
    };
  });
};
var aesEncrypt = exports.aesEncrypt = function aesEncrypt(text, password) {
  var key = _pbkdf["default"].pbkdf2Sync(password, 'salt', 1, 256 / 8, 'sha512');
  var engine = new _aesJs["default"].ModeOfOperation.ctr(key);
  return _aesJs["default"].utils.hex.fromBytes(engine.encrypt(_aesJs["default"].utils.utf8.toBytes(text)));
};
var aesDecrypt = exports.aesDecrypt = function aesDecrypt(text, password) {
  var key = _pbkdf["default"].pbkdf2Sync(password, 'salt', 1, 256 / 8, 'sha512');
  var engine = new _aesJs["default"].ModeOfOperation.ctr(key);
  return _aesJs["default"].utils.utf8.fromBytes(engine.decrypt(_aesJs["default"].utils.hex.toBytes(text)));
};
var encrypt = exports.encrypt = function encrypt(text) {
  return getEncryptConfig().then(function (_ref) {
    var shouldEncrypt = _ref.shouldEncrypt,
      masterPassword = _ref.masterPassword;
    if (!shouldEncrypt) return text;
    return "".concat(CIPHER_PREFIX).concat(aesEncrypt(RAW_PREFIX + text, masterPassword));
  });
};
var decrypt = exports.decrypt = function decrypt(text) {
  return getEncryptConfig().then(function (_ref2) {
    var shouldEncrypt = _ref2.shouldEncrypt,
      masterPassword = _ref2.masterPassword;
    if (!shouldEncrypt) return text;
    var raw = aesDecrypt(text.replace(CIPHER_PREFIX_REG, ''), masterPassword);
    if (raw.indexOf(RAW_PREFIX) !== 0) throw new Error('Wrong master password');
    return raw.replace(RAW_PREFIX_REG, '');
  })["catch"](function (e) {
    throw new Error('password string invalid');
  });
};
var encryptIfNeeded = exports.encryptIfNeeded = function encryptIfNeeded(text, dom) {
  if (dom && dom.tagName.toUpperCase() === 'INPUT' && dom.type === 'password') {
    return encrypt(text);
  }
  return Promise.resolve(text);
};
var decryptIfNeeded = exports.decryptIfNeeded = function decryptIfNeeded(text, dom) {
  if (!CIPHER_PREFIX_REG.test(text)) {
    return Promise.resolve(text);
  }
  if (!dom || ['INPUT', 'TEXTAREA'].indexOf(dom.tagName.toUpperCase()) !== -1) {
    return decrypt(text);
  }
  return Promise.resolve(text);
};

/***/ }),

/***/ 23427:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.evaluateScript = evaluateScript;
var _kdJsInterpreter = _interopRequireDefault(__webpack_require__(97425));
var _web_extension = _interopRequireDefault(__webpack_require__(41953));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function evaluateScript(code) {
  var interpreter = new _kdJsInterpreter["default"](code);
  var regexChecked = false;
  var run = function run() {
    var hasMore = interpreter.run();
    // console.log('interpreter:>>', interpreter)

    if (!regexChecked && _web_extension["default"].isFirefox()) {
      var includesRegex = interpreter.stateStack.map(function (x) {
        var _x$node;
        return (_x$node = x.node) === null || _x$node === void 0 || (_x$node = _x$node.callee) === null || _x$node === void 0 || (_x$node = _x$node.property) === null || _x$node === void 0 ? void 0 : _x$node.name;
      }).filter(function (x) {
        return x;
      }).some(function (x) {
        return ['exec', 'search', 'match', 'replace', 'split'].includes(x);
      });
      // console.log('regexChecked:>>', regexChecked)
      // console.log('includesRegex:>>', includesRegex)
      if (includesRegex) {
        throw new Error('E501: [Firefox only] executeScript_Sandbox does not support regular expressions.');
      }
      regexChecked = true;
    }
    if (!hasMore) {
      return Promise.resolve(interpreter.value);
    }
    return new Promise(function (resolve) {
      setTimeout(function () {
        resolve(run());
      }, 100);
    });
  };
  return run();
}

/***/ }),

/***/ 2363:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _ts_utils = __webpack_require__(1601);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var normalizeLabelName = function normalizeLabelName(label) {
  return label.toUpperCase();
};
var BREAK_KEY = 'break__';
var Interpreter = exports["default"] = /*#__PURE__*/function () {
  function Interpreter() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Interpreter);
    _defineProperty(this, "state", (0, _ts_utils.clone)(Interpreter.DefaultState));
    if (opts.pre) {
      this.__customPre = opts.pre;
    }
    if (opts.run) {
      this.__customRun = opts.run;
    }
    if (opts.post) {
      this.__customPost = opts.post;
    }
  }
  _createClass(Interpreter, [{
    key: "reset",
    value: function reset() {
      this.__setState({
        labels: {},
        tags: [],
        commands: []
      });
    }
  }, {
    key: "preprocess",
    value: function preprocess(commands) {
      var _this = this;
      var nextState = {
        commands: commands,
        tags: []
      };
      var halfTags = [];
      var errorAtIndex = function errorAtIndex(i, msg) {
        var e = new Error(msg);
        e.errorIndex = i;
        return e;
      };
      commands.forEach(function (c, i) {
        if (_this.__customPre && _this.__customPre(c, i)) return;
        var topHalfTag = halfTags[halfTags.length - 1];
        switch (c.cmd) {
          // Commands for if, while, do, times, forEach statements
          case 'if_v2':
          case 'if':
          case 'times':
          case 'forEach':
          case 'while_v2':
          case 'while':
          case 'do':
            {
              halfTags.push({
                type: c.cmd,
                start: {
                  index: i,
                  command: c
                }
              });
              break;
            }
          case 'repeatIf':
            {
              if (!topHalfTag || !/^do$/.test(topHalfTag.type)) {
                throw errorAtIndex(i, "No matching do for this repeatIf (at command #".concat(i + 1, ")"));
              }
              nextState.tags.push(_objectSpread(_objectSpread({}, topHalfTag), {}, {
                end: {
                  index: i,
                  command: c
                }
              }));
              halfTags.pop();
              break;
            }
          case 'elseif':
          case 'else':
            {
              if (!topHalfTag || !/^if/.test(topHalfTag.type)) {
                throw errorAtIndex(i, "No matching if for this ".concat(c.cmd, " (at command #").concat(i + 1, ")"));
              }
              topHalfTag.children = topHalfTag.children || [];
              var existingElseIndex = topHalfTag.children.findIndex(function (fork) {
                return fork.command && fork.command.cmd === 'else';
              });
              if (existingElseIndex !== -1) {
                var existingElse = topHalfTag.children[existingElseIndex];
                throw new Error("'".concat(c.cmd, "' (at command #").concat(i + 1, ") could not be used after '").concat(existingElse.command.cmd, "' (at command #").concat(existingElse.index + 1, ")"));
              }
              topHalfTag.children.push({
                index: i,
                command: c
              });
              break;
            }
          case 'break':
            {
              var targetHalfTag;
              for (var j = halfTags.length - 1; j >= 0; j--) {
                if (halfTags[j].start.index < i && /^(do|while|forEach|times)/.test(halfTags[j].type)) {
                  targetHalfTag = halfTags[j];
                  break;
                }
              }
              if (!targetHalfTag) {
                throw errorAtIndex(i, "No matching loop command for this ".concat(c.cmd, " (at command #").concat(i + 1, ")"));
              }
              targetHalfTag.children = targetHalfTag.children || [];
              targetHalfTag.children.push({
                index: i,
                command: c
              });
              break;
            }
          case 'continue':
            {
              // console.log('continue:>> i, c: ', i, c);
              // console.log('continue:>> halfTags: ', halfTags);

              // find from bottom last tag having index less than current index
              var lastTag = null;
              for (var _j = halfTags.length - 1; _j >= 0; _j--) {
                if (halfTags[_j].start.index < i && /^(do|while|forEach|times)/.test(halfTags[_j].type)) {
                  lastTag = halfTags[_j];
                  break;
                }
              }

              // console.log('continue:>> lastTag: ', lastTag);
              var _targetHalfTag = lastTag;
              if (!_targetHalfTag) {
                throw errorAtIndex(i, "No matching loop command for this ".concat(c.cmd, " (at command #").concat(i + 1, ")"));
              }
              _targetHalfTag.children = _targetHalfTag.children || [];
              _targetHalfTag.children.push({
                index: i,
                command: c
              });

              // expected output for continue/break:
              // for (let i = 1; i <= 4; i++) {
              //   console.log('%c [echo] outerLoop: outer_loop' + i, 'color: blue');
              //   for (let j = 1; j <= 3; j++) {
              //     console.log('%c [echo] middleLoop: middle_loop' + j, 'color: green');
              //     for (let k = 1; k <= 2; k++) {
              //       console.log('%c [echo] innerLoop: inner_loop' + k, 'color: red');
              //       continue; // OR: break             
              //     }
              //   }           
              // }

              break;
            }
          case 'end':
          case 'endWhile':
          case 'endif':
            {
              var _ref = function () {
                  switch (c.cmd) {
                    case 'end':
                      return [/^(if|while|times|forEach)/, 'if/while/times/forEach'];
                    case 'endWhile':
                      return [/^while/, 'while'];
                    case 'endif':
                      return [/^if/, 'if'];
                  }
                }(),
                _ref2 = _slicedToArray(_ref, 2),
                reg = _ref2[0],
                text = _ref2[1];
              if (!topHalfTag || !reg.test(topHalfTag.type)) {
                throw errorAtIndex(i, "No matching ".concat(text, " for this end (at command #").concat(i + 1, ")"));
              }
              nextState.tags.push(_objectSpread(_objectSpread({}, topHalfTag), {}, {
                end: {
                  index: i,
                  command: c
                }
              }));
              halfTags.pop();
              break;
            }
          case 'label':
            {
              if (!c.target || !c.target.length) {
                throw new Error('invalid target for label command');
              }
              _this.__setState({
                labels: _objectSpread(_objectSpread({}, _this.state.labels), {}, _defineProperty({}, normalizeLabelName(c.target), {
                  index: i
                }))
              });
              break;
            }
        }
      });
      if (halfTags.length > 0) {
        var topHalfTag = halfTags[halfTags.length - 1];
        throw errorAtIndex(topHalfTag.start.index, "Unclosed '".concat(topHalfTag.type, "' (at command #").concat(topHalfTag.start.index + 1, ")"));
      }
      this.__setState(nextState);
    }
  }, {
    key: "run",
    value: function run(command, index) {
      var _this2 = this;
      var cmd = command.cmd,
        target = command.target,
        value = command.value;
      var p = function () {
        switch (cmd) {
          case 'onError':
            {
              var _value = command.value && command.value.trim();
              var _target = command.target && command.target.trim();
              var isValidTarget = _target && (/^#restart$/i.test(_target) || /^#goto$/i.test(_target));
              if (!isValidTarget) {
                throw new Error('invalid target for onError command');
              }
              if (/^#goto$/i.test(_target)) {
                var labelName = normalizeLabelName(_value);
                if (!_this2.state.labels[labelName]) {
                  throw new Error("label ".concat(_value, " doesn't exist"));
                }
              }
              return Promise.resolve({
                isFlowLogic: true
              });
            }
          case 'gotoLabel':
            {
              if (!target || !target.length) {
                throw new Error('invalid target for gotoLabel command');
              }
              var _labelName = normalizeLabelName(target);
              if (!_this2.state.labels[_labelName]) {
                throw new Error("label ".concat(target, " doesn't exist"));
              }
              return Promise.resolve({
                isFlowLogic: true,
                nextIndex: _this2.state.labels[_labelName].index
              });
            }
          case 'elseif':
            {
              var tag = _this2.state.tags.find(function (tag) {
                return /^if/.test(tag.type) && tag.children && tag.children.find(function (fork) {
                  return fork.index === index && fork.command.cmd === cmd;
                });
              });
              if (!tag) {
                throw new Error("tag not found for this else (at command #".concat(index + 1, ")"));
              }

              // Note: if the `if` tag has already tried some branch, then this `elseif` should act like `else`
              // otherwise it acts like `if`
              if (tag.alreadyRun) {
                return Promise.resolve({
                  isFlowLogic: true,
                  nextIndex: tag.end.index + 1
                });
              } else {
                return Promise.resolve({
                  isFlowLogic: false
                });
              }
            }
          case 'else':
            {
              // Note: 'else' and 'elseif' command itself will be skipped if condition is false,
              // But it will be run as the ending command of 'if-else' when condition is true
              var _tag = _this2.state.tags.find(function (tag) {
                return /^if/.test(tag.type) && tag.children && tag.children.find(function (fork) {
                  return fork.index === index && fork.command.cmd === cmd;
                });
              });
              if (!_tag) {
                throw new Error("tag not found for this else (at command #".concat(index + 1, ")"));
              }
              return Promise.resolve({
                isFlowLogic: true,
                nextIndex: _tag.end.index + 1
              });
            }
          case 'break':
            {
              var _tag2 = _this2.state.tags.find(function (tag) {
                return /^(do|while|forEach|times)/.test(tag.type) && tag.children && tag.children.find(function (item) {
                  return item.index === index && item.command.cmd === cmd;
                });
              });
              if (!_tag2) {
                throw new Error("No loop found for this break (at command #".concat(index + 1, ")"));
              }
              _this2.setExtraByKey('times_1', 0);
              _this2.addBreak({
                command: command,
                // for debugging purpose
                targetTagStartIndex: _tag2.start.index
              });
              return Promise.resolve({
                isFlowLogic: true,
                nextIndex: _tag2.end.index + 1
              });
            }
          case 'continue':
            {
              // console.log('continue:>> index, cmd, target: ', index, cmd, target);
              // console.log('continue:>> this.state.tags: ', this.state.tags);
              var _tag3 = _this2.state.tags.find(function (tag) {
                return /^(do|while|forEach|times)/.test(tag.type) && tag.children && tag.children.find(function (item) {
                  return item.index === index && item.command.cmd === cmd;
                });
              });

              // console.log('continue:>> tag: ', tag);

              if (!_tag3) {
                throw new Error("No loop found for this break (at command #".concat(index + 1, ")"));
              }
              return Promise.resolve({
                isFlowLogic: true,
                nextIndex: _tag3.start.index
              });
            }
          case 'endif':
            {
              return Promise.resolve({
                isFlowLogic: true
              });
            }
          case 'endWhile':
            {
              var _tag4 = _this2.state.tags.find(function (tag) {
                return /^while/.test(tag.type) && tag.end.index === index;
              });
              if (!_tag4) {
                throw new Error("tag not found for this endWhile (at command #".concat(index + 1, ")"));
              }
              return Promise.resolve({
                isFlowLogic: true,
                nextIndex: _tag4.start.index
              });
            }
          case 'end':
            {
              var _tag5 = _this2.state.tags.find(function (tag) {
                return /^(if|while|times|forEach)/.test(tag.type) && tag.end.index === index;
              });
              if (!_tag5) {
                throw new Error("tag not found for this end (at command #".concat(index + 1, ")"));
              }
              if (/^if/.test(_tag5.type)) {
                return Promise.resolve({
                  isFlowLogic: true
                });
              }

              // Then it's a `while`, `forEach`, `times`
              return Promise.resolve({
                isFlowLogic: true,
                nextIndex: _tag5.start.index
              });
            }
          case 'comment':
            return Promise.resolve({
              isFlowLogic: true
            });

          // As of 'label', it doesn't do anything, so we just kind of skip it
          case 'label':
            return Promise.resolve({
              isFlowLogic: true
            });
          case 'do':
            return Promise.resolve({
              isFlowLogic: true
            });

          // Note: gotoIf, if and while need to run eval, which is not allowed in extension scope,
          // so we have to run eval in content script
          //
          // gotoIf_v2/if_v2/while_v2 will be run in extension scope (we've added `unsafe-eval` in `content_security_policy)
          case 'gotoIf':
          case 'if':
          case 'while':
          case 'gotoIf_v2':
          case 'if_v2':
          case 'while_v2':
          case 'repeatIf':
          default:
            return Promise.resolve({
              isFlowLogic: false
            });
        }
      }();
      return p.then(function (result) {
        if (result.isFlowLogic) {
          return result;
        }
        if (_this2.__customRun) {
          var _p = _this2.__customRun(command, index);
          if (_p) return Promise.resolve(_p);
        }
        return result;
      });
    }
  }, {
    key: "postRun",
    value: function postRun(command, index, result) {
      var _this3 = this;
      var cmd = command.cmd,
        target = command.target,
        value = command.value;
      if (this.__customPost) {
        var p = this.__customPost(command, index, result);
        if (p) return Promise.resolve(p);
      }
      switch (cmd) {
        case 'gotoIf_v2':
        case 'gotoIf':
          {
            // short-circuit the check on value
            if (!result.condition) return Promise.resolve();
            if (!value || !value.length) {
              throw new Error('invalid value for value command');
            }
            var labelName = normalizeLabelName(value);
            if (!this.state.labels[labelName]) {
              throw new Error("label ".concat(value, " doesn't exist"));
            }
            return Promise.resolve({
              nextIndex: this.state.labels[labelName].index
            });
          }
        case 'elseif':
        case 'if_v2':
        case 'if':
          {
            var cond = result.condition;
            var tag = function () {
              if (cmd === 'elseif') {
                return _this3.state.tags.find(function (tag) {
                  return /^if/.test(tag.type) && tag.children && tag.children.find(function (fork) {
                    return fork.index === index && fork.command.cmd === 'elseif';
                  });
                });
              } else {
                return _this3.state.tags.find(function (tag) {
                  return /^if/.test(tag.type) && tag.start.index === index;
                });
              }
            }();
            if (!tag) {
              throw new Error("'if' tag not found for this ".concat(cmd, " (at command #").concat(index + 1, ")"));
            }

            // Mark this `if` tag as already run if condition fulfilled,
            // so that any coming `elseif` could know which role itself is
            tag.alreadyRun = !!cond;
            var forkIndex = function () {
              if (cmd !== 'elseif') {
                return 0;
              }
              var curIndex = (tag.children || []).findIndex(function (fork) {
                return fork.index === index && fork.command.cmd === 'elseif';
              });
              return curIndex === -1 ? -1 : curIndex + 1;
            }();
            if (forkIndex === -1) {
              throw new Error("Can't find fork for this elseif (at command #".concat(index + 1, ")"));
            }
            var branchIndex = function () {
              var fork = tag.children && tag.children[forkIndex];
              if (!fork) {
                return null;
              }

              // Note: if next fork is elseif, it should execute that elseif
              // if next fork is else, it should go to the next line of that else
              var offset = fork && fork.command.cmd === 'else' ? 1 : 0;
              return fork.index + offset;
            }();
            var endIndex = tag.end && tag.end.index + 1;
            return Promise.resolve({
              nextIndex: cond ? index + 1 : branchIndex || endIndex
            });
          }
        case 'times':
        case 'forEach':
        case 'while_v2':
        case 'while':
          {
            var _cond = result.condition;
            var _tag6 = this.state.tags.find(function (tag) {
              return /^while|times|forEach/.test(tag.type) && tag.start.index === index;
            });
            if (!_tag6) {
              throw new Error("tag not found for this ".concat(cmd, " (at command #").concat(index + 1, ")"));
            }
            if (!_tag6.end || _tag6.end.index === undefined || _tag6.end.index === null) {
              throw new Error("tag doesn't have a valid end index");
            }
            return Promise.resolve(_cond ? {} : {
              nextIndex: _tag6.end.index + 1
            });
          }
        case 'repeatIf':
          {
            var _cond2 = result.condition;
            var _tag7 = this.state.tags.find(function (tag) {
              return /^do$/.test(tag.type) && tag.end.index === index;
            });
            if (!_tag7) {
              throw new Error("tag not found for this repeatIf (at command #".concat(index + 1, ")"));
            }
            if (!_tag7.end || _tag7.start.index === undefined || _tag7.start.index === null) {
              throw new Error("tag doesn't have a valid start index");
            }
            return Promise.resolve(_cond2 ? {
              nextIndex: _tag7.start.index + 1
            } : {});
          }
        default:
          return Promise.resolve();
      }
    }
  }, {
    key: "commandIndexByLabel",
    value: function commandIndexByLabel(labelName) {
      var label = this.state.labels[normalizeLabelName(labelName)];
      if (!label) {
        throw new Error("label '".concat(labelName, "' doesn't exist"));
      }
      return label.index;
    }
  }, {
    key: "backupState",
    value: function backupState() {
      return (0, _ts_utils.clone)(this.state);
    }
  }, {
    key: "restoreState",
    value: function restoreState(state) {
      this.__setState(state);
    }
  }, {
    key: "getKeyForTimes",
    value: function getKeyForTimes(commandIndex) {
      return "times_".concat(commandIndex);
    }
  }, {
    key: "getKeyForSurroundingTimes",
    value: function getKeyForSurroundingTimes(timesCommandIndex) {
      var _this4 = this;
      var tagIndex = this.state.tags.findIndex(function (tag) {
        return /^(times)/.test(tag.type) && tag.start.index === timesCommandIndex;
      });
      if (tagIndex === -1) {
        return null;
      }
      var currentTimesTag = this.state.tags[tagIndex];
      var surroundingTimesTag = function () {
        for (var i = tagIndex; i < _this4.state.tags.length; i++) {
          var tag = _this4.state.tags[i];
          if (tag.type === 'times' && tag.start.index < currentTimesTag.start.index && tag.end.index > currentTimesTag.end.index) {
            return tag;
          }
        }
        return null;
      }();
      if (!surroundingTimesTag) {
        return null;
      }
      return this.getKeyForTimes(surroundingTimesTag.start.index);
    }
  }, {
    key: "getExtraByKey",
    value: function getExtraByKey(key) {
      return this.state.extra[key];
    }
  }, {
    key: "setExtraByKey",
    value: function setExtraByKey(key, value) {
      this.state.extra[key] = value;
    }
  }, {
    key: "getBreaks",
    value: function getBreaks() {
      return this.state.extra[BREAK_KEY];
    }
  }, {
    key: "addBreak",
    value: function addBreak(value) {
      var existingBreaks = this.getBreaks(BREAK_KEY);
      this.setExtraByKey(BREAK_KEY, existingBreaks ? [].concat(_toConsumableArray(existingBreaks), [value]) : [value]);
    }
  }, {
    key: "removeBreak",
    value: function removeBreak(targetTagStartIndex) {
      var existingBreaks = this.getBreaks(BREAK_KEY) || [];
      var newValue = existingBreaks.filter(function (item) {
        return item.targetTagStartIndex !== targetTagStartIndex;
      });
      this.setExtraByKey(BREAK_KEY, newValue);
    }
  }, {
    key: "hasBreak",
    value: function hasBreak(targetTagStartIndex) {
      var existingBreaks = this.getBreaks(BREAK_KEY) || [];
      var isExist = existingBreaks.some(function (item) {
        return item.targetTagStartIndex === targetTagStartIndex;
      });
      return isExist;
    }
  }, {
    key: "updateExtraByKey",
    value: function updateExtraByKey(key, updater) {
      this.setExtraByKey(key, updater(this.getExtraByKey[key]));
    }
  }, {
    key: "removeExtraByKey",
    value: function removeExtraByKey(key) {
      delete this.state.extra[key];
    }
  }, {
    key: "__setState",
    value: function __setState(st) {
      this.state = _objectSpread(_objectSpread({}, this.state), st);
    }
  }]);
  return Interpreter;
}();
_defineProperty(Interpreter, "DefaultState", {
  labels: {},
  tags: [],
  commands: [],
  // Any data specific to any command, for example, `times` and `forEach` uses it to store loop cursor
  extra: {}
});

/***/ }),

/***/ 96571:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _ipc_bg_cs = __webpack_require__(59711);
var throwNotTop = function throwNotTop() {
  throw new Error('You are not a top window, not allowed to initialize/use csIpc');
};

// browser.runtime.id in firefox extension isn't necessarily found in window.location.href 
// window.location.href  eg. "moz-extension://add2840d-0b3e-41f0-8da1-55d780cc5dd8/sidepanel.html"
var isSidepanelInFirefox = typeof window !== 'undefined' && window.location.href.match(/moz-extension:\/\/[a-z0-9-]+\/sidepanel.html/);
var isSidepanel = false;
if (typeof window !== 'undefined' && (window.location.href.startsWith("chrome-extension://".concat(chrome.runtime.id, "/sidepanel.html")) || isSidepanelInFirefox)) {
  isSidepanel = true;
}

// Note: csIpc is only available to top window
var ipc = typeof window !== 'undefined' && window.top === window ? isSidepanel ? (0, _ipc_bg_cs.spInit)() : (0, _ipc_bg_cs.csInit)() : {
  ask: throwNotTop,
  send: throwNotTop,
  onAsk: throwNotTop,
  destroy: throwNotTop
};

// Note: one ipc singleton per content script
var _default = exports["default"] = ipc;

/***/ }),

/***/ 50261:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.2
 * 2016-06-16 18:25:19
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || function (view) {
  "use strict";

  // IE <10 is explicitly unsupported
  if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
    return;
  }
  var doc = view.document
    // only get URL when necessary in case Blob.js hasn't overridden it yet
    ,
    get_URL = function get_URL() {
      return view.URL || view.webkitURL || view;
    },
    is_firefox_extension = window.location.protocol === 'moz-extension:',
    create_link_for_ff_ext = function create_link_for_ff_ext() {
      // Temporary fix for firefox extension on Mac / Linux
      // reference: https://bugzilla.mozilla.org/show_bug.cgi?format=default&id=1420419
      var iframeId = 'downloadFrame';
      var $iframe = doc.createElementNS("http://www.w3.org/1999/xhtml", "iframe");
      $iframe.id = iframeId;
      $iframe.style.visibility = 'hidden';
      $iframe.style.position = 'absolute';
      $iframe.style.left = '-999px';
      doc.body.appendChild($iframe);
      var link = $iframe.contentDocument.createElement('a');

      // wait for next tick when iframe is already in document,
      // otherwise link won't be add to body of iframe
      setTimeout(function () {
        $iframe.contentDocument.body.appendChild(link);
      });
      return link;
    },
    save_link = is_firefox_extension ? create_link_for_ff_ext() : doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
    can_use_save_link = ("download" in save_link),
    click = function click(node) {
      var event = new MouseEvent("click");
      node.dispatchEvent(event);
    },
    is_safari = /constructor/i.test(view.HTMLElement) || view.safari,
    is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent),
    throw_outside = function throw_outside(ex) {
      (view.setImmediate || view.setTimeout)(function () {
        throw ex;
      }, 0);
    },
    force_saveable_type = "application/octet-stream"
    // the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
    ,
    arbitrary_revoke_timeout = 1000 * 40 // in ms
    ,
    revoke = function revoke(file) {
      var revoker = function revoker() {
        if (typeof file === "string") {
          // file is an object URL
          get_URL().revokeObjectURL(file);
        } else {
          // file is a File
          file.remove();
        }
      };
      setTimeout(revoker, arbitrary_revoke_timeout);
    },
    dispatch = function dispatch(filesaver, event_types, event) {
      event_types = [].concat(event_types);
      var i = event_types.length;
      while (i--) {
        var listener = filesaver["on" + event_types[i]];
        if (typeof listener === "function") {
          try {
            listener.call(filesaver, event || filesaver);
          } catch (ex) {
            throw_outside(ex);
          }
        }
      }
    },
    auto_bom = function auto_bom(blob) {
      // prepend BOM for UTF-8 XML and text/* types (including HTML)
      // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
      if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
        return new Blob([String.fromCharCode(0xFEFF), blob], {
          type: blob.type
        });
      }
      return blob;
    },
    FileSaver = function FileSaver(blob, name, no_auto_bom) {
      if (!no_auto_bom) {
        blob = auto_bom(blob);
      }
      // First try a.download, then web filesystem, then object URLs
      var filesaver = this,
        type = blob.type,
        force = type === force_saveable_type,
        object_url,
        dispatch_all = function dispatch_all() {
          dispatch(filesaver, "writestart progress write writeend".split(" "));
        }
        // on any filesys errors revert to saving with object URLs
        ,
        fs_error = function fs_error() {
          if ((is_chrome_ios || force && is_safari) && view.FileReader) {
            // Safari doesn't allow downloading of blob urls
            var reader = new FileReader();
            reader.onloadend = function () {
              var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
              var popup = view.open(url, '_blank');
              if (!popup) view.location.href = url;
              url = undefined; // release reference before dispatching
              filesaver.readyState = filesaver.DONE;
              dispatch_all();
            };
            reader.readAsDataURL(blob);
            filesaver.readyState = filesaver.INIT;
            return;
          }
          // don't create more object URLs than needed
          if (!object_url) {
            object_url = get_URL().createObjectURL(blob);
          }
          if (force) {
            view.location.href = object_url;
          } else {
            var opened = view.open(object_url, "_blank");
            if (!opened) {
              // Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
              view.location.href = object_url;
            }
          }
          filesaver.readyState = filesaver.DONE;
          dispatch_all();
          revoke(object_url);
        };
      filesaver.readyState = filesaver.INIT;
      if (can_use_save_link) {
        object_url = get_URL().createObjectURL(blob);
        setTimeout(function () {
          save_link.href = object_url;
          save_link.download = name;
          click(save_link);
          dispatch_all();
          revoke(object_url);
          filesaver.readyState = filesaver.DONE;
        });
        return;
      }
      fs_error();
    },
    FS_proto = FileSaver.prototype,
    saveAs = function saveAs(blob, name, no_auto_bom) {
      return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
    };
  // IE 10+ (native saveAs)
  if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
    return function (blob, name, no_auto_bom) {
      name = name || blob.name || "download";
      if (!no_auto_bom) {
        blob = auto_bom(blob);
      }
      return navigator.msSaveOrOpenBlob(blob, name);
    };
  }
  FS_proto.abort = function () {};
  FS_proto.readyState = FS_proto.INIT = 0;
  FS_proto.WRITING = 1;
  FS_proto.DONE = 2;
  FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;
  return saveAs;
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || (void 0).content);
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if ( true && module.exports) {
  module.exports.saveAs = saveAs;
} else if ( true && __webpack_require__.amdD !== null && __webpack_require__.amdO !== null) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return saveAs;
  }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}

/***/ }),

/***/ 18392:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getPlayer = exports.Player = void 0;
var _eventEmitter = _interopRequireDefault(__webpack_require__(53068));
var _utils = __webpack_require__(46580);
var _log = _interopRequireDefault(__webpack_require__(89130));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var MODE = {
  STRAIGHT: 'STRAIGHT',
  SINGLE: 'SINGLE',
  LOOP: 'LOOP'
};
var STATUS = {
  PLAYING: 'PLAYING',
  PAUSED: 'PAUSED',
  STOPPED: 'STOPPED',
  ERROR: 'ERROR'
};
var END_REASON = {
  COMPLETE: 'COMPLETE',
  ERROR: 'ERROR',
  MANUAL: 'MANUAL'
};
var NEXT_INDEX_INITIATOR = {
  INIT: 'INIT',
  NORMAL: 'NORMAL',
  LOOP: 'LOOP'
};
var isEmpty = function isEmpty(x) {
  return x === undefined || x === null;
};
var initialState = {
  startUrl: null,
  startIndex: null,
  endIndex: null,
  nextIndex: null,
  nextIndexInitiator: NEXT_INDEX_INITIATOR.INIT,
  errorIndex: null,
  doneIndices: [],
  mode: MODE.STRAIGHT,
  resources: [],
  // preDelay: 0,
  // postDelay: 0,

  status: STATUS.STOPPED
};

// Note: A generic player for consuming some kind of resources
// It supports 3 modes: single, straight, loop.
// Also for straight and loop, it can start or end at any valid index you want
//
// The main API of a player is
// 1. constructor({ run: Function,  prepare: Function })
// 2. play(config)
// 3. pause()
// 4. resume()
// 5. stop()
//
// Events it emits
// 1. START
// 2. PREPARED
// 3. TO_PLAY
// 4. PLAYED_LIST
// 5. PAUSED
// 6. RESUMED
// 7. END
// 8. ERROR
var Player = exports.Player = /*#__PURE__*/function () {
  function Player(opts, state) {
    _classCallCheck(this, Player);
    _defineProperty(this, "state", _objectSpread({}, initialState));
    _defineProperty(this, "toResumePromises", {});
    if (!opts) {
      throw new Error('Player - constructor: must provide opts as 1st argument');
    }
    if (typeof opts.run !== 'function') {
      throw new Error('Player - constructor: must provide a run function');
    }
    if (typeof opts.prepare !== 'function') {
      throw new Error('Player - constructor: must provide a prepare function');
    }
    if (typeof opts.handleResult !== 'function') {
      throw new Error('Player - constructor: must provide a handleResult function');
    }
    this.__run = opts.run;
    this.__prepare = opts.prepare;
    this.__handle = opts.handleResult;
    this.__setState(state || {});
  }
  _createClass(Player, [{
    key: "play",
    value: function play(config) {
      var _this = this;
      if (!config) {
        throw new Error('Player - play: config should not be empty');
      }
      if (!config.mode || Object.keys(MODE).indexOf(config.mode) === -1) {
        throw new Error('Player - play: must provide a valid mode, now it is ' + config.mode);
      }
      if (config.mode === MODE.LOOP && (!config.loopsStart || config.loopsStart < 0 || Math.floor(config.loopsStart) !== config.loopsStart || !config.loopsEnd || config.loopsEnd < config.loopsStart || Math.floor(config.loopsEnd) !== config.loopsEnd)) {
        throw new Error("Player - play: must provide a valid tuple of \"loopsStart\" and \"loopsEnd\" in loop mode, now it is ".concat(config.loopsStart, ", ").concat(config.loopsEnd));
      }
      if (config.resources.length !== 0) {
        if (isEmpty(config.startIndex) || config.startIndex < 0 || config.startIndex >= config.resources.length) {
          throw new Error("Player - play: startIndex out of range, now it is ".concat(config.startIndex, ", len: ").concat(config.resources.length));
        }
      }

      // Note: endIndex could be omitted
      if (!isEmpty(config.endIndex) && (config.endIndex < 0 || config.endIndex >= config.resources.length)) {
        throw new Error("Player - play: endIndex out of range, now it is ".concat(config.endIndex, ", len: ").concat(config.resources.length));
      }
      var nextIndex = config.nextIndex,
        startIndex = config.startIndex,
        startUrl = config.startUrl,
        resources = config.resources,
        title = config.title,
        extra = config.extra,
        doneIndices = config.doneIndices,
        noEndEvent = config.noEndEvent,
        token = config.token,
        isStep = config.isStep,
        loopsCursor = config.loopsCursor,
        loopsStart = config.loopsStart,
        loopsEnd = config.loopsEnd,
        isBackFromCalling = config.isBackFromCalling,
        needDelayAfterLoop = config.needDelayAfterLoop;
      var endIndex = config.endIndex || resources.length - 1;
      var basicState = {
        token: token,
        title: title,
        extra: extra,
        needDelayAfterLoop: needDelayAfterLoop,
        isBackFromCalling: isBackFromCalling,
        startUrl: startUrl,
        startIndex: startIndex,
        endIndex: endIndex,
        nextIndex: nextIndex !== undefined ? nextIndex : startIndex,
        errorIndex: null,
        doneIndices: doneIndices || [],
        mode: config.mode,
        loopsCursor: 1,
        loopsStart: 1,
        loopsEnd: 1,
        isStep: isStep || false,
        noEndEvent: noEndEvent || false,
        resources: config.resources,
        breakpoints: config.breakpoints || [],
        status: STATUS.PLAYING,
        "public": config["public"] || {},
        callback: config.callback || function () {},
        lastPlayConfig: config,
        playUID: Math.random()
      };
      ['preDelay', 'postDelay'].forEach(function (key) {
        if (isEmpty(config[key])) return;
        basicState[key] = config[key];
      });
      switch (config.mode) {
        case MODE.STRAIGHT:
          this.__setState(_objectSpread({}, basicState));
          break;
        case MODE.SINGLE:
          this.__setState(_objectSpread(_objectSpread({}, basicState), {}, {
            endIndex: startIndex
          }));
          break;
        case MODE.LOOP:
          this.__setState(_objectSpread(_objectSpread({}, basicState), {}, {
            loopsStart: loopsStart,
            loopsEnd: loopsEnd,
            loopsCursor: loopsCursor !== undefined ? loopsCursor : loopsStart
          }));
          break;
        default:
          break;
      }
      this.emit('START', {
        title: title,
        loopsCursor: this.state.loopsCursor,
        doneIndices: this.state.doneIndices,
        extra: this.state.extra,
        isBackFromCalling: this.state.isBackFromCalling
      });
      return Promise.resolve().then(function () {
        return _this.__prepare(_this.state);
      }).then(function () {
        _this.emit('PREPARED', {
          title: title,
          loopsCursor: _this.state.loopsCursor,
          doneIndices: _this.state.doneIndices,
          extra: _this.state.extra,
          isBackFromCalling: _this.state.isBackFromCalling
        });
      }).then(function () {
        return _this.__go(_this.state.token || null);
      }, function (e) {
        return _this.__errLog(e, e.errorIndex);
      });
    }
  }, {
    key: "pause",
    value: function pause() {
      var _this2 = this;
      this.__setState({
        status: STATUS.PAUSED
      });
      setTimeout(function () {
        _this2.emit('PAUSED', {
          extra: _this2.state.extra
        });
      }, 0);
      return this.__createPromiseWaitForResume(this.state.token);
    }
  }, {
    key: "resume",
    value: function resume(isStep) {
      this.__setState({
        status: STATUS.PLAYING,
        isStep: !!isStep
      });
      this.emit('RESUMED', {
        extra: this.state.extra
      });
      // this.__go(null)

      var item = this.toResumePromises[this.state.token];
      if (item && item.resolve) {
        item.resolve();
      }
    }
  }, {
    key: "stop",
    value: function stop(opts) {
      this.__end(END_REASON.MANUAL, opts);
    }
  }, {
    key: "stopWithError",
    value: function stopWithError(error) {
      this.__errLog(error);
    }
  }, {
    key: "jumpTo",
    value: function jumpTo(nextIndex) {
      var resources = this.state.resources;

      // Note: validate nextIndex by resources.length instead of startIndex and endIndex,
      // to make it possible for 'run from here' to jump to commands ahead of the start point
      if (nextIndex < 0 || nextIndex >= resources.length) {
        throw new Error('jumpTo: nextIndex out of range');
      }
      this.__setState({
        nextIndex: nextIndex
      });
    }
  }, {
    key: "setPostDelay",
    value: function setPostDelay(n) {
      this.__setState({
        postDelay: n
      });
    }
  }, {
    key: "setSuperFastMode",
    value: function setSuperFastMode(val) {
      this.__setState({
        superFast: val
      });
    }
  }, {
    key: "getStatus",
    value: function getStatus() {
      return this.state.status;
    }
  }, {
    key: "getState",
    value: function getState() {
      return _objectSpread({}, this.state);
    }
  }, {
    key: "setState",
    value: function setState(state) {
      return this.__setState(state);
    }
  }, {
    key: "replayLastConfig",
    value: function replayLastConfig() {
      var config = this.state.lastPlayConfig;
      if (!config) throw new Error('No last play config available');
      return this.play(_objectSpread(_objectSpread({}, config), {}, {
        nextIndex: config.startIndex
      }));
    }

    // Note: playUID changes on every `play` call
    // it's useful for features with timer to tell if it should continue to run
  }, {
    key: "getPlayUID",
    value: function getPlayUID() {
      return this.state.playUID;
    }
  }, {
    key: "checkPlayUID",
    value: function checkPlayUID(uid) {
      return this.state.playUID === uid;
    }
  }, {
    key: "__go",
    value: function __go(token) {
      var _this3 = this;
      // Note: in case it is returned from previous call

      if (token === undefined || token === null) {
        this.state.token = token = Math.random();
      } else if (token !== this.state.token) {
        return;
      }
      var guardToken = function guardToken(fn) {
        return function () {
          if (token !== _this3.state.token) {
            throw new Error('token expired');
          }
          return fn.apply(void 0, arguments);
        };
      };
      var _this$state = this.state,
        resources = _this$state.resources,
        nextIndex = _this$state.nextIndex,
        preDelay = _this$state.preDelay;
      var pre = preDelay > 0 ? this.__delay(function () {
        return undefined;
      }, preDelay) : Promise.resolve();

      // Note: the flow of this process:
      // 1. delay if `preDelay` set
      // 2. check `__shouldContinue`
      // 3. stop if the player is stopped or paused
      // 4. otherwise call `__run` to actually consume the current resource
      // 5. set the state to next by calling `__setNext`
      // 6. delay if `postDelay` set
      return pre.then(function () {
        return _this3.__shouldContinue();
      }).then(function (_ref) {
        var _this3$state$breakpoi;
        var paused = _ref.paused,
          complete = _ref.complete;
        if (paused) {
          throw new Error('player: paused or stopped');
        }
        if (complete) {
          return;
        }
        var _this3$state = _this3.state,
          resources = _this3$state.resources,
          nextIndex = _this3$state.nextIndex,
          startIndex = _this3$state.startIndex,
          loopsCursor = _this3$state.loopsCursor,
          loopsStart = _this3$state.loopsStart,
          loopsEnd = _this3$state.loopsEnd,
          nextIndexInitiator = _this3$state.nextIndexInitiator,
          superFast = _this3$state.superFast;
        var obj = {
          loopsCursor: loopsCursor,
          index: nextIndex,
          currentLoop: loopsCursor - loopsStart + 1,
          loops: loopsEnd - loopsStart + 1,
          resource: resources[nextIndex],
          extra: _this3.state.extra
        };

        // Note: when we're running loops
        var isBottomFrame = !_this3.state.extra || _this3.state.extra.isBottomFrame;
        if (isBottomFrame && nextIndex === startIndex) {
          if (nextIndexInitiator === NEXT_INDEX_INITIATOR.LOOP || nextIndexInitiator === NEXT_INDEX_INITIATOR.INIT) {
            _this3.emit('LOOP_START', obj);
          }
          if (nextIndexInitiator === NEXT_INDEX_INITIATOR.LOOP && loopsCursor !== loopsStart) {
            _this3.emit('LOOP_RESTART', obj);
          }
        }
        _this3.emit('TO_PLAY', {
          index: nextIndex,
          currentLoop: loopsCursor - loopsStart + 1,
          loops: loopsEnd - loopsStart + 1,
          resource: resources[nextIndex],
          extra: _this3.state.extra
        });
        var hasBreakpoints = ((_this3$state$breakpoi = _this3.state.breakpoints) === null || _this3$state$breakpoi === void 0 ? void 0 : _this3$state$breakpoi.length) > 0;

        // **Info: breakpoint promise takes 30ms
        var possibleBreakpointPromise = !hasBreakpoints ? Promise.resolve() : function () {
          (0, _log["default"])('8. possibleBreakpointPromise:>> ');
          // Note: there will never be two breakpoints in straight. Use `lastBreakpoint` to tell whether we just hit a breakpoint
          // Also note that, 'TO_PLAY' events need to be fired before we pause.
          if (_this3.state.lastBreakpoint === undefined && _this3.state.breakpoints.indexOf(nextIndex) !== -1) {
            _this3.__setState({
              lastBreakpoint: nextIndex
            });
            _this3.emit('BREAKPOINT', {
              index: nextIndex,
              currentLoop: loopsCursor - loopsStart + 1,
              loops: loopsEnd - loopsStart + 1,
              resource: resources[nextIndex],
              extra: _this3.state.extra
            });
            return _this3.pause();
          } else {
            _this3.__setState({
              lastBreakpoint: undefined
            });
            return Promise.resolve();
          }
        }();

        // Note: Check whether token expired or not after each async operations
        // Also also in the final catch to prevent unnecessary invoke of __errLog
        return possibleBreakpointPromise
        // ** This is where player run happens 
        .then(function () {
          return _this3.__run(resources[nextIndex], _this3.state);
        }).then(guardToken(function (res) {
          // Note: allow users to handle the result
          return _this3.__handle(res, resources[nextIndex], _this3.state).then(guardToken(function (nextIndex) {
            // Note: __handle has the chance to return a `nextIndex`, mostly when it's
            // from a flow logic. But still, it could be undefined for normal commands
            var oldLoopsCursor = _this3.state.loopsCursor;
            _this3.__setNext(nextIndex);
            // TODO: re-consider this. It delays the chain by 20ms for this go to the next then statement
            if (!superFast) {
              _this3.emit('PLAYED_LIST', {
                indices: _this3.state.doneIndices,
                extra: _this3.state.extra
              });
            }
            return oldLoopsCursor !== _this3.state.loopsCursor;
          })).then(function (isLoopsCursorChanged) {
            // __handle may change postDelay
            var _this3$state2 = _this3.state,
              postDelay = _this3$state2.postDelay,
              needDelayAfterLoop = _this3$state2.needDelayAfterLoop;
            var delay = Math.max(postDelay, isLoopsCursorChanged && needDelayAfterLoop ? 10 : 0);
            return delay > 0 ? _this3.__delay(function () {
              return undefined;
            }, delay) : Promise.resolve();
          }).then(function () {
            if (_this3.state.isStep) return _this3.pause().then(function () {
              return _this3.__go(token);
            });
            return _this3.__go(token);
          });
        }))["catch"](guardToken(function (err) {
          return _this3.__errLog(err);
        }));
      });
    }
  }, {
    key: "__shouldContinue",
    value: function __shouldContinue() {
      var _this$state2 = this.state,
        status = _this$state2.status,
        mode = _this$state2.mode,
        nextIndex = _this$state2.nextIndex,
        startIndex = _this$state2.startIndex,
        endIndex = _this$state2.endIndex,
        token = _this$state2.token;
      var ret;
      if (status === STATUS.PAUSED || status === STATUS.STOPPED) {
        // Note: when it's paused, use a pending promise to holde the execution
        // so we can continue running after resume and resolve the promise
        var promiseItem = this.toResumePromises[this.state.token];
        return promiseItem ? promiseItem.promise.then(function () {
          return {};
        }) : {
          paused: true
        };
      }
      if (status === STATUS.PLAYING && nextIndex >= startIndex && nextIndex <= endIndex) {
        return Promise.resolve({
          paused: false,
          complete: false
        });
      }

      // Note: make this function return promise, just in case
      // an async check is needed in future

      this.__end(END_REASON.COMPLETE);
      return Promise.resolve({
        complete: true
      });
    }
  }, {
    key: "__createPromiseWaitForResume",
    value: function __createPromiseWaitForResume(token) {
      var _this4 = this;
      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          _this4.toResumePromises[token] = {
            resolve: resolve,
            reject: reject,
            promise: p
          };
        }, 10);
      });
      return p;
    }
  }, {
    key: "__createPromiseForStop",
    value: function __createPromiseForStop(token, stopReason) {
      var _this5 = this;
      var p = new Promise(function (resolve, reject) {
        setTimeout(function () {
          _this5.toResumePromises[token] = {
            resolve: resolve,
            reject: reject,
            promise: p
          };
          reject(new Error("Stop reason: ".concat(stopReason)));
        }, 10);
      });
      return p;
    }
  }, {
    key: "__end",
    value: function __end(reason, opts) {
      // Note: CANNOT end the player twice
      if (this.state.status === STATUS.STOPPED) return;
      if (Object.keys(END_REASON).indexOf(reason) === -1) {
        throw new Error('Player - __end: invalid reason, ' + reason);
      }
      var silent = opts && opts.silent;
      var noEndEvent = this.state.noEndEvent && reason === END_REASON.COMPLETE;
      if (!noEndEvent && !silent) {
        this.emit('END', {
          opts: opts,
          reason: reason,
          extra: this.state.extra
        });
        if (reason !== END_REASON.ERROR) {
          this.state.callback(null, reason);
        }
      }
      if (reason !== END_REASON.COMPLETE) {
        this.__createPromiseForStop(this.state.token, reason);
      }
      this.__setState({
        status: STATUS.STOPPED
      });
      if (this.state.extra && this.state.extra.isBottomFrame) {
        this.__setState({
          nextIndexInitiator: NEXT_INDEX_INITIATOR.INIT
        });
      }
    }
  }, {
    key: "__errLog",
    value: function __errLog(err, errorIndex) {
      // Note: CANNOT log error if player is already stopped
      if (this.state.status === STATUS.STOPPED) {
        throw new Error(err);
      }
      this.emit('ERROR', {
        errorIndex: errorIndex !== undefined ? errorIndex : this.state.nextIndex,
        msg: err && err.message,
        stack: err && err.stack,
        extra: this.state.extra,
        restart: !!err.restart
      });
      this.state.callback(err, null);
      this.__end(END_REASON.ERROR);
      throw new Error(err);
    }
  }, {
    key: "__setNext",
    value: function __setNext(nextIndexPassed) {
      if (nextIndexPassed !== undefined && (nextIndexPassed < 0 || nextIndexPassed > this.state.resources.length)) {
        // Note: nextIndexPassed is allowed to be equal to resources.length
        // That means we run out of commands
        throw new Error("invalid nextIndexPassed ".concat(nextIndexPassed));
      }
      var _this$state3 = this.state,
        mode = _this$state3.mode,
        doneIndices = _this$state3.doneIndices,
        nextIndex = _this$state3.nextIndex,
        endIndex = _this$state3.endIndex,
        startIndex = _this$state3.startIndex,
        loopsCursor = _this$state3.loopsCursor,
        loopsEnd = _this$state3.loopsEnd;
      var nextIndexToSet = nextIndexPassed !== undefined ? nextIndexPassed : nextIndex + 1;
      var done = doneIndices.indexOf(nextIndex) === -1 ? [].concat(_toConsumableArray(doneIndices), [nextIndex]) : doneIndices;
      var lcur = loopsCursor;
      var next = null;
      var initiator = NEXT_INDEX_INITIATOR.NORMAL;
      if (mode === MODE.LOOP) {
        if (nextIndexToSet <= endIndex) {
          next = nextIndexToSet;
        } else if (loopsCursor >= loopsEnd) {
          next = nextIndexToSet;
        } else {
          lcur += 1;
          next = startIndex;
          done = [];
          initiator = NEXT_INDEX_INITIATOR.LOOP;
        }
      } else {
        next = nextIndexToSet;
      }

      // __setNext is still called after __end
      // so to protect the INIT value, check whether
      // it's already stopped
      if (this.state.status === STATUS.STOPPED && this.state.nextIndexInitiator === NEXT_INDEX_INITIATOR.INIT) {
        initiator = NEXT_INDEX_INITIATOR.INIT;
      }
      this.__setState({
        loopsCursor: lcur,
        nextIndex: next,
        nextIndexInitiator: initiator,
        doneIndices: done
      });
    }
  }, {
    key: "__setState",
    value: function __setState(obj) {
      this.state = _objectSpread(_objectSpread({}, this.state), obj);
    }
  }, {
    key: "__delay",
    value: function __delay(fn, timeout) {
      var _this6 = this;
      var past = 0;
      var timer = setInterval(function () {
        past += 1000;
        _this6.emit('DELAY', {
          extra: _this6.state.extra,
          total: timeout,
          past: past
        });
      }, 1000);
      return (0, _utils.delay)(fn, timeout).then(function (res) {
        if (timer) clearInterval(timer);
        return res;
      });
    }
  }]);
  return Player;
}();
(0, _eventEmitter["default"])(Player.prototype);
Player.C = Player.prototype.C = {
  MODE: MODE,
  STATUS: STATUS,
  END_REASON: END_REASON
};
var playerPool = {};

// factory function to return a player singleton
var getPlayer = exports.getPlayer = function getPlayer() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var state = arguments.length > 1 ? arguments[1] : undefined;
  var name = opts.name || 'testCase';
  delete opts.name;
  if (Object.keys(opts).length > 0) {
    playerPool[name] = new Player(opts, state);
  }
  if (!playerPool[name]) {
    throw new Error('player not initialized');
  }
  return playerPool[name];
};

/***/ }),

/***/ 55720:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFocusedWindowSize = getFocusedWindowSize;
exports.getWindowSize = getWindowSize;
exports.resizeViewport = resizeViewport;
exports.resizeViewportOfTab = resizeViewportOfTab;
exports.resizeWindow = resizeWindow;
var _web_extension = _interopRequireDefault(__webpack_require__(41953));
var _utils = __webpack_require__(46580);
var _log = _interopRequireDefault(__webpack_require__(89130));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var calcOffset = function calcOffset(screenTotal, screenOffset, oldOffset, oldSize, newSize) {
  var preferStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var isCloserToStart = preferStart || oldOffset < screenTotal - oldOffset - oldSize;
  (0, _log["default"])('calcOffset', screenTotal, oldOffset, oldSize, newSize, preferStart);
  if (isCloserToStart) {
    return oldOffset;

    // Note: comment out a smarter position for now
    // if (newSize < oldSize) {
    //   return oldOffset
    // }

    // if (newSize < oldSize + oldOffset - screenOffset) {
    //   return oldSize + oldOffset - newSize
    // }

    // return screenOffset
  }
  if (!isCloserToStart) {
    var oldEndOffset = screenOffset + screenTotal - oldOffset - oldSize;
    return oldSize + oldOffset - newSize;

    // Note: comment out a smarter position for now
    // if (newSize < oldSize) {
    //   return oldSize + oldOffset - newSize
    // }

    // if (newSize < oldSize + oldEndOffset) {
    //   return oldOffset
    // }

    // return screenOffset + screenTotal - newSize
  }
};

// winSize.width
// winSize.height
function resizeWindow(winId, winSize, screenAvailableRect) {
  var sw = screenAvailableRect.width;
  var sh = screenAvailableRect.height;
  var sx = screenAvailableRect.x;
  var sy = screenAvailableRect.y;
  return _web_extension["default"].windows.get(winId).then(function (win) {
    var lastLeft = win.left;
    var lastTop = win.top;
    var lastWidth = win.width;
    var lastHeight = win.height;
    return _web_extension["default"].windows.update(winId, winSize).then(function (win) {
      var left = calcOffset(sw, sx, lastLeft, lastWidth, win.width);
      var top = calcOffset(sh, sy, lastTop, lastHeight, win.height, true);
      _web_extension["default"].windows.update(winId, {
        left: left,
        top: top
      });
      var actual = {
        width: win.width,
        height: win.height
      };
      return {
        actual: actual,
        desired: winSize,
        diff: ['width', 'height'].filter(function (key) {
          return actual[key] !== winSize[key];
        })
      };
    });
  });
}

// pureViewportSize.width
// pureViewportSize.height
// referenceViewportWindowSize.window.width
// referenceViewportWindowSize.window.height
// referenceViewportWindowSize.viewport.width
// referenceViewportWindowSize.viewport.height
function resizeViewport(winId, pureViewportSize, screenAvailableRect) {
  var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var maxRetry = 2;
  (0, _log["default"])('resizeViewport, ROUND', count);
  return getWindowSize(winId).then(function (currentSize) {
    logWindowSize(currentSize);
    var dx = currentSize.window.width - currentSize.viewport.width;
    var dy = currentSize.window.height - currentSize.viewport.height;
    var newWinSize = {
      width: dx + pureViewportSize.width,
      height: dy + pureViewportSize.height
    };
    (0, _log["default"])('size set to', newWinSize);
    return resizeWindow(winId, newWinSize, screenAvailableRect).then(function () {
      return getWindowSize(winId);
    }).then(function (newSize) {
      logWindowSize(newSize);
      var data = {
        actual: newSize.viewport,
        desired: pureViewportSize,
        diff: ['width', 'height'].filter(function (key) {
          return newSize.viewport[key] !== pureViewportSize[key];
        })
      };
      if (data.diff.length === 0 || count >= maxRetry) {
        return data;
      }
      return (0, _utils.delay)(function () {}, 0).then(function () {
        return resizeViewport(winId, pureViewportSize, screenAvailableRect, count + 1);
      });
    });
  });
}
function resizeViewportOfTab(tabId, pureViewportSize, screenAvailableRect) {
  return _web_extension["default"].tabs.get(tabId).then(function (tab) {
    return resizeViewport(tab.windowId, pureViewportSize, screenAvailableRect);
  });
}

// size.window.width
// size.window.height
// size.window.left
// size.window.top
// size.viewport.wdith
// size.viewport.height
function getWindowSize(winId) {
  return _web_extension["default"].windows.get(winId, {
    populate: true
  }).then(function (win) {
    var tab = win.tabs.find(function (tab) {
      return tab.active;
    });
    return {
      window: {
        width: win.width,
        height: win.height,
        left: win.left,
        top: win.top
      },
      viewport: {
        width: tab.width,
        height: tab.height
      }
    };
  });
}
function getFocusedWindowSize() {
  return _web_extension["default"].windows.getLastFocused().then(function (win) {
    return getWindowSize(win.id);
  });
}
function logWindowSize(winSize) {
  (0, _log["default"])(winSize.window, winSize.viewport);
  (0, _log["default"])('dx = ', winSize.window.width - winSize.viewport.width);
  (0, _log["default"])('dy = ', winSize.window.height - winSize.viewport.height);
}

/***/ }),

/***/ 54836:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createVarsFilter = void 0;
exports["default"] = varsFactory;
exports.getVarsInstance = void 0;
var _registry = __webpack_require__(50149);
var _utils = __webpack_require__(46580);
var _languages = __webpack_require__(64013);
var _ts_utils = __webpack_require__(1601);
var _cv_utils = __webpack_require__(7345);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var standardKeyConstants = ['KEY_LEFT', 'KEY_UP', 'KEY_RIGHT', 'KEY_DOWN', 'KEY_PGUP', 'KEY_PAGE_UP', 'KEY_PGDN', 'KEY_PAGE_DOWN', 'KEY_BKSP', 'KEY_BACKSPACE', 'KEY_DEL', 'KEY_DELETE', 'KEY_ENTER', 'KEY_TAB', 'KEY_ESC', 'KEY_SPACE', 'KEY_HOME', 'KEY_END'];
var metaKeyConstants = ['KEY_CTRL', 'KEY_ALT', 'KEY_SHIFT', 'KEY_WIN', 'KEY_CMD', 'KEY_META'];
var fnKeyConstants = ['KEY_F1', 'KEY_F2', 'KEY_F3', 'KEY_F4', 'KEY_F5', 'KEY_F6', 'KEY_F7', 'KEY_F8', 'KEY_F9', 'KEY_F10', 'KEY_F11', 'KEY_F12', 'KEY_F13', 'KEY_F14', 'KEY_F15'];
var numericKeyConstants = ['KEY_Num0', 'KEY_Num1', 'KEY_Num2', 'KEY_Num3', 'KEY_Num4', 'KEY_Num5', 'KEY_Num6', 'KEY_Num7', 'KEY_Num8', 'KEY_Num9'];
var numberKeyConstants = ['KEY_0', 'KEY_1', 'KEY_2', 'KEY_3', 'KEY_4', 'KEY_5', 'KEY_6', 'KEY_7', 'KEY_8', 'KEY_9'];
var letterKeyConstants = ['KEY_A', 'KEY_B', 'KEY_C', 'KEY_D', 'KEY_E', 'KEY_F', 'KEY_G', 'KEY_H', 'KEY_I', 'KEY_J', 'KEY_K', 'KEY_L', 'KEY_M', 'KEY_N', 'KEY_O', 'KEY_P', 'KEY_Q', 'KEY_R', 'KEY_S', 'KEY_T', 'KEY_U', 'KEY_V', 'KEY_W', 'KEY_X', 'KEY_Y', 'KEY_Z'];
var keyConstants = [].concat(standardKeyConstants, metaKeyConstants, fnKeyConstants, numberKeyConstants, numericKeyConstants, letterKeyConstants).map(function (key) {
  return key.toUpperCase();
});
var isValidKeyConstant = function isValidKeyConstant(pattern) {
  var str = pattern && pattern.toUpperCase();
  if (keyConstants.indexOf(str) !== -1) return true;
  if (/^KEY_\w+(\+KEY_\w+)*$/.test(str)) {
    var keys = str.split('+');
    return _utils.and.apply(void 0, _toConsumableArray(keys.map(function (s) {
      return keyConstants.indexOf(s) !== -1;
    })));
  }
  return false;
};
var DEFAULT_KEY = 'main';
var cache = {};
var validateVariableName = function validateVariableName(name) {
  if (name.charAt(0) === '!') {
    name = name.substr(1);
  }
  try {
    (0, _utils.validateStandardName)(name);
  } catch (e) {
    throw new Error("Invalid variable name '".concat(name, "'. A variable name ") + e.message);
  }
  return true;
};
var regDollarV2 = /\$\{((!?\w+)((\.\w+|\[(\d+|\$\{!?\w+\})\])*))\}/gi;
var regStoredVars = /storedVars\[('|")((!?\w+)((\.\w+|\[(\d+|\$\{!?\w+\})\])*))\1\]/gi;
function substrToList(substr) {
  var regSubstr = /\.(\w+)|\[(\d+|\$\{!?\w+\})\]/gi;
  var normalizedStr = substr && substr.trim();
  if (!normalizedStr || normalizedStr.length === 0) {
    return [];
  }
  var result = [];
  var lastEndIndex = -1;
  var m;

  // eslint-disable-next-line no-cond-assign
  while (m = regSubstr.exec(substr)) {
    if (!m || m.index !== lastEndIndex + 1) {
      throw new Error('Invalid variable expression');
    }
    result.push(m[1] || m[2]);
    lastEndIndex = lastEndIndex + m[0].length;
  }
  if (lastEndIndex !== normalizedStr.length - 1) {
    throw new Error('Invalid variable expression ending');
  }
  return result;
}
function listToSubstr(list) {
  return list.map(function (str) {
    return /^\d+$/.test(str) ? "[".concat(str, "]") : ".".concat(str);
  }).join('');
}
function varsFactory() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_KEY;
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var isBoolean = function isBoolean(val) {
    return ['TRUE', 'FALSE'].indexOf((val + '').toUpperCase()) !== -1;
  };
  var opts = _objectSpread({
    isInvalidInternalVar: function isInvalidInternalVar(key) {
      return key.indexOf('!') === 0 && key !== '!TIMEOUT_PAGELOAD' && key !== '!TIMEOUT_WAIT' && key !== '!TIMEOUT_MACRO' && key !== '!TIMEOUT_DOWNLOAD' && key !== '!TIMEOUT_DOWNLOAD_START' && key !== '!REPLAYSPEED' && key !== '!LOOP' && key !== '!TESTSUITE_LOOP' && key !== '!URL' && key !== '!CURRENT_TAB_NUMBER' && key !== '!CURRENT_TAB_NUMBER_RELATIVE' && key !== '!CURRENT_TAB_NUMBER_RELATIVE_INDEX' && key !== '!CURRENT_TAB_NUMBER_RELATIVE_ID' && key !== '!MACRONAME' && key !== '!RUNTIME' && key !== '!CSVLINE' && key !== '!CSVLINE' && key !== '!LASTCOMMANDOK' && key !== '!ERRORIGNORE' && key !== '!CSVREADLINENUMBER' && key !== '!CSVREADSTATUS' && key !== '!CSVREADMAXROW' && key !== '!CLIPBOARD' && key !== '!STATUSOK' && key !== '!WAITFORVISIBLE' && key !== '!IMAGEX' && key !== '!IMAGEY' && key !== '!IMAGEWIDTH' && key !== '!IMAGEHEIGHT' && key !== '!VISUALSEARCHAREA' && key !== '!STOREDIMAGERECT' && key !== '!STRINGESCAPE' && key !== '!CMD_VAR1' && key !== '!CMD_VAR2' && key !== '!CMD_VAR3' && key !== '!OCRLANGUAGE' && key !== '!OCRENGINE' && key !== '!OCRSCALE' && key !== '!OCRTABLEEXTRACTION' && key !== '!OCRX' && key !== '!OCRY' && key !== '!OCRHEIGHT' && key !== '!OCRWIDTH' && key !== '!OCR_LEFT_X' && key !== '!OCR_RIGHT_X' && key !== '!BROWSER' && key !== '!OS' && key !== '!TIMES' && key !== '!FOREACH' && key !== '!CVSCOPE' && key !== '!XRUN_EXITCODE' && key !== '!PROXY_EXEC_COUNT' && key !== '!GLOBAL_TESTSUITE_STOP_ON_ERROR' && key !== '!LAST_DOWNLOADED_FILE_NAME' && !/^!COL\d+$/i.test(key);
    },
    readonly: ['!LOOP', 'TESTSUITE_LOOP', '!URL', '!CURRENT_TAB_NUMBER', '!CURRENT_TAB_NUMBER_RELATIVE', '!CURRENT_TAB_NUMBER_RELATIVE_ID', '!CURRENT_TAB_NUMBER_RELATIVE_INDEX', '!MACRONAME', '!RUNTIME', '!LASTCOMMANDOK', '!CSVREADSTATUS', '!CSVREADMAXROW', '!VISUALSEARCHAREA', '!BROWSER', '!OS', '!CVSCOPE', '!XRUN_EXITCODE', '!PROXY_EXEC_COUNT', '!TIMES', '!FOREACH', '!LAST_DOWNLOADED_FILE_NAME'].concat(_toConsumableArray(keyConstants)),
    typeCheck: {
      '!REPLAYSPEED': function REPLAYSPEED(val) {
        return ['SLOWV1', 'SLOW', 'MEDIUMV1', 'MEDIUM', 'FASTV1', 'FAST', 'NODISPLAYV1', 'NODISPLAY'].indexOf((val || '').toUpperCase()) !== -1;
      },
      '!TIMEOUT_PAGELOAD': function TIMEOUT_PAGELOAD(val) {
        return parseInt(val, 10) >= 0;
      },
      '!TIMEOUT_WAIT': function TIMEOUT_WAIT(val) {
        return parseInt(val, 10) >= 0;
      },
      '!TIMEOUT_MACRO': function TIMEOUT_MACRO(val) {
        return parseInt(val, 10) >= 0;
      },
      '!TIMEOUT_DOWNLOAD': function TIMEOUT_DOWNLOAD(val) {
        return parseInt(val, 10) >= 0;
      },
      '!TIMEOUT_DOWNLOAD_START': function TIMEOUT_DOWNLOAD_START(val) {
        return parseInt(val, 10) >= 0;
      },
      '!CSVREADLINENUMBER': function CSVREADLINENUMBER(val) {
        return parseInt(val, 10) >= 0;
      },
      '!OCRLANGUAGE': function OCRLANGUAGE(val, store) {
        return (0, _languages.isValidOCRLanguage)(val, window['store']);
      },
      '!OCRENGINE': function OCRENGINE(val) {
        return [1, 2, 98, 99].indexOf(parseInt(val, 10)) !== -1;
      },
      '!OCRSCALE': isBoolean,
      '!OCRX': function OCRX(val) {
        return parseInt(val, 10) >= 0;
      },
      '!OCRY': function OCRY(val) {
        return parseInt(val, 10) >= 0;
      },
      '!OCRHEIGHT': function OCRHEIGHT(val) {
        return parseInt(val, 10) >= 0;
      },
      '!OCRWIDTH': function OCRWIDTH(val) {
        return parseInt(val, 10) >= 0;
      },
      '!OCR_LEFT_X': function OCR_LEFT_X(val) {
        return parseInt(val, 10) >= 0;
      },
      '!OCR_RIGHT_X': function OCR_RIGHT_X(val) {
        return parseInt(val, 10) >= 0;
      },
      '!ERRORIGNORE': isBoolean,
      '!STATUSOK': isBoolean,
      '!WAITFORVISIBLE': isBoolean,
      '!STRINGESCAPE': isBoolean,
      '!GLOBAL_TESTSUITE_STOP_ON_ERROR': isBoolean,
      '!CVSCOPE': function CVSCOPE(val) {
        return [_cv_utils.ComputerVisionType.Browser, _cv_utils.ComputerVisionType.Desktop, _cv_utils.ComputerVisionType.DesktopScreenCapture].indexOf(val) !== -1;
      }
    },
    normalize: function normalize(key, val) {
      var upperKey = key.toUpperCase();
      var acceptStringTrueFalse = function acceptStringTrueFalse(val) {
        if (val === 'true') return true;
        if (val === 'false') return false;
        return val;
      };
      var num = function num(s) {
        return parseFloat(s);
      };
      switch (upperKey) {
        case '!ERRORIGNORE':
        case '!STATUSOK':
        case '!WAITFORVISIBLE':
        case '!STRINGESCAPE':
        case '!GLOBAL_TESTSUITE_STOP_ON_ERROR':
        case '!OCRSCALE':
        case '!OCRTABLEEXTRACTION':
          return acceptStringTrueFalse(val);
        case '!TIMEOUT_PAGELOAD':
        case '!TIMEOUT_WAIT':
        case '!TIMEOUT_MACRO':
        case '!TIMEOUT_DOWNLOAD':
        case '!TIMEOUT_DOWNLOAD_START':
        case '!OCRENGINE':
          return num(val);
        default:
          return val;
      }
    }
  }, options);
  var vars = initial;
  var listeners = new _registry.Registry({
    process: function process(fn, data, eventName) {
      return fn(data);
    }
  });
  var fireOnChange = function fireOnChange() {
    return listeners.fire('change', {
      vars: Object.assign({}, vars)
    });
  };
  var self = {
    reset: function reset() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (options.keepGlobal) {
        var globals = Object.keys(vars).reduce(function (prev, key) {
          if (/^!?global/i.test(key) || /^!TESTSUITE_LOOP$/i.test(key)) {
            prev[key] = vars[key];
          }
          return prev;
        }, {});
        vars = globals;
      } else {
        vars = {};
      }
      fireOnChange();
    },
    render: function render(str, options) {
      var _ref = options && options.withHashNotation ? [regStoredVars, 3, 4] : [regDollarV2, 2, 3],
        _ref2 = _slicedToArray(_ref, 3),
        reg = _ref2[0],
        mainIndex = _ref2[1],
        subIndex = _ref2[2];
      var decorate = options && options.shouldStringify ? function (x) {
        return JSON.stringify(x);
      } : _ts_utils.id;
      return self.replaceAllVars({
        str: str,
        reg: reg,
        decorate: decorate,
        getVarName: function getVarName(args) {
          return args[mainIndex];
        },
        getSubstring: function getSubstring(args) {
          return args[subIndex];
        }
      });
    },
    replaceAllVars: function replaceAllVars(params) {
      var str = params.str,
        reg = params.reg,
        _params$getVarName = params.getVarName,
        getVarName = _params$getVarName === void 0 ? function (args) {
          return args[1];
        } : _params$getVarName,
        _params$getSubstring = params.getSubstring,
        getSubstring = _params$getSubstring === void 0 ? function (args) {
          return args[2];
        } : _params$getSubstring,
        _params$decorate = params.decorate,
        decorate = _params$decorate === void 0 ? function (val) {
          return val;
        } : _params$decorate;
      return str.replace(reg, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var variable = (getVarName(args) || '').toUpperCase();
        var subs = substrToList(getSubstring(args)).map(function (key) {
          return self.render(key);
        });

        // Note: keep as it is if it's a KEY_XXX variable, which should be handled by command runner
        if (isValidKeyConstant(variable)) {
          return args[0];
        }
        var root = self.getVarForRender(variable);
        var rawValue = subs.reduce(function (prev, key, i) {
          if (prev === null || prev === undefined) {
            throw new Error("".concat(variable).concat(listToSubstr(subs.slice(0, i)), " is ").concat(prev));
          }
          return prev[key];
        }, root);
        return decorate(rawValue, args);
      });
    },
    getVarForRender: function getVarForRender(key) {
      var upperKey = (key || '').toUpperCase();
      if (upperKey in vars) {
        return vars[upperKey];
      } else {
        if (/^!cmd_var(1|2|3)$/i.test(upperKey)) return 'NOT_SET';
        if (/^!/.test(upperKey)) {
          throw new Error("Internal variable \"".concat(upperKey, "\" not supported"));
        } else {
          throw new Error("variable \"".concat(upperKey, "\" is not defined"));
        }
      }
    },
    get: function get(field) {
      return vars[field.toUpperCase()];
    },
    set: function set(obj, isAdmin) {
      Object.keys(obj).forEach(function (key) {
        var trimmedKey = key.trim();
        if (trimmedKey.length === 0) return;
        validateVariableName(trimmedKey);
        var targetKey = trimmedKey.toUpperCase();

        // Note: prevent variable with empty name
        if (targetKey.length === 0) return;

        // Note: special treatment for !CSVLINE
        if (/^!CSVLINE$/i.test(targetKey)) {
          var csvLine = self.get('!CSVLINE');
          if (csvLine === undefined) {
            csvLine = [];
          } else if (!Array.isArray(csvLine)) {
            csvLine = [csvLine];
          }
          csvLine.push(obj[key]);
          vars['!CSVLINE'] = csvLine;
          return;
        }
        if (!isAdmin && opts.readonly.indexOf(targetKey) !== -1) {
          throw new Error("Cannot write to readonly variable '".concat(key, "'"));
        }
        if (opts.isInvalidInternalVar(targetKey)) {
          throw new Error("Not allowed to write to '".concat(key, "'"));
        }
        if (opts.typeCheck[targetKey] && !opts.typeCheck[targetKey](obj[key])) {
          throw new Error("Value '".concat(obj[key], "' is not supported for variable \"").concat(targetKey, "\""));
        }
        vars[targetKey] = opts.normalize(key, obj[key]);
      });
      fireOnChange();
    },
    clear: function clear(reg) {
      Object.keys(vars).forEach(function (key) {
        if (reg.test(key)) {
          delete vars[key];
        }
      });
      fireOnChange();
    },
    isReadOnly: function isReadOnly(variable) {
      var str = variable && variable.toUpperCase ? variable.toUpperCase() : '';
      return opts.readonly.indexOf(str) !== -1;
    },
    dump: function dump() {
      return _objectSpread({}, vars);
    },
    onChange: function onChange(fn) {
      listeners.add('change', fn);
      return function () {
        return listeners.remove('change', fn);
      };
    }
  };
  cache[name] = self;
  return self;
}
var getVarsInstance = exports.getVarsInstance = function getVarsInstance() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_KEY;
  return cache[name];
};
var createVarsFilter = exports.createVarsFilter = function createVarsFilter(_ref3) {
  var _ref3$withUserDefined = _ref3.withUserDefined,
    withUserDefined = _ref3$withUserDefined === void 0 ? true : _ref3$withUserDefined,
    withCommonInternal = _ref3.withCommonInternal,
    withAdvancedInternal = _ref3.withAdvancedInternal;
  var checkUserDefined = function checkUserDefined(name) {
    return !/^!/.test(name);
  };
  var checkCommonInternal = function checkCommonInternal(name) {
    var list = ['!url', '!clipboard', '!runtime', '!statusok', '!errorignore'].map(function (x) {
      return x.toUpperCase();
    });
    return list.indexOf(name.toUpperCase()) !== -1;
  };
  var checkAdvancedInternal = function checkAdvancedInternal(name) {
    return /^!/.test(name) && !checkCommonInternal(name);
  };
  var orCheck = function orCheck(fns) {
    return function () {
      for (var i = 0, len = fns.length; i < len; i++) {
        if (fns[i].apply(fns, arguments)) return true;
      }
      return false;
    };
  };
  var list = [withUserDefined ? checkUserDefined : null, withCommonInternal ? checkCommonInternal : null, withAdvancedInternal ? checkAdvancedInternal : null].filter(function (x) {
    return !!x;
  });
  return orCheck(list);
};

/***/ }),

/***/ 64305:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getSaveTestCase;
var _react = _interopRequireDefault(__webpack_require__(96540));
var _reactDom = _interopRequireDefault(__webpack_require__(40961));
var _antd = __webpack_require__(33061);
var _index = __webpack_require__(35127);
var _recomputed = __webpack_require__(87307);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var SaveAsModal = /*#__PURE__*/function (_React$Component) {
  _inherits(SaveAsModal, _React$Component);
  function SaveAsModal() {
    var _this;
    _classCallCheck(this, SaveAsModal);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, SaveAsModal, [].concat(args));
    _defineProperty(_assertThisInitialized(_this), "state", {
      name: null
    });
    return _this;
  }
  _createClass(SaveAsModal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;
      if (this.props.name) {
        this.setState({
          name: this.props.name
        });
      }
      setTimeout(function () {
        var input = _this2.inputSaveTestCase.refs.input;
        input.focus();
        input.selectionStart = input.selectionEnd = input.value.length;
      }, 100);
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;
      return /*#__PURE__*/_react["default"].createElement(_antd.Modal, {
        title: "Save macro as..",
        okText: "Save",
        cancelText: "Cancel",
        open: true,
        onOk: function onOk() {
          return _this3.props.onOk(_this3.state.name);
        },
        onCancel: this.props.onCancel,
        className: "save-modal"
      }, /*#__PURE__*/_react["default"].createElement(_antd.Input, {
        style: {
          width: '100%'
        },
        onKeyDown: function onKeyDown(e) {
          e.keyCode === 13 && _this3.props.onOk(_this3.state.name);
        },
        onChange: function onChange(e) {
          return _this3.setState({
            name: e.target.value
          });
        },
        value: this.state.name || '',
        placeholder: "macro name",
        ref: function ref(el) {
          _this3.inputSaveTestCase = el;
        }
      }));
    }
  }]);
  return SaveAsModal;
}(_react["default"].Component);
var getContainer = function getContainer() {
  var id = 'save_test_case_container';
  var $el = document.getElementById(id);
  if ($el) return $el;
  var $new = document.createElement('div');
  $new.id = id;
  document.body.appendChild($new);
  return $new;
};
var getTestCaseName = function getTestCaseName(state) {
  var src = state.editor.editing.meta.src;
  return src && src.name && src.name.length ? src.name : 'Untitled';
};
var tryToSave = function tryToSave(store, testCaseName) {
  var $container = getContainer();
  var state = store.getState();
  var existed = !!state.editor.editing.meta.src;
  if (existed) {
    return store.dispatch((0, _index.saveEditingAsExisted)()).then(function () {
      return true;
    });
  }
  return new Promise(function (resolve, reject) {
    var onSave = function onSave(name) {
      return store.dispatch((0, _index.saveEditingAsNew)(name)).then(function () {
        _antd.message.success('successfully saved!', 1.5);
        resolve(true);
      }, function (e) {
        _antd.message.error(e.message, 1.5);
        reject(e);
      });
    };
    _reactDom["default"].render( /*#__PURE__*/_react["default"].createElement(SaveAsModal, {
      name: testCaseName,
      onOk: onSave,
      onCancel: function onCancel() {
        return resolve(false);
      }
    }), $container);
    // TODO
  }).then(function (saved) {
    _reactDom["default"].unmountComponentAtNode($container);
    return saved;
  })["catch"](function (e) {
    console.error(e.message);
    throw e;
  });
};
var factory = function factory(store) {
  var withIsSaving = function withIsSaving(fn) {
    store.dispatch((0, _index.updateUI)({
      isSaving: true
    }));
    return new Promise(function (resolve) {
      resolve(fn());
    })["finally"](function () {
      store.dispatch((0, _index.updateUI)({
        isSaving: false
      }));
    });
  };
  return {
    saveOrNot: function saveOrNot() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var state = store.getState();
      var hasUnsaved = (0, _recomputed.hasUnsavedMacro)(state);
      var isExisting = !!state.editor.editing.meta.src;
      var opts = _objectSpread({
        getTitle: function getTitle(data) {
          return "Unsaved changes in macro \"".concat(data.macroName, "\"");
        },
        getContent: function getContent(data) {
          return 'Do you want to discard or save these changes?';
        },
        okText: 'Save',
        cancelText: 'Discard'
      }, options || {});
      return withIsSaving(function () {
        if (!hasUnsaved) return Promise.resolve(true);
        if (isExisting && options.autoSaveExisting) {
          return tryToSave(store);
        }
        return new Promise(function (resolve, reject) {
          var macroName = getTestCaseName(state);
          _antd.Modal.confirm({
            title: opts.getTitle({
              macroName: macroName
            }),
            content: opts.getContent({
              macroName: macroName
            }),
            okText: opts.okText,
            cancelText: opts.cancelText,
            onOk: function onOk() {
              tryToSave(store).then(resolve, reject);
              return Promise.resolve(true);
            },
            onCancel: function onCancel() {
              resolve(false);
              return Promise.resolve(true);
            }
          });
        });
      });
    },
    save: function save(defaultName) {
      var state = store.getState();
      var hasUnsaved = (0, _recomputed.hasUnsavedMacro)(state);
      return withIsSaving(function () {
        if (!hasUnsaved) return Promise.resolve(true);
        return tryToSave(store, defaultName);
      });
    }
  };
};
var api;
function getSaveTestCase(store) {
  if (api) return api;
  if (!store) throw new Error('must provide store');
  api = factory(store);
  return api;
}

/***/ }),

/***/ 51302:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = exports["default"] = {
  "Core/DemoAutofill": {
    "CreationDate": "2020-05-28",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "store",
      "Target": "15",
      "Value": "!TIMEOUT_WAIT"
    }, {
      "Command": "store",
      "Target": "60",
      "Value": "!TIMEOUT_PAGELOAD"
    }, {
      "Command": "open",
      "Target": "https://docs.google.com/forms/d/1cbI5dMRs0-t_IwNzPm6T3lAG_nPgsnJZEA-FEYVARxg/",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"UI.Vision IDE\")]",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//*[text()[contains(.,'Web Testing')]]",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"Form Autofilling\")]",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//*[text()[contains(.,\"General Web Automation\")]]",
      "Value": ""
    }, {
      "Command": "pause",
      "Target": "500",
      "Value": ""
    }, {
      "Command": "captureScreenshot",
      "Target": "AutoFill1stPage${!LOOP}",
      "Value": ""
    }, {
      "Command": "clickAndWait",
      "Target": "xpath=//*[@id=\"mG61Hd\"]/div/div/div[3]/div/div/div/span/span",
      "Value": "",
      "Targets": ["xpath=//*[@id=\"mG61Hd\"]/div/div/div[3]/div/div/div/span/span", "xpath=//*[@id=\"mG61Hd\"]/div[2]/div/div[3]/div/div/div/span/span"]
    }, {
      "Command": "type",
      "Target": "xpath=//input[@type='text']",
      "Value": "This is a single line test..."
    }, {
      "Command": "type",
      "Target": "xpath=//textarea",
      "Value": "...and this a multiline test:\nLine2\nLine3"
    }, {
      "Command": "captureScreenshot",
      "Target": "AutoFill2ndPage${!LOOP}",
      "Value": ""
    }, {
      "Command": "pause",
      "Target": "1000",
      "Value": ""
    }, {
      "Command": "clickAndWait",
      "Target": "xpath=//*[@id=\"mG61Hd\"]/div/div/div[3]/div[1]/div[1]/div[2]/span/span",
      "Value": ""
    }, {
      "Command": "captureScreenshot",
      "Target": "AutoFill3rdPage${!LOOP}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "DemoAutofill macro completed (shown as notification because of #shownotification in the 3rd column)",
      "Value": "#shownotification"
    }, {
      "Command": "comment",
      "Target": "Open form filling tutorial page",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/rpa/docs/selenium-ide/form-filling",
      "Value": ""
    }, {
      "Command": "assertTitle",
      "Target": "*Form Filling*",
      "Value": ""
    }]
  },
  "Core/DemoDragDrop": {
    "CreationDate": "2017-10-18",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/demo/webtest/dragdrop/",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Reduce replay speed so we can better see what is going on...",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "medium",
      "Value": "!replayspeed"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=one",
      "Value": "id=bin"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=two",
      "Value": "id=bin"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=three",
      "Value": "id=bin"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=four",
      "Value": "id=bin"
    }, {
      "Command": "dragAndDropToObject",
      "Target": "id=five",
      "Value": "id=bin"
    }]
  },
  "Core/DemoDownload": {
    "CreationDate": "2018-11-23",
    "Commands": [{
      "Command": "store",
      "Target": "60",
      "Value": "!timeout_download"
    }, {
      "Command": "store",
      "Target": "10",
      "Value": "!timeout_wait"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var d=new Date(); return d.getFullYear() + '-' +((d.getMonth()+1))+'-' +d.getDate();",
      "Value": "todaydate"
    }, {
      "Command": "echo",
      "Target": "Today is ${todaydate}",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/filedownload",
      "Value": ""
    }, {
      "Command": "onDownload",
      "Target": "DownloadTest1_${todaydate}.exe",
      "Value": "true"
    }, {
      "Command": "store",
      "Target": "${!runtime}",
      "Value": "starttime"
    }, {
      "Command": "click",
      "Target": "linkText=XModules for Windows",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "File name on disk is ${!LAST_DOWNLOADED_FILE_NAME}",
      "Value": "blue"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return parseFloat(${!runtime})-parseFloat(${starttime})",
      "Value": "downloadtime"
    }, {
      "Command": "echo",
      "Target": "Download1 (Windows version) took ${downloadtime} seconds",
      "Value": "blue"
    }, {
      "Command": "onDownload",
      "Target": "DownloadTest2_${todaydate}.exe",
      "Value": "true"
    }, {
      "Command": "store",
      "Target": "${!runtime}",
      "Value": "starttime"
    }, {
      "Command": "click",
      "Target": "partialLinkText=for macOS",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "File name on disk is ${!LAST_DOWNLOADED_FILE_NAME}",
      "Value": "green"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return parseFloat(${!runtime})-parseFloat(${starttime})",
      "Value": "downloadtime"
    }, {
      "Command": "echo",
      "Target": "Download2 (Mac) took ${downloadtime} seconds",
      "Value": "green"
    }, {
      "Command": "echo",
      "Target": "All done...",
      "Value": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=OnDownload command",
      "Value": ""
    }]
  },
  "Core/DemoExtract": {
    "CreationDate": "2018-05-28",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/executescript",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Current page URL = ${!URL}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Current loop value = ${!LOOP}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "This macro shows various methods to extract and save data from a website",
      "Value": ""
    }, {
      "Command": "storeAttribute",
      "Target": "css=img.responsive-img@src",
      "Value": "mylink"
    }, {
      "Command": "echo",
      "Target": "href=${mylink}",
      "Value": ""
    }, {
      "Command": "storeAttribute",
      "Target": "css=img.responsive-img@alt",
      "Value": "myalttext"
    }, {
      "Command": "echo",
      "Target": "alt text = ${myalttext}",
      "Value": ""
    }, {
      "Command": "storeAttribute",
      "Target": "//input[@id='sometext']@size",
      "Value": "boxsize"
    }, {
      "Command": "echo",
      "Target": "input box size =${boxsize}",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "This box is ${boxsize} chars wide"
    }, {
      "Command": "executeScript",
      "Target": "document.title = ${boxsize};",
      "Value": ""
    }, {
      "Command": "assertTitle",
      "Target": "70",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[3]",
      "Value": ""
    }, {
      "Command": "storeText",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[3]",
      "Value": "myheader"
    }, {
      "Command": "echo",
      "Target": "header = ${myheader}",
      "Value": ""
    }, {
      "Command": "storeTitle",
      "Target": "",
      "Value": "mytitle"
    }, {
      "Command": "echo",
      "Target": "page title = ${mytitle}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "page title = ${mytitle}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "page title = ${mytitle}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "page title = ${mytitle}",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Now test some extraction with storeValue",
      "Value": ""
    }, {
      "Command": "storeValue",
      "Target": "id=sometext",
      "Value": "mytext"
    }, {
      "Command": "select",
      "Target": "id=tesla",
      "Value": "label=Model Y"
    }, {
      "Command": "storeValue",
      "Target": "id=tesla",
      "Value": "mytesla"
    }, {
      "Command": "echo",
      "Target": "The text box contains [${mytext}] and the select box has the value [${mytesla}] selected",
      "Value": ""
    }, {
      "Command": "verifyValue",
      "Target": "id=tesla",
      "Value": "y"
    }, {
      "Command": "storeChecked",
      "Target": "name=vehicle",
      "Value": "hasbike"
    }, {
      "Command": "storeChecked",
      "Target": "xpath=(//input[@name='vehicle'])[2]",
      "Value": "hascar"
    }, {
      "Command": "storeChecked",
      "Target": "xpath=(//input[@name='vehicle'])[3]",
      "Value": "hasboat"
    }, {
      "Command": "echo",
      "Target": "User has bike:${hasbike}, car:${hascar}, boat:${hasboat}",
      "Value": "green"
    }, {
      "Command": "comment",
      "Target": "Search and extract directly from the page SOURCE",
      "Value": "y"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=[\\$\\£\\€](\\d+(?:\\.\\d{1,2})?)",
      "Value": "match1"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=[\\$\\£\\€](\\d+(?:\\.\\d{1,2})?)@2",
      "Value": "match2"
    }, {
      "Command": "comment",
      "Target": "You can also extract without regex with the * symbol",
      "Value": "match2b"
    }, {
      "Command": "sourceExtract",
      "Target": "$*<",
      "Value": "match2b"
    }, {
      "Command": "echo",
      "Target": "Coffee costs ${match1} and tea ${match2}",
      "Value": "blue"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=_width: (\\d+)",
      "Value": "match1"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=_width: (\\d+)@1,1",
      "Value": "match1group1"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=_width: (\\d+)@2",
      "Value": "match2"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=_width: (\\d+)@2,1",
      "Value": "match2group1"
    }, {
      "Command": "echo",
      "Target": "match1 = [${MATCH1}] (group1 = [${match1group1}]) match2 =  [${MATCH2}]  (group1 = [${MATCH2GROUP1}])",
      "Value": "blue"
    }, {
      "Command": "comment",
      "Target": "Extract Google Analytics ID",
      "Value": ""
    }, {
      "Command": "sourceExtract",
      "Target": "G-*,",
      "Value": "ga_option1"
    }, {
      "Command": "sourceExtract",
      "Target": "regex=G-[0-9]+-[0-9]+",
      "Value": "ga_option2"
    }, {
      "Command": "echo",
      "Target": "Google Analytics ID = ${ga_option2}",
      "Value": "pink"
    }, {
      "Command": "comment",
      "Target": "Some assertion test for QA",
      "Value": ""
    }, {
      "Command": "if",
      "Target": "${match2group1} != 22",
      "Value": ""
    }, {
      "Command": "throwError",
      "Target": "Regex Extraction failed for Match2(1):  ${match2group1}",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Last but not least, taking a screenshot is another way to extract data",
      "Value": ""
    }, {
      "Command": "captureScreenshot",
      "Target": "myscreenshot_${mytitle}",
      "Value": ""
    }, {
      "Command": "storeImage",
      "Target": "//*[@id=\"page-header\"]/div/div/h1",
      "Value": "pagetitle.png"
    }, {
      "Command": "comment",
      "Target": "Export images to download folder",
      "Value": ""
    }, {
      "Command": "localStorageExport",
      "Target": "myscreenshot_${mytitle}.png",
      "Value": ""
    }, {
      "Command": "localStorageExport",
      "Target": "pagetitle.png",
      "Value": ""
    }]
  },
  "Core/DemoFrames": {
    "CreationDate": "2022-02-27",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/demo/webtest/frames/",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Reduce replay speed so we can better see what is going on...",
      "Value": "",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "medium",
      "Value": "!replayspeed",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=0",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "name=mytext1",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=mytext1",
      "Value": "Frame1 (index=0)",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=1",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "name=mytext2",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=mytext2",
      "Value": "Frame2 (index=1)",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=2",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "name=mytext3",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=mytext3",
      "Value": "Frame3 (index=2)",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=3",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "name=mytext4",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=mytext4",
      "Value": "Frame4 (index=3)",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=4",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "name=mytext5",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=mytext5",
      "Value": "Frame5 (index=4)",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=2",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=mytext3",
      "Value": "now testing iframe inside this frame",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=0",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"UI.Vision IDE\")]",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "xpath=//input[@type='text']",
      "Value": "iframe in frame: works!",
      "Description": ""
    }, {
      "Command": "clickAndWait",
      "Target": "xpath=//div[3]/div/div/div/span",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=entry.1572386418",
      "Value": "Form Filling Test Done!",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "xpath=//*[@id=\"mG61Hd\"]/div/div/div[3]/div[1]/div[1]/div[2]/span/span",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=2",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=mytext3",
      "Value": "Test completed!",
      "Description": ""
    }]
  },
  "Core/DemoTakeScreenshots": {
    "CreationDate": "2024-6-8",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/blog/",
      "Value": "",
      "Description": ""
    }, {
      "Command": "captureEntirePageScreenshot",
      "Target": "rpablog",
      "Value": "",
      "Description": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=read more@POS=1",
      "Value": "",
      "Description": ""
    }, {
      "Command": "captureEntirePageScreenshot",
      "Target": "article1",
      "Value": "",
      "Description": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/blog/",
      "Value": "",
      "Description": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=read more@POS=2",
      "Value": "",
      "Description": ""
    }, {
      "Command": "captureEntirePageScreenshot",
      "Target": "article2",
      "Value": "",
      "Description": ""
    }, {
      "Command": "captureScreenshot",
      "Target": "article2_just_viewport",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "take screenshot of an _element_ with storeImage",
      "Value": "",
      "Description": ""
    }, {
      "Command": "storeImage",
      "Target": "partialLinkText=Blog",
      "Value": "blogtitle",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Next: Run OCR on the screenshot to verify its content",
      "Value": "",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "eng",
      "Value": "!ocrlanguage",
      "Description": "English OCR"
    }, {
      "Command": "store",
      "Target": "98",
      "Value": "!ocrengine",
      "Description": "use Javascript OCR engine"
    }, {
      "Command": "OCRExtractScreenshot",
      "Target": "blogtitle.png",
      "Value": "ocr_result",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "OCR Result = ${ocr_result}",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "if",
      "Target": "${ocr_result}.indexOf(\"RPA\") !== -1",
      "Value": "",
      "Description": "Make sure string includes \"RPA\""
    }, {
      "Command": "echo",
      "Target": "yes, screenshot taking and OCR worked",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }]
  },
  "Core/DemoIfElse": {
    "CreationDate": "2018-4-28",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/executeScript",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "How to use gotoIf and label(s) for flow control. For a while/endWhile demo, see the DemoSaveCSV macro.",
      "Value": ""
    }, {
      "Command": "executeScript",
      "Target": "return (new Date().getHours())",
      "Value": "mytime"
    }, {
      "Command": "echo",
      "Target": "mytime = ${mytime}",
      "Value": ""
    }, {
      "Command": "if",
      "Target": "${mytime}  > 16",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Good afternoon!",
      "Value": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Good morning!",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "storeAttribute",
      "Target": "//input[@id='sometext-WRONG-ID-TEST']@size",
      "Value": "boxsize"
    }, {
      "Command": "if",
      "Target": "${boxsize} == \"#LNF\"",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "The xpath was not found. In this case the variable gets filled with #LNF (Locator Not Found).",
      "Value": "blue"
    }, {
      "Command": "storeAttribute",
      "Target": "//input[@id='sometext']@size",
      "Value": "boxsize"
    }, {
      "Command": "echo",
      "Target": "With correct Xpath ID we get: Boxsize = ${boxsize}",
      "Value": "green"
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "gotoIf",
      "Target": "${boxsize} > 70",
      "Value": "BOX-TOO-BIG"
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "This box is ${boxsize} chars wide"
    }, {
      "Command": "executeScript",
      "Target": "document.title = ${boxsize};",
      "Value": ""
    }, {
      "Command": "gotoLabel",
      "Target": "END",
      "Value": ""
    }, {
      "Command": "label",
      "Target": "BOX-TOO-BIG",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Input box too big. This is just a test of gotoIf",
      "Value": ""
    }, {
      "Command": "executeScript",
      "Target": "document.title = \"Just a gotoIf test. This line should not be reached unless you edit the macro\"",
      "Value": ""
    }, {
      "Command": "label",
      "Target": "END",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "test case completed",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "",
      "Value": ""
    }, {
      "Command": "onError",
      "Target": "#goto",
      "Value": "fixerror"
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "this line works"
    }, {
      "Command": "type",
      "Target": "id=sometextXXXXX",
      "Value": "this line has the wrong ID..."
    }, {
      "Command": "echo",
      "Target": "this line is never reached, because of the error above",
      "Value": "blue"
    }, {
      "Command": "gotoLabel",
      "Target": "end-part2",
      "Value": ""
    }, {
      "Command": "label",
      "Target": "fixerror",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "here we can have code that handles the error..",
      "Value": "green"
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "Fix Error Section: This command works."
    }, {
      "Command": "label",
      "Target": "end-part2",
      "Value": ""
    }]
  },
  "Core/DemoIframe": {
    "CreationDate": "2022-05-18",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/demo/iframes",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "//*[@id=\"content\"]/div[2]/div/p[1]",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[1]",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "First iframe: Embedded Google Doc",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "index=0",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "//span[contains(text(),\"UI.Vision IDE\")]",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "xpath=//input[@type='text']",
      "Value": "Automating a website inside an embedded iframe",
      "Description": ""
    }, {
      "Command": "clickAndWait",
      "Target": "xpath=//div[3]/div/div/div/span",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "name=entry.1572386418",
      "Value": "Form Filling Test Done!",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "xpath=//*[@id=\"mG61Hd\"]/div/div/div[3]/div[1]/div[1]/div[2]/span/span",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectFrame",
      "Target": "relative=top",
      "Value": "",
      "Description": "Back to main page (top frame)"
    }]
  },
  "Core/DemoImplicitWaiting": {
    "CreationDate": "2019-8-5",
    "Commands": [{
      "Command": "comment",
      "Target": "waitForElementVisible is not part of implicit waiting",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/waitforelementvisible",
      "Value": ""
    }, {
      "Command": "waitForElementVisible",
      "Target": "css=#div1 > h1",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "css=#div1 > h1",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "20",
      "Value": "!timeout_wait"
    }, {
      "Command": "waitForElementVisible",
      "Target": "css=#div2 > h1",
      "Value": ""
    }, {
      "Command": "click",
      "Target": "css=#div2 > h1",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Implicit waiting: Wait for elements to be loaded  or <timeout_wait> is reached",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/webtest/implicitwaiting/",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "15",
      "Value": "!TIMEOUT_WAIT"
    }, {
      "Command": "assertText",
      "Target": "/html/body/header/center/p[2]",
      "Value": "Use the select box to start the timer..."
    }, {
      "Command": "select",
      "Target": "id=minutesSelect",
      "Value": "label=5 Seconds"
    }, {
      "Command": "echo",
      "Target": "The next element (target) is not available yet... Ui.Vision waits for it up to ${!TIMEOUT_WAIT} seconds to appear.",
      "Value": "blue"
    }, {
      "Command": "click",
      "Target": "/html/body/header/center/img",
      "Value": ""
    }]
  },
  "Core/DemoCsvReadWithWhile": {
    "CreationDate": "2024-1-25",
    "Commands": [{
      "Command": "store",
      "Target": "180",
      "Value": "!timeout_macro"
    }, {
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "comment",
      "Target": "The file ReadCSVTestData.csv is pre-installed with Ui.Vision.",
      "Value": ""
    }, {
      "Command": "csvRead",
      "Target": "ReadCSVTestData.csv",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Status = ${!csvReadStatus}, line = ${!csvReadLineNumber}",
      "Value": ""
    }, {
      "Command": "while",
      "Target": "${!csvReadStatus} == \"OK\"",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "status = ${!csvReadStatus}, line = ${!csvReadLineNumber}",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Call subroutine for the actual form filling",
      "Value": ""
    }, {
      "Command": "run",
      "Target": "Sub/Sub_DemoCsvRead_FillForm",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number(${!csvReadLineNumber})+1",
      "Value": "!csvReadLineNumber"
    }, {
      "Command": "store",
      "Target": "true",
      "Value": "!errorIgnore"
    }, {
      "Command": "echo",
      "Target": "Reading CSV line No.  ${!csvReadLineNumber} ",
      "Value": "!errorIgnore"
    }, {
      "Command": "csvRead",
      "Target": "ReadCSVTestData.csv",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "false",
      "Value": "!errorIgnore"
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }]
  },
  "Core/DemoCsvReadArray": {
    "CreationDate": "2024-04-04",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Create an array and save the content to a CSV file",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var arr = []; for(var x = 0; x < 5; x++){arr[x] = []; for(var y = 0; y < 3; y++){arr[x][y] = (x+1)*(y+1);}}; return arr",
      "Value": "array1",
      "Description": "Note that (non-sandbox) executeScript command  would run inside the webpage, so a website must be open in the browser. That is why we prefer the _sandbox version here."
    }, {
      "Command": "comment",
      "Target": "Manually set two array values ",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var newArr = ${array1}; newArr[0][2] = 'Hello World'; return newArr",
      "Value": "array1",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var newArr = ${array1}; newArr[2][1] = 'This is how you set an array value'; return newArr",
      "Value": "array1",
      "Description": "We must use executeScript here since the \"_Sandbox\" version can not return arrays. "
    }, {
      "Command": "csvSaveArray",
      "Target": "array1",
      "Value": "data_from_array.csv",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Read the array again from csv file",
      "Value": "",
      "Description": ""
    }, {
      "Command": "csvReadArray",
      "Target": "data_from_array.csv",
      "Value": "myCSV",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Number of rows = ${!CsvReadMaxRow}",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${mycsv[0]}.length;",
      "Value": "col",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Number of columns = ${col}",
      "Value": "pink",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "loop over all CSV values",
      "Value": "",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "nodisplay",
      "Value": "!replayspeed",
      "Description": "Speed up replay by disabling animations/IDE updates. Log file still gets written, it is just not shown."
    }, {
      "Command": "forEach",
      "Target": "myCSV",
      "Value": "row",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "col1=${row[0]}, col2=${row[1]}, col3=${row[2]}",
      "Value": "brown",
      "Description": ""
    }, {
      "Command": "forEach",
      "Target": "row",
      "Value": "elem",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Element=${elem}",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "row",
      "Value": "elem",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed",
      "Description": "Show the IDE updates again (such as the current line and log)"
    }, {
      "Command": "comment",
      "Target": "Another way to loop over the array content",
      "Value": "",
      "Description": ""
    }, {
      "Command": "times",
      "Target": "${!CsvReadMaxRow}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Substract 1 from !times, as the array index starts with 0",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!times} - 1;",
      "Value": "i",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Row ${i}, 3rd Element => ${myCSV[${i}][2]}",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }]
  },
  "Core/DemoCsvSave": {
    "CreationDate": "2018-06-01",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed"
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/csvsave",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var d = new Date(); m = d.getFullYear()+\"-\"+(d.getMonth()+1)+\"-\"+ d.getDate()+\" \"+ d.getHours()+\":\" + d.getMinutes() + \":\" + d.getSeconds(); return m",
      "Value": "timestamp"
    }, {
      "Command": "store",
      "Target": "${timestamp}",
      "Value": "!csvLine"
    }, {
      "Command": "echo",
      "Target": "First column in the CSV is time (${timestamp})",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Set i = 1 as we start the extraction with the 2nd table cell.",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "1",
      "Value": "i"
    }, {
      "Command": "while",
      "Target": "(${i} < 8)",
      "Value": ""
    }, {
      "Command": "executeScript",
      "Target": "return Number (${i}) + 1",
      "Value": "i"
    }, {
      "Command": "echo",
      "Target": "Current value of i = ${i}",
      "Value": "i"
    }, {
      "Command": "storeText",
      "Target": "//*[@id=\"gcw_mainFNGP5XSu6\"]/div[2]/table/tbody/tr[2]/td[${i}]/a",
      "Value": "c2"
    }, {
      "Command": "store",
      "Target": "${c2}",
      "Value": "!csvLine"
    }, {
      "Command": "echo",
      "Target": "Extracted Value for i=${i} is exchange rate = ${c2}",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "${!csvLine}",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Append content of !csvLine to CSV file (or create file if none exists)",
      "Value": ""
    }, {
      "Command": "csvSave",
      "Target": "CurrencyConverterData",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "If needed, you can download (save) the CSV data from the CSV tab to the the download folder",
      "Value": ""
    }, {
      "Command": "localStorageExport",
      "Target": "currencyconverterdata.csv",
      "Value": ""
    }]
  },
  "XModules/DemoPDFTest_with_OCR": {
    "CreationDate": "2022-05-18",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed",
      "Description": ""
    }, {
      "Command": "if",
      "Target": "${!browser} ==\"firefox\"",
      "Value": "",
      "Description": ""
    }, {
      "Command": "throwError",
      "Target": "This macro works only in Chrome and Edge - Firefox does not support automating PDF documents yet.",
      "Value": "",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "open",
      "Target": "http://download.ui.vision/demo/pdf-test.pdf",
      "Value": "",
      "Description": ""
    }, {
      "Command": "setWindowSize",
      "Target": "800x700",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Check that PDF is loaded OK",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Option 1: Check with image search",
      "Value": "",
      "Description": ""
    }, {
      "Command": "visualAssert",
      "Target": "pdftest_salesquote.png@0.35",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Option 2: Check with text search  search",
      "Value": "",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "ENG",
      "Value": "!ocrlanguage",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "1",
      "Value": "!ocrengine",
      "Description": "Online OCR uses the OCR API at https://ocr.space - on this website you can test the different OCR engines directly and use the one that works best."
    }, {
      "Command": "store",
      "Target": "true",
      "Value": "!ocrscale",
      "Description": "Upscaling can help with smaller fonts"
    }, {
      "Command": "OCRSearch",
      "Target": "sales quote",
      "Value": "matches",
      "Description": "Search the (visible part of the ) PDF for the word \"sales quote\""
    }, {
      "Command": "echo",
      "Target": "Number of matches: ${matches}",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "if",
      "Target": "${matches} == \"0\"",
      "Value": "",
      "Description": ""
    }, {
      "Command": "throwError",
      "Target": "Something wrong, I can not find the text <sales quote>",
      "Value": "",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Now extract the quote number and check that it is the correct one",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClickRelative",
      "Target": "getquotenumber_dpi_96_relative.png@0.30",
      "Value": "",
      "Description": "Takes a screenshof the area inside the pink box and OCR its. The extracted area can be checked by looking at the \"__lastscreenshot.png\" image in the Screenshots tab"
    }, {
      "Command": "OCRExtractRelative",
      "Target": "getquotenumber_dpi_96_relative.png@0.30",
      "Value": "q",
      "Description": "Takes a screenshof the area inside the pink box and OCR its. The extracted area can be checked by looking at the \"__lastscreenshot.png\" image in the Screenshots tab"
    }, {
      "Command": "echo",
      "Target": "Extracted text in pink area: >${q}<",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "executeScript",
      "Target": "return ${q}.replace(/( |\\n|\\r)/gm, \"\")",
      "Value": "q",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Remove space(s) and line break(s): Quote Number: >${q}<",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var string = ${q}, substring = \"135\";  b= string.lastIndexOf(substring)>=0; return b;",
      "Value": "textfound",
      "Description": "lastIndexOf>=0 is true if the substring is found inside the q variable, see https://forum.ui.vision/t/string-search-startswith-and-includes/10081/3"
    }, {
      "Command": "if",
      "Target": "${textfound} == true",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Quote number OK",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "throwError",
      "Target": "Wrong quote number. Extracted text was >${q}<",
      "Value": "",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "The X... commands require the RealUser XModule to be installed",
      "Value": "",
      "Description": ""
    }, {
      "Command": "pause",
      "Target": "500",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Click on the document to give it the focus. For this, we click on the word \"SALES QUOTE\".",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClick",
      "Target": "ocr=sales quote",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Scroll down to next page",
      "Value": "",
      "Description": ""
    }, {
      "Command": "if",
      "Target": "${!os}==\"mac\"",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Page scroll in macOS is CMD key + Down",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_CMD+KEY_DOWN}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Page scroll in Windows and Linux is PAGE DOWN key",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_PAGE_DOWN}${KEY_PAGE_DOWN}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Find link image and click it",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Wait 0.5 seconds for the PDF to complete scrolling. Otherwise if the Xclick image is found while the PDF still scrolls, the click goes to the wrong location.",
      "Value": "",
      "Description": ""
    }, {
      "Command": "pause",
      "Target": "500",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClick",
      "Target": "ocr=website",
      "Value": "",
      "Description": "For XClick to work correctly make sure the browser zoom is at 100%. Otherwise the calculated x/y are wrong."
    }, {
      "Command": "comment",
      "Target": "Check the right page is loaded (here: check logo is there)",
      "Value": "",
      "Description": ""
    }, {
      "Command": "assertElementPresent",
      "Target": "//*[@id=\"logo\"]/img",
      "Value": "",
      "Description": "Make sure the previous XClick was successful "
    }]
  },
  "XModules/DemoXClickTextRelative": {
    "CreationDate": "2024-06-08",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed",
      "Description": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/draw",
      "Value": "",
      "Description": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=calculator",
      "Value": "",
      "Description": "The calculator website is NOT affiliated with Ui.Vision."
    }, {
      "Command": "pause",
      "Target": "1000",
      "Value": "",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "eng",
      "Value": "!ocrlanguage",
      "Description": "English OCR"
    }, {
      "Command": "store",
      "Target": "98",
      "Value": "!ocrengine",
      "Description": "use Javascript OCR engine"
    }, {
      "Command": "XClickTextRelative",
      "Target": "mc#R8,-14",
      "Value": "",
      "Description": "Click 8. Anchor button has the text \"mc\""
    }, {
      "Command": "XClickTextRelative",
      "Target": "mc#R30,-14",
      "Value": "",
      "Description": "times"
    }, {
      "Command": "XClickTextRelative",
      "Target": "mc#R8,-14",
      "Value": "",
      "Description": "Click 8"
    }, {
      "Command": "XClick",
      "Target": "${!ocrX},${!ocrY}",
      "Value": "",
      "Description": "Repeat click on last found xclick position (here: press 8 again)"
    }, {
      "Command": "XClick",
      "Target": "${!ocrX},${!ocrY}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClick",
      "Target": "${!ocrX},${!ocrY}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClickTextRelative",
      "Target": "mc#R30,-41",
      "Value": "",
      "Description": "= sign "
    }, {
      "Command": "store",
      "Target": "99",
      "Value": "!ocrengine",
      "Description": "Switch to XModule OCR. It is better with numbers."
    }, {
      "Command": "OCRExtractbyTextRelative",
      "Target": "mc#R22,16H12W21",
      "Value": "s",
      "Description": "Get text (numbers) from calculator display"
    }, {
      "Command": "echo",
      "Target": "Extracted string (Calculator result) is \"${s}\"",
      "Value": "blue",
      "Description": "String maybe still contains line breaks like /r/n from the OCR"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var inputString=${s};\nvar numericString = '';\nfor (var i = 0; i < inputString.length; i++) {\n    var char = inputString.charAt(i);\n    if (char >= '0' && char <= '9') {\n        numericString += char;\n    }\n}\nreturn numericString;",
      "Value": "i",
      "Description": "Remove all non numeric chars. Use method without regular expressions for string replacement, so it works in Firefox, too."
    }, {
      "Command": "if",
      "Target": "${i} == 71104",
      "Value": "",
      "Description": "8 x 888 = 7104"
    }, {
      "Command": "echo",
      "Target": "8 x 8888 is ${i}, Calculator works!",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Wrong result: i = ${i}",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "throwError",
      "Target": "Calculator result is wrong",
      "Value": "",
      "Description": "Trigger an error if the value is not correct. (Useful for automated testing)"
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }]
  },
  "Core/DemoExecuteScript": {
    "CreationDate": "2024-2-1",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed",
      "Description": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/executescript",
      "Value": "",
      "Description": ""
    }, {
      "Command": "assertText",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[1]",
      "Value": "Input box to display some results",
      "Description": ""
    }, {
      "Command": "verifyText",
      "Target": "//*[@id=\"content\"]/div[2]/div/h2[1]",
      "Value": "Input box to display some results",
      "Description": ""
    }, {
      "Command": "verifyTitle",
      "Target": "Selenium IDE executeScript Demo Page",
      "Value": "",
      "Description": ""
    }, {
      "Command": "assertTitle",
      "Target": "Selenium IDE executeScript Demo Page",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript",
      "Target": "function randomString(length, chars) {\n    var result = '';\n    for (var i = length; i > 0; --i) result += chars[Math.round(Math.random() * (chars.length - 1))];\n    return result;\n}\n\n//The executeScript script(s) can have multiple lines!\n\n//Demo: Here we generate a random key \nvar s = randomString(8, '0123456789ABCDE') + \"<= Random String\";\n\n//Set the page title to the random key \ndocument.title = s;\n\nreturn s;\n",
      "Value": "s",
      "Description": "executeScript can run Javascript... and store the result in a variable (optional)"
    }, {
      "Command": "assertTitle",
      "Target": "${s}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Use sourceSearch to assert we have the right Google Analytics Code",
      "Value": "",
      "Description": ""
    }, {
      "Command": "sourceSearch",
      "Target": "G-VJNCDYRXBP",
      "Value": "matches",
      "Description": ""
    }, {
      "Command": "if",
      "Target": "${matches} == 0",
      "Value": "",
      "Description": ""
    }, {
      "Command": "throwError",
      "Target": "Google Analytics ID is wrong!",
      "Value": "",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "First some basic calculations with STORE",
      "Value": "",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "15",
      "Value": "AAA",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "10",
      "Value": "BBB",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return (Number (${AAA}) - Number (${BBB}) )",
      "Value": "CCC",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "${CCC}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript",
      "Target": "document.title = ${CCC};",
      "Value": "",
      "Description": ""
    }, {
      "Command": "assertTitle",
      "Target": "5",
      "Value": "",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "SELenium IDe",
      "Value": "AAA",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${AAA}.toUpperCase()",
      "Value": "CCC",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "${CCC}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "${CCC}",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Generate TODAYs date in in YYYY-MM-DD format ",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Create today's date in the YYYY-MM-DD format",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var d = new Date(); \nvar m = ((d.getMonth()+1)<10)?'0'+(d.getMonth()+1):(d.getMonth()+1);\nvar d2 = (d.getDate() <10)?'0'+d.getDate():d.getDate(); \nvar date_today = d.getFullYear()+\"-\"+m+\"-\"+d2; \nreturn date_today",
      "Value": "mydate",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Today is ${mydate}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Pick a random item from a list, useful for data-driven testing",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return new Array ('cat','dog','fish','dog','deer','frog','whale','dog','seal','horse','elephant')",
      "Value": "names",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${names}.length",
      "Value": "len",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "array length = ${len}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Math.floor(Math.random()*${len})",
      "Value": "num",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "num=${num}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "The next command picks the random item",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${names}[${num}]",
      "Value": "myrandomname",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "Today is ${mydate}, and we draw a ${myrandomname}",
      "Value": "output",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "To is ${mydate}, and we draw a ${myrandomname}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "id=sometext",
      "Value": "${output}",
      "Description": ""
    }, {
      "Command": "if",
      "Target": "parseFloat(${!runtime}) > 20",
      "Value": "",
      "Description": ""
    }, {
      "Command": "throwError",
      "Target": "Runtime too slow (${!runtime} seconds), test failed",
      "Value": "",
      "Description": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Runtime Ok, test passed!",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "With @POS you click on the (in this case) 3rd link with the same name. Great for looping over a list of links with the same name.",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=This link@POS=3",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Demo: Create array and then loop over it with forEach",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript",
      "Target": "var arr = [\"Hello\",\"World\", \"2020\"]; \nreturn arr;",
      "Value": "myarray",
      "Description": "We must use executeScript here, since executeScript _Sandbox does not support returning arrays."
    }, {
      "Command": "forEach",
      "Target": "myarray",
      "Value": "elem",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "${elem}",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }]
  },
  "Core/DemoTabs": {
    "CreationDate": "2022-11-11",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/demo/tabs",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "linkText=Open new web page in new browser tab",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectWindow",
      "Target": "tab=1",
      "Value": "",
      "Description": ""
    }, {
      "Command": "assertTitle",
      "Target": "*1* TAB1",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "TabIndexAbsolute=${!current_tab_number} TabIndexRELATIVE=${!current_tab_number_relative}",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "id=sometext1",
      "Value": "this is tab 1",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "linkText=Open yet another web page in a new browser tab",
      "Value": "",
      "Description": ""
    }, {
      "Command": "selectWindow",
      "Target": "tab=2",
      "Value": "",
      "Description": ""
    }, {
      "Command": "assertTitle",
      "Target": "*2* TAB2",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "id=sometext2",
      "Value": "And this is tab 2!",
      "Description": ""
    }, {
      "Command": "selectWindow",
      "Target": "tab=1",
      "Value": "",
      "Description": ""
    }, {
      "Command": "assertTitle",
      "Target": "*1* TAB1",
      "Value": "",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "id=sometext1",
      "Value": "Now back in tab 1 - test done!",
      "Description": ""
    }, {
      "Command": "selectWindow",
      "Target": "tab=close",
      "Value": "",
      "Description": "Close the current tab (tab1)"
    }, {
      "Command": "assertTitle",
      "Target": "*2* TAB2",
      "Value": "",
      "Description": "What was tab2 is now the tab with the relative ID=1 (since the old tab1 is closed)"
    }, {
      "Command": "selectWindow",
      "Target": "tab=1",
      "Value": "",
      "Description": "Now switching to the NEW tab1 means being on what was formerly tab2. It is the tab we are already on."
    }, {
      "Command": "assertTitle",
      "Target": "*2* TAB2",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "We can also open new tabs",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "TabIndexAbsolute=${!current_tab_number} TabIndexRELATIVE=${!current_tab_number_relative}",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "selectWindow",
      "Target": "tab=open",
      "Value": "https://ui.vision",
      "Description": ""
    }, {
      "Command": "selectWindow",
      "Target": "tab=open",
      "Value": "https://ocr.space",
      "Description": ""
    }, {
      "Command": "type",
      "Target": "id=imageUrl",
      "Value": "Ui.Vision Tab Test done",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "TabIndexAbsolute=${!current_tab_number} TabIndexRELATIVE=${!current_tab_number_relative}",
      "Value": "brown",
      "Description": ""
    }, {
      "Command": "assert",
      "Target": "!current_tab_number_relative",
      "Value": "3",
      "Description": ""
    }]
  },
  "XModules/DemoVisualUITest": {
    "CreationDate": "2022-2-21",
    "Commands": [{
      "Command": "open",
      "Target": "https://ui.vision/",
      "Value": ""
    }, {
      "Command": "setWindowSize",
      "Target": "1024x768",
      "Value": ""
    }, {
      "Command": "visualVerify",
      "Target": "uitest_logo_wide_dpi_96.png@0.70",
      "Value": ""
    }, {
      "Command": "visualVerify",
      "Target": "uitest_share_dpi_96.png@0.70",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Resize to iPhone6 screen size",
      "Value": ""
    }, {
      "Command": "setWindowSize",
      "Target": "375x768",
      "Value": ""
    }, {
      "Command": "visualVerify",
      "Target": "uitest_logo_mobile_dpi_96.png",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Missing menu is critical, so we use ASSERT (instead of just VERIFY)",
      "Value": ""
    }, {
      "Command": "visualAssert",
      "Target": "uitest_hamburger_dpi_96.png",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Check that Share buttons do not show",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "At this point, page is surely loaded => reduce wait for (normally missing) image",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "2",
      "Value": "!timeout_wait"
    }, {
      "Command": "visualSearch",
      "Target": "uitest_share_dpi_96.png@0.70",
      "Value": "count"
    }, {
      "Command": "if",
      "Target": "${count} > 0",
      "Value": ""
    }, {
      "Command": "throwError",
      "Target": "Share buttons should NOT show on mobile phones",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Restore default wait (not really needed here, since macro stops now anyway)",
      "Value": ""
    }, {
      "Command": "store",
      "Target": "10",
      "Value": "!timeout_wait"
    }, {
      "Command": "comment",
      "Target": "Done, enlarge browser again",
      "Value": ""
    }, {
      "Command": "setWindowSize",
      "Target": "1024x768",
      "Value": ""
    }]
  },
  "XModules/DemoXType": {
    "CreationDate": "2019-01-28",
    "Commands": [{
      "Command": "store",
      "Target": "medium",
      "Value": "!replayspeed"
    }, {
      "Command": "comment",
      "Target": "Make sure the browser is in the foreground, so it receives the XTYPE keystrokes",
      "Value": ""
    }, {
      "Command": "bringBrowserToForeground",
      "Target": "",
      "Value": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/xtype",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "To save the page, open the browser save dialog with a shortcut",
      "Value": ""
    }, {
      "Command": "if",
      "Target": "${!os}==\"mac\"",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Save web page in macOS is CMD+S",
      "Value": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_CMD+KEY_S}",
      "Value": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Save web page in Windows and Linux is CTRL+S",
      "Value": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_CTRL+KEY_S}",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Generate today's date and time ",
      "Value": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var d= new Date(); var m=((d.getMonth()+1)<10)?'0'+(d.getMonth()+1):(d.getMonth()+1); m = d.getFullYear()+\"-\"+m+\"-\"+d.getDate(); return m",
      "Value": "mydate"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return new Date().getHours()+\"-\" + new Date().getMinutes() + \"-\" + new Date().getSeconds()",
      "Value": "mytime"
    }, {
      "Command": "echo",
      "Target": "Today is ${mydate}, and the time is ${mytime}",
      "Value": "blue"
    }, {
      "Command": "comment",
      "Target": "Wait for the dialog to appear before sending the next keystrokes",
      "Value": ""
    }, {
      "Command": "pause",
      "Target": "2000",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "Send the new file name to the dialog and press ENTER",
      "Value": "blue"
    }, {
      "Command": "XType",
      "Target": "Page_saved_by_UiVision_${mydate}_${mytime}",
      "Value": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_ENTER}",
      "Value": ""
    }]
  },
  "XModules/DemoXRun": {
    "CreationDate": "2019-09-16",
    "Commands": [{
      "Command": "echo",
      "Target": "This demo macro uses hard-coded paths for the default calculator app. But the correct path depends on your operating system version and language. So the default path in this macro might be wrong and needs to be adjusted.",
      "Value": "blue"
    }, {
      "Command": "if",
      "Target": "${!os}==\"mac\"",
      "Value": ""
    }, {
      "Command": "XRun",
      "Target": "/Applications/Calculator.app/Contents/MacOS/Calculator",
      "Value": ""
    }, {
      "Command": "elseif",
      "Target": "${!os}==\"linux\"",
      "Value": ""
    }, {
      "Command": "XRun",
      "Target": "/snap/bin/gnome-calculator",
      "Value": ""
    }, {
      "Command": "elseif",
      "Target": "${!os}==\"windows\"",
      "Value": ""
    }, {
      "Command": "XRun",
      "Target": "C:\\Windows\\System32\\calc.exe",
      "Value": ""
    }, {
      "Command": "comment",
      "Target": "You find the example PowerShell script for this demo in the UI.Vision docs for \"XRunAndWait\"",
      "Value": "-executionpolicy bypass -File  c:\\test\\test1.ps1  c:\\test\\test.txt Hello"
    }, {
      "Command": "comment",
      "Target": "XRunAndWait // Powershell.exe ",
      "Value": "-executionpolicy bypass -File  c:\\test\\test1.ps1  c:\\test\\test.txt Hello"
    }, {
      "Command": "comment",
      "Target": "echo // Exitcode = ${!xrun_exitcode}  (Note: The exit code is only captured if you use XRunAndWait)",
      "Value": ""
    }, {
      "Command": "else",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "This should never happen",
      "Value": ""
    }, {
      "Command": "end",
      "Target": "",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Calculator app launched ",
      "Value": ""
    }]
  },
  "XModules/DemoXClick": {
    "CreationDate": "2022-05-19",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed",
      "Description": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/draw",
      "Value": "",
      "Description": ""
    }, {
      "Command": "bringBrowserToForeground",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "linkText=this link",
      "Value": "",
      "Description": ""
    }, {
      "Command": "pause",
      "Target": "1000",
      "Value": "",
      "Description": ""
    }, {
      "Command": "visualAssert",
      "Target": "draw_canvas_dpi_96.png",
      "Value": "",
      "Description": "Check we are on the right page"
    }, {
      "Command": "XClick",
      "Target": "draw_plus_dpi_96.png",
      "Value": "",
      "Description": "Click the plus icon to start a new drawing"
    }, {
      "Command": "XClick",
      "Target": "draw_redbutton_dpi_96.png",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "We use a relative click, since the pencil icon can change shape",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClickRelative",
      "Target": "draw_pencil_dpi_96.png",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_ESC}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClickRelative",
      "Target": "draw_startingpoint_dpi_96.png",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Starting point: x=${!imagex} y=${!imagey}",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "${!imagex}",
      "Value": "x",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "${!imagey}",
      "Value": "y",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Draw top line --->",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#down",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${x}) +100",
      "Value": "x",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#move",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#up",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Draw right line down",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#down",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${y}) +100",
      "Value": "y",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#move",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#up",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Draw bottom line <---",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#down",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${x}) - 100",
      "Value": "x",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#move",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#up",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Draw left line up",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#down",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${y}) - 100",
      "Value": "y",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#move",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "${x},${y}",
      "Value": "#up",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "visualVerify // draw_compare_dpi_96.png",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Add some text...",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClick",
      "Target": "draw_text1_dpi_96.png",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_ESC}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Now click on the canvas. This is the place where the text starts.",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${y}) +180",
      "Value": "y",
      "Description": ""
    }, {
      "Command": "XClick",
      "Target": "${x},${y}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Send keystrokes",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XType",
      "Target": "Demo completed.",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Click once more on the canvas to close text menu",
      "Value": "",
      "Description": ""
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return Number (${y}) - 150",
      "Value": "y",
      "Description": ""
    }, {
      "Command": "XClick",
      "Target": "${x},${y}",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Confirm that the text is shown. @0.5 overwrites the global confidence level.",
      "Value": "",
      "Description": ""
    }, {
      "Command": "visualAssert",
      "Target": "draw_checkresult1_dpi_96.png@0.4",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "DemoXClick completed",
      "Value": "#shownotification",
      "Description": ""
    }]
  },
  "XModules/DemoXMove": {
    "CreationDate": "2021-05-17",
    "Commands": [{
      "Command": "comment",
      "Target": "This demo shows *two* methods to select an image from a list of matches",
      "Value": "",
      "Description": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/demo/draw",
      "Value": "",
      "Description": ""
    }, {
      "Command": "clickAndWait",
      "Target": "linkText=this external website",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Move 2nd range slider using #POS method",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XMove",
      "Target": "slider_handle_dpi_96.png@0.75#2",
      "Value": "#down",
      "Description": "Press slider handle down"
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "var x = ${!imagex}; return x+200",
      "Value": "xnew",
      "Description": "Calcuate new X position. "
    }, {
      "Command": "XMove",
      "Target": "${xnew}, ${!imagey}",
      "Value": "#up",
      "Description": "Move slider handle and release left mouse button"
    }, {
      "Command": "comment",
      "Target": "Move 3rd slider with AREALIMIT method",
      "Value": "",
      "Description": ""
    }, {
      "Command": "click",
      "Target": "xpath=//ion-list[3]/ion-item/div/div/ion-range",
      "Value": "#down",
      "Description": "CLICK is not needed. We used it just to find the XPath for use with visionLimitSearchArea below."
    }, {
      "Command": "pause",
      "Target": "2000",
      "Value": "",
      "Description": ""
    }, {
      "Command": "visionLimitSearchArea",
      "Target": "element: xpath=//ion-list[3]/ion-item/div/div/ion-range",
      "Value": "",
      "Description": "Restrict computer vision image search to the HTML tag area"
    }, {
      "Command": "XMove",
      "Target": "slider_handle_dpi_96.png@0.6",
      "Value": "#down",
      "Description": "We do not need to add \"#1\" because in the new (limited) area there is only one slider handle, so the BEST MATCH option (=without #) is most reliable"
    }, {
      "Command": "XMoveRelative",
      "Target": "slider_red_dpi_96.png@0.6",
      "Value": "#up",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Confirm slider is in the right position.",
      "Value": "",
      "Description": ""
    }, {
      "Command": "storeText",
      "Target": "xpath=//ion-list[3]/ion-list-header/div/ion-badge",
      "Value": "warmth",
      "Description": "Extract slider position"
    }, {
      "Command": "echo",
      "Target": "Slider WARMTH value is: ${warmth}",
      "Value": "red",
      "Description": ""
    }, {
      "Command": "assert",
      "Target": "warmth",
      "Value": "2000",
      "Description": "Show error if slider has not the expected value"
    }]
  },
  "XModules_Desktop/DemoXDesktopAutomation": {
    "CreationDate": "2024-02-13",
    "Commands": [{
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Running DESKTOP image search now",
      "Value": "#shownotification",
      "Description": ""
    }, {
      "Command": "XDesktopAutomation",
      "Target": "true",
      "Value": "",
      "Description": "Look at the desktop, not only the browser"
    }, {
      "Command": "run",
      "Target": "Sub/Sub_XDesktopAutomation_Area",
      "Value": "",
      "Description": "In the sub, we limit the search area for better performance"
    }, {
      "Command": "store",
      "Target": "true",
      "Value": "!errorignore",
      "Description": "Log button can be greyed out - try both options. "
    }, {
      "Command": "XClick",
      "Target": "desktop_logstab_white_dpi_96.png@0.5",
      "Value": "",
      "Description": "Log button can have white or grey background"
    }, {
      "Command": "store",
      "Target": "false",
      "Value": "!errorignore",
      "Description": ""
    }, {
      "Command": "if",
      "Target": "${!statusOK} == false",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_logstab_grey_dpi_96.png@0.5",
      "Value": "",
      "Description": "Now try the GREY button image"
    }, {
      "Command": "store",
      "Target": "true",
      "Value": "!statusOK",
      "Description": "Reset !statusOK value. It does NOT reset by itself during macro run."
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_clearbutton_dpi_96.png@0.5",
      "Value": "",
      "Description": "Press Clear button"
    }, {
      "Command": "echo",
      "Target": "Log cleared by macro (clear button pressed)",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "Now search and open other tabs",
      "Value": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_vartab_dpi_96.png@0.5",
      "Value": "",
      "Description": "Open Variable tab"
    }, {
      "Command": "XClick",
      "Target": "desktop_scrtab_dpi_96.png@0.4",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XClick",
      "Target": "desktop_vitab_dpi_96.png@0.4",
      "Value": "",
      "Description": ""
    }, {
      "Command": "visualAssert",
      "Target": "desktop_check_v_tab_dpi_96.png@0.5",
      "Value": "",
      "Description": "Make sure that we are on the correct tab. For that, we search for the icons."
    }]
  },
  "XModules_Desktop/DemoAutomateChromeDevTools": {
    "CreationDate": "2024-04-28",
    "Commands": [{
      "Command": "XDesktopAutomation",
      "Target": "true",
      "Value": "",
      "Description": "We need desktop automation, since we are not working inside the browser viewport"
    }, {
      "Command": "store",
      "Target": "Console",
      "Value": "WordConsole",
      "Description": "In English the tab is called \"Console\". If your browser uses a different language, enter \"your word\" for Console here"
    }, {
      "Command": "store",
      "Target": "fast",
      "Value": "!replayspeed",
      "Description": ""
    }, {
      "Command": "if",
      "Target": "${!os}==\"mac\" || ${!os}==\"windows\"",
      "Value": "",
      "Description": "|| means \"or\" in Javascript notation"
    }, {
      "Command": "store",
      "Target": "99",
      "Value": "!ocrengine",
      "Description": "99 = XModule integrated OCR (Mac and Windows, no Linux yet)"
    }, {
      "Command": "else",
      "Target": "",
      "Value": "",
      "Description": "For Linux we have no local OCR XModule yet, so use online OCR"
    }, {
      "Command": "store",
      "Target": "2",
      "Value": "!ocrengine",
      "Description": "Engine 1 and 2 are Online OCR. They work on all platforms and offer more languages. For more information please see https://ui.vision/x/desktop-automation#ocr"
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "store",
      "Target": "eng",
      "Value": "!OCRlanguage",
      "Description": ""
    }, {
      "Command": "open",
      "Target": "https://ui.vision/rpa/x/desktop-automation/screen-scraping",
      "Value": "",
      "Description": "Show the relevant Ui.Vision Docs page"
    }, {
      "Command": "bringBrowserToForeground",
      "Target": "",
      "Value": "",
      "Description": "Make sure the browser is in the foreground, so it receives the XTYPE keystrokes"
    }, {
      "Command": "OCRSearch",
      "Target": "${WordConsole}",
      "Value": "words_found",
      "Description": "Check if the developer console is already open"
    }, {
      "Command": "echo",
      "Target": "How often is this word on the screen?: ${words_found} ",
      "Value": "pink",
      "Description": ""
    }, {
      "Command": "if",
      "Target": "${words_found} > 0",
      "Value": "",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Developer Console already open",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "else",
      "Target": "Dev window already open",
      "Value": "green",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "Open Developer Console",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "if",
      "Target": "${!os}==\"mac\"",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_OPTION+KEY_CMD+KEY_I}",
      "Value": "",
      "Description": "Mac "
    }, {
      "Command": "else",
      "Target": "",
      "Value": "",
      "Description": ""
    }, {
      "Command": "XType",
      "Target": "${KEY_CTRL+KEY_SHIFT+KEY_I}",
      "Value": "",
      "Description": "Windows and Linux"
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": "Mac/Win,Linux"
    }, {
      "Command": "end",
      "Target": "",
      "Value": "",
      "Description": "Open/NotOpen"
    }, {
      "Command": "XClickText",
      "Target": "${WordConsole}",
      "Value": "",
      "Description": "Select Tab \"Console\""
    }, {
      "Command": "XClickTextRelative",
      "Target": "${WordConsole}#R5,-4",
      "Value": "",
      "Description": "Click in FILTER box. We find this box RELATIVE to the word \"Console\""
    }, {
      "Command": "XType",
      "Target": "${KEY_BACKSPACE}${KEY_BACKSPACE}${KEY_BACKSPACE}${KEY_BACKSPACE}${KEY_BACKSPACE}${KEY_BACKSPACE}${KEY_BACKSPACE}${KEY_BACKSPACE}",
      "Value": "",
      "Description": "Clear box from previous macro runs (if any)"
    }, {
      "Command": "XType",
      "Target": "Demo",
      "Value": "",
      "Description": "Set a filter (just as text entry demo)"
    }, {
      "Command": "XClickTextRelative",
      "Target": "${WordConsole}#R5,-30",
      "Value": "",
      "Description": "Click in console window, again we find this window by starting at the CONSOLE word"
    }, {
      "Command": "XType",
      "Target": "* Demo completed, Runtime =${!runtime} *",
      "Value": "",
      "Description": ""
    }]
  },
  "XModules_Desktop/Sub/Sub_XDesktopAutomation_Area": {
    "CreationDate": "2021-04-29",
    "Commands": [{
      "Command": "comment",
      "Target": "SUBROUTINE used by DemoXDesktopAutomation",
      "Value": "",
      "Description": ""
    }, {
      "Command": "comment",
      "Target": "It uses two anchor images to define the new search area",
      "Value": "",
      "Description": ""
    }, {
      "Command": "visualAssert",
      "Target": "desktop_area_topleft3_dpi_96.png@0.4",
      "Value": "",
      "Description": "Find image to calculate the top left x/y for visionLimitSearchArea "
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!imagex}-${!imagewidth}/1.5",
      "Value": "x1",
      "Description": "New limited area top left corner = bottom left corner of the anchor image. We use image x/y and image width/height to calculate this value. For X we use /1.5 instead of /2 in the formular below to make the area a bit wider."
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!imagey}+${!imageheight}/2",
      "Value": "y1",
      "Description": ""
    }, {
      "Command": "visualAssert",
      "Target": "desktop_area_bottomright_dpi_96.png@0.4",
      "Value": "",
      "Description": "Find image to calculate the bottom right x/y for visionLimitSearchArea."
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!imagex}+${!imagewidth}/2",
      "Value": "x2",
      "Description": "New Search Area bottom right corner = top right corner of the anchor image."
    }, {
      "Command": "executeScript_Sandbox",
      "Target": "return ${!imagey}-${!imageheight}/2",
      "Value": "y2",
      "Description": ""
    }, {
      "Command": "echo",
      "Target": "x1=${x1}, y1=${y1}, x2=${x2}, y2=${y2}",
      "Value": "blue",
      "Description": ""
    }, {
      "Command": "visionLimitSearchArea",
      "Target": "area=${x1},${y1},${x2},${y2}",
      "Value": "",
      "Description": ""
    }]
  },
  "Core/Sub/Sub_DemoCsvRead_FillForm": {
    "CreationDate": "2020-08-08",
    "Commands": [{
      "Command": "comment",
      "Target": "Subroutine used by DemoCsvReadWithLoop and DemoCsvReadWithWhile",
      "Value": ""
    }, {
      "Command": "echo",
      "Target": "Inside subroutine: Status = ${!csvReadStatus}, Line = ${!csvReadLineNumber}",
      "Value": "green"
    }, {
      "Command": "open",
      "Target": "https://docs.google.com/forms/d/e/1FAIpQLScGWVjexH2FNzJqPACzuzBLlTWMJHgLUHjxehtU-2cJxtu6VQ/viewform",
      "Value": ""
    }, {
      "Command": "type",
      "Target": "xpath=//input[@type='text']",
      "Value": "${!COL1}_${!csvReadLineNumber}"
    }, {
      "Command": "type",
      "Target": "xpath=//div[3]/div/div/div[2]/div/div/div/div/input",
      "Value": "${!COL2}"
    }, {
      "Command": "type",
      "Target": "xpath=//div[4]/div/div/div[2]/div/div/div/div/input",
      "Value": "${!COL3}"
    }, {
      "Command": "clickAndWait",
      "Target": "xpath=//span/span",
      "Value": ""
    }]
  }
};

/***/ }),

/***/ 49571:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _react = _interopRequireWildcard(__webpack_require__(96540));
var _reactDom = _interopRequireDefault(__webpack_require__(40961));
var _reactRouterDom = __webpack_require__(92648);
var _antd = __webpack_require__(33061);
var _en_US = _interopRequireDefault(__webpack_require__(13173));
var _reactDndHtml5Backend = _interopRequireDefault(__webpack_require__(77163));
var _reactDnd = __webpack_require__(81592);
var _fuzzyset = _interopRequireDefault(__webpack_require__(27058));
var _semver = _interopRequireDefault(__webpack_require__(99589));
var _config = _interopRequireDefault(__webpack_require__(8747));
var _path2 = _interopRequireDefault(__webpack_require__(26513));
var _file_saver = _interopRequireDefault(__webpack_require__(50261));
var _redux = __webpack_require__(68806);
var _init_player = __webpack_require__(45329);
var _web_extension = _interopRequireDefault(__webpack_require__(41953));
var _ipc_cs = _interopRequireDefault(__webpack_require__(96571));
var _storage = __webpack_require__(97467);
var _cs_timeout = __webpack_require__(41279);
var _storage2 = __webpack_require__(82798);
var _xfile = __webpack_require__(63109);
var _xlocal = __webpack_require__(95536);
var _ocr = __webpack_require__(99998);
var _test_case_model = __webpack_require__(56109);
var _test_suite_model = __webpack_require__(38117);
var _storage3 = _interopRequireDefault(__webpack_require__(88555));
var _utils = __webpack_require__(46580);
var _ts_utils = __webpack_require__(1601);
var _convert_utils = __webpack_require__(75852);
var C = _interopRequireWildcard(__webpack_require__(95902));
var _log = _interopRequireDefault(__webpack_require__(89130));
var _macro_log = __webpack_require__(91433);
var _variables = __webpack_require__(54836);
var _player = __webpack_require__(18392);
var _save_test_case = _interopRequireDefault(__webpack_require__(64305));
var _languages = __webpack_require__(64013);
var _actions = __webpack_require__(35127);
var _download_man = __webpack_require__(54138);
var _macro_extra_data = __webpack_require__(3112);
var _04_01_macro_suite_storage = __webpack_require__(37740);
var _migration = __webpack_require__(78954);
var _types = __webpack_require__(37915);
var _simple_actions = __webpack_require__(8588);
var _log2 = __webpack_require__(26480);
var _recomputed = __webpack_require__(87307);
var _state = __webpack_require__(78493);
var _license = __webpack_require__(12277);
var _delegate = __webpack_require__(12702);
var _capture_screenshot = __webpack_require__(6329);
var _ipc_cache = __webpack_require__(75866);
var _tab_utils = __webpack_require__(20041);
var _timeout_counter = __webpack_require__(83945);
var _sidepanel = __webpack_require__(17767);
var _intercept_log = _interopRequireDefault(__webpack_require__(36447));
var _client = __webpack_require__(5338);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /* global PREINSTALL_CSV_LIST PREINSTALL_VISION_LIST */
var App = /*#__PURE__*/(0, _react.lazy)(function () {
  return Promise.all(/* import() */[__webpack_require__.e(290), __webpack_require__.e(854), __webpack_require__.e(243), __webpack_require__.e(421), __webpack_require__.e(328)]).then(__webpack_require__.bind(__webpack_require__, 42328));
});
var SidepanelApp = /*#__PURE__*/(0, _react.lazy)(function () {
  return Promise.all(/* import() */[__webpack_require__.e(290), __webpack_require__.e(854), __webpack_require__.e(65), __webpack_require__.e(421), __webpack_require__.e(940)]).then(__webpack_require__.bind(__webpack_require__, 96940));
});
(0, _intercept_log["default"])();
(0, _cs_timeout.polyfillTimeoutFunctions)(_ipc_cs["default"]);
(0, _delegate.handleDelegatedBrowserFileSystemAPI)();

// TODO: uncomment/fix later
// const store = createStore(
//   reducer,
//   window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
// )

var captureScreenshotService = new _capture_screenshot.CaptureScreenshotService({
  captureVisibleTab: function captureVisibleTab(windowId, options) {
    return _ipc_cs["default"].ask('PANEL_CAPTURE_VISIBLE_TAB', {
      windowId: windowId,
      options: options
    });
  }
});

// FIXME: better not passing store via `window` object
window['store'] = _redux.store;

//let isSidePanel = window.location.href.includes('sidepanel.html');

var container = document.getElementById('root');
var root = (0, _client.createRoot)(container); // createRoot(container!) if you use TypeScript
var render = function render() {
  return root.render( /*#__PURE__*/_react["default"].createElement(_reactDnd.DndProvider, {
    backend: _reactDndHtml5Backend["default"]
  }, /*#__PURE__*/_react["default"].createElement(_antd.ConfigProvider, {
    locale: _en_US["default"]
  }, /*#__PURE__*/_react["default"].createElement(_redux.Provider, {
    store: _redux.store
  }, /*#__PURE__*/_react["default"].createElement(_reactRouterDom.HashRouter, null, (0, _utils.isSidePanelWindow)() ? /*#__PURE__*/_react["default"].createElement(SidepanelApp, null) : /*#__PURE__*/_react["default"].createElement(App, null))))));
};
var timestampCache = {};
var DURATION = 2000;

// Note: listen to any db changes and restore all data from db to redux store
// All test cases are stored in indexeddb (dexie)
var bindMacroAndTestSuites = function bindMacroAndTestSuites() {
  var curStorageMode = (0, _storage.getStorageManager)().getCurrentStrategyType();
  var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
  var suiteStorage = (0, _storage.getStorageManager)().getTestSuiteStorage();
  var onError = function onError(errorList) {
    errorList.filter(function (item) {
      return item.fileName !== '__Untitled__';
    }).forEach(function (errorItem) {
      var key = errorItem.fullFilePath;
      if (!timestampCache[key] || new Date() * 1 - timestampCache[key] > DURATION) {
        timestampCache[key] = new Date() * 1;
        _redux.store.dispatch((0, _actions.addLog)('warning', errorItem.error.message));
      }
    });
  };
  var restoreTestCases = function restoreTestCases() {
    _redux.store.dispatch(_simple_actions.Actions.setIsLoadingMacros(true));
    var pMacrosExtra = (0, _macro_extra_data.getMacroExtraKeyValueData)().getAll().then(function (data) {
      // log('restoreMacrosExtra', data)

      _redux.store.dispatch((0, _actions.setMacrosExtra)(data));
    });
    var pFolderStructure = function () {
      if (!(0, _recomputed.getShouldLoadResources)(_redux.store.getState())) {
        return Promise.resolve();
      }
      return macroStorage.listR().then(function (entryNodes) {
        // log('restoreMacroFolderStructure', entryNodes)

        _redux.store.dispatch(_simple_actions.Actions.setMacroFolderStructure(entryNodes));
      });
    }();
    return Promise.all([pMacrosExtra, pFolderStructure])["finally"](function () {
      return _redux.store.dispatch(_simple_actions.Actions.setIsLoadingMacros(false));
    });
  }

  // FIXME: need to unbind previous listeners when bindMacroAndTestSuites is called for more than once
  ;
  [_storage2.FlatStorageEvent.ListChanged, _storage2.FlatStorageEvent.FilesChanged].forEach(function (eventName) {
    macroStorage.off(eventName);
    macroStorage.on(eventName, function () {
      if (curStorageMode !== (0, _storage.getStorageManager)().getCurrentStrategyType()) return;
      (0, _log["default"])('macroStorage - eventName', eventName);
      setTimeout(restoreTestCases, 50);
    });
  });
  return (0, _ts_utils.flow)((0, _ts_utils.guardVoidPromise)(restoreTestCases));
};

// Note: editing is stored in localstorage
var restoreEditing = function restoreEditing() {
  return _storage3["default"].get('editing').then(function (editing) {
    if (!editing) return;
    var finalEditing = editing;
    if (editing.baseUrl) {
      finalEditing = _objectSpread({}, editing);
      finalEditing.commands = finalEditing.commands.map((0, _test_case_model.commandWithoutBaseUrl)(editing.baseUrl));
      delete finalEditing.baseUrl;
    }
    _redux.store.dispatch((0, _actions.setEditing)(finalEditing));
  });
};
var restoreConfig = function restoreConfig() {
  return _storage3["default"].get('config').then(function (config) {
    var cfg = _objectSpread({
      showSidePanel: false,
      useDarkTheme: false,
      sidePanelOnLeft: false,
      showSettingsOnStart: false,
      showSidebar: false,
      showBottomArea: true,
      playScrollElementsIntoView: true,
      playHighlightElements: true,
      playCommandInterval: 0.3,
      // selenium related
      saveAlternativeLocators: true,
      recordNotification: true,
      recordClickType: 'click',
      showTestCaseTab: true,
      logFilter: 'All',
      onErrorInLoop: 'continue_next_loop',
      // Run macros from outside
      allowRunFromBookmark: true,
      allowRunFromFileSchema: true,
      allowRunFromHttpSchema: true,
      // timeout in seconds
      timeoutPageLoad: 60,
      timeoutElement: 10,
      timeoutMacro: 0,
      timeoutDownload: 60,
      // backup relative
      lastBackupActionTime: new Date() * 1,
      enableAutoBackup: true,
      autoBackupInterval: 7,
      autoBackupTestCases: true,
      autoBackupTestSuites: true,
      autoBackupScreenshots: true,
      autoBackupCSVFiles: true,
      autoBackupVisionImages: true,
      // security relative
      shouldEncryptPassword: 'no',
      masterPassword: '',
      // variable relative
      showCommonInternalVariables: true,
      showAdvancedInternalVariables: false,
      // xmodules related
      storageMode: _storage.StorageStrategyType.Browser,
      xmodulesStatus: 'unregistered',
      // orc related
      ocrCalibration: 6,
      ocrCalibration_internal: 6,
      ocrScaling: 100,
      ocrEngine: 98,
      ocrMode: 'enabled',
      // 'disabled',
      ocrLanguage: 'eng',
      ocrLanguageOption: _languages.ocrLanguageOptions,
      ocrOfflineURL: '',
      ocrOfflineAPIKey: '',
      // vision related
      cvScope: 'browser',
      defaultVisionSearchConfidence: 0.6,
      useDesktopScreenCapture: true,
      waitBeforeDesktopScreenCapture: false,
      secondsBeforeDesktopScreenCapture: 3,
      // proxy related,
      defaultProxy: '',
      defaultProxyAuth: '',
      turnOffProxyAfterReplay: true
    }, config);
    _redux.store.dispatch((0, _actions.updateConfig)(cfg));
    return cfg;
  });
};
var restoreCSV = function restoreCSV() {
  if (!(0, _recomputed.getShouldLoadResources)(_redux.store.getState())) {
    return Promise.resolve();
  }

  // Note: just try to init storage. Eg. For browser fs, it will try to create root folder
  (0, _storage.getStorageManager)().getCSVStorage();
  return _redux.store.dispatch((0, _actions.listCSV)());
};
var restoreScreenshots = function restoreScreenshots() {
  (0, _storage.getStorageManager)().getScreenshotStorage();
  return _redux.store.dispatch((0, _actions.listScreenshots)());
};
var restoreVisions = function restoreVisions() {
  if (!(0, _recomputed.getShouldLoadResources)(_redux.store.getState())) {
    return Promise.resolve();
  }
  (0, _storage.getStorageManager)().getVisionStorage();
  return _redux.store.dispatch((0, _actions.listVisions)());
};
var downloadTextFile = function downloadTextFile(text, fileName) {
  var blob = new Blob([text], {
    type: 'text/plain;charset=utf-8'
  });
  _file_saver["default"].saveAs(blob, fileName);
};
var prepareBeforeRun = function prepareBeforeRun(options) {
  if (options.savelog) {
    _redux.store.dispatch((0, _actions.clearLogs)());
  }
};
var genPlayerPlayCallback = function genPlayerPlayCallback(_ref) {
  var options = _ref.options,
    installed = _ref.installed;
  // Only run this callback once, we've added it to two places
  // 1. Player callback
  // 2. Promise finally of the entire macro run
  var alreadyRun = false;
  return function (err, reason) {
    if (alreadyRun) {
      return;
    }
    alreadyRun = true;
    var pSaveLog = (0, _utils.delay)(function () {}, 1000);
    if (options.savelog) {
      var isFullPath = /\\|\//.test(options.savelog);
      var logs = _redux.store.getState().logs;
      var errorLog = logs.find(function (log) {
        return log.type === 'error' && !(log.options && log.options.ignored);
      });
      var error = err || errorLog && {
        message: errorLog.text
      };
      var logTitle = error ? "Status=Error: ".concat(error.message) : "Status=OK";
      var logContent = logs.map(function (log) {
        return (0, _macro_log.renderLog)(log, false);
      });
      var text = [logTitle, '###'].concat(_toConsumableArray(logContent)).join('\n');
      if (isFullPath) {
        var os = function os() {
          if (/windows/i.test(ua)) return 'windows';
          if (/mac/i.test(ua)) return 'mac';
          return 'linux';
        };
        var ua = window.navigator.userAgent;
        var _path = options.savelog;
        if (installed && installed != undefined) {
          var osType = os();
          (0, _ocr.runDownloadLog)(text, _path, osType).then(function (data) {
            return (0, _download_man.getDownloadMan)().prepareDownload(options.savelog);
          });
        } else {
          pSaveLog = (0, _utils.delay)(function () {}, 500).then(function () {
            downloadTextFile(text, decodeURIComponent(options.savelog));
            // Note: We have to wait until savelog download completes if there is any
            return (0, _download_man.getDownloadMan)().prepareDownload(options.savelog);
          });
        }
      } else {
        if (!isFullPath || !(0, _storage.getStorageManager)().isXFileMode()) {
          pSaveLog = (0, _utils.delay)(function () {}, 500).then(function () {
            downloadTextFile(text, decodeURIComponent(options.savelog));
            // Note: We have to wait until savelog download completes if there is any
            return (0, _download_man.getDownloadMan)().prepareDownload(options.savelog);
          });
        } else {
          pSaveLog = (0, _log2.getLogService)().logTo(options.savelog, text);
        }
      }
    }
    var closeBrowser = (0, _ts_utils.parseBoolLike)(options.closeBrowser, false);
    var closeRPA = (0, _ts_utils.parseBoolLike)(options.closeRPA !== undefined ? options.closeRPA : options.closeKantu, true);
    if (closeBrowser && reason !== _player.Player.C.END_REASON.MANUAL) {
      // Close all tabs If close option is set
      pSaveLog["catch"](function (e) {
        _log["default"].warn('Save log error: ', e.message);
      }).then(function () {
        return _ipc_cs["default"].ask('PANEL_CLOSE_ALL_WINDOWS', {});
      });
    }

    // Note: it's better to keep kantu open if it's opened manually before
    if (!err && reason === _player.Player.C.END_REASON.COMPLETE && closeRPA && !closeBrowser) {
      // Close kantu panel
      setTimeout(function () {
        window.close();
      }, 1000);
    }
  };
};
var genOverrideScope = function genOverrideScope(_ref2) {
  var options = _ref2.options;
  return Object.keys(options || {}).reduce(function (prev, key) {
    var m = key.match(/^cmd_var(1|2|3)$/i);
    if (!m) return prev;
    prev["!CMD_VAR".concat(m[1])] = options[key];
    return prev;
  }, {});
};
var validParams = ['direct', 'closeBrowser', 'closeKantu', 'closeRPA', 'continueInLastUsedTab', 'nodisplay', 'folder', 'savelog', 'storage', 'macro', 'testsuite', 'storageMode', 'loadmacrotree', 'cmd_var1', 'cmd_var2', 'cmd_var3', 'cmd_var4', 'cmd_var5', 'cmd_var6', 'cmd_var7', 'cmd_var8', 'cmd_var9', 'cmd_var10'];
var fuzzyObj = new _fuzzyset["default"](validParams);
var initFromCommandLineArgs = function initFromCommandLineArgs(args) {
  var loadMacroTree = (0, _ts_utils.parseBoolLike)(args.loadmacrotree);
  var noDisplay = (0, _ts_utils.parseBoolLike)(args.nodisplay, false);
  if (loadMacroTree) {
    _redux.store.dispatch(_simple_actions.Actions.setFrom(_state.RunBy.Manual));
  }
  if (noDisplay) {
    _redux.store.dispatch(_simple_actions.Actions.setNoDisplayInPlay(true));
  }
};
var guardCommandLineArgs = function guardCommandLineArgs(args, storageMode) {
  // Check params
  var keys = Object.keys(args);
  var checkName = function checkName(pattern, str) {
    if (typeof pattern === 'string') {
      return pattern === str;
    } else {
      return pattern.test(str);
    }
  };
  var checkValue = function checkValue(name, value) {
    switch (name) {
      case 'continueInLastUsedTab':
      case 'closeKantu':
      case 'closeRPA':
      case 'closeBrowser':
      case 'direct':
      case 'loadmacrotree':
      case 'nodisplay':
        if (/^0|1|true|false$/i.test(value)) {
          return true;
        } else {
          throw new Error("\"".concat(name, "\" should be 0, 1, true or false, but now it's ").concat(value));
        }
      case 'storage':
        if (['browser', 'xfile'].indexOf(value) !== -1) {
          return true;
        } else {
          throw new Error("\"".concat(name, "\" should be either browser or xfile, but now it's ").concat(value));
        }
      default:
        return true;
    }
  };
  keys.forEach(function (key) {
    if (key.trim().length === 0) {
      return;
    }
    var isValid = validParams.find(function (name) {
      return checkName(name, key);
    });
    if (!isValid) {
      var match = fuzzyObj.get(key);
      var guess = !match || !match[0] || !match[0][1] ? '' : ", do you mean \"".concat(match[0][1], "\"?");
      _redux.store.dispatch((0, _actions.addLog)('warning', "Unknown command line parameter: \"".concat(key, "\"").concat(guess)));
    }
    try {
      checkValue(key, args[key]);
    } catch (e) {
      _redux.store.dispatch((0, _actions.addLog)('warning', "Invalid value for cmd line arg: ".concat(e.message)));
    }
  });
};
var bindIpcEvent = function bindIpcEvent() {
  var prepareByOptions = function prepareByOptions() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var lowerCaseOptions = Object.keys(options).reduce(function (prev, key) {
      prev[key.toLowerCase()] = options[key];
      return prev;
    }, {});
    if ((0, _ts_utils.parseBoolLike)(lowerCaseOptions.continueinlastusedtab, false)) {
      return _ipc_cs["default"].ask('PANEL_CLOSE_CURRENT_TAB_AND_SWITCH_TO_LAST_PLAYED');
    } else {
      return Promise.resolve();
    }
  };
  var handleCommand = function handleCommand(cmd, args) {
    // log(cmd, args)

    switch (cmd) {
      case 'PROXY_UPDATE':
        {
          _redux.store.dispatch((0, _actions.updateProxy)(args.proxy));
          return true;
        }
      case 'OPEN_SETTINGS':
        _redux.store.dispatch((0, _actions.updateUI)({
          showSettings: true
        }));
        return true;
      case 'INSPECT_RESULT':
        _redux.store.dispatch((0, _actions.doneInspecting)());
        _redux.store.dispatch((0, _actions.updateSelectedCommand)({
          target: args.locatorInfo.target,
          targetOptions: args.locatorInfo.targetOptions
        }));
        return true;
      case 'RECORD_ADD_COMMAND':
        (0, _log["default"])('got add command', cmd, args);
        var state = _redux.store.getState();
        var commandCount = (0, _recomputed.editorCommandCount)(state);
        var recordIndex = (0, _recomputed.getIndexToInsertRecorded)(state);
        var shouldSkip = state.recorder.skipOpen && args.cmd === 'open';
        _redux.store.dispatch(_simple_actions.Actions.toggleRecorderSkipOpen(false));
        if (shouldSkip) {
          return false;
        }
        if (recordIndex > 0 && recordIndex <= commandCount) {
          _redux.store.dispatch((0, _actions.insertCommand)(args, recordIndex, true));
        } else {
          _redux.store.dispatch((0, _actions.appendCommand)(args, true));
        }
        return true;
      case 'TIMEOUT_STATUS':
        if (_redux.store.getState().status !== C.APP_STATUS.PLAYER) {
          return;
        }
        if (args.playUID && !(0, _player.getPlayer)().checkPlayUID(args.playUID)) {
          return;
        }
        _redux.store.dispatch((0, _actions.setTimeoutStatus)(args));
        return true;
      case 'RUN_TEST_CASE':
        {
          if (_redux.store.getState().status !== C.APP_STATUS.NORMAL) {
            _antd.message.error('can only run macros when it is not recording or playing');
            return false;
          }
          var testCase = args.testCase,
            options = args.options;
          guardCommandLineArgs(options);
          initFromCommandLineArgs(options);
          var storageMan = (0, _storage.getStorageManager)();
          var storageMode = testCase.storageMode || storageMan.getCurrentStrategyType();
          storageMan.isStrategyTypeAvailable(storageMode)["catch"](function (e) {
            _antd.message.error(e.message);
            throw e;
          }).then(function () {
            var needChange = storageMan.setCurrentStrategyType(storageMode);
            _redux.store.dispatch((0, _actions.updateConfig)({
              storageMode: storageMode
            }));
            return needChange ? (0, _utils.delay)(function () {
              return reloadResources.onLastReloadFinished();
            }, 100) : undefined;
          }).then(function () {
            return prepareByOptions(options);
          }).then(function () {
            var state = _redux.store.getState();
            var shouldLoadResources = (0, _recomputed.getShouldLoadResources)(state);
            if (!shouldLoadResources) {
              return Promise.resolve(true);
            }
            return new Promise(function (resolve) {
              resolve(reloadResources.onLastReloadFinished ? reloadResources.onLastReloadFinished() : null);
            }).then(function () {
              return (0, _ts_utils.until)('macros ready', function () {
                var state = _redux.store.getState();
                var macroNodes = (0, _recomputed.getMacroFileNodeList)(state);
                return {
                  pass: macroNodes && macroNodes.length > 0,
                  result: true
                };
              }, 1000, 20 * 1000);
            });
          }).then(function () {
            // Note: for backward compatibility, still use `name` field (which makes sense in flat fs mode) to store `path`
            // after we migrate to standard folder mode
            var state = _redux.store.getState();
            var shouldLoadResources = (0, _recomputed.getShouldLoadResources)(state);
            var macroPath = testCase.name;
            if (shouldLoadResources) {
              var found = (0, _recomputed.findMacroNodeWithCaseInsensitiveRelativePath)(state, testCase.name);
              if (!found) {
                throw new Error("Can't find macro with name \"".concat(testCase.name, "\""));
              }
              macroPath = found.fullPath;
            } else if (_path2["default"].isAbsolute(macroPath) && (0, _storage.getStorageManager)().isXFileMode()) {
              var msg = ["Absolute path locations like \"".concat(macroPath, "\" are not supported yet. "), "Macro location must be relative to macro root folder (currently \"".concat((0, _xfile.getXFile)().getCachedConfig().rootDir, "\")")].join('');
              throw new Error(msg);
            }
            var errorMsg = "No macro found with path '".concat(macroPath, "'");
            return storageMan.getMacroStorage().read(macroPath, 'Text').then(function (macro) {
              if (!macro) {
                _antd.message.error(errorMsg);
                throw new Error(errorMsg);
              }
              return macro;
            }, function (e) {
              if (/File size cannot be determined.|A requested file or directory could not be found/.test(e.message)) {
                throw new Error(errorMsg);
              } else {
                return Promise.reject(e);
              }
            }).then(function (tc) {
              (0, _xlocal.getXLocal)().getVersionLocal().then(function (data) {
                var installed = data.installed,
                  version = data.version;
                var openTc = tc.data.commands.find(function (item) {
                  return item.cmd.toLowerCase() === 'open';
                });
                prepareBeforeRun(options);
                var callback = genPlayerPlayCallback({
                  options: options,
                  installed: installed,
                  version: version
                });
                _redux.store.dispatch((0, _actions.editTestCase)(tc.id));
                _redux.store.dispatch((0, _actions.playerPlay)({
                  macroId: tc && tc.id,
                  title: macroPath,
                  extra: {
                    id: tc && tc.id
                  },
                  mode: _player.Player.C.MODE.STRAIGHT,
                  startIndex: 0,
                  startUrl: openTc ? openTc.target : null,
                  resources: tc.data.commands,
                  postDelay: state.player.playInterval * 1000,
                  overrideScope: genOverrideScope({
                    options: options
                  }),
                  callback: callback
                }))["finally"](callback);
                (0, _sidepanel.checkIfSidePanelOpen)().then(function (isOpen) {
                  _redux.store.dispatch((0, _actions.updateUI)({
                    sidebarTab: 'Macro'
                  }));
                });
              });
            });
          })["catch"](function (e) {
            _redux.store.dispatch((0, _actions.addLog)('error', e.message));
          });
          return true;
        }
      case 'RUN_TEST_SUITE':
        {
          if (_redux.store.getState().status !== C.APP_STATUS.NORMAL) {
            _antd.message.error('can only run test suites when it is not recording or playing');
            return false;
          }
          var testSuite = args.testSuite,
            _options = args.options;
          guardCommandLineArgs(_options);
          initFromCommandLineArgs(_options);
          var _storageMode = testSuite.storageMode || _storage.StorageStrategyType.Browser;
          var _storageMan = (0, _storage.getStorageManager)();
          _storageMan.isStrategyTypeAvailable(_storageMode)["catch"](function (e) {
            _antd.message.error(e.message);
            throw e;
          }).then(function () {
            var needChange = _storageMan.setCurrentStrategyType(_storageMode);
            return needChange ? (0, _utils.delay)(function () {}, 1000) : undefined;
          }).then(function () {
            return prepareByOptions(_options);
          }).then(function () {
            var state = _redux.store.getState();
            var shouldLoadResources = (0, _recomputed.getShouldLoadResources)(state);
            if (testSuite.macroFolder && testSuite.macroFolder.length > 0) {
              var pMacroNodes = function () {
                if (shouldLoadResources) {
                  return (0, _ts_utils.until)('macros ready', function () {
                    var state = _redux.store.getState();
                    var macroNodes = (0, _recomputed.getMacroFileNodeList)(state);
                    return {
                      pass: macroNodes && macroNodes.length > 0,
                      result: macroNodes
                    };
                  }, 1000, 20 * 1000).then(function () {
                    var folder = (0, _recomputed.findMacroFolderWithCaseInsensitiveRelativePath)(_redux.store.getState(), testSuite.macroFolder);
                    return folder && folder.children || [];
                  });
                }
                return _storageMan.getMacroStorage().listR(testSuite.macroFolder).then(function (nodes) {
                  return nodes.filter(function (node) {
                    return node.isFile;
                  });
                });
              }();
              return pMacroNodes.then(function (foundNodes) {
                var macroStorage = _storageMan.getMacroStorage();
                var dirPath = macroStorage.dirPath(testSuite.macroFolder.replace(/\\/g, '/'));
                var path = macroStorage.getPathLib();
                var folderName = path.basename(dirPath);
                if (foundNodes.length === 0) {
                  throw new Error("No folder found for ".concat(testSuite.macroFolder, ", or no macro found in it"));
                }
                prepareBeforeRun(_options);
                (0, _player.getPlayer)({
                  name: 'testSuite'
                }).play({
                  title: folderName,
                  mode: (0, _player.getPlayer)().C.MODE.STRAIGHT,
                  startIndex: 0,
                  resources: foundNodes.map(function (item) {
                    return {
                      id: item.fullPath,
                      loops: 1
                    };
                  }),
                  extra: {
                    id: dirPath,
                    name: folderName
                  },
                  "public": {
                    scope: genOverrideScope({
                      options: _options
                    })
                  },
                  callback: genPlayerPlayCallback({
                    options: _options
                  })
                });
              });
            }
            if (testSuite.name && testSuite.name.length > 0) {
              var pTestSuite = function () {
                if (shouldLoadResources) {
                  return (0, _ts_utils.until)('testSuites ready', function () {
                    var state = _redux.store.getState();
                    var testSuites = state.editor.testSuites;
                    return {
                      pass: testSuites && testSuites.length > 0,
                      result: true
                    };
                  }).then(function () {
                    var state = _redux.store.getState();
                    return (0, _actions.findSameNameTestSuite)(testSuite.name, state.editor.testSuites);
                  });
                }
                return _storageMan.getTestSuiteStorage().read(testSuite.name, 'Text');
              }();
              return pTestSuite.then(function (ts) {
                if (!ts) {
                  _antd.message.error("no macro found with name '".concat(testSuite.name, "'"));
                  return false;
                }
                prepareBeforeRun(_options);
                (0, _player.getPlayer)({
                  name: 'testSuite'
                }).play({
                  title: ts.name,
                  extra: {
                    id: ts.id,
                    name: ts.name
                  },
                  mode: (0, _player.getPlayer)().C.MODE.STRAIGHT,
                  startIndex: 0,
                  resources: ts.cases.map(function (item) {
                    return {
                      id: item.testCaseId,
                      loops: item.loops
                    };
                  }),
                  "public": {
                    scope: genOverrideScope({
                      options: _options
                    })
                  },
                  callback: genPlayerPlayCallback({
                    options: _options
                  })
                });
                return _redux.store.dispatch((0, _actions.updateUI)({
                  sidebarTab: 'test_suites'
                }));
              });
            }
          })["catch"](function (e) {
            _redux.store.dispatch((0, _actions.addLog)('error', e.message));
          });
          return true;
        }
      case 'IMPORT_AND_RUN':
        {
          var _options2 = args.options;
          var _testCase;
          if (args.html) {
            try {
              _testCase = (0, _convert_utils.fromHtml)(args.html);
            } catch (e) {
              _antd.message.error('Failed to parse html', 1.5);
              return false;
            }
          }
          if (args.json) {
            try {
              var jsonStr = typeof args.json === 'string' ? args.json : JSON.stringify(args.json);
              _testCase = (0, _convert_utils.fromJSONString)(jsonStr);
            } catch (e) {
              _antd.message.error('Failed to parse json', 1.5);
              return false;
            }
          }
          if (!_testCase) {
            _antd.message.error('Nothing to import');
            return false;
          }
          guardCommandLineArgs(_options2);
          var _storageMode2 = args.storageMode || _storage.StorageStrategyType.Browser;
          var _storageMan2 = (0, _storage.getStorageManager)();
          return _storageMan2.isStrategyTypeAvailable(_storageMode2)["catch"](function (e) {
            _antd.message.error(e.message);
            throw e;
          }).then(function () {
            var needChange = _storageMan2.setCurrentStrategyType(_storageMode2);
            return needChange ? (0, _utils.delay)(function () {}, 1000) : undefined;
          }).then(function () {
            return prepareByOptions(_options2);
          }).then(function () {
            var state = _redux.store.getState();
            var shouldLoadResources = (0, _recomputed.getShouldLoadResources)(state);
            if (!shouldLoadResources) {
              return Promise.resolve(true);
            }
            return new Promise(function (resolve) {
              resolve(reloadResources.onLastReloadFinished ? reloadResources.onLastReloadFinished() : null);
            }).then(function () {
              return (0, _ts_utils.until)('macros ready', function () {
                var state = _redux.store.getState();
                var macroNodes = (0, _recomputed.getMacroFileNodeList)(state);
                return {
                  pass: macroNodes && macroNodes.length > 0,
                  result: true
                };
              }, 1000, 20 * 1000);
            });
          }).then(function () {
            return _redux.store.dispatch((0, _actions.upsertTestCase)(_testCase)).then(function () {
              return _redux.store.dispatch((0, _actions.editTestCase)(_testCase.name));
            }).then(function (macro) {
              var state = _redux.store.getState();
              var openTc = macro.data.commands.find(function (command) {
                return command.cmd.toLowerCase() === 'open';
              });
              _redux.store.dispatch((0, _actions.playerPlay)({
                macroId: macro.id,
                title: macro.name,
                extra: {
                  id: macro.id
                },
                mode: _player.Player.C.MODE.STRAIGHT,
                startIndex: 0,
                startUrl: openTc ? openTc.target : null,
                resources: macro.data.commands,
                postDelay: state.player.playInterval * 1000,
                overrideScope: genOverrideScope({
                  options: _options2
                }),
                callback: genPlayerPlayCallback({
                  options: _options2
                })
              }));
              return true;
            })["catch"](function (e) {
              _log["default"].error(e.stack);
              throw e;
            });
          });
        }
      case 'ADD_VISION_IMAGE':
        {
          var dataUrl = args.dataUrl,
            _args$requireRename = args.requireRename,
            requireRename = _args$requireRename === void 0 ? false : _args$requireRename;
          var fileName = "".concat((0, _utils.randomName)(), "_dpi_").concat((0, _utils.getPageDpi)(), ".png");
          return (0, _storage.getStorageManager)().getVisionStorage().write(fileName, (0, _utils.dataURItoBlob)(dataUrl)).then(restoreVisions).then(function () {
            if (!requireRename) return {
              fileName: fileName
            };
            return _redux.store.dispatch((0, _actions.renameVisionImage)(fileName)).then(function (fileName) {
              restoreVisions();
              return {
                fileName: fileName
              };
            });
          });
        }
      case 'RESTORE_SCREENSHOTS':
        {
          restoreScreenshots();
          return true;
        }
      case 'UPDATE_ACTIVE_TAB':
        {
          updatePageTitle(args);
          return true;
        }
      case 'IS_ACTIVE':
        {
          return true;
        }
      case 'ADD_LOG':
        {
          if (!args) return false;
          if (args.info) _redux.store.dispatch((0, _actions.addLog)('info', args.info, args.options));
          if (args.warning) _redux.store.dispatch((0, _actions.addLog)('warning', args.warning));
          if (args.error) _redux.store.dispatch((0, _actions.addLog)('error', args.error));
          return true;
        }
      case 'SCREEN_AREA_SELECTED':
        {
          return captureScreenshotService.captureScreenInSelectionSimple(args.tabId, {
            rect: args.rect,
            devicePixelRatio: args.devicePixelRatio
          }).then(function (dataUrl) {
            return handleCommand('ADD_VISION_IMAGE', {
              dataUrl: dataUrl,
              requireRename: false
            });
          });
        }
      case 'STORE_SCREENSHOT_IN_SELECTION':
        {
          var tabId = args.tabId,
            rect = args.rect,
            devicePixelRatio = args.devicePixelRatio,
            _fileName = args.fileName;
          return (0, _ipc_cache.getIpcCache)().get(tabId).then(function (ipc) {
            return (0, _tab_utils.activateTab)(tabId, true).then(function () {
              return (0, _utils.delay)(function () {}, C.SCREENSHOT_DELAY);
            }).then(function () {
              return captureScreenshotService.captureScreenInSelection(tabId, {
                rect: rect,
                devicePixelRatio: devicePixelRatio
              }, {
                startCapture: function startCapture() {
                  return ipc.ask('START_CAPTURE_FULL_SCREENSHOT', {
                    hideScrollbar: false
                  });
                },
                endCapture: function endCapture(pageInfo) {
                  return ipc.ask('END_CAPTURE_FULL_SCREENSHOT', {
                    pageInfo: pageInfo
                  });
                },
                scrollPage: function scrollPage(offset) {
                  return ipc.ask('SCROLL_PAGE', {
                    offset: offset
                  });
                }
              });
            }).then(function (dataUrl) {
              return (0, _storage.getStorageManager)().getScreenshotStorage().overwrite(_fileName, (0, _utils.dataURItoBlob)(dataUrl)).then(function () {
                handleCommand('RESTORE_SCREENSHOTS');
                return _fileName;
              });
            });
          });
        }
    }
  };
  _ipc_cs["default"].onAsk(handleCommand);

  // It's for the call from popup page
  window.handleCommand = handleCommand;
};
var bindWindowEvents = function bindWindowEvents() {
  // reset status to normal when panel closed
  window.addEventListener('beforeunload', function () {
    _ipc_cs["default"].ask('PANEL_STOP_RECORDING', {});
    _ipc_cs["default"].ask('PANEL_STOP_PLAYING', {});
  });
  window.addEventListener('resize', function () {
    // if sidepanel return, we need to update the size
    // const isSidePanel = window.location.href.includes('sidepanel.html')
    if ((0, _utils.isSidePanelWindow)()) {
      return;
    }
    var size = {
      width: window.outerWidth,
      height: window.outerHeight
    };
    var state = _redux.store.getState();
    _redux.store.dispatch((0, _actions.updateConfig)({
      size: _objectSpread(_objectSpread({}, state.config.size), {}, _defineProperty({}, state.config.showSidebar ? 'with_sidebar' : 'standard', size))
    }));
  });
  window.addEventListener('message', function (e) {
    switch (e.data && e.data.type) {
      case 'RELOAD_VISIONS':
        return _redux.store.dispatch((0, _actions.listVisions)());
    }
  });
  (0, _timeout_counter.onTimeoutStatus)(function (payload) {
    if (_redux.store.getState().status !== C.APP_STATUS.PLAYER) {
      return;
    }
    if (payload.playUID && !(0, _player.getPlayer)().checkPlayUID(payload.playUID)) {
      return;
    }
    _redux.store.dispatch((0, _actions.setTimeoutStatus)(payload));
  });
};
var bindVariableChange = function bindVariableChange() {
  // Note: bind to onChange in next tick, to make sure vars instance is already initialized
  // so that `bindVariableChange` could be executed before `initPlayer`
  setTimeout(function () {
    (0, _variables.getVarsInstance)().onChange(function (_ref3) {
      var vars = _ref3.vars;
      var variables = Object.keys(vars).map(function (key) {
        return {
          key: key,
          value: vars[key]
        };
      });
      _redux.store.dispatch((0, _actions.setVariables)(variables));
    });
  }, 0);
};
var initSaveTestCase = function initSaveTestCase() {
  (0, _save_test_case["default"])(_redux.store);
};
var updatePageTitle = function updatePageTitle(args) {
  // Note: Firefox includes page url in title, there could be not enough space for tab title
  if (_web_extension["default"].isFirefox()) return true;
  var origTitle = document.title.replace(/ - .*$/, '');
  document.title = "".concat(origTitle, " - (Tab: ").concat(args.title, ")");
};
function tryPreinstall() {
  return _storage3["default"].get('preinstall_info').then(function (info) {
    var status = function () {
      if (!info) return 'fresh';
      var _info$askedVersions = info.askedVersions,
        askedVersions = _info$askedVersions === void 0 ? [] : _info$askedVersions;
      if (askedVersions.indexOf(_config["default"].preinstall.version) === -1) return 'new_version_available';
      return 'up_to_date';
    }();
    switch (status) {
      case 'fresh':
        return _redux.store.dispatch((0, _actions.preinstall)());
      case 'new_version_available':
        return _redux.store.dispatch((0, _actions.updateUI)({
          newPreinstallVersion: true
        }));
      case 'up_to_date':
      default:
        return false;
    }
  });
}
function reloadResources() {
  var p = bindMacroAndTestSuites().then(function () {
    return (0, _ts_utils.flow)((0, _ts_utils.guardVoidPromise)(restoreCSV), (0, _ts_utils.guardVoidPromise)(restoreVisions), (0, _ts_utils.guardVoidPromise)(restoreScreenshots), (0, _ts_utils.guardVoidPromise)(function () {
      return _redux.store.dispatch((0, _actions.resetEditingIfNeeded)());
    }));
  });
  reloadResources.onLastReloadFinished = function (callback) {
    return callback ? p.then(callback) : p;
  };
  return p;
}
function checkXFileVersion() {
  return (0, _xfile.getXFile)().getVersion().then(function (versionInfo) {
    if (!versionInfo.version) {
      return;
    }
    if (_semver["default"].lt(versionInfo.version, _config["default"].xfile.minVersionToReadBigFile)) {
      var msg = "Can not read/save screenshot on hard-drive. Please upgrade FileAccess XModule to latest version (>= ".concat(_config["default"].xfile.minVersionToReadBigFile, ").");
      _antd.message.warn(msg);
      _redux.store.dispatch((0, _actions.addLog)('warning', msg));
    }
  });
}
function bindStorageModeChanged() {
  var first = true;
  (0, _storage.getStorageManager)().on(_storage.StorageManagerEvent.StrategyTypeChanged, function (type) {
    if (first) {
      first = false;
      return;
    }
    try {
      var p = function () {
        if (type === _storage.StorageStrategyType.XFile) {
          return checkXFileVersion();
        }
        return Promise.resolve();
      }();
      p.then(reloadResources).then(function () {
        _redux.store.dispatch(_simple_actions.Actions.selectInitialMacro(type));
      });
    } catch (e) {
      _log["default"].warn(e);
    }
  });
  (0, _storage.getStorageManager)().on(_storage.StorageManagerEvent.RootDirChanged, function (type) {
    reloadResources();
  });
  (0, _storage.getStorageManager)().on(_storage.StorageManagerEvent.ForceReload, function (type) {
    reloadResources();
  });
}
function remedyMigrationIfNeeded() {
  var todo = [];
  var shouldRemedyMacroFsMigration = (0, _04_01_macro_suite_storage.getMigrateMacroTestSuiteToBrowserFileSystem)().shouldMigrate() && !(0, _migration.getKantuMigrationService)().isMigrated(_types.MigrationJobType.MigrateMacroTestSuiteToBrowserFileSystem);
  if (shouldRemedyMacroFsMigration || _config["default"].forceMigrationRemedy) {
    alert("Kantu introduced an internal storage migration in this version. It isn't supposed to disturb you, but looks like there is some unexpected error: \n\n=> Solution: After you click OK Kantu is going to download your macros and test suites from the old storage into a ZIP file. You can then manually import the macros back into the new Kantu version.\n\nIf you see this dialog, please also inform us at team@a9t9.com or in the user forum about the issue.");
    todo.push(function () {
      return (0, _04_01_macro_suite_storage.getMigrateMacroTestSuiteToBrowserFileSystem)().remedy();
    });
  }
  return _ts_utils.flow.apply(void 0, todo);
}
function initFromQuery() {
  var queries = (0, _utils.parseQuery)(window.location.search);
  _redux.store.dispatch(_simple_actions.Actions.setFrom(queries.from || _state.RunBy.Manual));
  if (queries.settings) {
    _redux.store.dispatch((0, _actions.updateUI)({
      showSettings: true
    }));
  }
}
function initProxyState() {
  _ipc_cs["default"].ask('PANEL_GET_PROXY').then(function (proxy) {
    _redux.store.dispatch((0, _actions.updateProxy)(proxy));
  });
}
function init() {
  initFromQuery();
  bindIpcEvent();
  bindWindowEvents();
  bindVariableChange();
  bindStorageModeChanged();
  (0, _init_player.initPlayer)(_redux.store);
  restoreEditing();
  restoreConfig();
  initSaveTestCase();
  initProxyState();
  tryPreinstall()["catch"](function (e) {
    _log["default"].warn('Error in preinstall', e);
  }).then(function () {
    reloadResources();
  });
  setTimeout(function () {
    remedyMigrationIfNeeded();
  }, 1000);
  _ipc_cs["default"].ask('I_AM_PANEL', {});
  document.title = document.title + ' ' + _web_extension["default"].runtime.getManifest().version;
  _ipc_cs["default"].ask('PANEL_CURRENT_PLAY_TAB_INFO').then(updatePageTitle);
  _storage3["default"].get('config').then(function (config) {
    if (config && config.useDarkTheme) {
      document.documentElement.setAttribute('data-theme', 'dark');
    }
    render(config);
  });
}
Promise.all([restoreConfig(), (0, _xfile.getXFile)().getConfig(), (0, _license.getLicenseService)().getLatestInfo()]).then(function (_ref4) {
  var _ref5 = _slicedToArray(_ref4, 2),
    config = _ref5[0],
    xFileConfig = _ref5[1];
  // Note: This is the first call of getStorageManager
  // and it must passed in `getMacros` to make test suite work
  (0, _storage.getStorageManager)(config.storageMode, {
    getConfig: function getConfig() {
      return _redux.store.getState().config;
    },
    getMacros: function getMacros() {
      return (0, _recomputed.getMacroFileNodeList)(_redux.store.getState());
    },
    getMaxMacroCount: function getMaxMacroCount(strategyType) {
      var count = function () {
        switch (strategyType) {
          case _storage.StorageStrategyType.XFile:
            return (0, _license.getLicenseService)().getMaxXFileMacros();
          case _storage.StorageStrategyType.Browser:
          default:
            return Infinity;
        }
      }();
      return Promise.resolve(count);
    }
  });
  init();
}, init);

/***/ }),

/***/ 45329:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48287)["Buffer"];


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ocrViewportCalibration = exports.ocrViewport = exports.initPlayer = void 0;
var _react = _interopRequireDefault(__webpack_require__(96540));
var _antd = __webpack_require__(33061);
var _variables = _interopRequireWildcard(__webpack_require__(54836));
var _interpreter2 = _interopRequireDefault(__webpack_require__(2363));
var _eval = __webpack_require__(23427);
var _storage = __webpack_require__(97467);
var _csv = __webpack_require__(5421);
var _player = __webpack_require__(18392);
var _ipc_cs = _interopRequireDefault(__webpack_require__(96571));
var _log = _interopRequireDefault(__webpack_require__(89130));
var _utils = __webpack_require__(46580);
var C = _interopRequireWildcard(__webpack_require__(95902));
var act = _interopRequireWildcard(__webpack_require__(35127));
var _simple_actions = __webpack_require__(8588);
var _web_extension = _interopRequireDefault(__webpack_require__(41953));
var _file_saver = _interopRequireDefault(__webpack_require__(50261));
var _macro_log = __webpack_require__(91433);
var _xy = __webpack_require__(10029);
var _desktop = __webpack_require__(14406);
var _x_user_io = __webpack_require__(4124);
var _xlocal = __webpack_require__(95536);
var _ocr = __webpack_require__(99998);
var _ts_utils = __webpack_require__(1601);
var _storage2 = __webpack_require__(82798);
var _types = __webpack_require__(35847);
var _counter = __webpack_require__(80199);
var _command_counter = __webpack_require__(38268);
var _endpoint_picker = __webpack_require__(30502);
var _prompt = __webpack_require__(10409);
var _types2 = __webpack_require__(76701);
var _call_stack = __webpack_require__(41488);
var _macro = __webpack_require__(9599);
var _types3 = __webpack_require__(95022);
var _macro_monitor = __webpack_require__(78799);
var _recomputed = __webpack_require__(87307);
var _types4 = __webpack_require__(6351);
var _command = __webpack_require__(85393);
var _filesystem = __webpack_require__(89937);
var _proxy = __webpack_require__(44790);
var _types5 = __webpack_require__(78847);
var _xfile = __webpack_require__(63109);
var _macro_extra_data = __webpack_require__(3112);
var _dom_utils = __webpack_require__(92950);
var _path2 = _interopRequireWildcard(__webpack_require__(26513));
var _encrypt = __webpack_require__(21208);
var _license = __webpack_require__(12277);
var _cv_utils = __webpack_require__(7345);
var _search_vision = __webpack_require__(16977);
var _config = _interopRequireDefault(__webpack_require__(8747));
var _tab_utils = __webpack_require__(20041);
var _capture_screenshot = __webpack_require__(6329);
var _global_state = __webpack_require__(8327);
var _tab = __webpack_require__(13755);
var _run_command = __webpack_require__(7030);
var _clipboard = _interopRequireDefault(__webpack_require__(92642));
var _timeout_counter = __webpack_require__(83945);
var _languages = __webpack_require__(64013);
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var REPLAY_SPEED_DELAY = {
  NODISPLAYV1: 1,
  NODISPLAY: 1,
  FASTV1: 1,
  // avoid UI freezing (DemoCsvReadArray: Fast=0 is ~30-40% faster as no UI updates)
  FAST: 1,
  MEDIUMV1: 300,
  MEDIUM: 300,
  SLOWV1: 2000,
  SLOW: 2000
};
var TimeTracker = /*#__PURE__*/function () {
  function TimeTracker() {
    _classCallCheck(this, TimeTracker);
    this.reset();
  }
  _createClass(TimeTracker, [{
    key: "reset",
    value: function reset() {
      this.startTime = new Date();
    }
  }, {
    key: "elapsed",
    value: function elapsed() {
      return new Date() - this.startTime;
    }
  }, {
    key: "elapsedInSeconds",
    value: function elapsedInSeconds() {
      var diff = this.elapsed();
      return (diff / 1000).toFixed(2) + 's';
    }
  }]);
  return TimeTracker;
}();
var captureScreenshotService = new _capture_screenshot.CaptureScreenshotService({
  captureVisibleTab: function captureVisibleTab(windowId, options) {
    return _ipc_cs["default"].ask('PANEL_CAPTURE_VISIBLE_TAB', {
      windowId: windowId,
      options: options
    });
  }
});
var setProxy = function setProxy(proxy) {
  return _ipc_cs["default"].ask('PANEL_SET_PROXY', {
    proxy: proxy
  });
};
var checkRelativeIndexArr = [];
var checkRelativeIndex = function checkRelativeIndex(index) {
  var Count = checkRelativeIndexArr.filter(function (r) {
    return r === index;
  }).length;
  if (Count == 0) {
    checkRelativeIndexArr.push(index);
    return 1;
  } else {
    return 0;
  }
};
var checkRelativeTabId = function checkRelativeTabId(tabId) {
  return new Promise(function (resolve, reject) {
    _web_extension["default"].tabs.get(tabId).then(function (tab) {
      if (tab.length != 0) {
        resolve(true);
      } else {
        resolve(false);
      }
    })["catch"](function (e) {
      resolve(false);
    });
  });
};
var getTabIdwithIndex0 = function getTabIdwithIndex0(tabId) {
  return new Promise(function (resolve, reject) {
    chrome.tabs.query({}, function (tabs) {
      var ctab = tabs.filter(function (r) {
        return r.active === true && r.url.indexOf('chrome-extension://') == -1;
      }); // TODO: add "moz-extension://" too ??
      resolve(ctab[0]);
    });
  });
};
var replaceEscapedChar = function replaceEscapedChar(str, command, field) {
  var shouldEscape = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  if (!shouldEscape) {
    return str;
  }
  if (['csvRead', 'csvReadArray', 'csvSave', 'gotoIf', 'if', 'while', 'gotoIf_v2', 'if_v2', 'while_v2', 'XType', 'elseif', 'repeatIf', 'executeScript', 'executeScript_Sandbox', 'executeAsyncScript', 'executeAsyncScript_Sandbox'].indexOf(command.cmd) !== -1 && field === 'target') {
    return str;
  }
  if (['csvSaveArray'].indexOf(command.cmd) !== -1 && field === 'value') {
    return str;
  }
  if (['XRun', 'XRunAndWait'].indexOf(command.cmd) !== -1) {
    return str;
  }
  return [[/\\n/g, '\n'], [/\\t/g, '\t'], [/\\b/g, '\b'], [/\\f/g, '\f'], [/\\t/g, '\t'], [/\\v/g, '\v']].reduce(function (prev, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      reg = _ref2[0],
      c = _ref2[1];
    return prev.replace(reg, c);
  }, str);
};
function captureImage(args) {
  var searchArea = args.searchArea,
    storedImageRect = args.storedImageRect,
    scaleDpi = args.scaleDpi,
    isDesktop = args.isDesktop,
    devicePixelRatio = args.devicePixelRatio;
  if (isDesktop) {
    var cvApi = (0, _desktop.getNativeCVAPI)();
    var crop = function crop(imgSrc) {
      switch (searchArea) {
        case 'rect':
          {
            if (!storedImageRect) {
              throw new Error('storedImageRect is required');
            }
            // Note: Must scale up rect to screen coordinates
            return (0, _dom_utils.subImage)(imgSrc, (0, _dom_utils.scaleRect)(storedImageRect, devicePixelRatio)).then(function (dataUrl) {
              return {
                dataUrl: dataUrl,
                offset: {
                  x: storedImageRect.x,
                  y: storedImageRect.y
                }
              };
            });
          }
        default:
          {
            return Promise.resolve({
              dataUrl: imgSrc,
              offset: {
                x: 0,
                y: 0
              }
            });
          }
      }
    };
    return cvApi.captureDesktop({
      path: undefined
    }).then(function (hardDrivePath) {
      return cvApi.readFileAsDataURL(hardDrivePath, true);
    }).then(function (originalDataUrl) {
      return crop(originalDataUrl).then(function (_ref3) {
        var dataUrl = _ref3.dataUrl,
          offset = _ref3.offset;
        return Promise.all([(0, _search_vision.saveDataUrlToLastScreenshot)(dataUrl), (0, _search_vision.saveDataUrlToLastDesktopScreenshot)(originalDataUrl)]).then(function () {
          return {
            dataUrl: dataUrl,
            offset: offset,
            viewportOffset: offset,
            scale: 1 / devicePixelRatio
          };
        });
      });
    });
  } else {
    return (0, _search_vision.getScreenshotInSearchArea)({
      searchArea: searchArea,
      storedImageRect: storedImageRect,
      devicePixelRatio: devicePixelRatio,
      captureScreenshotService: captureScreenshotService,
      dpiScale: scaleDpi ? 96 / (0, _utils.getPageDpi)() : 1
    });
  }
}
var getOcrResponse = function getOcrResponse(_ref4) {
  var searchArea = _ref4.searchArea,
    storedImageRect = _ref4.storedImageRect,
    ocrApiTimeout = _ref4.ocrApiTimeout,
    store = _ref4.store,
    lang = _ref4.lang,
    engine = _ref4.engine,
    scale = _ref4.scale,
    isTable = _ref4.isTable,
    isDesktop = _ref4.isDesktop,
    isLog = _ref4.isLog,
    imageDataUrl = _ref4.imageDataUrl;
  var ocrScale = scale;
  return new Promise(function (resolve, reject) {
    // Note: must make sure `getOcrCommandCounter` is called with args before this (currently it's in `initPlayer`)
    var ocrCmdCounter = (0, _command_counter.getOcrCommandCounter)();
    var getApiAndKey = function getApiAndKey() {
      var stateConfig = store.getState().config;
      console.log('config :>> ', _config["default"]);
      console.log('stateConfig :>> ', stateConfig);
      var ocrMode = stateConfig.ocrMode,
        ocrEngine = stateConfig.ocrEngine,
        ocrSpaceApiKey = stateConfig.ocrSpaceApiKey,
        ocrOfflineURL = stateConfig.ocrOfflineURL,
        ocrOfflineAPIKey = stateConfig.ocrOfflineAPIKey;
      console.log('ocrMode :>> ', ocrMode);
      console.log('ocrSpaceApiKey :>> ', ocrSpaceApiKey);
      switch (ocrMode) {
        case 'enabled':
          {
            if (!ocrSpaceApiKey) {
              throw new Error('Please set OCR API key first');
            }
            var ocrEndpointPicker = (0, _endpoint_picker.getOcrEndpointPicker)();

            // For sample keys check: https://github.com/teamdocs/sidebar_uiv/issues/106
            // All free keys start with "K8...". 
            var isFreeApiKey = (0, _ocr.isOcrSpaceFreeKey)(ocrSpaceApiKey);
            if (!isFreeApiKey) {
              // it's a pro key 
              var proOcrEndpoint;
              if (ocrEngine == 1) {
                proOcrEndpoint = _config["default"].ocr.proApi1Endpoint;
              } else if (ocrEngine == 2) {
                proOcrEndpoint = _config["default"].ocr.proApi2Endpoint;
              }
              var server = ocrEndpointPicker.setSingleServerInstance({
                "id": ocrEngine.toString(),
                "key": ocrSpaceApiKey,
                "url": proOcrEndpoint
              });
              return server;
            } else {
              var _server = ocrEndpointPicker.setSingleServerInstance({
                "id": "3",
                "key": ocrSpaceApiKey,
                "url": _config["default"].ocr.freeApiEndpoint
              });
              return _server;
            }
          }
        case 'offline_enabled':
          {
            if (!/^https?:\/\//.test(ocrOfflineURL)) {
              throw new Error('Please set local OCR API first');
            }
            if (!ocrOfflineAPIKey || !ocrOfflineAPIKey.length) {
              throw new Error('Please set local OCR API key first');
            }
            return Promise.resolve({
              url: ocrOfflineURL,
              key: ocrOfflineAPIKey
            });
          }
        default:
          {
            throw new Error('Please enable OCR first');
          }
      }
    };
    var prepare = function () {
      // If version is not free version and the user reaches the 100th online OCR conversions,
      // then - before making the 101 conversion - call the API for a license check.
      // Of course, only if we've cached the license key and previous license check result
      if ((0, _license.getLicenseService)().hasNoLicense() || ocrCmdCounter.get() !== _config["default"].xmodulesLimit.unregistered.ocrCommandCount) {
        return Promise.resolve();
      }
      return (0, _license.getLicenseService)().recheckLicenseIfPossible().then(function () {
        var isExpired = (0, _license.getLicenseService)().isLicenseExpired();
        if (isExpired) {
          throw new Error('Activation check failed. Reset to free edition. If you believe this was an error, please contact tech support');
        }
      });
    }();
    var dataURLObjPromise = imageDataUrl ? Promise.resolve({
      dataUrl: imageDataUrl
    }) : prepare.then(function () {
      return isDesktop ? Promise.resolve() : _ipc_cs["default"].ask('PANEL_CLEAR_OCR_MATCHES_ON_PLAYING_PAGE');
    })
    // Note: add 1s delay here to make sure old OCR overlayed are cleared before taking new screenshot
    .then(function () {
      return (0, _utils.delay)(function () {}, 1000);
    }).then(function () {
      return captureImage({
        isDesktop: isDesktop,
        storedImageRect: storedImageRect,
        searchArea: /\.png/i.test(searchArea) ? 'rect' : searchArea,
        scaleDpi: true,
        devicePixelRatio: window.devicePixelRatio
      });
    });
    return dataURLObjPromise.then(function (_ref5) {
      var dataUrl = _ref5.dataUrl,
        _ref5$offset = _ref5.offset,
        offset = _ref5$offset === void 0 ? {
          x: 0,
          y: 0
        } : _ref5$offset,
        _ref5$viewportOffset = _ref5.viewportOffset,
        viewportOffset = _ref5$viewportOffset === void 0 ? {
          x: 0,
          y: 0
        } : _ref5$viewportOffset,
        _ref5$scale = _ref5.scale,
        scale = _ref5$scale === void 0 ? 1 : _ref5$scale;
      // console.log('final dataUrl :>> ', dataUrl);

      var blob = (0, _utils.dataURItoBlob)(dataUrl);
      var fileSize = (0, _storage2.readableSize)(blob.size);
      var startTime = new Date() * 1;
      var getDuration = function getDuration(startTime, endTime) {
        return ((endTime - startTime) / 1000).toFixed(1) + 's';
      };
      var cancelCountDown = (0, _ts_utils.countDown)({
        interval: 1000,
        timeout: ocrApiTimeout,
        onTick: function onTick(_ref6) {
          var past = _ref6.past,
            total = _ref6.total;
          store.dispatch(act.setTimeoutStatus({
            past: past,
            total: total,
            type: 'OCR in progress'
          }));
        }
      });

      // Note: check in advance so that it throws error before making OCR requests
      ocrCmdCounter.check();
      if (store.getState().player.status != 'STOPPED') {
        store.dispatch(act.addLog('info', "OCR (".concat(lang, ") started (").concat(fileSize, ")")));
      }
      if (engine == 98) {
        var tesseractLanguage = (0, _languages.convertOcrLanguageToTesseractLanguage)(lang);
        var tesseractResult = (0, _ocr.runOCRTesseractC)({
          engine: engine,
          image: dataUrl.split(',')[1],
          imageDataURL: dataUrl,
          language: tesseractLanguage,
          totalTimeout: ocrApiTimeout,
          singleApiTimeout: _config["default"].ocr.singleApiTimeout,
          os: function () {
            var ua = window.navigator.userAgent;
            if (/windows/i.test(ua)) return 'windows';
            if (/mac/i.test(ua)) return 'mac';
            return 'linux';
          }(),
          isOverlayRequired: true
        }, function (log, isNetwork) {
          // console.log('log :>> ', log);
          if (isNetwork && 'loading language traineddata' === log.status) {
            var progressInPercentText = (log.progress * 100).toFixed(0) + '%';
            store.dispatch(act.addLog('info', "Loading OCR (".concat(lang, ") language - ").concat(progressInPercentText)));
          }
        }).then(function (data) {
          console.log('tess data :>> ', data);
          var ocrRes = data;
          cancelCountDown();
          if (store.getState().player.status != 'STOPPED') {
            store.dispatch(act.addLog('info', "OCR result received (".concat(getDuration(startTime, new Date().getTime()), " from Javascript OCR)")));
          }
          return {
            offset: offset,
            viewportOffset: viewportOffset,
            response: (0, _ocr.scaleOcrResponseCoordinates)(ocrRes, scale)
          };
        });
        console.log('tesseractResult:>>', tesseractResult);
        return tesseractResult;
      } else if (engine == 99) {
        var _startTime = new Date().getTime();
        var xModuleOcrResult = (0, _ocr.runOCRLocal)({
          engine: engine,
          image: dataUrl.split(',')[1],
          language: lang,
          totalTimeout: ocrApiTimeout,
          singleApiTimeout: _config["default"].ocr.singleApiTimeout,
          os: function () {
            var ua = window.navigator.userAgent;
            if (/windows/i.test(ua)) return 'windows';
            if (/mac/i.test(ua)) return 'mac';
            return 'linux';
          }(),
          isOverlayRequired: true
        }).then(function (data) {
          var b = new Buffer.from(data, 'base64');
          var results = b.toString();
          var ocrRes = JSON.parse(results);
          console.log('local ocrRes :>> ', ocrRes);
          cancelCountDown();
          if (store.getState().player.status != 'STOPPED') {
            store.dispatch(act.addLog('info', "OCR result received (".concat(getDuration(_startTime, new Date().getTime()), " from XModule OCR)")));
          }
          return {
            offset: offset,
            viewportOffset: viewportOffset,
            response: (0, _ocr.scaleOcrResponseCoordinates)(ocrRes, scale)
          };
        });
        console.log('xModuleOcrResult :>> ', xModuleOcrResult);
        return xModuleOcrResult;
      } else {
        var remoteOcrResult = (0, _ocr.runOCR)({
          engine: engine,
          isTable: isTable,
          scale: ocrScale,
          image: dataUrl,
          language: lang,
          totalTimeout: ocrApiTimeout,
          singleApiTimeout: _config["default"].ocr.singleApiTimeout,
          isOverlayRequired: true,
          getApiUrlAndApiKey: function getApiUrlAndApiKey() {
            return getApiAndKey().then(function (data) {
              console.log('getApiUrlAndApiKey data :>> ', data);
              //  store.dispatch(act.addLog('info', `OCR request is sent to ${data.url}`))
              return data;
            });
          },
          shouldRetry: function shouldRetry() {
            var ocrMode = store.getState().config.ocrMode;
            console.log('shouldRetry :>> ');
            switch (ocrMode) {
              case 'enabled':
                return (0, _endpoint_picker.getOcrEndpointPicker)().isAllDown().then(function (down) {
                  return !down;
                });
              case 'offline_enabled':
              case 'disabled':
                return false;
            }
          },
          didGetResponse: function didGetResponse(data) {
            var server = data.server,
              startTime = data.startTime,
              endTime = data.endTime,
              response = data.response,
              error = data.error;
            var id = server.id || server.url;
            console.log('didGetResponse data:>> ', data);
            return (0, _endpoint_picker.getOcrEndpointPicker)().validServers().then(function (result) {
              // It hasn't marked current api, so it's safer to tell we have next to try if there are gte 2 servers.
              var hasNextToTry = result.servers.length >= 2;
              var endpointType = server.url == _config["default"].ocr.proApi1Endpoint ? 'pro1' : server.url == _config["default"].ocr.proApi2Endpoint ? 'pro2' : 'free';
              if (response) {
                store.dispatch(act.addLog('info', "OCR result received (".concat(getDuration(startTime, endTime), " from ").concat(endpointType, " endpoint)")));
              } else if (error) {
                store.dispatch(act.addLog('warning', "Error in OCR endpoint ".concat(id, " after ").concat(getDuration(startTime, endTime), ": ").concat(error.message) + (hasNextToTry ? ' - trying next.' : '')));
              }
              if (id && response) {
                (0, _endpoint_picker.getOcrEndpointPicker)().use(id);
              }
              if (!id) return Promise.resolve();
              // Note: only mark server as error if browser is online
              if (!window.navigator.onLine) return Promise.resolve();
              return (0, _endpoint_picker.getOcrEndpointPicker)().report(id, {
                lastError: error,
                lastOcrExitCode: response ? response.OCRExitCode : undefined,
                lastRequestTimestamp: startTime,
                lastResponseTimestamp: endTime,
                lastTotalMilliseconds: endTime - startTime
              }).then(function () {});
            });
          }
        }).then(function (data) {
          cancelCountDown();

          // Don't increase ocr counter if it's a local ocr requests
          if (store.getState().config.ocrMode === 'enabled') {
            ocrCmdCounter.inc();
          }
          return {
            offset: offset,
            viewportOffset: viewportOffset,
            response: (0, _ocr.scaleOcrResponseCoordinates)(data, scale)
          };
        }, function (e) {
          cancelCountDown();
          if (/All OCR servers are down/i.test(e.message)) {
            (0, _endpoint_picker.getOcrEndpointPicker)().reset();
          }
          throw e;
        });
        console.log('remoteOcrResult :>> ', remoteOcrResult);
        return remoteOcrResult;
      }
    }).then(resolve, reject);
  });
};

// calibration OCR
var ocrViewportCalibration = exports.ocrViewportCalibration = function ocrViewportCalibration(_ref7) {
  var store = _ref7.store,
    isDesktop = _ref7.isDesktop;
  var clearBadge = function clearBadge() {
    return _ipc_cs["default"].ask('PANEL_UPDATE_BADGE', {
      type: 'play',
      clear: true
    });
  };
  return getOcrResponse({
    store: store,
    isDesktop: isDesktop,
    lang: store.getState().config.ocrLanguage,
    engine: store.getState().config.ocrEngine,
    scale: 'true',
    searchArea: 'viewport',
    storedImageRect: null,
    ocrApiTimeout: _config["default"].ocr.apiTimeout
  }).then(function (_ref8) {
    var response = _ref8.response,
      offset = _ref8.offset,
      viewportOffset = _ref8.viewportOffset;
    var documentBasedParseResults = (0, _ts_utils.safeUpdateIn)(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
      return _objectSpread(_objectSpread({}, word), {}, {
        Top: word.Top + offset.y,
        Left: word.Left + offset.x
      });
    }, response.ParsedResults);
    var viewportBasedParseResults = (0, _ts_utils.safeUpdateIn)(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
      return _objectSpread(_objectSpread({}, word), {}, {
        Top: word.Top + viewportOffset.y,
        Left: word.Left + viewportOffset.x
      });
    }, response.ParsedResults);
    var _ref9 = function () {
        var match = 'OCRTEXTX'.match(/^(.+)@POS=(\d+)$/i);
        if (!match) return ['OCRTEXTX', 0, false];
        return [match[1], parseInt(match[2]) - 1, true];
      }(),
      _ref10 = _slicedToArray(_ref9, 3),
      str = _ref10[0],
      index = _ref10[1],
      hasPos = _ref10[2];
    var searchResult = (0, _ocr.searchTextInOCRResponse)({
      text: str,
      index: index,
      exhaust: true,
      parsedResults: viewportBasedParseResults
    });
    var hit = searchResult.hit,
      all = searchResult.all;
    if (hit) {
      var center = (0, _ocr.ocrMatchCenter)(hit);
      var calibrateNumber = center.width * window.devicePixelRatio / hit.words[0].word.WordText.length;
      store.getState().config.ocrCalibration_internal = calibrateNumber;
      (0, _global_state.updateState)((0, _utils.setIn)(['ocrCalibration_internal'], calibrateNumber));
      localStorage.setItem('ocrCalibration', calibrateNumber);
    }
    var ocrMatches = [
    // All words identified by OCR into one group
    {
      similarity: 1,
      highlight: _types.OcrHighlightType.Matched,
      words: (0, _ocr.allWordsWithPosition)(documentBasedParseResults, [])
    }];

    // show overlay on website
    return _ipc_cs["default"].ask('PANEL_HIGHLIGHT_OCR_MATCHES', {
      ocrMatches: ocrMatches,
      isDesktop: isDesktop,
      screenAvailableSize: {
        width: screen.availWidth,
        height: screen.availHeight
      },
      localStorage: (0, _utils.cloneSerializableLocalStorage)(localStorage)
    });
  }).then(function () {
    clearBadge();
  }, function (e) {
    clearBadge();
    throw e;
  });
};
var ocrViewport = exports.ocrViewport = function ocrViewport(_ref11) {
  var store = _ref11.store,
    isDesktop = _ref11.isDesktop;
  var clearBadge = function clearBadge() {
    return _ipc_cs["default"].ask('PANEL_UPDATE_BADGE', {
      type: 'play',
      clear: true
    });
  };
  return getOcrResponse({
    store: store,
    isDesktop: isDesktop,
    lang: store.getState().config.ocrLanguage,
    engine: store.getState().config.ocrEngine,
    scale: 'true',
    searchArea: 'viewport',
    storedImageRect: null,
    ocrApiTimeout: _config["default"].ocr.apiTimeout
  }).then(function (_ref12) {
    var response = _ref12.response,
      offset = _ref12.offset,
      viewportOffset = _ref12.viewportOffset;
    console.log('response :>> ', response);
    var documentBasedParseResults = (0, _ts_utils.safeUpdateIn)(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
      return _objectSpread(_objectSpread({}, word), {}, {
        Top: word.Top + offset.y,
        Left: word.Left + offset.x
      });
    }, response.ParsedResults);
    var ocrMatches = [
    // All words identified by OCR into one group
    {
      similarity: 1,
      highlight: _types.OcrHighlightType.Matched,
      words: (0, _ocr.allWordsWithPosition)(documentBasedParseResults, [])
    }];

    // show overlay on website
    // 
    return _ipc_cs["default"].ask('PANEL_HIGHLIGHT_OCR_MATCHES', {
      ocrMatches: ocrMatches,
      isDesktop: isDesktop,
      screenAvailableSize: {
        width: screen.availWidth,
        height: screen.availHeight
      },
      localStorage: (0, _utils.cloneSerializableLocalStorage)(localStorage),
      showOcrOverlay: true
    });
  }).then(function () {
    clearBadge();
  }, function (e) {
    clearBadge();
    throw e;
  });
};
var withVisualHighlightHidden = function withVisualHighlightHidden(fn) {
  var hide = function hide() {
    return _ipc_cs["default"].ask('PANEL_HIDE_VISION_HIGHLIGHT')["catch"](function () {});
  };
  var show = function show() {
    return _ipc_cs["default"].ask('PANEL_SHOW_VISION_HIGHLIGHT')["catch"](function () {});
  };
  return hide().then(function () {
    return fn();
  }).then(function (data) {
    show();
    return data;
  }, function (e) {
    show();
    throw e;
  });
};
var hideDownloadBar = function hideDownloadBar() {
  return _ipc_cs["default"].ask('PANEL_DISABLE_DOWNLOAD_BAR', {})["catch"](function (e) {
    return true;
  });
};
var showDownloadbar = function showDownloadbar() {
  return _ipc_cs["default"].ask('PANEL_ENABLE_DOWNLOAD_BAR', {})["catch"](function (e) {
    return true;
  });
};
var showDownloadBarFinally = function showDownloadBarFinally(hasXCommand, fn) {
  return Promise.resolve(fn()).then(function (data) {
    if (!hasXCommand()) {
      return data;
    }
    return showDownloadbar().then(function () {
      return data;
    });
  }, function (e) {
    if (!hasXCommand()) {
      return Promise.reject(e);
    }
    return showDownloadbar().then(function () {
      return Promise.reject(e);
    });
  });
};
var interpretSpecialCommands = function interpretSpecialCommands(_ref13) {
  var store = _ref13.store,
    vars = _ref13.vars,
    getTcPlayer = _ref13.getTcPlayer,
    getInterpreter = _ref13.getInterpreter,
    xCmdCounter = _ref13.xCmdCounter;
  var commandRunners = [interpretCSVCommands({
    store: store,
    vars: vars,
    getTcPlayer: getTcPlayer,
    getInterpreter: getInterpreter,
    xCmdCounter: xCmdCounter
  }), interpretCsFreeCommands({
    store: store,
    vars: vars,
    getTcPlayer: getTcPlayer,
    getInterpreter: getInterpreter,
    xCmdCounter: xCmdCounter
  })];
  return function (command, index) {
    return commandRunners.reduce(function (prev, cur) {
      if (prev !== undefined) return prev;
      return cur(command, index);
    }, undefined);
  };
};
var interpretCsFreeCommands = function interpretCsFreeCommands(_ref14) {
  var store = _ref14.store,
    vars = _ref14.vars,
    getTcPlayer = _ref14.getTcPlayer,
    getInterpreter = _ref14.getInterpreter,
    xCmdCounter = _ref14.xCmdCounter;
  var runCsFreeCommands = function runCsFreeCommands(command, index, parentCommand) {
    var csvStorage = (0, _storage.getStorageManager)().getCSVStorage();
    var ssStorage = (0, _storage.getStorageManager)().getScreenshotStorage();
    var macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
    var path = macroStorage.getPathLib();
    // console.log('command :>> ', command);
    // console.log('parentCommand :>> ', parentCommand);
    var cmd = command.cmd,
      target = command.target,
      value = command.value,
      extra = command.extra;
    var result = {
      isFlowLogic: true
    };
    var runCommand = function runCommand(command) {
      // console.log('runCommand command :>> ', command);
      return askBackgroundToRunCommand({
        vars: vars,
        store: store,
        command: command,
        state: getTcPlayer().getState(),
        preRun: function preRun(command, state, askBgToRun) {
          return askBgToRun(command);
        }
      });
    };
    var guardOcrSettings = function guardOcrSettings() {
      if (store.getState().config.ocrMode === 'disabled' && store.getState().config.ocrEngine != 99 && vars.get('!ocrEngine') != 99 && store.getState().config.ocrEngine != 98 && vars.get('!ocrEngine') != 98) {
        throw new Error('OCR feature disabled.');
      }
    };
    var playerState = getTcPlayer().getState();
    var curMacroRelativePath = (0, _storage.getStorageManager)().getMacroStorage().relativePath(playerState.extra.macroId);
    var curMacroDirPath = path.dirname(curMacroRelativePath);
    var resolvePath = function resolvePath(subpath) {
      subpath = subpath.replace(/\\/g, '/');
      if (subpath.indexOf('/') === 0) {
        return path.normalize(subpath).replace(/^(\/|\\)/, '');
      } else {
        return path.join(curMacroDirPath, subpath);
      }
    };
    var getSidePanelWidth = /*#__PURE__*/function () {
      var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(args) {
        var sidePanelPadding, config;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // sidepanel has a padding around it's content
              sidePanelPadding = 20;
              _context.next = 3;
              return store.getState().config;
            case 3:
              config = _context.sent;
              if (!(config && !config.sidePanelOnLeft)) {
                _context.next = 8;
                break;
              }
              return _context.abrupt("return", Promise.resolve([0, args]));
            case 8:
              return _context.abrupt("return", (0, _global_state.getState)().then(function (globalState) {
                return _web_extension["default"].tabs.get(globalState.tabIds.toPlay).then(function (playTab) {
                  return _web_extension["default"].windows.get(playTab.windowId).then(function (playWindow) {
                    var sidePanelWidth = playWindow.width - playTab.width - sidePanelPadding;
                    return [sidePanelWidth, args];
                  });
                });
              }));
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function getSidePanelWidth(_x) {
        return _ref15.apply(this, arguments);
      };
    }();
    var shouldShowOcrOverlay = function shouldShowOcrOverlay(cmd) {
      var isDesktopMode = (0, _cv_utils.isCVTypeForDesktop)(vars.get("!CVSCOPE"));
      var isApplicableCmd = ['XClickText', 'XClickTextRelative', 'XMoveText', 'XMoveTextRelative', 'OCRSearch', 'OCRExtractbyTextRelative'].includes(cmd);
      if (isApplicableCmd && isDesktopMode) {
        return true;
      } else {
        return false;
      }
    };
    if (shouldShowOcrOverlay(cmd)) {
      store.dispatch(_simple_actions.Actions.setOcrInDesktopMode(true));
    }
    console.log('cmd:>> ', cmd);
    switch (cmd) {
      case 'repeatIf':
      case 'elseif':
      case 'if_v2':
      case 'while_v2':
      case 'gotoIf_v2':
      case 'if':
      case 'while':
      case 'gotoIf':
        {
          (0, _log["default"])("Executing ".concat(cmd, ": ").concat(target));
          return (0, _eval.evaluateScript)(target).then(function (result) {
            return {
              condition: result,
              byPass: true
            };
          }, function (e) {
            throw new Error("Error in condition of ".concat(cmd, ": ").concat(e.message));
          });
        }
      case 'times':
        {
          var interpreter = getInterpreter();
          var timesKey = interpreter.getKeyForTimes(index);
          var cursor = 1 + (interpreter.getExtraByKey(timesKey) || 0);
          var max = parseInt(target, 10);
          if (isNaN(max)) {
            throw new Error('target must be a positive number');
          }
          if (max < 1) {
            return {
              condition: false,
              byPass: true
            };
          }
          var shouldContinue = cursor <= max;
          if (shouldContinue) {
            interpreter.setExtraByKey(timesKey, cursor);
            vars.set({
              '!TIMES': cursor
            }, true);
          } else {
            interpreter.removeExtraByKey(timesKey);
            var key = interpreter.getKeyForSurroundingTimes(index);
            var nextCursor = interpreter.getExtraByKey(key);
            if (nextCursor !== undefined) {
              vars.set({
                '!TIMES': nextCursor
              }, true);
            } else {
              vars.set({
                '!TIMES': cursor
              }, true);
            }
          }
          return {
            condition: shouldContinue,
            byPass: true
          };
        }
      case 'forEach':
        {
          var _interpreter = getInterpreter();
          var forEachKey = "forEach_".concat(index);
          var tagHasBreak = _interpreter.hasBreak(index);
          if (tagHasBreak) {
            _interpreter.removeBreak(index);
          }
          var current = _interpreter.getExtraByKey(forEachKey);
          var _cursor = tagHasBreak ? 0 : 1 + (current === undefined ? -1 : current);
          var list = vars.get(target);
          if (!Array.isArray(list)) {
            throw new Error('target must be an array');
          }
          var len = list.length;
          var _shouldContinue = _cursor < len;
          var varsToSet = _shouldContinue ? _defineProperty({}, value, list[_cursor]) : null;
          vars.set({
            '!FOREACH': _cursor
          }, true);
          if (!_shouldContinue) {
            _interpreter.removeExtraByKey(forEachKey);
          } else {
            _interpreter.setExtraByKey(forEachKey, _cursor);
          }
          return {
            vars: varsToSet,
            condition: _shouldContinue,
            byPass: true
          };
        }
      case 'assert':
      case 'verify':
        {
          var isAssert = cmd === 'assert';
          var varName = target;
          if (!varName || !varName.length) {
            throw new Error("".concat(cmd, ": target is required as variable name"));
          }
          var actualString = "".concat(vars.get(varName));
          var expectedString = "".concat(value);
          if (actualString === expectedString) {
            return {
              byPass: true
            };
          }
          var _message = "Expected variable ".concat(varName, " to be ").concat(expectedString, ", but it is ").concat(actualString);
          if (isAssert) {
            throw new Error(_message);
          }
          return {
            byPass: true,
            log: {
              error: _message
            }
          };
        }
      case 'executeScript_Sandbox':
      case 'executeAsyncScript_Sandbox':
        {
          var code = ";(function () { ".concat(target, " })();");
          return (0, _eval.evaluateScript)(code).then(function (result) {
            if (value && value.length) {
              return {
                byPass: true,
                vars: _defineProperty({}, value, result)
              };
            }
            return {
              byPass: true
            };
          })["catch"](function (e) {
            throw new Error("Error in executeScript_Sandbox code: ".concat(e.message));
          });
        }
      case 'setProxy':
        {
          var p = function () {
            if (/direct/i.test(target && target.trim())) {
              return setProxy(null).then(function () {
                return store.dispatch(act.addLog('info', 'Proxy reset to none'));
              });
            }
            var _ref17 = function () {
                if (/default/i.test(target && target.trim())) {
                  return [store.getState().config.defaultProxy, store.getState().config.defaultProxyAuth];
                }
                return [target, value];
              }(),
              _ref18 = _slicedToArray(_ref17, 2),
              proxyUrl = _ref18[0],
              auth = _ref18[1];
            var proxy = (0, _proxy.parseProxyUrl)(proxyUrl, auth);
            var isSocks = proxy.type === _types5.ProxyScheme.Socks4 || proxy.type === _types5.ProxyScheme.Socks5;
            var hasAuth = !!proxy.username;
            if (isSocks && hasAuth && !(0, _dom_utils.isFirefox)()) {
              store.dispatch(act.addLog('warning', "Browser doesn't support authentication on socks proxy"));
            }
            return setProxy(proxy).then(function () {
              vars.set({
                '!PROXY_EXEC_COUNT': 1 + (vars.get('!PROXY_EXEC_COUNT') || 0)
              }, true);
              store.dispatch(act.addLog('info', 'Proxy set to ' + proxyUrl));
            });
          }();
          return p.then(function () {
            return {
              byPass: true
            };
          });
        }
      case 'run':
        {
          var state = store.getState();
          var macroRelativePath = resolvePath(target);
          var macroNode = (0, _recomputed.findMacroNodeWithCaseInsensitiveRelativePath)(state, macroRelativePath);
          var _macroStorage = (0, _storage.getStorageManager)().getMacroStorage();
          return _macroStorage.read(macroNode && macroNode.fullPath || macroRelativePath, 'Text').then(function (macro) {
            var openCmd = macro.data.commands.find(function (command) {
              return command.cmd.toLowerCase() === 'open' || command.cmd.toLowerCase() === 'openBrowser';
            });
            var playerState = act.commonPlayerState(store.getState(), {
              extra: {
                id: macro.id
              },
              mode: (0, _player.getPlayer)().C.MODE.STRAIGHT,
              startIndex: 0,
              startUrl: openCmd ? openCmd.target : null,
              resources: macro.data.commands,
              postDelay: state.config.playCommandInterval * 1000,
              isStep: (0, _player.getPlayer)().getState().isStep,
              loopsCursor: 1,
              loopsStart: 1,
              loopsEnd: 1
            }, macro.id, macro.name);
            return (0, _utils.delay)(function () {}, 10).then(function () {
              return (0, _call_stack.getMacroCallStack)().call(macro, {
                playerState: playerState,
                status: _macro.MacroStatus.Running,
                nextIndex: 0,
                commandResults: []
              });
            }).then(function () {
              store.dispatch(act.updateMacroPlayStatus(macro.id, _macro_extra_data.MacroResultStatus.Success));
              return {
                byPass: true
              };
            });
          });
        }
      case 'store':
        {
          var target_ = target;

          // if value == '!ocrlanguage' and engine == 98 (tesseract) 
          // then transform the target (eg. ger) to tesseract language code (deu)
          if (value == '!ocrlanguage') {
            var engine_ = store.getState().config.ocrEngine;
            if (engine_ == 98) {
              target_ = (0, _languages.convertOcrLanguageToTesseractLanguage)(target);
            }
          }
          return {
            byPass: true,
            vars: _defineProperty({}, value, target_)
          };
        }
      case 'echo':
        {
          var _extra = function () {
            if (value === '#shownotification') {
              return {
                options: {
                  notification: true
                }
              };
            }
            if (value) {
              return {
                options: {
                  color: value
                }
              };
            }
            return {};
          }();

          // console.log('echo target :>> ', target);        

          return {
            byPass: true,
            log: _objectSpread({
              info: target
            }, _extra)
          };
        }
      case 'prompt':
        {
          var _target$match = target.match(/^([^@]+)(?:@(.+))?$/),
            _target$match2 = _slicedToArray(_target$match, 3),
            _ = _target$match2[0],
            _message2 = _target$match2[1],
            defaultAnswer = _target$match2[2];
          return (0, _utils.isSidePanelWindowAsync)(window).then(function (isSidePanel) {
            if (!isSidePanel) {
              return _ipc_cs["default"].ask('PANEL_BRING_PANEL_TO_FOREGROUND');
            }
          }).then(function () {
            return (0, _prompt.prompt)({
              message: _message2,
              value: defaultAnswer || ''
            });
          }).then(function (text) {
            return {
              byPass: true,
              vars: _defineProperty({}, value, text)
            };
          });
        }
      case 'throwError':
        {
          throw new Error(target);
        }
      case 'pause':
        {
          var n = parseInt(target);
          if (!target || !target.length || n === 0) {
            return {
              byPass: true,
              control: {
                type: 'pause'
              }
            };
          }
          if (isNaN(n) || n < 0) {
            throw new Error('target of pause command must be a positive integer');
          }
          var currentPlayUID = getTcPlayer().getPlayUID();
          return (0, _ts_utils.withCountDown)({
            timeout: n,
            interval: 1000,
            onTick: function onTick(_ref19) {
              var total = _ref19.total,
                past = _ref19.past,
                cancel = _ref19.cancel;
              if (store.getState().player.status !== C.PLAYER_STATUS.PLAYING) {
                return cancel();
              }
              if (!getTcPlayer().checkPlayUID(currentPlayUID)) {
                return cancel();
              }
              store.dispatch(act.setTimeoutStatus({
                past: past,
                total: total,
                type: 'pause'
              }));
            }
          }).then(function () {
            return {
              byPass: true
            };
          });
        }
      case 'localStorageExport':
        {
          var deleteAfterExport = /\s*#DeleteAfterExport\s*/i.test(value);
          if (/^\path=/i.test(target)) {
            (0, _xlocal.getXLocal)().getVersionLocal().then(function (data) {
              var installed = data.installed,
                version = data.version;
              var text = store.getState().logs.map(_macro_log.renderLog).join('\n');
              var ua = window.navigator.userAgent;
              var path = target.split('path=')[1];
              function os() {
                if (/windows/i.test(ua)) return 'windows';
                if (/mac/i.test(ua)) return 'mac';
                return 'linux';
              }
              if (installed) {
                var osType = os();
                (0, _ocr.runDownloadLog)(text, path, osType).then(function (data) {
                  (0, _log["default"])(data);
                });
              } else {
                var _text = store.getState().logs.map(_macro_log.renderLog).join('\n');
                _file_saver["default"].saveAs(new Blob([_text]), 'uivision_log.txt');
                if (deleteAfterExport) {
                  store.dispatch(act.clearLogs());
                }
              }
            });
            return result;
          }
          if (/^\s*log\s*$/i.test(target)) {
            var text = store.getState().logs.map(_macro_log.renderLog).join('\n');
            _file_saver["default"].saveAs(new Blob([text]), 'uivision_log.txt');
            if (deleteAfterExport) {
              store.dispatch(act.clearLogs());
            }
            return result;
          }
          if (/\.csv$/i.test(target)) {
            return csvStorage.exists(target).then(function (existed) {
              if (!existed) throw new Error("".concat(target, " doesn't exist"));
              return csvStorage.read(target, 'Text').then(function (text) {
                _file_saver["default"].saveAs(new Blob([text]), target);
                if (deleteAfterExport) {
                  csvStorage.remove(target).then(function () {
                    return store.dispatch(act.listCSV());
                  });
                }
                return result;
              });
            });
          }
          if (/\.png$/i.test(target)) {
            return ssStorage.exists(target).then(function (existed) {
              if (!existed) throw new Error("".concat(target, " doesn't exist"));
              return ssStorage.read(target, 'ArrayBuffer').then(function (buffer) {
                _file_saver["default"].saveAs(new Blob([new Uint8Array(buffer)]), target);
                if (deleteAfterExport) {
                  ssStorage.remove(target).then(function () {
                    return store.dispatch(act.listScreenshots());
                  });
                }
                return result;
              });
            });
          }
          throw new Error("".concat(target, " doesn't exist"));
        }
      case 'OCRSearch':
        {
          guardOcrSettings();
          if (!value || !value.length) {
            throw new Error('value is required');
          }
          var curent_cmd = localStorage.curent_cmd;
          var _lang = vars.get('!ocrLanguage').toLowerCase();
          var _engine = vars.get('!ocrEngine') || store.getState().config.ocrEngine;
          var _scale = vars.get('!ocrScale');
          var isTable = vars.get('!ocrTableExtraction');
          var timeout = vars.get('!TIMEOUT_WAIT') * 1000;
          var searchArea = vars.get('!visualSearchArea') || 'viewport';
          var storedImageRect = vars.get('!storedImageRect');
          var _ocrApiTimeout = _config["default"].ocr.apiTimeout;
          var _ref20 = function () {
              var match = target.match(/^(.+)@POS=(\d+)$/i);
              if (!match) return [target, 0, false];
              return [match[1], parseInt(match[2]) - 1, true];
            }(),
            _ref21 = _slicedToArray(_ref20, 3),
            str = _ref21[0],
            _index = _ref21[1],
            hasPos = _ref21[2];
          var isLog = command.mode_type != undefined && command.mode_type == 'local' ? 'NA' : true;
          var run = function run() {
            return getOcrResponse({
              store: store,
              lang: _lang,
              scale: _scale,
              engine: _engine,
              isTable: isTable,
              searchArea: searchArea,
              storedImageRect: storedImageRect,
              ocrApiTimeout: _ocrApiTimeout,
              isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')),
              isLog: isLog
            }).then( /*#__PURE__*/function () {
              var _ref23 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref22) {
                var response, offset, viewportOffset, viewportBasedParseResults, documentBasedParseResults, searchResult, hit, all, newVars, textHasWildcard, ocrMatches, pScaleFactor;
                return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                  while (1) switch (_context2.prev = _context2.next) {
                    case 0:
                      response = _ref22.response, offset = _ref22.offset, viewportOffset = _ref22.viewportOffset;
                      console.log('getOcrResponse response :>> ', response);

                      // const state = await getState()
                      viewportBasedParseResults = (0, _ts_utils.safeUpdateIn)(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
                        return _objectSpread(_objectSpread({}, word), {}, {
                          Top: word.Top + viewportOffset.y,
                          Left: word.Left + viewportOffset.x
                        });
                      }, response.ParsedResults);
                      documentBasedParseResults = (0, _ts_utils.safeUpdateIn)(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
                        return _objectSpread(_objectSpread({}, word), {}, {
                          Top: word.Top + offset.y,
                          Left: word.Left + offset.x
                        });
                      }, response.ParsedResults);
                      searchResult = (0, _ocr.searchTextInOCRResponse)({
                        text: str,
                        index: _index,
                        exhaust: true,
                        parsedResults: viewportBasedParseResults
                      });
                      hit = searchResult.hit, all = searchResult.all;
                      console.log('searchResult :>> ', searchResult);

                      // if (command.extra && command.extra.throwError != undefined && command.extra.throwError != true)
                      if (!(command.mode_type != undefined && command.mode_type == 'local' && command.extra && command.extra.throwError != true)) {
                        _context2.next = 10;
                        break;
                      }
                      if (!(searchResult.all.length == 0)) {
                        _context2.next = 10;
                        break;
                      }
                      throw new Error("E311: OCR text match for '".concat(str, "' not found"));
                    case 10:
                      newVars = function () {
                        if (!hit) {
                          return _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, value, 0), '!ocrx', 0), '!ocry', 0), '!ocrwidth', 0), '!ocrheight', 0), '!ocr_left_x', 0), '!ocr_right_x', 0);
                        } else {
                          var center = (0, _ocr.ocrMatchCenter)(hit);

                          // Note: when '@POS=xx' is used, the possible values are only 0 and 1
                          vars.set({
                            '!ocrx': center.x,
                            '!ocry': center.y,
                            '!ocrwidth': center.width,
                            '!ocrheight': center.height,
                            '!ocr_left_x': center.x - center.width / 2,
                            '!ocr_right_x': center.x + center.width / 2
                          }, true);
                          return _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, value, hasPos ? 1 : all.length), '!ocrx', center.x), '!ocry', center.y), '!ocrwidth', center.width), '!ocrheight', center.height), '!ocr_left_x', center.x - center.width / 2), '!ocr_right_x', center.x + center.width / 2);
                        }
                      }();
                      textHasWildcard = str.includes('*') || str.includes('?');
                      ocrMatches = [
                      // All words identified by OCR into one group
                      {
                        similarity: 1,
                        highlight: _types.OcrHighlightType.Identified,
                        words: (0, _ocr.allWordsWithPosition)(documentBasedParseResults, (0, _ts_utils.flatten)(all.map(function (item) {
                          return item.words.map(function (word) {
                            return word.position;
                          });
                        })))
                      }].concat(_toConsumableArray((0, _ts_utils.compose)(all[_index] ? (0, _utils.setIn)([_index, 'highlight'], textHasWildcard ? _types.OcrHighlightType.WildcardTopMatched : _types.OcrHighlightType.TopMatched) : function (x) {
                        return x;
                      }, (0, _utils.setIn)(['[]', 'highlight'], textHasWildcard ? _types.OcrHighlightType.WildcardMatched : _types.OcrHighlightType.Matched), (0, _utils.updateIn)(['[]', 'words', '[]', 'word'], function (word) {
                        return _objectSpread(_objectSpread({}, word), {}, {
                          Top: word.Top + offset.y - viewportOffset.y,
                          Left: word.Left + offset.x + viewportOffset.x
                        });
                      }))(all)));
                      if (extra && extra.debugVisual && curent_cmd != 'OCRExtractbyTextRelative' && curent_cmd != 'visionLimitSearchAreabyTextRelative') {
                        // show overlay on website
                        _ipc_cs["default"].ask('PANEL_HIGHLIGHT_OCR_MATCHES', {
                          ocrMatches: ocrMatches,
                          isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')),
                          screenAvailableSize: {
                            width: screen.availWidth,
                            height: screen.availHeight
                          },
                          localStorage: (0, _utils.cloneSerializableLocalStorage)(localStorage)
                        });
                      } else {
                        // Note: store ocrMatches for preview window when Find button click (OCRExtractbyTextRelative);
                        localStorage.setItem('ocrMatches_preview', JSON.stringify(ocrMatches));
                      }
                      pScaleFactor = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')) ? (0, _xy.getNativeXYAPI)().getScalingFactor() : Promise.resolve(1); // Note: In desktop mode, `!ocrx`, `!ocry` and `best` should be desktop coordinates
                      return _context2.abrupt("return", pScaleFactor.then(function (factor) {
                        return (0, _ts_utils.compose)(newVars['!ocrx'] === undefined ? _ts_utils.id : (0, _ts_utils.safeUpdateIn)(['vars', '!ocrx'], function (n) {
                          return n * factor;
                        }), newVars['!ocry'] === undefined ? _ts_utils.id : (0, _ts_utils.safeUpdateIn)(['vars', '!ocry'], function (n) {
                          return n * factor;
                        }), (0, _ts_utils.safeUpdateIn)(['best'], function (match) {
                          return match && match.similarity ? (0, _ocr.scaleOcrTextSearchMatch)(match, factor) : null;
                        }))({
                          vars: newVars,
                          byPass: true,
                          best: hit
                        });
                      }));
                    case 16:
                    case "end":
                      return _context2.stop();
                  }
                }, _callee2);
              }));
              return function (_x2) {
                return _ref23.apply(this, arguments);
              };
            }());
          };
          if (command.mode_type !== undefined && command.mode_type === 'local') {
            var runWithRetry = (0, _utils.retry)(run, {
              timeout: timeout,
              shouldRetry: function shouldRetry(e) {
                return store.getState().status === C.APP_STATUS.PLAYER && /OCR.*\ not found/.test(e.message);
              },
              retryInterval: function retryInterval(retryCount, lastRetryInterval) {
                return 0.5 + 0.25 * retryCount;
              },
              onFirstFail: function onFirstFail() {
                (0, _timeout_counter.startSendingTimeoutStatus)(timeout, 'Vision waiting');
              },
              onFinal: function onFinal() {
                (0, _timeout_counter.clearTimerForTimeoutStatus)();
              }
            });
            return runWithRetry()["catch"](function (e) {
              // Note: extra.throwError === true, when "Find" button is used
              if (cmd === 'OCRSearch' || extra && extra.throwError) {
                throw e;
              }
              return _objectSpread(_objectSpread({
                byPass: true
              }, isNotVerifyOrAssert && value && value.length ? {
                vars: _defineProperty({}, value, 0)
              } : {}), cmd === 'visualVerify' ? {
                log: {
                  error: e.message
                }
              } : {});
            });
          } else {
            return run();
          }
        }
      case 'OCRExtractScreenshot':
        guardOcrSettings();
        if (!value || !value.length) {
          throw new Error('value is required');
        }
        var lang = vars.get('!ocrLanguage').toLowerCase();
        var engine = vars.get('!ocrEngine');
        var scale = vars.get('!ocrScale');
        var ocrApiTimeout = _config["default"].ocr.apiTimeout;
        var ssImageName = /\.(png)$/i.test(target) ? target : null;
        console.log('ssImageName :>> ', ssImageName);
        if (ssImageName) {
          return (0, _storage.getStorageManager)().getScreenshotStorage().read(ssImageName, 'DataURL')["catch"](function () {
            // search in vision
            return (0, _storage.getStorageManager)().getVisionStorage().read(ssImageName, 'DataURL')["catch"](function () {
              throw new Error("".concat(ssImageName, " not found in Screenshots"));
            }).then(function (dataUrl) {
              throw new Error("E505: OCRExtractScreenshot uses images from the Screenshot tab as input");
            });
          }).then(function (dataUrl) {
            return dataUrl;
          }).then(function (imageDataUrl) {
            console.log('imageDataUrl :>> ', imageDataUrl);
            if (imageDataUrl) {
              return getOcrResponse({
                store: store,
                lang: lang,
                scale: scale,
                engine: engine,
                ocrApiTimeout: ocrApiTimeout,
                imageDataUrl: imageDataUrl
              }).then(function (_ref26) {
                var response = _ref26.response;
                return {
                  byPass: true,
                  vars: _defineProperty({}, value, response.ParsedResults && response.ParsedResults[0] ? response.ParsedResults[0].ParsedText : '')
                };
              });
            } else {
              throw new Error('Screenshot not found');
            }
          });
        } else {
          throw new Error('target is expected to have *.png extension');
        }
      case 'OCRExtract':
        throw new Error('E318: OCRExtract has been deprecated, use OCRExtractRelative or OCRExtractScreenshot instead');
      case 'OCRExtractRelative':
        {
          guardOcrSettings();
          if (!value || !value.length) {
            throw new Error('value is required');
          }
          var _lang2 = vars.get('!ocrLanguage').toLowerCase();
          var _engine2 = vars.get('!ocrEngine');
          var _scale2 = vars.get('!ocrScale');
          var _isTable = vars.get('!ocrTableExtraction');
          var _ocrApiTimeout2 = _config["default"].ocr.apiTimeout;
          var isRelative = /relative/i.test(cmd);
          var ocrExtractFromBrowserPage = function ocrExtractFromBrowserPage() {
            return _ipc_cs["default"].ask('PANEL_CLEAR_OCR_MATCHES_ON_PLAYING_PAGE')["catch"](function () {}).then(function () {
              return (0, _utils.delay)(function () {}, 1000);
            }).then(function () {
              return Promise.all([runCsFreeCommands(_objectSpread(_objectSpread({}, command), {}, {
                cmd: 'visualAssert',
                target: target,
                value: '',
                extra: _objectSpread(_objectSpread({}, command.extra || {}), {}, {
                  // Note: `relativeVisual` is used in bg.js, for call of `visualAssert` that doesn't specify relativeVisual,
                  // it still uses file name postfix "_relative" to tell whether it's relative (green/pink boxes) or not
                  relativeVisual: isRelative,
                  debugVisual: false
                })
              })), (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')) ? (0, _xy.getNativeXYAPI)().getScalingFactor() : Promise.resolve(1)]);
            }).then(function (_ref27) {
              var _ref28 = _slicedToArray(_ref27, 2),
                result = _ref28[0],
                scalingFactor = _ref28[1];
              var best = result.best;
              if (!best) throw new Error("E311: No OCR text match found for '".concat(target, "'"));
              return withVisualHighlightHidden(function () {
                return getOcrResponse({
                  store: store,
                  lang: _lang2,
                  scale: _scale2,
                  engine: _engine2,
                  isTable: _isTable,
                  ocrApiTimeout: _ocrApiTimeout2,
                  searchArea: 'rect',
                  storedImageRect: {
                    // Note: In desktop mode, coordinates returned by `visualXXX` is already desktop mouse coordinates
                    // must convert it back to css coordinates (for later use in image cropping or preview highlight)
                    x: best.viewportLeft / scalingFactor,
                    y: best.viewportTop / scalingFactor,
                    width: best.width / scalingFactor,
                    height: best.height / scalingFactor
                  },
                  isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'))
                }).then(function (_ref29) {
                  var response = _ref29.response,
                    offset = _ref29.offset,
                    viewportOffset = _ref29.viewportOffset;
                  var documentBasedParseResults = (0, _ts_utils.safeUpdateIn)(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
                    return _objectSpread(_objectSpread({}, word), {}, {
                      Top: word.Top + offset.y,
                      Left: word.Left + offset.x
                    });
                  }, response.ParsedResults);
                  var ocrMatches = [
                  // All words identified by OCR into one group
                  {
                    similarity: 1,
                    highlight: _types.OcrHighlightType.Matched,
                    words: (0, _ocr.allWordsWithPosition)(documentBasedParseResults, [])
                  }];
                  if (extra && extra.debugVisual) {
                    // show overlay on website
                    _ipc_cs["default"].ask('PANEL_HIGHLIGHT_OCR_MATCHES', {
                      ocrMatches: ocrMatches,
                      isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')),
                      screenAvailableSize: {
                        width: screen.availWidth,
                        height: screen.availHeight
                      },
                      localStorage: (0, _utils.cloneSerializableLocalStorage)(localStorage)
                    });
                  }
                  return {
                    byPass: true,
                    vars: _defineProperty({}, value, response.ParsedResults && response.ParsedResults[0] ? response.ParsedResults[0].ParsedText : '')
                  };
                });
              });
            });
          };
          return ocrExtractFromBrowserPage();
        }
      case 'OCRExtractbyTextRelative':
        {
          guardOcrSettings();
          var _lang3 = vars.get('!ocrLanguage').toLowerCase();
          var _engine3 = vars.get('!ocrEngine');
          var _scale3 = vars.get('!ocrScale');
          var _isTable2 = vars.get('!ocrTableExtraction');
          var _ocrApiTimeout3 = _config["default"].ocr.apiTimeout;
          var _isRelative = /relative/i.test(cmd);
          var trimmedTarget = target.trim();
          var isDesktopMode = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
          (0, _global_state.updateState)((0, _utils.setIn)(['caliber_trget'], trimmedTarget));
          (0, _global_state.updateState)((0, _utils.setIn)(['curent_cmd'], cmd));
          localStorage.setItem('curent_cmd', cmd);
          localStorage.setItem('caliber_trget', trimmedTarget);
          localStorage.setItem('isDesktopMode', isDesktopMode);
          var defaultWh = 'W30H10';
          var regexForTarget = /^.*#R.*,.*$/;
          if (!regexForTarget.test(trimmedTarget)) {
            throw new Error('Wrong input ' + trimmedTarget);
          }
          if (trimmedTarget.indexOf('W') === -1 && trimmedTarget.indexOf('H') === -1) {
            trimmedTarget = trimmedTarget + defaultWh;
          }
          if (trimmedTarget.indexOf('#R') == -1 || trimmedTarget.includes(' ') || trimmedTarget.includes('X')) {
            throw new Error('Wrong input ' + trimmedTarget);
          }
          if (trimmedTarget.indexOf('W') === -1 || trimmedTarget.indexOf('H') === -1) {
            throw new Error('Wrong input ' + trimmedTarget);
          }
          var indexW = trimmedTarget.indexOf('W');
          var indexH = trimmedTarget.indexOf('H');
          if (indexW !== -1 && indexH !== -1 && indexW < indexH) {
            (0, _log["default"])("'W' appears first in the string");
          } else {
            // Note: reason for this changes is we are using regex accordingly in getCoordinates function for commands.
            // Extract the values of 'W' and 'H' from the string
            var wValue = trimmedTarget.match(/W(\d+)/)[1];
            var hValue = trimmedTarget.match(/H(\d+)/)[1];
            trimmedTarget = trimmedTarget.replace(/W(\d+)/, "H".concat(hValue));
            trimmedTarget = trimmedTarget.replace(/H(\d+)/, "W".concat(wValue));
            localStorage.setItem('caliber_trget', trimmedTarget);
          }
          return _ipc_cs["default"].ask('PANEL_CLEAR_OCR_MATCHES_ON_PLAYING_PAGE')["catch"](function () {}).then(function () {
            return (0, _utils.delay)(function () {}, 1000);
          }).then(function () {
            return Promise.all([runCsFreeCommands(_objectSpread(_objectSpread({}, command), {}, {
              cmd: 'OCRSearch',
              target: trimmedTarget.split('#')[0],
              value: '__ocrResult__'
            })), (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')) ? (0, _xy.getNativeXYAPI)().getScalingFactor() : Promise.resolve(1)]);
          }).then(function (_ref30) {
            var _ref31 = _slicedToArray(_ref30, 2),
              result = _ref31[0],
              scalingFactor = _ref31[1];
            store.dispatch(_simple_actions.Actions.setOcrInDesktopMode(false));

            // const isDesk = isCVTypeForDesktop(vars.get('!CVSCOPE'));
            // Note: This part is commented to get slected area screenshot on FInd button click
            // if (extra && extra.debugVisual && isDesk) {
            //   return {
            //     byPass: true,
            //     vars: {
            //       [value]: ''
            //     }
            //   }
            // }

            var best = result.best;
            if (!best) throw new Error("E311: No OCR text match found for '".concat(target, "'"));
            var xC = result.best.words[0].word.Left;
            var yC = result.best.words[0].word.Top;
            var HeightR = result.best.words[0].word.Height;
            var WidthR = result.best.words[0].word.Width;
            var yD = 0;
            var xD = 0;
            function getCoordinates(str) {
              // var regex = /TL(-?\d+),(-?\d+)BR(-?\d+),(-?\d+)/;
              var regex = /R(-?\d+),(-?\d+)W(-?\d+)H(-?\d+)/;
              var matches = str.match(regex);
              var x = parseInt(matches[1]);
              var y = parseInt(matches[2]);
              var W = parseInt(matches[3]);
              var H = parseInt(matches[4]);
              return [x, y, W, H];
            }
            var cal_tragte = localStorage.getItem('caliber_trget') ? localStorage.getItem('caliber_trget') : '';
            var caliberTick = cal_tragte;
            if (caliberTick.indexOf('W') == -1 || caliberTick.indexOf('H') == -1) {
              caliberTick = caliberTick + 'W30H10';
            }
            function getTickCounter(str) {
              function getNumberSet(num, type) {
                if (parseInt(num) > 0 && type == 'X') {
                  return ['>', parseInt(num)];
                } else if (parseInt(num) < 0 && type == 'X') {
                  return ['<', parseInt(String(num).replace('-', ''))];
                } else if (parseInt(num) > 0 && type == 'Y') {
                  return ['^', parseInt(num)];
                } else {
                  return ['v', parseInt(String(num).replace('-', ''))];
                }
              }
              var nums = getCoordinates(str);
              var _getNumberSet = getNumberSet(nums[0], 'X'),
                _getNumberSet2 = _slicedToArray(_getNumberSet, 2),
                x1 = _getNumberSet2[0],
                y1 = _getNumberSet2[1];
              var _getNumberSet3 = getNumberSet(nums[1], 'Y'),
                _getNumberSet4 = _slicedToArray(_getNumberSet3, 2),
                x2 = _getNumberSet4[0],
                y2 = _getNumberSet4[1];
              ;
              var valueObj = {};
              valueObj[x1] = y1;
              valueObj[x2] = y2;
              return valueObj;
            }
            ;
            var countCalObj = getTickCounter(caliberTick);

            // let ocrCalibration = !!localStorage.getItem('ocrCalibration') ? localStorage.getItem('ocrCalibration') : 7;
            // const isDesktopMode = isCVTypeForDesktop(vars.get('!CVSCOPE'));
            // if(isDesktopMode == "false"){
            //   ocrCalibration = 7;
            // }

            var ocrCalibration = store.getState().config.ocrCalibration_internal ? store.getState().config.ocrCalibration_internal : 6;
            var isDesktopMode = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
            if (!isDesktopMode) {
              ocrCalibration = 7;
            }
            for (var x in countCalObj) {
              if (x === 'v' || x === 'v') {
                yD += yC + ocrCalibration * countCalObj[x]; // down (add in y offset)
              }
              if (x === '>') {
                xD += xC + ocrCalibration * countCalObj[x]; // right (add in x offset)
              }
              if (x === '<') {
                xD += xC - ocrCalibration * countCalObj[x]; // left (minus in x offset)
              }
              if (x === '^') {
                yD += yC - ocrCalibration * countCalObj[x]; // up (minus in y offset)
              }
            }
            var all_nums = getCoordinates(caliberTick);
            var rectTop = yD;
            var rectLeft = xD;
            var rectWidth = ocrCalibration * all_nums[2];
            var rectHeight = ocrCalibration * all_nums[3];
            return withVisualHighlightHidden(function () {
              return getOcrResponse({
                store: store,
                lang: _lang3,
                scale: _scale3,
                engine: _engine3,
                isTable: _isTable2,
                ocrApiTimeout: _ocrApiTimeout3,
                searchArea: 'rect',
                storedImageRect: {
                  x: rectLeft / scalingFactor,
                  y: rectTop / scalingFactor,
                  width: rectWidth / scalingFactor,
                  height: rectHeight / scalingFactor
                },
                isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'))
              }).then(function (_ref32) {
                var response = _ref32.response,
                  offset = _ref32.offset,
                  viewportOffset = _ref32.viewportOffset;
                var documentBasedParseResults = (0, _ts_utils.safeUpdateIn)(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
                  return _objectSpread(_objectSpread({}, word), {}, {
                    Top: word.Top + offset.y,
                    Left: word.Left + offset.x
                  });
                }, response.ParsedResults);
                var ocrMatches = [
                // All words identified by OCR into one group
                {
                  similarity: 1,
                  highlight: _types.OcrHighlightType.Matched,
                  words: (0, _ocr.allWordsWithPosition)(documentBasedParseResults, [])
                }];
                // Note: This code is now needed for preview window for command OCRExtractbyTextRelative.
                if (extra && extra.debugVisual) {
                  // show overlay on website
                  var ocrMatches_preview = localStorage.getItem('ocrMatches_preview');
                  ocrMatches = ocrMatches_preview ? JSON.parse(ocrMatches_preview) : ocrMatches;
                  _ipc_cs["default"].ask('PANEL_HIGHLIGHT_OCR_MATCHES', {
                    ocrMatches: ocrMatches,
                    isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')),
                    screenAvailableSize: {
                      width: screen.availWidth,
                      height: screen.availHeight
                    },
                    localStorage: (0, _utils.cloneSerializableLocalStorage)(localStorage)
                  });
                }
                return {
                  byPass: true,
                  vars: _defineProperty({}, value, response.ParsedResults && response.ParsedResults[0] ? response.ParsedResults[0].ParsedText : '')
                };
              });
            });
          });
        }
      case 'visualVerify':
      case 'visualAssert':
      case 'visualSearch':
      case 'visionFind':
        {
          if (cmd === 'visualSearch') {
            if (!value || !value.length) {
              throw new Error("".concat(cmd, ": Must specify a variable to save the result"));
            }
          }
          var verifyPatternImage = function verifyPatternImage(fileName, command) {
            return (0, _storage.getStorageManager)().getVisionStorage().exists(fileName).then(function (existed) {
              if (!existed) throw new Error("Error #120: ".concat(((parentCommand === null || parentCommand === void 0 ? void 0 : parentCommand.cmd) || cmd) + ':' || 0, ": No input image found for file name '").concat(fileName, "'"));
            });
          };
          var imageTarget = (0, _command.parseImageTarget)(target);
          if (!target) {
            throw new Error("Target should be like 'abc.png@0.8#1'");
          }
          if (!imageTarget) {
            throw new Error("Error #120: ".concat(((parentCommand === null || parentCommand === void 0 ? void 0 : parentCommand.cmd) || cmd) + ':' || 0, " No input image found for file name '").concat(fileName, "'"));
          }
          var imageUrl = imageTarget.imageUrl,
            visionFileName = imageTarget.fileName,
            _imageTarget$confiden = imageTarget.confidence,
            minSimilarity = _imageTarget$confiden === void 0 ? store.getState().config.defaultVisionSearchConfidence : _imageTarget$confiden,
            rawIndex = imageTarget.index;
          var resultIndex = typeof rawIndex !== 'number' || isNaN(rawIndex) ? 0 : rawIndex;
          var _isNotVerifyOrAssert = ['visualVerify', 'visualAssert'].indexOf(cmd) === -1;
          var _searchArea = vars.get('!visualSearchArea');
          var _timeout = vars.get('!TIMEOUT_WAIT') * 1000;
          var cvScope = vars.get('!CVSCOPE');
          var saveImageFirstIfNeeded = function saveImageFirstIfNeeded() {
            if (!imageUrl || !imageUrl.length) {
              return Promise.resolve();
            }
            var getBlob = function getBlob() {
              if (imageUrl.indexOf('data:') === 0) {
                return Promise.resolve((0, _utils.dataURItoBlob)(imageUrl));
              }
              return (0, _utils.loadImage)(imageUrl);
            };
            return getBlob().then(function (blob) {
              return (0, _storage.getStorageManager)().getVisionStorage().write(visionFileName, blob);
            }).then(function () {
              store.dispatch(act.listVisions());
            });
          };
          var _run = function _run() {
            var prepare = (0, _cv_utils.isCVTypeForDesktop)(cvScope) ? Promise.resolve() : _ipc_cs["default"].ask('PANEL_CLEAR_VISION_RECTS_ON_PLAYING_PAGE');
            // #324 .then(() => delay(() => {}, 500))

            return prepare.then(saveImageFirstIfNeeded).then(function () {
              return (0, _search_vision.searchVision)({
                visionFileName: visionFileName,
                minSimilarity: minSimilarity,
                searchArea: _searchArea,
                cvScope: cvScope,
                command: command,
                captureScreenshotService: captureScreenshotService,
                devicePixelRatio: window.devicePixelRatio,
                storedImageRect: vars.get('!storedImageRect')
              });
            }).then(function (_ref33) {
              var regions = _ref33.regions,
                imageInfo = _ref33.imageInfo;
              (0, _log["default"])('regions', regions, imageInfo);
              var notFound = regions.length === 0;
              var outOfRange = regions.length <= resultIndex;
              if (notFound || outOfRange) {
                // Reset image related vars to 0 if not found
                vars.set({
                  '!imageX': 0,
                  '!imageY': 0,
                  '!imageWidth': 0,
                  '!imageHeight': 0
                }, true);
                if (notFound) {
                  throw new Error("Image '".concat(visionFileName, "' (conf. = ").concat(minSimilarity, ") not found"));
                }
                if (outOfRange) {
                  throw new Error("Found ".concat(regions.length, " ").concat(regions.length > 1 ? 'matches' : 'match', ", but you are looking for #").concat(resultIndex + 1));
                }
              }

              // Note: if rawIndex is set, sort by top > left (treat all matches above threshold equally)
              // otherwise, by score > top > left (= BEST match from all above threshold, see #836)
              if (resultIndex === rawIndex) {
                regions.sort(function (a, b) {
                  var vSign = Math.sign(a.matched.offsetTop - b.matched.offsetTop);
                  var hSign = Math.sign(a.matched.offsetLeft - b.matched.offsetLeft);
                  return vSign || hSign;
                });
              } else {
                regions.sort(function (a, b) {
                  var scoreSign = Math.sign(b.matched.score - a.matched.score);
                  var vSign = Math.sign(a.matched.offsetTop - b.matched.offsetTop);
                  var hSign = Math.sign(a.matched.offsetLeft - b.matched.offsetLeft);
                  return scoreSign || vSign || hSign;
                });
              }
              var best = regions[resultIndex].matched;
              if (!(0, _cv_utils.isCVTypeForDesktop)(cvScope)) {
                var shouldHighlightElements = store.getState().config.playHighlightElements || extra && extra.debugVisual;
                if (shouldHighlightElements) {
                  _ipc_cs["default"].ask('PANEL_HIGHLIGHT_RECTS', {
                    selectedIndex: resultIndex,
                    scoredRects: regions.map(function (r) {
                      return _objectSpread(_objectSpread({}, r.matched), {}, {
                        left: r.matched.pageLeft,
                        top: r.matched.pageTop
                      });
                    })
                  });
                }
              } else if (extra && extra.debugVisual) {
                var convert = function convert(rect, index, type) {
                  if (!rect) return null;
                  return {
                    type: type,
                    index: index,
                    x: rect.viewportLeft,
                    y: rect.viewportTop,
                    width: rect.width,
                    height: rect.height,
                    score: rect.score
                  };
                };
                _ipc_cs["default"].ask('PANEL_HIGHLIGHT_DESKTOP_RECTS', {
                  imageInfo: imageInfo,
                  screenAvailableSize: {
                    width: screen.availWidth,
                    height: screen.availHeight
                  },
                  selectedIndex: resultIndex,
                  scoredRects: (0, _ts_utils.flatten)(regions.map(function (r, i) {
                    return [convert(r.reference, i, i === resultIndex ? _types2.DesktopScreenshot.RectType.ReferenceOfBestMatch : _types2.DesktopScreenshot.RectType.Reference), convert(r.matched, i, i === resultIndex ? _types2.DesktopScreenshot.RectType.BestMatch : _types2.DesktopScreenshot.RectType.Match)].filter(function (x) {
                      return x;
                    });
                  }))
                });
              }
              var pScaleFactor = (0, _cv_utils.isCVTypeForDesktop)(cvScope) ? (0, _xy.getNativeXYAPI)().getScalingFactor() : Promise.resolve(1);

              // Note: Make sure `best`, `!imageX` and `!imageY` are all desktop coordinates (for later use in XClick)
              // While in PANEL_HIGHLIGHT_DESKTOP_RECTS, it uses css coordinates
              var top = best.viewportTop;
              var left = best.viewportLeft;
              return pScaleFactor.then(function (factor) {
                return {
                  byPass: true,
                  vars: _objectSpread({
                    '!imageX': Math.round(factor * (left + best.width / 2)),
                    '!imageY': Math.round(factor * (top + best.height / 2)),
                    '!imageWidth': Math.round(factor * best.width),
                    '!imageHeight': Math.round(factor * best.height)
                  }, _isNotVerifyOrAssert && value && value.length ? _defineProperty({}, value, regions.length) : {}),
                  best: (0, _utils.objMap)(function (n) {
                    return n * factor;
                  }, best)
                };
              }).then(function (res) {
                return (0, _utils.delay)(function () {
                  return res;
                }, 100);
              });
            });
          };
          var _runWithRetry = (0, _utils.retry)(_run, {
            timeout: _timeout,
            shouldRetry: function shouldRetry(e) {
              return store.getState().status === C.APP_STATUS.PLAYER && /Image.*\(conf\. =.*\) not found/.test(e.message);
            },
            retryInterval: function retryInterval(retryCount, lastRetryInterval) {
              return 0.5 + 0.25 * retryCount;
            },
            onFirstFail: function onFirstFail() {
              (0, _timeout_counter.startSendingTimeoutStatus)(_timeout, 'Vision waiting');
            },
            onFinal: function onFinal() {
              (0, _timeout_counter.clearTimerForTimeoutStatus)();
            }
          });
          return verifyPatternImage(visionFileName, cmd).then(function () {
            return _runWithRetry()["catch"](function (e) {
              // Note: extra.throwError === true, when "Find" button is used
              if (cmd === 'visualAssert' || extra && extra.throwError) {
                throw e;
              }
              return _objectSpread(_objectSpread({
                byPass: true
              }, _isNotVerifyOrAssert && value && value.length ? {
                vars: _defineProperty({}, value, 0)
              } : {}), cmd === 'visualVerify' ? {
                log: {
                  error: e.message
                }
              } : {});
            });
          });
        }
      case 'visionLimitSearchArea':
      case 'visionLimitSearchAreaRelative':
        {
          var _isRelative2 = /relative/i.test(cmd);
          var area = target.trim();
          var _p = Promise.resolve({
            byPass: true
          });

          // This method is helping you to debug visionLimitSearchArea
          // It takes screenshot according to coordinates to be set
          //
          // Overall, visionLimitSearchArea takes screenshot on the search area if its value is not viewport or full
          // `element: xxx` achieve that by sharing same logic as storeImage (you can find it in command_runner.js)
          var setImageRectVarAndTakeScreenshot = function setImageRectVarAndTakeScreenshot(_ref35) {
            var rect = _ref35.rect,
              isDesktop = _ref35.isDesktop,
              searchArea = _ref35.searchArea;
            vars.set({
              '!storedImageRect': rect
            }, true);
            return captureImage({
              isDesktop: isDesktop,
              storedImageRect: rect,
              searchArea: /\.png/i.test(searchArea) ? 'rect' : searchArea,
              scaleDpi: true,
              devicePixelRatio: window.devicePixelRatio
            });
          };

          // Note: In desktop mode, we assume coordinates users provide in 'area=...' are returned by `visualXXX`,
          // which is already desktop mouse coordinates, we must convert it back to css coordinates (for later use in image cropping or preview highlight)
          var _scale4 = function _scale4(rect) {
            switch (vars.get('!CVSCOPE')) {
              case _cv_utils.ComputerVisionType.Browser:
                return Promise.resolve(rect);
              case _cv_utils.ComputerVisionType.Desktop:
              case _cv_utils.ComputerVisionType.DesktopScreenCapture:
                return (0, _xy.getNativeXYAPI)().getScalingFactor().then(function (factor) {
                  return {
                    x: rect.x / factor,
                    y: rect.y / factor,
                    width: rect.width / factor,
                    height: rect.height / factor
                  };
                });
            }
          };
          if (_isRelative2 && !/\.png/i.test(area)) {
            throw new Error("".concat(cmd, " only accepts a vision image as target"));
          }
          if (/^viewport$/.test(area)) {
            vars.set({
              '!visualSearchArea': 'viewport'
            }, true);
            return _p;
          }
          if (/^full$/.test(area)) {
            vars.set({
              '!visualSearchArea': 'full'
            }, true);
            return _p;
          }
          if (/^area=/i.test(area)) {
            var coordinates = area.replace(/^area=/i, '').split(/\s*,\s*/g).map(function (str) {
              return parseFloat(str.trim());
            });
            var isValid = coordinates.length === 4 && _utils.and.apply(void 0, _toConsumableArray(coordinates.map(function (n) {
              return typeof n === 'number' && !isNaN(n);
            })));
            if (!isValid) {
              throw new Error('area should be in format of "area=x1,y1,x2,y2"');
            }
            var rect = {
              x: coordinates[0],
              y: coordinates[1],
              width: coordinates[2] - coordinates[0],
              height: coordinates[3] - coordinates[1]
            };
            vars.set({
              '!visualSearchArea': 'rect'
            }, true);
            return _scale4(rect).then(function (finalRect) {
              return setImageRectVarAndTakeScreenshot({
                isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')),
                searchArea: 'rect',
                rect: finalRect
              }).then(function () {
                return {
                  byPass: true
                };
              });
            });
          }
          if (/\.png/.test(area)) {
            return runCsFreeCommands(_objectSpread(_objectSpread({}, command), {}, {
              cmd: 'visualAssert',
              target: area,
              value: '',
              extra: _objectSpread(_objectSpread({}, command.extra || {}), {}, {
                // Note: `relativeVisual` is used in bg.js, for call of `visualAssert` that doesn't specify relativeVisual,
                // it still uses file name postfix "_relative" to tell whether it's relative (green/pink boxes) or not
                relativeVisual: _isRelative2
              })
            })).then(function (result) {
              var best = result.best;
              if (!best) throw new Error("No match found for ".concat(area, " in screenshot"));
              vars.set({
                '!visualSearchArea': area
              }, true);
              return _scale4({
                // Note: In desktop mode, coordinates returned by `visualXXX` is already desktop mouse coordinates
                // must convert it back to css coordinates (for later use in image cropping or preview highlight)
                x: best.offsetLeft,
                y: best.offsetTop,
                width: best.width,
                height: best.height
              }).then(function (rect) {
                return setImageRectVarAndTakeScreenshot({
                  rect: rect,
                  searchArea: area,
                  isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'))
                });
              }).then(function () {
                return {
                  byPass: true
                };
              });
            });
          }

          // If it doesn't match patterns above, we assume it's element in browser mode, or an vision image in desktop mode
          switch (vars.get('!CVSCOPE')) {
            case _cv_utils.ComputerVisionType.Browser:
              if (/^element:/.test(area)) {
                vars.set({
                  '!visualSearchArea': area
                }, true);
                return _ipc_cs["default"].ask('PANEL_CLEAR_VISION_RECTS_ON_PLAYING_PAGE').then(function () {
                  // Note: let cs page to process this case, it acts almost the same as a `storeImage` command
                  return Promise.resolve({
                    byPass: false
                  });
                });
              } else {
                throw new Error("E360: Target of visionLimitSearchArea could only be either 'viewport', 'full' or 'element:...'");
              }
            case _cv_utils.ComputerVisionType.Desktop:
            case _cv_utils.ComputerVisionType.DesktopScreenCapture:
              throw new Error('E361: In desktop mode, target of visionLimitSearchArea could only be a vision image name or area');
          }
          break;
        }
      case 'visionLimitSearchAreabyTextRelative':
        {
          guardOcrSettings();
          var _lang4 = vars.get('!ocrLanguage').toLowerCase();
          var _engine4 = vars.get('!ocrEngine');
          var _scale5 = vars.get('!ocrScale');
          var _isTable3 = vars.get('!ocrTableExtraction');
          var _ocrApiTimeout4 = _config["default"].ocr.apiTimeout;
          var _isRelative3 = /relative/i.test(cmd);
          var _trimmedTarget = target.trim();
          var _isDesktopMode = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
          (0, _global_state.updateState)((0, _utils.setIn)(['caliber_trget'], _trimmedTarget));
          (0, _global_state.updateState)((0, _utils.setIn)(['curent_cmd'], cmd));
          localStorage.setItem('curent_cmd', cmd);
          localStorage.setItem('caliber_trget', _trimmedTarget);
          localStorage.setItem('isDesktopMode', _isDesktopMode);
          var _defaultWh = 'W30H10';
          var _regexForTarget = /^.*#R.*,.*$/;
          if (!_regexForTarget.test(_trimmedTarget)) {
            throw new Error("Error E310: Relative coordinates missing. Format should be: word#R(X),(Y)");
          }
          if (_trimmedTarget.indexOf('W') === -1 && _trimmedTarget.indexOf('H') === -1) {
            _trimmedTarget = _trimmedTarget + _defaultWh;
          }
          if (_trimmedTarget.indexOf('#R') == -1 || _trimmedTarget.includes(' ') || _trimmedTarget.includes('X')) {
            throw new Error('Wrong input ' + _trimmedTarget);
          }
          if (_trimmedTarget.indexOf('W') === -1 || _trimmedTarget.indexOf('H') === -1) {
            throw new Error('Wrong input ' + _trimmedTarget);
          }
          var indexW = _trimmedTarget.indexOf('W');
          var indexH = _trimmedTarget.indexOf('H');
          if (indexW !== -1 && indexH !== -1 && indexW < indexH) {
            (0, _log["default"])("'W' appears first in the string");
          } else {
            // Note: reason for this changes is we are using regex accordingly in getCoordinates function for commands.
            // Extract the values of 'W' and 'H' from the string
            var _wValue = _trimmedTarget.match(/W(\d+)/)[1];
            var _hValue = _trimmedTarget.match(/H(\d+)/)[1];
            _trimmedTarget = _trimmedTarget.replace(/W(\d+)/, "H".concat(_hValue));
            _trimmedTarget = _trimmedTarget.replace(/H(\d+)/, "W".concat(_wValue));
            localStorage.setItem('caliber_trget', _trimmedTarget);
          }
          return _ipc_cs["default"].ask('PANEL_CLEAR_OCR_MATCHES_ON_PLAYING_PAGE')["catch"](function () {}).then(function () {
            return (0, _utils.delay)(function () {}, 1000);
          }).then(function () {
            return Promise.all([runCsFreeCommands(_objectSpread(_objectSpread({}, command), {}, {
              cmd: 'OCRSearch',
              target: _trimmedTarget.split('#')[0],
              value: '__ocrResult__'
            })), (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')) ? (0, _xy.getNativeXYAPI)().getScalingFactor() : Promise.resolve(1)]);
          }).then(function (_ref36) {
            var _ref37 = _slicedToArray(_ref36, 2),
              result = _ref37[0],
              scalingFactor = _ref37[1];
            store.dispatch(_simple_actions.Actions.setOcrInDesktopMode(false));
            var best = result.best;
            if (!best) throw new Error("E311: No OCR text match found for '".concat(target, "'"));
            var xC = result.best.words[0].word.Left;
            var yC = result.best.words[0].word.Top;
            var HeightR = result.best.words[0].word.Height;
            var WidthR = result.best.words[0].word.Width;
            var yD = 0;
            var xD = 0;
            function getCoordinates(str) {
              // var regex = /TL(-?\d+),(-?\d+)BR(-?\d+),(-?\d+)/;
              var regex = /R(-?\d+),(-?\d+)W(-?\d+)H(-?\d+)/;
              var matches = str.match(regex);
              var x = parseInt(matches[1]);
              var y = parseInt(matches[2]);
              var W = parseInt(matches[3]);
              var H = parseInt(matches[4]);
              return [x, y, W, H];
            }
            var cal_tragte = localStorage.getItem('caliber_trget') ? localStorage.getItem('caliber_trget') : '';
            var caliberTick = cal_tragte;
            if (caliberTick.indexOf('W') == -1 || caliberTick.indexOf('H') == -1) {
              caliberTick = caliberTick + 'W30H10';
            }
            function getTickCounter(str) {
              function getNumberSet(num, type) {
                if (parseInt(num) > 0 && type == 'X') {
                  return ['>', parseInt(num)];
                } else if (parseInt(num) < 0 && type == 'X') {
                  return ['<', parseInt(String(num).replace('-', ''))];
                } else if (parseInt(num) > 0 && type == 'Y') {
                  return ['^', parseInt(num)];
                } else {
                  return ['v', parseInt(String(num).replace('-', ''))];
                }
              }
              var nums = getCoordinates(str);
              var _getNumberSet5 = getNumberSet(nums[0], 'X'),
                _getNumberSet6 = _slicedToArray(_getNumberSet5, 2),
                x1 = _getNumberSet6[0],
                y1 = _getNumberSet6[1];
              var _getNumberSet7 = getNumberSet(nums[1], 'Y'),
                _getNumberSet8 = _slicedToArray(_getNumberSet7, 2),
                x2 = _getNumberSet8[0],
                y2 = _getNumberSet8[1];
              ;
              var valueObj = {};
              valueObj[x1] = y1;
              valueObj[x2] = y2;
              return valueObj;
            }
            ;
            var countCalObj = getTickCounter(caliberTick);

            // let ocrCalibration = !!localStorage.getItem('ocrCalibration') ? localStorage.getItem('ocrCalibration') : 7;
            // const isDesktopMode = isCVTypeForDesktop(vars.get('!CVSCOPE'));
            // if(isDesktopMode == "false"){
            //   ocrCalibration = 7;
            // }

            var ocrCalibration = store.getState().config.ocrCalibration_internal ? store.getState().config.ocrCalibration_internal : 6;
            var isDesktopMode = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
            if (!isDesktopMode) {
              ocrCalibration = 7;
            }
            for (var x in countCalObj) {
              if (x === 'v' || x === 'v') {
                yD += yC + ocrCalibration * countCalObj[x]; // down (add in y offset)
              }
              if (x === '>') {
                xD += xC + ocrCalibration * countCalObj[x]; // right (add in x offset)
              }
              if (x === '<') {
                xD += xC - ocrCalibration * countCalObj[x]; // left (minus in x offset)
              }
              if (x === '^') {
                yD += yC - ocrCalibration * countCalObj[x]; // up (minus in y offset)
              }
            }
            var all_nums = getCoordinates(caliberTick);
            var rectTop = yD;
            var rectLeft = xD;
            var rectWidth = ocrCalibration * all_nums[2];
            var rectHeight = ocrCalibration * all_nums[3];
            var targetRect = {
              x: rectLeft,
              y: rectTop,
              width: rectWidth,
              height: rectHeight
            };
            return withVisualHighlightHidden(function () {
              return getOcrResponse({
                store: store,
                lang: _lang4,
                scale: _scale5,
                engine: _engine4,
                isTable: _isTable3,
                ocrApiTimeout: _ocrApiTimeout4,
                searchArea: 'rect',
                storedImageRect: {
                  x: rectLeft / scalingFactor,
                  y: rectTop / scalingFactor,
                  width: rectWidth / scalingFactor,
                  height: rectHeight / scalingFactor
                },
                isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'))
              }).then(function (_ref38) {
                var response = _ref38.response,
                  offset = _ref38.offset,
                  viewportOffset = _ref38.viewportOffset;
                var documentBasedParseResults = (0, _ts_utils.safeUpdateIn)(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
                  return _objectSpread(_objectSpread({}, word), {}, {
                    Top: word.Top + offset.y,
                    Left: word.Left + offset.x
                  });
                }, response.ParsedResults);
                var ocrMatches = [
                // All words identified by OCR into one group
                {
                  similarity: 1,
                  highlight: _types.OcrHighlightType.Matched,
                  words: (0, _ocr.allWordsWithPosition)(documentBasedParseResults, [])
                }];

                // Note: This code is now needed for preview window for command OCRExtractbyTextRelative.
                if (extra && extra.debugVisual) {
                  // show overlay on website
                  var ocrMatches_preview = localStorage.getItem('ocrMatches_preview');
                  ocrMatches = ocrMatches_preview ? JSON.parse(ocrMatches_preview) : ocrMatches;
                  _ipc_cs["default"].ask('PANEL_HIGHLIGHT_OCR_MATCHES', {
                    ocrMatches: ocrMatches,
                    isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')),
                    screenAvailableSize: {
                      width: screen.availWidth,
                      height: screen.availHeight
                    },
                    localStorage: (0, _utils.cloneSerializableLocalStorage)(localStorage)
                  });
                }
                var setImageRectVarAndTakeScreenshot = function setImageRectVarAndTakeScreenshot(_ref39) {
                  var rect = _ref39.rect,
                    isDesktop = _ref39.isDesktop,
                    searchArea = _ref39.searchArea;
                  vars.set({
                    '!storedImageRect': rect
                  }, true);
                  return captureImage({
                    isDesktop: isDesktop,
                    storedImageRect: rect,
                    searchArea: /\.png/i.test(searchArea) ? 'rect' : searchArea,
                    scaleDpi: true,
                    devicePixelRatio: window.devicePixelRatio
                  });
                };
                vars.set({
                  '!visualSearchArea': 'rect'
                }, true);
                return setImageRectVarAndTakeScreenshot({
                  isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')),
                  searchArea: 'rect',
                  rect: targetRect
                }).then(function () {
                  return {
                    byPass: true
                  };
                });
              });
            });
          });
        }
      case 'visualGetPixelColor':
        {
          var targetReg = /^\s*(\d+)\s*,\s*(\d+)\s*$/;
          if (!targetReg.test(target)) {
            throw new Error('E362: visualGetPixelColor: target must be a position in this fomrat: 100,200');
          }
          if (!value || !value.length) {
            throw new Error('E363: visualGetPixelColor: must specify a variable name as value');
          }
          var _isDesktopMode2 = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
          var _target$match3 = target.match(targetReg),
            _target$match4 = _slicedToArray(_target$match3, 3),
            _2 = _target$match4[0],
            xStr = _target$match4[1],
            yStr = _target$match4[2];
          var x = parseInt(xStr, 10);
          var y = parseInt(yStr, 10);
          var rectSize = 16;
          var type = vars.get('!CVSCOPE');
          var getScreenshot = function getScreenshot(state) {
            switch (type) {
              case 'browser':
                {
                  var toPlayTabId = state.tabIds.toPlay;
                  return (0, _tab_utils.activateTab)(toPlayTabId, true).then(function () {
                    return (0, _utils.delay)(function () {}, C.SCREENSHOT_DELAY);
                  })
                  // Set scale factor to 1 / devicePixelRatio, so that the screenshot is in css pixel.
                  .then(function () {
                    return captureScreenshotService.captureScreen(toPlayTabId, devicePixelRatio, (0, _dom_utils.isFirefox)() ? 1 : 1 / devicePixelRatio);
                  }).then(function (dataUrl) {
                    (0, _search_vision.saveDataUrlToLastScreenshot)(dataUrl);
                    return dataUrl;
                  });
                }
              case 'desktop':
                {
                  var cvApi = (0, _desktop.getNativeCVAPI)();

                  // On the other hand, desktop screenshot is in device pixel
                  return cvApi.captureDesktop({
                    path: undefined
                  }).then(function (hardDrivePath) {
                    return cvApi.readFileAsDataURL(hardDrivePath, true);
                  }).then(function (dataUrl) {
                    (0, _search_vision.saveDataUrlToLastDesktopScreenshot)(dataUrl);
                    return dataUrl;
                  });
                }
              default:
                throw new Error("E364: Unsupported type: ".concat(type));
            }
          };
          return (0, _global_state.getState)().then(getScreenshot).then(function (dataUrl) {
            return (0, _dom_utils.getPixel)({
              dataUrl: dataUrl,
              x: x,
              y: y
            });
          }).then(function (colorHex) {
            if (_isDesktopMode2) {
              if (extra && extra.debugVisual) {
                // This scaling is due to we show desktop screenshot in its base size, so retina screens like 2560 x 1440
                // are shown as 2560 x 1440 (css px) images instead of its device size 5120 x 2880.
                // That said, the image is scaled down by 2, so we need to do the same to rects
                var _scale6 = 1 / window.devicePixelRatio;
                _ipc_cs["default"].ask('PANEL_HIGHLIGHT_DESKTOP_RECTS', {
                  imageInfo: {
                    source: _types2.DesktopScreenshot.ImageSource.Storage,
                    path: (0, _utils.ensureExtName)('.png', C.LAST_DESKTOP_SCREENSHOT_FILE_NAME)
                  },
                  screenAvailableSize: {
                    width: screen.availWidth,
                    height: screen.availHeight
                  },
                  selectedIndex: 0,
                  scoredRects: [{
                    x: _scale6 * (y - rectSize / 2),
                    y: _scale6 * (x - rectSize / 2),
                    width: _scale6 * rectSize,
                    height: _scale6 * rectSize,
                    text: colorHex,
                    type: _types2.DesktopScreenshot.RectType.BestMatch
                  }]
                });
              }
            } else {
              _ipc_cs["default"].ask('PANEL_SCREENSHOT_PAGE_INFO').then(function (pageInfo) {
                _ipc_cs["default"].ask('PANEL_HIGHLIGHT_RECT', {
                  rect: {
                    top: pageInfo.originalY + y - rectSize / 2,
                    left: pageInfo.originalX + x - rectSize / 2,
                    width: rectSize,
                    height: rectSize,
                    text: colorHex
                  }
                });
              });
            }
            vars.set(_defineProperty({}, value, colorHex));
            return {
              byPass: true
            };
          });
        }
      case 'XRun':
      case 'XRunAndWait':
        {
          var _fileName = target;
          var args = value;
          var waitForExit = /AndWait/.test(cmd);
          return (0, _xfile.getXFile)().sanityCheck().then(function () {
            return (0, _filesystem.getNativeFileSystemAPI)().runProcess({
              fileName: _fileName,
              waitForExit: waitForExit,
              arguments: args
            });
          }).then(function (result) {
            if (cmd === 'XRunAndWait') {
              vars.set({
                '!XRUN_EXITCODE': result.exitCode
              }, true);
              store.dispatch(act.addLog('info', "App close detected, Exit code=".concat(result.exitCode)));
            }
            return {
              byPass: true
            };
          });
        }
      case 'XDesktopAutomation':
        {
          var shouldEnableDesktopAutomation = (0, _ts_utils.parseBoolLike)(target, false);
          store.dispatch(act.updateUI({
            shouldEnableDesktopAutomation: shouldEnableDesktopAutomation
          }));
          vars.set({
            '!CVSCOPE': shouldEnableDesktopAutomation ? 'desktop' : 'browser'
          }, true);
          return Promise.resolve({
            byPass: true
          });
        }
      case 'bringBrowserToForeground':
        {
          var shouldHide;
          try {
            shouldHide = target === '' || target === undefined ? false : !(0, _ts_utils.strictParseBoolLike)(target);
          } catch (e) {
            throw new Error('E310: Invalid target for bringBrowserToForeground. It should be true / false or leave it blank');
          }
          var _p2 = shouldHide ? _ipc_cs["default"].ask('PANEL_MINIMIZE_ALL_WINDOWS_BUT_PANEL') : _ipc_cs["default"].ask('PANEL_BRING_PLAYING_WINDOW_TO_FOREGROUND');
          return _p2.then(function () {
            return {
              byPass: true
            };
          });
        }
      case 'bringIDEandBrowserToBackground':
        {
          return _ipc_cs["default"].ask('PANEL_MINIMIZE_ALL_WINDOWS').then(function () {
            return {
              byPass: true
            };
          });
        }
      case 'setWindowSize':
      case 'resize':
        {
          var _ref40 = function () {
              if (cmd === 'resize') {
                if (!/\s*\d+@\d+\s*/.test(target)) {
                  throw new Error("E365: Syntax for target of resize command is x@y, e.g. 800@600");
                }
                return target.split('@');
              } else {
                if (!/\s*\d+x\d+\s*/i.test(target)) {
                  throw new Error("E366: Syntax for target of setWindowSize command is WidthxHeight, e.g. 800x600");
                }
                return target.split(/x/i);
              }
            }(),
            _ref41 = _slicedToArray(_ref40, 2),
            strWidth = _ref41[0],
            strHeight = _ref41[1];
          var width = parseInt(strWidth, 10);
          var height = parseInt(strHeight, 10);
          (0, _log["default"])('resize', width, height);
          return _ipc_cs["default"].ask('PANEL_RESIZE_PLAY_TAB', {
            viewportSize: {
              width: width,
              height: height
            },
            screenAvailableRect: {
              x: window.screen.availLeft,
              y: window.screen.availTop,
              width: window.screen.availWidth,
              height: window.screen.availHeight
            }
          }).then(function (_ref42) {
            var actual = _ref42.actual,
              desired = _ref42.desired,
              diff = _ref42.diff;
            if (diff.length === 0) return {
              byPass: true
            };
            return {
              byPass: true,
              log: {
                warning: "W367: Only able to resize it to ".concat(actual.width, "@").concat(actual.height, ", given ").concat(desired.width, "@").concat(desired.height)
              }
            };
          });
        }
      case 'XType':
        {
          return (0, _x_user_io.getXUserIO)().sanityCheck()
          // .then(() => csIpc.ask('PANEL_IS_PLAYING_WINDOW_IN_FOREGROUND'))
          // .then(isInForeGround => {
          //   if (isInForeGround) return
          //   return runCsFreeCommands({ cmd: 'bringBrowserToForeground' })
          // })
          .then(function () {
            if (xCmdCounter.get() === 1) {
              return hideDownloadBar();
            }
          }).then(function () {
            return (0, _utils.delay)(function () {}, 300);
          }).then(function () {
            return (0, _encrypt.decryptIfNeeded)(target);
          }).then(function (text) {
            return (0, _xy.getNativeXYAPI)().sendText({
              text: text
            }).then(function (success) {
              if (!success) throw new Error("E311: Failed to XType '".concat(target, "'"));
              return {
                byPass: true
              };
            });
          });
        }
      case 'XMouseWheel':
        {
          var deltaX = parseFloat(target);
          if (isNaN(deltaX)) {
            throw new Error('E312: Target of XMouseWheel must be a number');
          }
          return (0, _x_user_io.getXUserIO)().sanityCheck().then(function () {
            if (xCmdCounter.get() === 1) {
              return hideDownloadBar();
            }
          }).then(function () {
            return (0, _xy.getNativeXYAPI)().sendMouseWheelEvent({
              deltaX: deltaX,
              deltaY: 0,
              deltaZ: 0
            }).then(function (success) {
              if (!success) throw new Error("E313: Failed to XMouseWheel '".concat(target, "'"));
              return {
                byPass: true
              };
            });
          });
        }
      case 'XMove':
      case 'XMoveText':
      case 'XMoveTextRelative':
      case 'XMoveRelative':
      case 'XClickRelative':
      case 'XClickTextRelative':
      case 'XClickText':
      case 'XClick':
        {
          var parseTarget = function parseTarget() {
            var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var cmd = arguments.length > 1 ? arguments[1] : undefined;
            var trimmedTarget = target.trim();
            var relativeCommands = ["XMoveTextRelative", "XClickTextRelative"];
            var regexForTarget = /^.*#R.*,.*$/;
            if (relativeCommands.includes(cmd) && !regexForTarget.test(trimmedTarget)) {
              throw new Error("Error E310: Relative coordinates missing. Format should be: word#R(X),(Y)");
            }
            var isDesktopMode = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
            (0, _global_state.updateState)((0, _utils.setIn)(['curent_cmd'], cmd));
            localStorage.setItem('curent_cmd', cmd);
            if (/^ocr=/i.test(trimmedTarget)) {
              guardOcrSettings();
              return {
                type: 'ocr',
                value: {
                  query: trimmedTarget.substr(4)
                }
              };
            }
            if (cmd === 'XMoveText') {
              guardOcrSettings();
              return {
                type: 'ocrTextXmove',
                value: {
                  query: trimmedTarget
                }
              };
            }
            if (cmd === 'XMoveTextRelative') {
              var _isDesktopMode3 = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
              (0, _global_state.updateState)((0, _utils.setIn)(['caliber_trget'], trimmedTarget));
              (0, _global_state.updateState)((0, _utils.setIn)(['curent_cmd'], cmd));
              localStorage.setItem('curent_cmd', cmd);
              localStorage.setItem('caliber_trget', trimmedTarget);
              localStorage.setItem('isDesktopMode', _isDesktopMode3);
              guardOcrSettings();
              return {
                type: 'ocrTextXmoveRelative',
                value: {
                  query: trimmedTarget
                }
              };
            }
            if (cmd === 'XClickText' && !/^text=/i.test(trimmedTarget)) {
              guardOcrSettings();
              3;
              return {
                type: 'ocrText',
                value: {
                  query: trimmedTarget
                }
              };
            }
            if (cmd === 'XClickTextRelative' && /#R/i.test(trimmedTarget)) {
              if (checkIfNumberFound(trimmedTarget)) {
                throw new Error('Wrong input ' + trimmedTarget);
              }
              var _isDesktopMode4 = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
              (0, _global_state.updateState)((0, _utils.setIn)(['caliber_trget'], trimmedTarget));
              (0, _global_state.updateState)((0, _utils.setIn)(['curent_cmd'], cmd));
              localStorage.setItem('curent_cmd', cmd);
              localStorage.setItem('caliber_trget', trimmedTarget);
              localStorage.setItem('isDesktopMode', _isDesktopMode4);
              guardOcrSettings();
              return {
                type: 'ocrText',
                value: {
                  query: trimmedTarget.split('#R')[0]
                }
              };
            }
            if ((0, _dom_utils.isLocator)(trimmedTarget)) {
              if (isDesktopMode) {
                throw new Error('E315: Locator is not support in desktop mode');
              }
              return {
                type: 'locator',
                value: {
                  locator: trimmedTarget
                }
              };
            }
            if (/^[dD](\d+(\.\d+)?)\s*,\s*(\d+(\.\d+)?)$/.test(trimmedTarget)) {
              return {
                type: 'desktop_coordinates',
                value: {
                  coordinates: trimmedTarget.substr(1).split(/\s*,\s*/)
                }
              };
            }
            if (/^(\d+(\.\d+)?)\s*,\s*(\d+(\.\d+)?)$/.test(trimmedTarget)) {
              return {
                type: isDesktopMode ? 'desktop_coordinates' : 'viewport_coordinates',
                value: {
                  coordinates: trimmedTarget.split(/\s*,\s*/)
                }
              };
            }
            if (/^.*\.png(@\d\.\d+)?(#\d+)?(\[[^\]]+\])?$/.test(trimmedTarget)) {
              return {
                type: 'visual_search',
                value: {
                  query: trimmedTarget
                }
              };
            }

            // fixit: it may not be XClick only??
            throw new Error("E316: XClick: invalid target, '".concat(target, "'"));
          };
          var checkIfNumberFound = function checkIfNumberFound() {
            var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var parts = str.split('#');
            for (var i = 0; i < parts.length; i++) {
              if (/\d/.test(parts[i])) {
                return false;
              }
            }
            return true;
          };
          var parseValueForXClick = function parseValueForXClick() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var normalValue = value.trim().toLowerCase();
            switch (normalValue) {
              case '':
                return '#left';
              case '#left':
              case '#middle':
              case '#right':
              case '#doubleclick':
              case '#tripleclick':
              case '#shiftclick':
              case '#ctrlclick':
                return normalValue;
              default:
                throw new Error("E317: XClick: invalid value, '".concat(value, "'"));
            }
          };
          var parseValueForXMove = function parseValueForXMove() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var normalValue = value.trim().toLowerCase();
            switch (normalValue) {
              case '':
                return '#move';
              case '#move':
              case '#up':
              case '#down':
                return normalValue;
              default:
                throw new Error("E318: XMove: invalid value, '".concat(value, "'"));
            }
          };
          var parseValue = {
            XClick: parseValueForXClick,
            XClickText: parseValueForXClick,
            XClickRelative: parseValueForXClick,
            XClickTextRelative: parseValueForXClick,
            OCRExtractbyTextRelative: parseValueForXClick,
            XMove: parseValueForXMove,
            XMoveText: parseValueForXMove,
            XMoveTextRelative: parseValueForXMove,
            XMoveRelative: parseValueForXMove
          }[cmd];
          var _isRelative4 = /relative/i.test(cmd) && !/XClickText/i.test(cmd);
          if (/relative/i.test(cmd) && cmd === 'OCRExtractbyTextRelative' || /relative/i.test(cmd) && cmd === 'XMoveTextRelative' || /relative/i.test(cmd) && cmd === 'visionLimitSearchAreabyTextRelative') {
            _isRelative4 = false;
          }
          return (0, _x_user_io.getXUserIO)().sanityCheck().then(function () {
            if (xCmdCounter.get() === 1) {
              return hideDownloadBar();
            }
          }).then(function () {
            var realTarget = parseTarget(target, cmd);
            var realValue = parseValue(value);
            var pNativeXYParams = function () {
              if (_isRelative4 && realTarget.type !== 'visual_search') {
                throw new Error("E319: ".concat(cmd, " only accepts a vision image as target"));
              }
              switch (realTarget.type) {
                case 'locator':
                  {
                    return runCommand(_objectSpread(_objectSpread({}, command), {}, {
                      cmd: 'locate',
                      target: realTarget.value.locator,
                      value: ''
                    })).then(function (result) {
                      var rect = result.rect;
                      if (!rect) throw new Error('E320: no rect data returned');
                      var x = rect.x + rect.width / 2;
                      var y = rect.y + rect.height / 2;
                      if (isNaN(x)) throw new Error('empty x');
                      if (isNaN(y)) throw new Error('empty y');
                      return {
                        type: 'viewport',
                        offset: {
                          x: x,
                          y: y
                        }
                      };
                    }).then(getSidePanelWidth).then(function (_ref43) {
                      var _ref44 = _slicedToArray(_ref43, 2),
                        sidePanelWidth = _ref44[0],
                        result = _ref44[1];
                      result.offset.x = result.offset.x + sidePanelWidth;
                      return result;
                    });
                  }
                case 'visual_search':
                  {
                    return runCsFreeCommands(_objectSpread(_objectSpread({}, command), {}, {
                      cmd: 'visualAssert',
                      target: realTarget.value.query,
                      value: '',
                      extra: _objectSpread(_objectSpread({}, command.extra || {}), {}, {
                        // Note: `relativeVisual` is used in bg.js, for call of `visualAssert` that doesn't specify relativeVisual,
                        // it still uses file name postfix "_relative" to tell whether it's relative (green/pink boxes) or not
                        relativeVisual: _isRelative4
                      })
                    }), undefined, command).then(function (result) {
                      var best = result.best;
                      if (!best) throw new Error('E321: no best found from result of verifyAssert triggered by XClick');
                      var isForDesktop = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
                      var x = best.viewportLeft + best.width / 2;
                      var y = best.viewportTop + best.height / 2;
                      if (isNaN(x)) throw new Error('empty x');
                      if (isNaN(y)) throw new Error('empty y');
                      return {
                        type: isForDesktop ? 'desktop' : 'viewport',
                        offset: {
                          x: x,
                          y: y
                        },
                        originalResult: result
                      };
                    }).then(getSidePanelWidth).then(function (_ref45) {
                      var _ref46 = _slicedToArray(_ref45, 2),
                        sidePanelWidth = _ref46[0],
                        prev = _ref46[1];
                      // we need this for visual_search
                      // eg. DemoXMove
                      if (prev.type === 'viewport') {
                        prev.offset.x = prev.offset.x + sidePanelWidth;
                      }
                      return prev;
                    });
                  }
                case 'ocr':
                  {
                    return runCsFreeCommands(_objectSpread(_objectSpread({}, command), {}, {
                      cmd: 'OCRSearch',
                      target: realTarget.value.query,
                      value: '__ocrResult__'
                    })).then(function (result) {
                      var best = result.best;
                      if (!best) throw new Error("E322: no match found for '".concat(target, "'"));
                      return {
                        type: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')) ? 'desktop' : 'viewport',
                        offset: (0, _ocr.ocrMatchCenter)(best),
                        originalResult: result
                      };
                    });
                  }
                case 'ocrTextR':
                  {
                    return _ipc_cs["default"].ask('PANEL_CLEAR_OCR_MATCHES_ON_PLAYING_PAGE')["catch"](function () {}).then(function () {
                      return (0, _utils.delay)(function () {}, 1000);
                    }).then(function () {
                      return Promise.all([runCsFreeCommands(_objectSpread(_objectSpread({}, command), {}, {
                        cmd: 'OCRSearch',
                        target: realTarget.value.query,
                        mode_type: 'local',
                        value: '__ocrResult__'
                      })), (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')) ? (0, _xy.getNativeXYAPI)().getScalingFactor() : Promise.resolve(1)]);
                    }).then(function (_ref47) {
                      var _ref48 = _slicedToArray(_ref47, 2),
                        result = _ref48[0],
                        scalingFactor = _ref48[1];
                      var best = result.best;
                      if (!best) throw new Error("E323: no match found for '".concat(target, "'"));
                      var xC = result.best.words[0].word.Left;
                      var yC = result.best.words[0].word.Top;
                      var HeightR = result.best.words[0].word.Height;
                      var WidthR = result.best.words[0].word.Width;
                      function getCoordinates(str) {
                        var regex = /TL(-?\d+),(-?\d+)BR(-?\d+),(-?\d+)/;
                        var matches = str.match(regex);
                        var x1 = parseInt(matches[1]);
                        var y1 = parseInt(matches[2]);
                        var x2 = parseInt(matches[3]);
                        var y2 = parseInt(matches[4]);
                        return [x1, y1, x2, y2];
                      }
                      var cal_tragte = localStorage.getItem('caliber_trget') ? localStorage.getItem('caliber_trget') : '';
                      var caliberTick = cal_tragte;
                      var countCalObj = getCoordinates(caliberTick);
                      var rectTop = yC + countCalObj[1];
                      var rectLeft = xC + countCalObj[0];
                      var rectWidth = countCalObj[2] - countCalObj[0];
                      var rectHeight = countCalObj[3] - countCalObj[1];
                      var lang = vars.get('!ocrLanguage').toLowerCase();
                      var engine = vars.get('!ocrEngine');
                      var scale = vars.get('!ocrScale');
                      var isTable = vars.get('!ocrTableExtraction');
                      var ocrApiTimeout = _config["default"].ocr.apiTimeout;
                      var isRelative = /relative/i.test(cmd);
                      return withVisualHighlightHidden(function () {
                        return getOcrResponse({
                          store: store,
                          lang: lang,
                          scale: scale,
                          engine: engine,
                          isTable: isTable,
                          ocrApiTimeout: ocrApiTimeout,
                          searchArea: 'rect',
                          storedImageRect: {
                            // Note: In desktop mode, coordinates returned by `visualXXX` is already desktop mouse coordinates
                            // must convert it back to css coordinates (for later use in image cropping or preview highlight)
                            x: rectLeft / scalingFactor,
                            y: rectTop / scalingFactor,
                            width: rectWidth / scalingFactor,
                            height: rectHeight / scalingFactor
                          },
                          isDesktop: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'))
                        }).then(function (_ref49) {
                          var response = _ref49.response,
                            offset = _ref49.offset,
                            viewportOffset = _ref49.viewportOffset;
                          var documentBasedParseResults = (0, _ts_utils.safeUpdateIn)(['[]', 'TextOverlay', 'Lines', '[]', 'Words', '[]'], function (word) {
                            return _objectSpread(_objectSpread({}, word), {}, {
                              Top: word.Top + offset.y,
                              Left: word.Left + offset.x
                            });
                          }, response.ParsedResults);
                          var ocrMatches = [
                          // All words identified by OCR into one group
                          {
                            similarity: 1,
                            highlight: _types.OcrHighlightType.Matched,
                            words: (0, _ocr.allWordsWithPosition)(documentBasedParseResults, [])
                          }];
                          return {
                            byPass: true,
                            vars: _defineProperty({}, value, response.ParsedResults && response.ParsedResults[0] ? response.ParsedResults[0].ParsedText : '')
                          };
                        });
                      });
                    });
                  }
                case 'ocrTextXmoveRelative':
                  {
                    var _isRelative5 = /relative/i.test(cmd) && !/XMoveText/i.test(cmd);
                    return _ipc_cs["default"].ask('PANEL_CLEAR_OCR_MATCHES_ON_PLAYING_PAGE')["catch"](function () {}).then(function () {
                      return (0, _utils.delay)(function () {}, 1000);
                    }).then(function () {
                      return Promise.all([runCsFreeCommands(_objectSpread(_objectSpread({}, command), {}, {
                        cmd: 'OCRSearch',
                        target: target.split('#')[0],
                        value: '__ocrResult__'
                      })), (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')) ? (0, _xy.getNativeXYAPI)().getScalingFactor() : Promise.resolve(1)]);
                    }).then(function (_ref50) {
                      var _ref51 = _slicedToArray(_ref50, 2),
                        result = _ref51[0],
                        scalingFactor = _ref51[1];
                      var isDesk = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
                      if (extra && extra.debugVisual && isDesk) {
                        return {
                          byPass: true,
                          vars: _defineProperty({}, value, '')
                        };
                      }
                      var best = result.best;
                      if (!best) throw new Error("E311: No OCR text match found for '".concat(target, "'"));
                      var rect = {
                        x: result.best.words[0].word.Left,
                        y: result.best.words[0].word.Top,
                        height: result.best.words[0].word.Height,
                        width: result.best.words[0].word.Width
                      };
                      var getTickCounter = function getTickCounter(str) {
                        function getNumberSet(num, type) {
                          if (parseInt(num) > 0 && type == 'X') {
                            return ['>', parseInt(num)];
                          } else if (parseInt(num) < 0 && type == 'X') {
                            return ['<', parseInt(num.replace('-', ''))];
                          } else if (parseInt(num) > 0 && type == 'Y') {
                            return ['^', parseInt(num)];
                          } else {
                            return ['v', parseInt(num.replace('-', ''))];
                          }
                        }
                        function getAllNumbersWithSign(str) {
                          var matches = str.match(/-?\d+/g);
                          if (matches) {
                            return matches;
                          }
                          return null;
                        }
                        if (str.indexOf('#R') !== -1) {
                          // ABC #R-6,3
                          var parts = str.split('#R');
                          var nums = getAllNumbersWithSign(parts[1]);
                          var _getNumberSet9 = getNumberSet(nums[0], 'X'),
                            _getNumberSet10 = _slicedToArray(_getNumberSet9, 2),
                            x1 = _getNumberSet10[0],
                            y1 = _getNumberSet10[1];
                          var _getNumberSet11 = getNumberSet(nums[1], 'Y'),
                            _getNumberSet12 = _slicedToArray(_getNumberSet11, 2),
                            x2 = _getNumberSet12[0],
                            y2 = _getNumberSet12[1];
                          ; // 3
                          var valueObj = {};
                          valueObj[x1] = y1;
                          valueObj[x2] = y2;
                          return valueObj;
                        }
                      };
                      var ocrCalibration = store.getState().config.ocrCalibration_internal ? store.getState().config.ocrCalibration_internal : 6;
                      var isDesktopMode = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
                      if (!isDesktopMode) {
                        ocrCalibration = 7;
                      }
                      var caliberTick = command.target;
                      var countCalObj = getTickCounter(caliberTick);
                      for (var x in countCalObj) {
                        if (x == 'v') {
                          rect['y'] = rect['y'] + ocrCalibration * countCalObj[x]; // down (add in y offset)
                        }
                        if (x == '>') {
                          rect['x'] = rect['x'] + ocrCalibration * countCalObj[x]; // right (add in x offset)
                        }
                        if (x == '<') {
                          rect['x'] = rect['x'] - ocrCalibration * countCalObj[x]; // left (minus in x offset)
                        }
                        if (x == '^') {
                          rect['y'] = rect['y'] - ocrCalibration * countCalObj[x]; // up (minus in y offset)
                        }
                      }
                      var isDesktop = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
                      // return csIpc.ask('PANEL_CLEAR_OCR_MATCHES_ON_PLAYING_PAGE')
                      // .catch(() => {})
                      // .then(() => delay(() => {}, 1000))
                      return (0, _utils.delay)(function () {}, 10).then(function () {
                        var coordinates = [rect.x, rect.y];
                        if (isDesktop) {
                          return Promise.resolve({
                            type: 'desktop',
                            offset: {
                              x: parseFloat(coordinates[0]),
                              y: parseFloat(coordinates[1])
                            }
                          });
                        } else {
                          return Promise.resolve({
                            type: 'viewport',
                            offset: {
                              x: parseFloat(coordinates[0]),
                              y: parseFloat(coordinates[1])
                            }
                          });
                        }
                      });
                    });
                  }
                case 'ocrTextXmove':
                  {
                    var _isRelative6 = /relative/i.test(cmd) && !/XMoveText/i.test(cmd);
                    return _ipc_cs["default"].ask('PANEL_CLEAR_OCR_MATCHES_ON_PLAYING_PAGE')["catch"](function () {}).then(function () {
                      return (0, _utils.delay)(function () {}, 1000);
                    }).then(function () {
                      return Promise.all([runCsFreeCommands(_objectSpread(_objectSpread({}, command), {}, {
                        cmd: 'OCRSearch',
                        target: target,
                        value: '__ocrResult__'
                      })), (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')) ? (0, _xy.getNativeXYAPI)().getScalingFactor() : Promise.resolve(1)]);
                    }).then(function (_ref52) {
                      var _ref53 = _slicedToArray(_ref52, 2),
                        result = _ref53[0],
                        scalingFactor = _ref53[1];
                      var isDesk = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
                      if (extra && extra.debugVisual && isDesk) {
                        return {
                          byPass: true,
                          vars: _defineProperty({}, value, '')
                        };
                      }
                      var best = result.best;
                      if (!best) throw new Error("E311: No OCR text match found for '".concat(target, "'"));
                      var rect = {
                        x: result.best.words[0].word.Left,
                        y: result.best.words[0].word.Top,
                        height: result.best.words[0].word.Height,
                        width: result.best.words[0].word.Width
                      };
                      var isDesktop = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));

                      // return csIpc
                      //   .ask('PANEL_CLEAR_OCR_MATCHES_ON_PLAYING_PAGE')
                      //   .catch(() => {})
                      //   .then(() => delay(() => {}, 1000))

                      return (0, _utils.delay)(function () {}, 10).then(function () {
                        var coordinates = [rect.x, rect.y];
                        if (isDesktop) {
                          return Promise.resolve({
                            type: 'desktop',
                            offset: {
                              x: parseFloat(coordinates[0]),
                              y: parseFloat(coordinates[1])
                            }
                          });
                        } else {
                          return Promise.resolve({
                            type: 'viewport',
                            offset: {
                              x: parseFloat(coordinates[0]),
                              y: parseFloat(coordinates[1])
                            }
                          });
                        }
                      });
                    });
                  }
                case 'ocrText':
                  {
                    return runCsFreeCommands(_objectSpread(_objectSpread({}, command), {}, {
                      cmd: 'OCRSearch',
                      target: realTarget.value.query,
                      mode_type: 'local',
                      value: '__ocrResult__'
                    })).then(function (result) {
                      var best = result.best;
                      if (!best) throw new Error("E323: no match found for '".concat(target, "'"));
                      return {
                        type: (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')) ? 'desktop' : 'viewport',
                        offset: (0, _ocr.ocrMatchCenter)(best),
                        originalResult: result
                      };
                    }).then(getSidePanelWidth).then(function (_ref54) {
                      var _ref55 = _slicedToArray(_ref54, 2),
                        sidePanelWidth = _ref55[0],
                        prev = _ref55[1];
                      // we need this for ocrText
                      if (prev.type === 'viewport') {
                        prev.offset.x = prev.offset.x + sidePanelWidth;
                      }
                      return prev;
                    });
                  }
                case 'desktop_coordinates':
                  {
                    var _coordinates = realTarget.value.coordinates;
                    return Promise.resolve({
                      type: 'desktop',
                      offset: {
                        x: parseFloat(_coordinates[0]),
                        y: parseFloat(_coordinates[1])
                      }
                    });
                  }
                case 'viewport_coordinates':
                  {
                    var _coordinates2 = realTarget.value.coordinates;
                    return Promise.resolve({
                      type: 'viewport',
                      offset: {
                        x: parseFloat(_coordinates2[0]),
                        y: parseFloat(_coordinates2[1])
                      }
                    }).then(getSidePanelWidth).then(function (_ref56) {
                      var _ref57 = _slicedToArray(_ref56, 2),
                        sidePanelWidth = _ref57[0],
                        result = _ref57[1];
                      result.offset.x = result.offset.x + sidePanelWidth;
                      return result;
                    });
                  }
              }
            }();
            return pNativeXYParams.then(function (_ref58) {
              var type = _ref58.type,
                offset = _ref58.offset,
                _ref58$originalResult = _ref58.originalResult,
                originalResult = _ref58$originalResult === void 0 ? {} : _ref58$originalResult;
              // Note: should not bring play tab to front if it's in desktop mode
              var prepare = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE')) ? Promise.resolve() : runCsFreeCommands({
                cmd: 'bringBrowserToForeground'
              });
              return prepare.then(function () {
                return (0, _utils.delay)(function () {}, 300);
              }).then(function () {
                var api = (0, _xy.getNativeXYAPI)();
                var _ref59 = function () {
                    switch (realValue) {
                      case '#left':
                        return [_xy.MouseButton.Left, _xy.MouseEventType.Click];
                      case '#middle':
                        return [_xy.MouseButton.Middle, _xy.MouseEventType.Click];
                      case '#right':
                        return [_xy.MouseButton.Right, _xy.MouseEventType.Click];
                      case '#doubleclick':
                        return [_xy.MouseButton.Left, _xy.MouseEventType.DoubleClick];
                      case '#tripleclick':
                        return [_xy.MouseButton.Left, _xy.MouseEventType.TripleClick];
                      case '#shiftclick':
                        return [_xy.MouseButton.Left, _xy.MouseEventType.ShiftClick];
                      case '#ctrlclick':
                        return [_xy.MouseButton.Left, _xy.MouseEventType.CtrlClick];
                      case '#move':
                        return [_xy.MouseButton.Left, _xy.MouseEventType.Move];
                      case '#up':
                        return [_xy.MouseButton.Left, _xy.MouseEventType.Up];
                      case '#down':
                        return [_xy.MouseButton.Left, _xy.MouseEventType.Down];
                      default:
                        throw new Error(":E324: Unsupported realValue: ".concat(realValue));
                    }
                  }(),
                  _ref60 = _slicedToArray(_ref59, 2),
                  button = _ref60[0],
                  eventType = _ref60[1];
                var event = {
                  button: button,
                  x: Math.round(offset.x),
                  // test avoid 65.5 etc
                  y: Math.round(offset.y),
                  type: eventType
                };

                // check command is TextRelative and calculate by caliber
                if (command.cmd == 'XClickTextRelative') {
                  var getTickCounter = function getTickCounter(str) {
                    function getNumberSet(num, type) {
                      if (parseInt(num) > 0 && type == 'X') {
                        return ['>', parseInt(num)];
                      } else if (parseInt(num) < 0 && type == 'X') {
                        return ['<', parseInt(num.replace('-', ''))];
                      } else if (parseInt(num) > 0 && type == 'Y') {
                        return ['^', parseInt(num)];
                      } else {
                        return ['v', parseInt(num.replace('-', ''))];
                      }
                    }
                    function getAllNumbersWithSign(str) {
                      var matches = str.match(/-?\d+/g);
                      if (matches) {
                        return matches;
                      }
                      return null;
                    }
                    if (str.indexOf('#R') !== -1) {
                      // ABC #R-6,3
                      var parts = str.split('#R');
                      var nums = getAllNumbersWithSign(parts[1]);
                      var _getNumberSet13 = getNumberSet(nums[0], 'X'),
                        _getNumberSet14 = _slicedToArray(_getNumberSet13, 2),
                        x1 = _getNumberSet14[0],
                        y1 = _getNumberSet14[1];
                      var _getNumberSet15 = getNumberSet(nums[1], 'Y'),
                        _getNumberSet16 = _slicedToArray(_getNumberSet15, 2),
                        x2 = _getNumberSet16[0],
                        y2 = _getNumberSet16[1];
                      ; // 3
                      var valueObj = {};
                      valueObj[x1] = y1;
                      valueObj[x2] = y2;
                      return valueObj;
                    }

                    // return str.split('').reduce((total, letter) => {
                    //   total[letter] ? total[letter]++ : total[letter] = 1;
                    //   return total;
                    // }, {});
                  };
                  var ocrCalibration = store.getState().config.ocrCalibration_internal ? store.getState().config.ocrCalibration_internal : 6;
                  var _isDesktopMode5 = (0, _cv_utils.isCVTypeForDesktop)(vars.get('!CVSCOPE'));
                  if (!_isDesktopMode5) {
                    ocrCalibration = 7;
                  }
                  // const caliberTick = command.target.split('#R')[1]; //old methode target
                  var caliberTick = command.target;
                  var countCalObj = getTickCounter(caliberTick);
                  for (var x in countCalObj) {
                    if (x == 'v') {
                      event['y'] = event['y'] + ocrCalibration * countCalObj[x]; // down (add in y offset)
                    }
                    if (x == '>') {
                      event['x'] = event['x'] + ocrCalibration * countCalObj[x]; // right (add in x offset)
                    }
                    if (x == '<') {
                      event['x'] = event['x'] - ocrCalibration * countCalObj[x]; // left (minus in x offset)
                    }
                    if (x == '^') {
                      event['y'] = event['y'] - ocrCalibration * countCalObj[x]; // up (minus in y offset)
                    }
                  }
                }
                if (['XClickTextRelative', 'XMoveTextRelative'].includes(command.cmd)) {
                  if (!originalResult || !originalResult.vars) {
                    originalResult = {
                      vars: {}
                    };
                  }
                  originalResult.vars['!ocrx'] = event['x'];
                  originalResult.vars['!ocry'] = event['y'];
                }
                (0, _log["default"])('event ===', event);
                var pSendMouseEvent = type === 'desktop' ? api.sendMouseEvent(event) : api.sendViewportMouseEvent(event, {
                  getViewportRectInScreen: function getViewportRectInScreen() {
                    return _ipc_cs["default"].ask('PANEL_GET_VIEWPORT_RECT_IN_SCREEN');
                  }
                });
                store.dispatch(_simple_actions.Actions.setOcrInDesktopMode(false));
                return pSendMouseEvent.then(function (success) {
                  if (!success) throw new Error("E201: Failed to ".concat(cmd, " ").concat(type, " coordinates at [").concat(offset.x, ", ").concat(offset.y, "]"));

                  // Note: `originalResult` is used by visualAssert to update !imageX and !imageY
                  return _objectSpread(_objectSpread({}, originalResult), {}, {
                    byPass: true
                  });
                });
              });
            });
          });
        }
      case 'captureDesktopScreenshot':
        {
          var cvApi = (0, _desktop.getNativeCVAPI)();
          var isJustFileName = function isJustFileName(str) {
            return !/[\\/]/.test(str);
          };
          var _path = target && target.trim();
          var filePath = _path && _path.length > 0 ? (0, _utils.ensureExtName)('.png', _path) : undefined;
          var next = filePath && isJustFileName(filePath) ? function (actualPath) {
            return cvApi.readFileAsBlob(actualPath).then(function (blob) {
              return (0, _storage.getStorageManager)().getScreenshotStorage().overwrite(_path, blob).then(function () {
                store.dispatch(act.listScreenshots());
                store.dispatch(act.addLog('info', "desktop screenshot saved to screenshot storage with file name '".concat(_path, "'")));
              });
            });
          } : function (actualPath) {
            store.dispatch(act.addLog('info', "desktop screenshot saved to hard drive at '".concat(actualPath, "'")));
          };
          return cvApi.captureDesktop({
            path: filePath
          }).then(next).then(function () {
            return {
              byPass: true
            };
          });
        }
      case 'captureScreenshot':
        {
          var _fileName2 = (0, _utils.ensureExtName)('.png', target);
          var _devicePixelRatio = window.devicePixelRatio;
          return (0, _global_state.getState)().then(function (state) {
            return (0, _tab_utils.activateTab)(state.tabIds.toPlay, true).then(function () {
              return (0, _utils.delay)(function () {}, C.SCREENSHOT_DELAY);
            }).then(function () {
              return captureScreenshotService.saveScreen((0, _storage.getStorageManager)().getScreenshotStorage(), state.tabIds.toPlay, _fileName2, _devicePixelRatio);
            });
          }).then(function (_ref61) {
            var fileName = _ref61.fileName,
              url = _ref61.url;
            return {
              screenshot: {
                url: url,
                name: fileName
              },
              byPass: true
            };
          });
        }
      case 'captureEntirePageScreenshot':
        {
          var originalFileName = (0, _utils.ensureExtName)('.png', target);
          // replace % with _ to avoid error in file name
          var _fileName3 = originalFileName.replace(/%/g, '_');
          return (0, _global_state.getState)().then(function (state) {
            return (0, _tab_utils.activateTab)(state.tabIds.toPlay, true).then(function () {
              return (0, _utils.delay)(function () {}, C.SCREENSHOT_DELAY);
            }).then(_tab.getPlayTabIpc).then(function (ipc) {
              return captureScreenshotService.saveFullScreen((0, _storage.getStorageManager)().getScreenshotStorage(), state.tabIds.toPlay, _fileName3, {
                startCapture: function startCapture() {
                  return ipc.ask('START_CAPTURE_FULL_SCREENSHOT', {}, C.CS_IPC_TIMEOUT);
                },
                endCapture: function endCapture(pageInfo) {
                  return ipc.ask('END_CAPTURE_FULL_SCREENSHOT', {
                    pageInfo: pageInfo
                  }, C.CS_IPC_TIMEOUT);
                },
                scrollPage: function scrollPage(offset) {
                  return ipc.ask('SCROLL_PAGE', {
                    offset: offset
                  }, C.CS_IPC_TIMEOUT);
                }
              });
            });
          }).then(function (_ref62) {
            var fileName = _ref62.fileName,
              url = _ref62.url;
            return {
              screenshot: {
                url: url,
                name: fileName
              },
              byPass: true
            };
          });
        }
      case 'selectWindow':
        {
          var _p3 = function () {
            switch (target && target.toUpperCase()) {
              case 'TAB=CLOSEALLOTHER':
                return _ipc_cs["default"].ask('PANEL_CLOSE_OTHER_TABS', {});
              case 'TAB=CLOSE':
                return _ipc_cs["default"].ask('PANEL_CLOSE_CURRENT_TAB', {});
              default:
                var _splitIntoTwo = (0, _utils.splitIntoTwo)('=', target),
                  _splitIntoTwo2 = _slicedToArray(_splitIntoTwo, 2),
                  _type = _splitIntoTwo2[0],
                  locator = _splitIntoTwo2[1];
                return _ipc_cs["default"].ask('PANEL_SELECT_WINDOW', {
                  target: target,
                  value: value
                });
            }
          }();

          // Note: let `selectWindow` pass through cs and back to background,
          // to keep the flow more consistent with the other commands
          return _p3.then(function () {
            return (0, _tab.getPlayTab)().then(function (tab) {
              return {
                byPass: true,
                pageUrl: tab.url,
                index: tab.index
              };
            });
          });
        }
      default:
        return undefined;
    }
  };
  return runCsFreeCommands;
};
var interpretCSVCommands = function interpretCSVCommands(_ref63) {
  var store = _ref63.store,
    vars = _ref63.vars;
  return function (command, index) {
    var csvStorage = (0, _storage.getStorageManager)().getCSVStorage();
    var cmd = command.cmd,
      target = command.target,
      value = command.value;
    var assertCsvExist = function assertCsvExist(target) {
      return csvStorage.exists(target).then(function (isExisted) {
        if (isExisted) {
          if (!vars.get('!CsvReadLineNumber')) {
            vars.set({
              '!CsvReadLineNumber': 1
            }, true);
          }
          return;
        }
        vars.set({
          '!CsvReadStatus': 'FILE_NOT_FOUND'
        }, true);
        var errMsg = "E325: csv file '".concat(target, "' does not exist");
        if ((0, _storage.getStorageManager)().isBrowserMode() && (_path2.posix.isAbsolute(target) || _path2.win32.isAbsolute(target))) {
          errMsg += '. Full path works only in hard-drive mode.';
        }
        throw new Error(errMsg);
      });
    };
    switch (cmd) {
      case 'csvRead':
        {
          if (value && value.length > 0) {
            store.dispatch(act.addLog('warning', 'csvRead: Value field should be empty (not used)'));
          }
          return assertCsvExist(target).then(function () {
            return csvStorage.read(target, 'Text').then(_csv.parseFromCSV).then(function (rows) {
              // Note: !CsvReadLineNumber starts from 1
              var index = vars.get('!CsvReadLineNumber') - 1;
              var row = rows[index];
              if (index >= rows.length) {
                vars.set({
                  '!CsvReadStatus': 'END_OF_FILE'
                }, true);
                throw new Error('end of csv file reached');
              } else {
                vars.set({
                  '!CsvReadStatus': 'OK',
                  '!CsvReadMaxRow': rows.length
                }, true);
              }
              vars.clear(/^!COL\d+$/i);
              row.forEach(function (data, i) {
                vars.set(_defineProperty({}, "!COL".concat(i + 1), data));
              });
              return {
                isFlowLogic: true
              };
            });
          });
        }
      case 'csvSave':
        {
          var csvLine = vars.get('!CSVLINE');
          if (!csvLine || !csvLine.length) {
            throw new Error('No data to save to csv');
          }
          return (0, _csv.stringifyToCSV)([csvLine]).then(function (newLineText) {
            var fileName = /\.csv$/i.test(target) ? target : target + '.csv';
            return csvStorage.exists(fileName).then(function (isExisted) {
              if (!isExisted) {
                return csvStorage.write(fileName, new Blob([newLineText]));
              }
              return csvStorage.read(fileName, 'Text').then(function (originalText) {
                var text = (originalText + '\n' + newLineText).replace(/\n+/g, '\n');
                return csvStorage.overwrite(fileName, new Blob([text]));
              });
            });
          }).then(function () {
            vars.clear(/^!CSVLINE$/);
            store.dispatch(act.listCSV());
          }).then(function () {
            return {
              isFlowLogic: true
            };
          });
        }
      case 'csvReadArray':
        {
          if (!value || !value.length) {
            throw new Error('E326: Please provide variable name as value');
          }
          return assertCsvExist(target).then(function () {
            return csvStorage.read(target, 'Text').then(_csv.parseFromCSV).then(function (rows) {
              vars.set({
                '!CsvReadStatus': true,
                '!CsvReadMaxRow': rows.length
              }, true);
              return {
                byPass: true,
                vars: _defineProperty({}, value, rows)
              };
            }, function (e) {
              vars.set({
                '!CsvReadStatus': false
              }, true);
              return Promise.reject(e);
            });
          });
        }
      case 'csvSaveArray':
        {
          if (!value || !value.length) {
            throw new Error('E327: Please provide csv file name as value');
          }
          if (!target || !target.length) {
            throw new Error('E328: Please provide array variable name as target');
          }
          var arr = vars.get(target);
          if (!arr) {
            throw new Error("E329: No variable found with name '".concat(target, "'"));
          }
          var isValidCsvArray = Array.isArray(arr) && Array.from(arr).every(function (item) {
            return Array.isArray(item);
          });
          if (!isValidCsvArray) {
            throw new Error('E330: Array must be two dimensional array');
          }
          return (0, _csv.stringifyToCSV)(arr).then(function (csvText) {
            var fileName = /\.csv$/i.test(value) ? value : value + '.csv';
            return csvStorage.overwrite(fileName, new Blob([csvText]));
          }).then(function () {
            store.dispatch(act.listCSV());
          }).then(function () {
            return {
              isFlowLogic: true
            };
          });
        }
      default:
        return undefined;
    }
  };
};

// Note: initialize the player, and listen to all events it emits
var initPlayer = exports.initPlayer = function initPlayer(store) {
  var vars = (0, _variables["default"])('main', {}, {
    '!TESTSUITE_LOOP': 1
  });
  var macroCallStack = (0, _call_stack.createMacroCallStack)({
    getCurrentMacroRunningStatus: function getCurrentMacroRunningStatus() {
      var playerState = tcPlayer.getState();
      var reducerState = store.getState();
      var commandResults = (0, _macro.getCommandResults)({
        count: playerState.resources.length,
        doneIndices: (0, _recomputed.getDoneCommandIndices)(reducerState),
        errorIndices: (0, _recomputed.getErrorCommandIndices)(reducerState),
        warningIndices: (0, _recomputed.getWarningCommandIndices)(reducerState)
      });
      return {
        playerState: playerState,
        commandResults: commandResults,
        status: _macro.MacroStatus.Running,
        nextIndex: playerState.nextIndex,
        interpreterState: interpreter.backupState()
      };
    },
    updateSelectedMacro: function updateSelectedMacro(macro, runningStatus) {
      return store.dispatch(act.editTestCase(macro.id));
    },
    restorePlayerState: function restorePlayerState(macro, runningStatus) {
      // Steps:
      // 1. Restore macro player state
      // 2. Restore player state in reducer
      var playerState = runningStatus.playerState,
        _runningStatus$interp = runningStatus.interpreterState,
        interpreterState = _runningStatus$interp === void 0 ? (0, _ts_utils.clone)(_interpreter2["default"].DefaultState) : _runningStatus$interp;
      tcPlayer.setState(playerState);
      store.dispatch(act.setPlayerState({
        // Note: since we don't show loop info for subroutines,
        // `currentLoop` and `loops` in reducer state is always for initial call frame,
        // so no neep to restore that info from call stack before playing any frame
        //
        // currentLoop:         playerState.loopsCursor - playerState.loopsStart + 1,
        // loops:               playerState.loopsEnd - playerState.loopsStart + 1,
        nextCommandIndex: playerState.nextIndex
      }));
      interpreter.restoreState(interpreterState);
    },
    playMacro: function playMacro(macro, runningStatus, _ref64) {
      var isBottom = _ref64.isBottom,
        isResume = _ref64.isResume,
        frameId = _ref64.frameId;
      // Note: do not use clone here, otherwise will lose `callback` in playerState
      var playerState = _objectSpread({}, runningStatus.playerState);
      playerState.noEndEvent = !isBottom;

      // Note: frameId in extra will be available in all kinds of player events,
      // frameId is used as id for monitor, so that we can control monitors in player events
      playerState.extra = _objectSpread(_objectSpread({}, playerState.extra || {}), {}, {
        frameId: frameId,
        macroId: macro.id,
        isBottomFrame: isBottom,
        isBackFromCalling: isResume
      });
      return showDownloadBarFinally(function () {
        return xCmdCounter.get() > 0;
      }, function () {
        if (isResume) {
          tcPlayer.setState(playerState);
          // Note: already increase `nextIndex` by one
          tcPlayer.__setNext(runningStatus.nextIndex);
          return tcPlayer.play(tcPlayer.getState());
        } else {
          var needDelayAfterLoop = _utils.and.apply(void 0, _toConsumableArray(playerState.resources.map(function (command) {
            return (0, _command.isExtensionResourceOnlyCommand)(command.cmd);
          })));
          var args = _objectSpread(_objectSpread({}, playerState), {}, {
            needDelayAfterLoop: needDelayAfterLoop
          });
          return tcPlayer.play(args);
        }
      });
    }
  });
  var ocrCmdCounter = (0, _command_counter.getOcrCommandCounter)({
    initial: 0,
    getMax: function getMax() {
      return (0, _license.getLicenseService)().getMaxOcrCalls();
    },
    onMax: function onMax(cur, max, initial) {
      throw new Error("OCR conversion limit reached");
    }
  });
  var xCmdCounter = new _counter.Counter({
    initial: 0,
    getMax: function getMax() {
      return (0, _license.getLicenseService)().getMaxXCommandCalls();
    },
    onMax: function onMax(cur, max, initial) {
      throw new Error("XClick/XClickText/XClickTextRelative/XMoveText/XMoveTextRelative/XMove/XType ".concat(max, " commands limit reached"));
    }
  });
  var proxyCounter = new _counter.Counter({
    initial: 0,
    getMax: function getMax() {
      return (0, _license.getLicenseService)().getMaxProxyCalls();
    },
    onMax: function onMax(cur, max, initial) {
      throw new Error("PROXY ".concat(max, " commands limit reached"));
    }
  });
  var interpreter = new _interpreter2["default"]({
    run: interpretSpecialCommands({
      vars: vars,
      store: store,
      xCmdCounter: xCmdCounter,
      getTcPlayer: function getTcPlayer() {
        return tcPlayer;
      },
      getInterpreter: function getInterpreter() {
        return interpreter;
      }
    })
  });
  var tcPlayer = initTestCasePlayer({
    store: store,
    vars: vars,
    interpreter: interpreter,
    xCmdCounter: xCmdCounter,
    ocrCmdCounter: ocrCmdCounter,
    proxyCounter: proxyCounter
  });
  // **important: don't remove tsPlayer. It's actually used by context menu "Testsuite: play all in folder"
  var tsPlayer = initTestSuitPlayer({
    store: store,
    vars: vars,
    tcPlayer: tcPlayer,
    xCmdCounter: xCmdCounter,
    ocrCmdCounter: ocrCmdCounter,
    proxyCounter: proxyCounter
  });
  initMacroMonitor({
    vars: vars,
    store: store
  });
  macroCallStack.on(_types3.CallStackEvent.BeforeRun, function (macroInfoList) {
    var lastMacroInfo = macroInfoList[macroInfoList.length - 1];
    var lastName = lastMacroInfo.name;
    var prevNames = macroInfoList.slice(0, -1).map(function (item) {
      return "'".concat(item.name, "'");
    });
    if (prevNames.length > 0) {
      store.dispatch(act.addLog('status', "Running '".concat(lastName, "', called by ").concat(prevNames.join(' > '))));
    }
  });
  macroCallStack.on(_types3.CallStackEvent.AfterReturn, function (macroInfoList) {
    var lastMacroInfo = macroInfoList[macroInfoList.length - 1];
    var lastName = lastMacroInfo.name;
    var lastFrameId = lastMacroInfo.frameId;
    var prevNames = macroInfoList.slice(0, -1).map(function (item) {
      return "'".concat(item.name, "'");
    });
    (0, _macro_monitor.getMacroMonitor)().removeTarget(lastFrameId);
    if (prevNames.length > 0) {
      store.dispatch(act.addLog('status', "Finished running '".concat(lastName, "', returning to ").concat(prevNames.join(' > '))));
    }
  });
  _ipc_cs["default"].onAsk(function (cmd, args) {
    switch (cmd) {
      case 'DOWNLOAD_COMPLETE':
        {
          var _fileName4 = args ? _path2["default"].basename(args.filename) : null;
          if (!_fileName4) {
            return false;
          }
          vars.set({
            '!LAST_DOWNLOADED_FILE_NAME': _fileName4
          }, true);
          return true;
        }
    }
  });

  // Note: No need to return anything in this method.
  // Because both test case player and test suite player are cached in player.js
  // All later usage of player utilize `getPlayer` method
};

// Note: Standalone function to ask background to run a command
var askBackgroundToRunCommand = function askBackgroundToRunCommand(_ref65) {
  var command = _ref65.command,
    state = _ref65.state,
    store = _ref65.store,
    vars = _ref65.vars,
    preRun = _ref65.preRun;
  // ** commands are by default superfast except it has any !REPLAYSPEED command in lower index that has v1 as suffix like: fastv1
  var superFast = /^(nodisplay|fast|medium|slow)$/i.test(vars.get('!REPLAYSPEED')) ? true : false;

  // const vars_ = getVarsInstance().dump()
  // console.log('vars_ :>> ', vars_)

  var firstOnDownloadIndex = state.resources.findIndex(function (command) {
    return command.cmd === 'onDownload';
  });
  var hasOnDownloadCmd = false;
  if (firstOnDownloadIndex !== -1) {
    var nextIndex = state.nextIndex;
    if (firstOnDownloadIndex < nextIndex) {
      hasOnDownloadCmd = true;
    }
  }
  var useClipboard = /!clipboard/i.test(command.target + ';' + command.value);
  var prepare = !useClipboard ? Promise.resolve({
    useClipboard: false
  }) : Promise.resolve({
    useClipboard: true,
    clipboard: _clipboard["default"].get()
  });
  if (_web_extension["default"].isFirefox()) {
    switch (command.cmd) {
      case 'onDownload':
        store.dispatch(act.addLog('warning', 'onDownload - changing file names not supported by Firefox extension api yet'));
        break;
    }
  }
  switch (command.cmd) {
    case 'XType':
      if (command.value && command.value.length > 0) {
        throw new Error("E340: XType currently doesn't use the \"Value\" field");
      }
      break;
  }
  return prepare.then(function (_ref66) {
    var useClipboard = _ref66.useClipboard,
      _ref66$clipboard = _ref66.clipboard,
      clipboard = _ref66$clipboard === void 0 ? '' : _ref66$clipboard;
    // Set clipboard variable if it is used
    if (useClipboard) {
      vars.set({
        '!CLIPBOARD': clipboard
      });
    }
    if (state.extra.isBottomFrame) {
      vars.set({
        '!LOOP': state.loopsCursor
      }, true);
    }
    vars.set({
      '!RUNTIME': (0, _ts_utils.milliSecondsToStringInSecond)((0, _macro_monitor.getMacroMonitor)().getDataFromInspector((0, _call_stack.getMacroCallStack)().bottom().id, _types4.MacroInspector.LoopTimer))
    }, true);
    if (command.cmd === 'open' || command.cmd === 'openBrowser') {
      // const indexR = vars.get('!CURRENT_TAB_NUMBER_RELATIVE') + 1;
      // vars.set({ '!CURRENT_TAB_NUMBER_RELATIVE': indexR}, true)
      command = _objectSpread(_objectSpread({}, command), {}, {
        href: state.startUrl
      });
    }

    // Note: translate shorthand '#efp'
    if (command.target && /^#efp$/i.test(command.target.trim())) {
      // eslint-disable-next-line no-template-curly-in-string
      command.target = '#elementfrompoint (${!imageX}, ${!imageY})';
    }
    var isRelatedToExecuteScript = ['executeScript', 'executeScript_Sandbox', 'executeAsyncScript', 'executeAsyncScript_Sandbox', 'if_v2', 'while_v2', 'gotoIf_v2', 'if', 'while', 'gotoIf', 'elseif', 'repeatIf'].indexOf(command.cmd) !== -1;
    if (command.cmd !== 'comment') {
      // Replace variables in 'target' and 'value' of commands
      ;
      ['target', 'value'].forEach(function (field) {
        if (command[field] === undefined) return;
        var oldEval = command.cmd === 'storeEval' && field === 'target' || command.cmd === 'gotoIfxxx' && field === 'target' || command.cmd === 'ifxxx' && field === 'target' || command.cmd === 'whilexxx' && field === 'target';
        var opts = oldEval ? {
          withHashNotation: true
        } : {};
        opts.shouldStringify = oldEval || isRelatedToExecuteScript;
        command = _objectSpread(_objectSpread({}, command), {}, _defineProperty({}, field, vars.render(replaceEscapedChar(['type'].includes(command.cmd) ? command[field] : command[field].trim(), command, field, vars.get('!StringEscape')), opts)));
      });
    }

    // add timeout info to each command's extra
    // Please note that we must set the timeout info at runtime for each command,
    // so that timeout could be modified by some 'store' commands and affect
    // the rest of commands
    command = (0, _utils.updateIn)(['extra'], function (extra) {
      return _objectSpread(_objectSpread({}, extra || {}), {}, {
        timeoutPageLoad: vars.get('!TIMEOUT_PAGELOAD'),
        timeoutElement: vars.get('!TIMEOUT_WAIT'),
        timeoutDownload: vars.get('!TIMEOUT_DOWNLOAD'),
        timeoutDownloadStart: vars.get('!TIMEOUT_DOWNLOAD_START') || Math.max(10, vars.get('!TIMEOUT_WAIT')),
        lastCommandOk: vars.get('!LASTCOMMANDOK'),
        errorIgnore: !!vars.get('!ERRORIGNORE'),
        waitForVisible: !!vars.get('!WAITFORVISIBLE'),
        superFast: superFast,
        hasOnDownloadCmd: hasOnDownloadCmd
      });
    }, command);
    return preRun(command, state, function (command) {
      var runCommandInPlayTab_result = (0, _run_command.runCommandInPlayTab)(command);
      console.log('runCommandInPlayTab_result:>> ', runCommandInPlayTab_result);
      return runCommandInPlayTab_result;
    });
  });
};
function initMacroMonitor(_ref67) {
  var store = _ref67.store,
    vars = _ref67.vars;
  (0, _macro_monitor.getMacroMonitor)(function (actionType, name, id, notBatch) {
    switch (actionType) {
      case _macro_monitor.MacroParamsProviderType.Constructor:
        {
          switch (name) {
            case _types4.MacroInspector.Countdown:
              return [function () {
                (0, _player.getPlayer)().stopWithError(new Error("E351: macro '".concat((0, _call_stack.getMacroCallStack)().peek().resource.name, "' timeout ").concat(vars.get('!TIMEOUT_MACRO'), "s (change the value in the settings if needed)")));
              }];
            case _types4.MacroInspector.Timer:
            case _types4.MacroInspector.LoopTimer:
            default:
              return [];
          }
        }
      case _macro_monitor.MacroParamsProviderType.Restart:
        {
          switch (name) {
            case _types4.MacroInspector.Countdown:
              return [vars.get('!TIMEOUT_MACRO') * 1000, true];
            case _types4.MacroInspector.Timer:
            case _types4.MacroInspector.LoopTimer:
            default:
              return [];
          }
        }
    }
  });
}
function isPausedOrStopped(str) {
  return /player: paused or stopped/.test(str);
}
var initTestCasePlayer = function initTestCasePlayer(_ref68) {
  var store = _ref68.store,
    vars = _ref68.vars,
    interpreter = _ref68.interpreter,
    xCmdCounter = _ref68.xCmdCounter,
    ocrCmdCounter = _ref68.ocrCmdCounter,
    proxyCounter = _ref68.proxyCounter;
  // Note: use this to track `onError` command
  // `onError` works like a global try catch, it takes effects on any commands coming after `onError`
  // Multilple `onError` are allowed, latter one overwrites previous one.
  // The scope of `onError` is current loop 
  var onErrorCommand = null;
  var player = (0, _player.getPlayer)({
    prepare: function prepare(state) {
      // Each 'replay' has an independent variable scope,
      // with global variables as initial scope

      if (state.extra.isBottomFrame && !state.extra.isBackFromCalling) {
        if (state.keepVariables != 'yes') {
          vars.reset({
            keepGlobal: true
          });
        }
        checkRelativeIndexArr = [];
        vars.set(state["public"].scope || {}, true);
        vars.set({
          '!StatusOK': true,
          '!WaitForVisible': false,
          '!StringEscape': true,
          '!IMAGEX': 0,
          '!IMAGEY': 0,
          '!OCRX': 0,
          '!OCRY': 0,
          '!OCRHEIGHT': 0,
          '!OCRWIDTH': 0,
          '!LAST_DOWNLOADED_FILE_NAME': vars.get('!LAST_DOWNLOADED_FILE_NAME') || '',
          '!URL': state.playUrl || '',
          '!CURRENT_TAB_NUMBER': state.playtabIndex,
          '!CURRENT_TAB_NUMBER_RELATIVE': 0,
          '!CURRENT_TAB_NUMBER_RELATIVE_INDEX': state.playtabIndex,
          '!CURRENT_TAB_NUMBER_RELATIVE_ID': state.playtabId,
          '!OCRENGINE': store.getState().config.ocrEngine,
          '!OCRLANGUAGE': store.getState().config.ocrLanguage,
          '!BROWSER': _web_extension["default"].isFirefox() ? 'firefox' : 'chrome',
          '!OS': function () {
            var ua = window.navigator.userAgent;
            if (/windows/i.test(ua)) return 'windows';
            if (/mac/i.test(ua)) return 'mac';
            return 'linux';
          }()
        }, true);
      }
      if (!state.extra.isBackFromCalling) {
        interpreter.reset();
        interpreter.preprocess(state.resources);
      }
      return _ipc_cs["default"].ask('PANEL_START_PLAYING', {
        url: state.startUrl,
        shouldNotActivateTab: true
      });
    },
    run: function run(command, state) {
      return askBackgroundToRunCommand({
        command: command,
        state: state,
        store: store,
        vars: vars,
        preRun: function preRun(command, state, askBgToRun) {
          // Note: all commands need to be run by interpreter before it is sent to bg
          // so that interpreter could pick those flow logic commands and do its job

          return new Promise(function (resolve, reject) {
            // Note: inc() has a chance to throw xCommand limit reached error,
            // so it's easier to keep it in the Promise constructor
            if (/^(XType|XClick|XClickText|XMove|XMoveText|XMoveTextRelative|XClickRelative|XClickTextRelative|XMoveRelative|XMouseWheel)$/i.test(command.cmd)) {
              xCmdCounter.inc();
            }
            if (command.cmd === 'setProxy') {
              // Note: do not need this as we already metion proxy permission in manifest
              // let {permissionText} = store.getState().config;
              // if( permissionText != "Permission OK"){
              //   throw new Error(`Please request proxy permission in settings`)
              // }
              proxyCounter.inc();
            }
            interpreter.run(command, state.nextIndex).then( /*#__PURE__*/function () {
              var _ref69 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(result) {
                var byPass, isFlowLogic, nextIndex, resetVars, isFound, isFoundTab, CURRENT_TAB_NUMBER_RELATIVE_INDEX, tabF, indexR, resultVars, varKey, varValue, convertObjFormatToRealObj, finalValue, result_;
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      byPass = result.byPass, isFlowLogic = result.isFlowLogic, nextIndex = result.nextIndex, resetVars = result.resetVars;
                      if (!(result.index != undefined)) {
                        _context3.next = 19;
                        break;
                      }
                      isFound = checkRelativeIndex(result.index);
                      if (!(isFound == 1 || 1)) {}
                      _context3.next = 6;
                      return checkRelativeTabId(vars.get('!CURRENT_TAB_NUMBER_RELATIVE_ID'));
                    case 6:
                      isFoundTab = _context3.sent;
                      CURRENT_TAB_NUMBER_RELATIVE_INDEX = isFoundTab ? vars.get('!CURRENT_TAB_NUMBER_RELATIVE_INDEX') : 'NA'; // const indexR = vars.get('!CURRENT_TAB_NUMBER_RELATIVE') + 1;
                      // const indexR = result.index - CURRENT_TAB_NUMBER_RELATIVE_INDEX;
                      if (state.mode == 'LOOP' && state.nextIndex == 1) {
                        CURRENT_TAB_NUMBER_RELATIVE_INDEX = 0;
                      }
                      if (!(CURRENT_TAB_NUMBER_RELATIVE_INDEX == 'NA')) {
                        _context3.next = 16;
                        break;
                      }
                      _context3.next = 12;
                      return getTabIdwithIndex0();
                    case 12:
                      tabF = _context3.sent;
                      CURRENT_TAB_NUMBER_RELATIVE_INDEX = tabF['index'] != undefined ? tabF['index'] : 0;
                      vars.set({
                        '!CURRENT_TAB_NUMBER_RELATIVE_ID': tabF['id']
                      }, true);
                      vars.set({
                        '!CURRENT_TAB_NUMBER_RELATIVE_INDEX': tabF['index']
                      }, true);
                    case 16:
                      // const indexR =  CURRENT_TAB_NUMBER_RELATIVE_INDEX == 0 ? 0: result.index - CURRENT_TAB_NUMBER_RELATIVE_INDEX;
                      indexR = result.index - CURRENT_TAB_NUMBER_RELATIVE_INDEX;
                      vars.set({
                        '!CURRENT_TAB_NUMBER_RELATIVE': indexR
                      }, true);
                    case 18:
                      vars.set({
                        '!CURRENT_TAB_NUMBER': result.index
                      }, true);
                    case 19:
                      // Record onError command
                      if (command.cmd === 'onError') {
                        onErrorCommand = command;
                      }

                      // fix sandbox array issue
                      if (!(command.cmd == 'executeScript_Sandbox')) {
                        _context3.next = 32;
                        break;
                      }
                      // console.log('executeScript_Sandbox result:>>', result)
                      resultVars = result.vars;
                      if (resultVars) {
                        _context3.next = 24;
                        break;
                      }
                      throw new Error('E503: A variable is required in the value field.');
                    case 24:
                      varKey = Object.keys(resultVars)[0]; // always the first key
                      varValue = Object.values(resultVars)[0]; // always the first value
                      console.log('varKey:>> ', varKey);
                      console.log('varValue:>> ', varValue);
                      convertObjFormatToRealObj = function convertObjFormatToRealObj(obj) {
                        if (!obj) return obj;
                        // console.log('obj:>> ', obj)
                        var newObj;
                        if (obj !== null && obj !== void 0 && obj.properties) {
                          var varValueType = obj["class"] == "Array" ? 'array' : 'object';
                          console.log('varValueType:>> ', varValueType);
                          if (varValueType == 'array') {
                            // it's an array
                            newObj = [];
                            for (var i = 0; i < obj.properties.length; i++) {
                              newObj.push(convertObjFormatToRealObj(obj.properties[i]));
                            }
                          } else {
                            // it's an object
                            newObj = {};
                            newObj = convertObjFormatToRealObj(obj.properties);
                          }
                        } else {
                          // console.log('last obj:>> ', obj)
                          var newKeys = Object.keys(obj);
                          var values = Object.values(obj);
                          var hasObjectOrArray = values.some(function (val) {
                            return val === null || val === void 0 ? void 0 : val.properties;
                          });
                          if (hasObjectOrArray) {
                            newObj = {};
                            for (var _i = 0; _i < newKeys.length; _i++) {
                              newObj[newKeys[_i]] = convertObjFormatToRealObj(values[_i]);
                            }
                          } else {
                            newObj = obj;
                          }
                        }
                        return newObj;
                      };
                      finalValue = convertObjFormatToRealObj(varValue); // console.log('finalValue:>> ', finalValue)
                      // put explicitly
                      result_ = {
                        byPass: byPass,
                        vars: _defineProperty({}, varKey, finalValue)
                      };
                      return _context3.abrupt("return", Promise.resolve(result_));
                    case 32:
                      if (!byPass) {
                        _context3.next = 34;
                        break;
                      }
                      return _context3.abrupt("return", Promise.resolve(result));
                    case 34:
                      if (!isFlowLogic) {
                        _context3.next = 36;
                        break;
                      }
                      return _context3.abrupt("return", Promise.resolve({
                        nextIndex: nextIndex
                      }));
                    case 36:
                      return _context3.abrupt("return", askBgToRun(command));
                    case 37:
                    case "end":
                      return _context3.stop();
                  }
                }, _callee3);
              }));
              return function (_x3) {
                return _ref69.apply(this, arguments);
              };
            }()).then(resolve, reject);
          });
        }
      })["catch"](function (e) {
        // Note: it will just log errors instead of a stop of whole macro, in following situations
        // 1. variable !ERRORIGNORE is set to true
        // 2. There is an `onError` command ahead in current loop.
        // 3. it's in loop mode, and it's not the last loop, and onErrorInLoop is continue_next_loop,
        if (vars.get('!ERRORIGNORE')) {
          return {
            log: {
              error: e.message
            }
          };
        }
        if (onErrorCommand) {
          var value = onErrorCommand.value && onErrorCommand.value.trim();
          var target = onErrorCommand.target && onErrorCommand.target.trim();
          if (/^#restart$/i.test(target)) {
            store.dispatch(act.addLog('status', 'onError - about to restart'));
            e.restart = true;
            throw e;
          } else if (/^#goto$/i.test(target)) {
            store.dispatch(act.addLog('status', "onError - about to goto label '".concat(value, "'")));
            return Promise.resolve({
              log: {
                error: e.message
              },
              nextIndex: interpreter.commandIndexByLabel(value)
            });
          }
        }
        var isPausedStopped = isPausedOrStopped(e.message);
        var continueNextLoop = state.mode === _player.Player.C.MODE.LOOP && state.loopsCursor < state.loopsEnd && store.getState().config.onErrorInLoop === 'continue_next_loop';
        if (continueNextLoop) {
          if (isPausedStopped) {
            return {
              // Note: simply set nextIndex to command count, it will enter next loop
              nextIndex: state.resources.length
            };
          }
          return {
            log: {
              error: e.message
            },
            // Note: simply set nextIndex to command count, it will enter next loop
            nextIndex: state.resources.length
          };
        }

        // Note: set these status values to false
        // status of those logs above will be taken care of by `handleResult`
        vars.set({
          '!LastCommandOK': false,
          '!StatusOK': false
        }, true);
        throw e;
      });
    },
    handleResult: function handleResult(result, command, state) {
      var prepares = [];
      var getCurrentPlayer = function getCurrentPlayer() {
        var state = store.getState();
        switch (state.player.mode) {
          case C.PLAYER_MODE.TEST_CASE:
            return (0, _player.getPlayer)({
              name: 'testCase'
            });
          case C.PLAYER_MODE.TEST_SUITE:
            return (0, _player.getPlayer)({
              name: 'testSuite'
            });
        }
      };
      (0, _tab.getPlayTab)().then(function (tab) {
        vars.set({
          '!CURRENT_TAB_NUMBER': tab.index
        }, true);
      });
      // Every command should return its window.url
      if (result && result.pageUrl) {
        vars.set({
          '!URL': result.pageUrl
        }, true);
      }
      if (result && result.vars) {
        var newVars = (0, _utils.objMap)(function (val) {
          if (val && val.__undefined__) return undefined;
          return val;
        }, result.vars);
        (0, _log["default"])('set vars', newVars);
        try {
          vars.set(newVars);

          // Note: if set value to !Clipboard, there is an async job we must get done before handleResult could return
          var clipBoardKey = Object.keys(result.vars).find(function (key) {
            return /!clipboard/i.test(key);
          });
          if (clipBoardKey) {
            prepares.push(Promise.resolve(_clipboard["default"].set(result.vars[clipBoardKey])));
          }

          // Note: if user sets !timeout_macro to some other value, re-calculate the time left
          var timeoutMacroKey = Object.keys(result.vars).find(function (key) {
            return /!timeout_macro/i.test(key);
          });
          if (timeoutMacroKey) {
            var frameId = (0, _call_stack.getMacroCallStack)().peek().id;
            (0, _macro_monitor.getMacroMonitor)().restartInspector(frameId, _types4.MacroInspector.Countdown);
          }
        } catch (e) {
          console.log;
          if (newVars['!ocrlanguage']) {
            var ocrEngine = vars.get('!ocrEngine') || store.getState().config.ocrEngine;
            var ocrEngineName = ocrEngine == 99 ? 'XModule' : ocrEngine == 98 ? 'JavaScript OCR' : ocrEngine == 1 || ocrEngine == 2 ? 'OCR.Space Engine' : 'OCR Engine';
            return Promise.reject(new Error("E502: ".concat(ocrEngineName, " encountered a problem")));
          }
          return Promise.reject(e);
        }
      }
      var hasError = false;
      if (result && result.log) {
        if (result.log.info) {
          store.dispatch(act.addLog('echo', result.log.info, result.log.options));
          if (result.log.options && result.log.options.notification) {
            _ipc_cs["default"].ask('PANEL_NOTIFY_ECHO', {
              text: result.log.info
            });
          }
        }
        if (result.log.warning) {
          store.dispatch(act.addLog('warning', result.log.warning, result.log.options));
        }
        if (result.log.error && !isPausedOrStopped(result.log.error)) {
          store.dispatch(act.addPlayerWarningCommandIndex(state.nextIndex));
          store.dispatch(act.addLog('error', result.log.error, {
            ignored: true
          }));
          hasError = true;
        }
      }

      // From spec: !StatusOK, very similar to !LastCommandOK but it does not get reset by a “good” command.
      // If set to error, it remains like this. But a user can use store | true | !StatusOK to manually reset it.
      if (command.cmd !== 'echo') {
        vars.set({
          '!LastCommandOK': !hasError
        }, true);
      }
      if (hasError) {
        vars.set({
          '!StatusOK': false
        }, true);
      }
      if (result && result.screenshot) {
        store.dispatch(act.addLog('info', 'a new screenshot captured'));
        (0, _storage.getStorageManager)().getScreenshotStorage().getLink(result.screenshot.name).then(function (link) {
          return _objectSpread(_objectSpread({}, result.screenshot), {}, {
            url: link
          });
        }).then(function (ss) {
          store.dispatch(act.listScreenshots());
        })["catch"](function (e) {
          _log["default"].error('screenshot obj error 1', e);
          _log["default"].error('screenshot obj error stack', e.stack);
        });
      }
      if (result && result.control) {
        switch (result.control.type) {
          case 'pause':
            // Important: should only pause test case player, not test suite player
            // Because once test suite player is paused, it is supposed to run the test case from start again
            _ipc_cs["default"].ask('PANEL_NOTIFY_AUTO_PAUSE', {});

            // pause() returns a promise that doesn't resolve,
            // must return that promise here to pause any further execution
            return (0, _player.getPlayer)({
              name: 'testCase'
            }).pause();
          default:
            throw new Error("Control type '".concat(result.control.type, "' not supported yet"));
        }
      }
      if (/^(nodisplay|fast|medium|slow)$/i.test(vars.get('!REPLAYSPEED'))) {
        player.setSuperFastMode(true);
      } else {
        player.setSuperFastMode(false);
      }
      if (store.getState().replaySpeedOverrideToFastMode && (state.postDelay !== REPLAY_SPEED_DELAY['FAST'] || store.getState().noDisplayInPlay)) {
        store.dispatch(_simple_actions.Actions.setNoDisplayInPlay(false));
        player.setPostDelay(REPLAY_SPEED_DELAY['FAST']);
      } else {
        if (/^(fastv1|fast|mediumv1|medium|slowv1|slow|nodisplayv1|nodisplay)$/i.test(vars.get('!REPLAYSPEED'))) {
          var val = vars.get('!REPLAYSPEED').toUpperCase();
          player.setPostDelay(REPLAY_SPEED_DELAY[val]);
        }
        var replaySpeedKey = Object.keys(result.vars || {}).find(function (key) {
          return key.toUpperCase() === '!REPLAYSPEED';
        });

        // Save nodisplay to store to reflect it in rendering
        // if !REPLAYSPEED is updated in vars
        if (replaySpeedKey) {
          store.dispatch(_simple_actions.Actions.setNoDisplayInPlay(/^nodisplayv1$/i.test(vars.get('!REPLAYSPEED')) || /^nodisplay$/i.test(vars.get('!REPLAYSPEED'))));
        }
      }

      // For those flow logic that set nextIndex directly in Interpreter.run method
      if (result && result.nextIndex !== undefined) {
        return Promise.all(prepares).then(function () {
          return result.nextIndex;
        });
      }

      // For those flow logic that has to get result from bg
      // and return nextIndex in Interpreter.postRun
      return Promise.all(prepares).then(function () {
        return interpreter.postRun(command, state.nextIndex, result);
      }).then(function () {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return data.nextIndex;
      });
    }
  }, {
    preDelay: 0
  });
  player.on('BREAKPOINT', function () {
    _ipc_cs["default"].ask('PANEL_NOTIFY_BREAKPOINT', {});
  });
  player.on('LOOP_START', function (_ref70) {
    var loopsCursor = _ref70.loopsCursor,
      extra = _ref70.extra;
    if (extra.isBottomFrame) {
      // Note: set 'csv read line number' to loops whenever a new loop starts
      vars.set({
        '!CsvReadLineNumber': loopsCursor,
        '!visualSearchArea': 'viewport',
        '!StatusOK': true
      }, true);
    }
    var frameId = extra.frameId;

    // Note: reset macro timeout, and loop timer on each loop
    (0, _macro_monitor.getMacroMonitor)().restartInspector(frameId, _types4.MacroInspector.LoopTimer);
    (0, _macro_monitor.getMacroMonitor)().restartInspector(frameId, _types4.MacroInspector.Countdown);
    if (extra.isBottomFrame) {
      // Note: reset onErrorCommand on each loop
      onErrorCommand = null;
    }
  });
  player.on('LOOP_RESTART', function (_ref71) {
    var currentLoop = _ref71.currentLoop,
      loopsCursor = _ref71.loopsCursor;
    _ipc_cs["default"].ask('PANEL_STOP_PLAYING', {});
    _ipc_cs["default"].ask('PANEL_START_PLAYING', {
      shouldNotActivateTab: true
    });
    store.dispatch(act.addLog('status', "Current loop: ".concat(currentLoop)));
  });
  player.on('START', function (_ref72) {
    var title = _ref72.title,
      extra = _ref72.extra,
      loopsCursor = _ref72.loopsCursor;
    (0, _log["default"])('START');
    if (store.getState().player.mode === C.PLAYER_MODE.TEST_CASE && extra.isBottomFrame && !extra.isBackFromCalling) {
      xCmdCounter.reset();
      proxyCounter.reset();
    }
    store.dispatch(act.startPlaying());
    store.dispatch(act.setPlayerState({
      status: C.PLAYER_STATUS.PLAYING,
      nextCommandIndex: null
    }));
    if (!extra.isBackFromCalling) {
      store.dispatch(act.updateMacroExtra((0, _recomputed.getCurrentMacroId)(store.getState()), {
        doneCommandIndices: [],
        errorCommandIndices: [],
        warningCommandIndices: []
      }));
    }
    store.dispatch(act.addLog('status', "Playing macro ".concat(title)));
  });
  player.on('PREPARED', function (_ref73) {
    var extra = _ref73.extra;
    if (!extra.isBackFromCalling) {
      // PREPARED event means all variables are already set
      var frameId = extra.frameId;
      (0, _macro_monitor.getMacroMonitor)().addTarget(frameId);
    }
  });
  player.on('PAUSED', function () {
    (0, _log["default"])('PAUSED');
    store.dispatch(act.setPlayerState({
      status: C.PLAYER_STATUS.PAUSED
    }));
    store.dispatch(act.addLog('status', "Macro paused"));

    // Pause all monitors (timers, coundown)
    (0, _macro_monitor.getMacroMonitor)().pause();
  });
  player.on('RESUMED', function () {
    (0, _log["default"])('RESUMED');
    store.dispatch(act.setPlayerState({
      status: C.PLAYER_STATUS.PLAYING
    }));
    store.dispatch(act.addLog('status', "Macro resumed"));

    // Resume all monitors (timers, coundown)
    (0, _macro_monitor.getMacroMonitor)().resume();
  });
  player.on('END', function (obj) {
    (0, _log["default"])('END', obj);
    _ipc_cs["default"].ask('PANEL_STOP_PLAYING', {});
    store.dispatch(act.stopPlaying());
    var state = store.getState();
    var extraState = state.player.nextCommandIndex !== null ? {
      lastNextCommandIndex: state.player.nextCommandIndex
    } : {};
    store.dispatch(act.setPlayerState(_objectSpread({
      status: C.PLAYER_STATUS.STOPPED,
      stopReason: obj.reason,
      nextCommandIndex: null,
      timeoutStatus: null
    }, extraState)));
    if (vars.get('!PROXY_EXEC_COUNT') > 0 && store.getState().config.turnOffProxyAfterReplay) {
      setProxy(null);
      store.dispatch(act.addLog('info', 'Proxy reset to none'));
    }
    var tcId = obj.extra && obj.extra.id;
    switch (obj.reason) {
      case player.C.END_REASON.COMPLETE:
        if (tcId) store.dispatch(act.updateMacroPlayStatus(tcId, _macro_extra_data.MacroResultStatus.Success));
        _antd.message.success('Macro completed running', 1.5);
        break;
      case player.C.END_REASON.ERROR:
        var stacks = (0, _call_stack.getMacroCallStack)().toArray();
        var len = stacks.length;
        stacks.forEach(function (item, i) {
          var status = i === len - 1 ? _macro_extra_data.MacroResultStatus.Error : _macro_extra_data.MacroResultStatus.ErrorInSub;
          store.dispatch(act.updateMacroPlayStatus(item.resource.id, status));
        });
        _antd.message.error('Macro encountered some error', 1.5);
        break;
    }
    var logMsg = _defineProperty(_defineProperty(_defineProperty({}, player.C.END_REASON.COMPLETE, 'Macro completed'), player.C.END_REASON.ERROR, 'Macro failed'), player.C.END_REASON.MANUAL, 'Macro was stopped manually');
    var frameId = obj.extra.frameId;
    var ms = (0, _macro_monitor.getMacroMonitor)().getDataFromInspector(frameId, _types4.MacroInspector.Timer);
    store.dispatch(act.addLog('info', logMsg[obj.reason] + " (Runtime ".concat((0, _ts_utils.milliSecondsToStringInSecond)(ms), ")")));
    (0, _macro_monitor.getMacroMonitor)().stopInspector(frameId, _types4.MacroInspector.Timer);
    (0, _macro_monitor.getMacroMonitor)().stopInspector(frameId, _types4.MacroInspector.LoopTimer);
    (0, _macro_monitor.getMacroMonitor)().stopInspector(frameId, _types4.MacroInspector.Countdown);

    // Note: show in badage the play result
    if (obj.reason === player.C.END_REASON.COMPLETE || obj.reason === player.C.END_REASON.ERROR) {
      _ipc_cs["default"].ask('PANEL_UPDATE_BADGE', _objectSpread({
        type: 'play',
        blink: 5000,
        text: obj.reason === player.C.END_REASON.COMPLETE ? 'done' : 'err'
      }, obj.reason === player.C.END_REASON.COMPLETE ? {} : {
        color: 'orange'
      }));
    }
    if (store.getState().player.mode !== C.PLAYER_MODE.TEST_SUITE) {
      store.dispatch(act.updateUI({
        shouldEnableDesktopAutomation: undefined
      }));
    }

    // on player end, reset super fast mode
    // player.setSuperFastMode(false)
  });
  player.on('TO_PLAY', function (_ref74) {
    var index = _ref74.index,
      currentLoop = _ref74.currentLoop,
      loops = _ref74.loops,
      resource = _ref74.resource,
      extra = _ref74.extra;
    // log('TO_PLAY', index, resource, 'currentLoop', currentLoop)

    store.dispatch(act.setPlayerState(_objectSpread({
      timeoutStatus: null,
      nextCommandIndex: index
    }, extra.isBottomFrame ? {
      currentLoop: currentLoop,
      loops: loops
    } : {})));
    var triple = [resource.cmd, resource.target, resource.value];
    var str = [''].concat(triple, ['']).join(' | ');
    store.dispatch(act.addLog('reflect', "Executing: ".concat(str)));

    // Note: show in badage the current command index (start from 1)
    _ipc_cs["default"].ask('PANEL_UPDATE_BADGE', {
      type: 'play',
      text: '' + (index + 1)
    });
  });
  player.on('PLAYED_LIST', function (_ref75) {
    var indices = _ref75.indices;
    // log('PLAYED_LIST', indices)

    store.dispatch(act.updateMacroDoneCommandsIndices((0, _recomputed.getCurrentMacroId)(store.getState()), indices));
  });
  player.on('ERROR', function (_ref76) {
    var errorIndex = _ref76.errorIndex,
      msg = _ref76.msg,
      stack = _ref76.stack,
      restart = _ref76.restart;
    _log["default"].error("command index: ".concat(errorIndex, ", Error: ").concat(msg, ", Stack: ").concat(stack));
    store.dispatch(act.addPlayerErrorCommandIndex(errorIndex));
    store.dispatch(act.addLog('error', msg));

    // Note: restart this player if restart is set to true in error, and it's not in test suite mode
    // Delay the execution so that 'END' event is emitted, and player is in stopped state
    if (restart && store.getState().player.mode === C.PLAYER_MODE.TEST_CASE) {
      setTimeout(function () {
        return player.replayLastConfig();
      }, 50);
    }
  });
  player.on('DELAY', function (_ref77) {
    var total = _ref77.total,
      past = _ref77.past;
    store.dispatch(act.setPlayerState({
      timeoutStatus: {
        type: 'delay',
        total: total,
        past: past
      }
    }));
  });
  return player;
};
var initTestSuitPlayer = function initTestSuitPlayer(_ref78) {
  var store = _ref78.store,
    vars = _ref78.vars,
    tcPlayer = _ref78.tcPlayer,
    xCmdCounter = _ref78.xCmdCounter,
    ocrCmdCounter = _ref78.ocrCmdCounter,
    proxyCounter = _ref78.proxyCounter;
  var tsTracker = new TimeTracker();
  var tcTracker = new TimeTracker();
  var state = {
    isPlaying: false,
    tsId: null,
    lastErrMsg: '',
    testCasePromiseHandlers: null,
    reports: [],
    stopReason: null
  };
  var setState = function setState(st) {
    state = _objectSpread(_objectSpread({}, state), st);
  };
  var addReport = function addReport(report) {
    setState({
      reports: state.reports.concat(report)
    });
  };
  var tsPlayer = (0, _player.getPlayer)({
    name: 'testSuite',
    prepare: function prepare() {
      setState({
        isPlaying: true,
        reports: []
      });
      vars.set({
        '!TESTSUITE_LOOP': 1,
        '!GLOBAL_TESTSUITE_STOP_ON_ERROR': false
      }, true);
    },
    run: function run(testCase, playerState) {
      var tcId = testCase.id;
      var tcLoops = testCase.loops > 1 ? parseInt(testCase.loops, 10) : 1;
      var state = store.getState();
      return (0, _storage.getStorageManager)().getMacroStorage().read(tcId, 'Text').then(function (tc) {
        var openTc = tc && tc.data.commands.find(function (c) {
          return c.cmd.toLowerCase() === 'open' || c.cmd.toLowerCase() === 'openBrowser';
        });
        if (!tc) {
          throw new Error('macro does not exist');
        }

        // update editing && start to play tcPlayer
        store.dispatch(act.editTestCase(tc.id));
        store.dispatch(act.playerPlay({
          macroId: tc.id,
          title: tc.name,
          extra: {
            id: tc.id,
            name: tc.name,
            shouldNotActivateTab: true
          },
          mode: tcLoops === 1 ? _player.Player.C.MODE.STRAIGHT : _player.Player.C.MODE.LOOP,
          loopsStart: 1,
          loopsEnd: tcLoops,
          startIndex: 0,
          startUrl: openTc ? openTc.target : null,
          resources: tc.data.commands,
          postDelay: state.config.playCommandInterval * 1000,
          // Note: This logic is to make sure !CMD_VAR${n} only take effect on first macro in a test suite
          overrideScope: playerState.nextIndex !== 0 ? {} : playerState["public"].scope
        }));
        return new Promise(function (resolve, reject) {
          setState({
            testCasePromiseHandlers: {
              resolve: resolve,
              reject: reject
            }
          });
        });
      });
    },
    handleResult: function handleResult(result, testCase, state) {
      // return undefined, so that player will play the next one
      return Promise.resolve(undefined);
    }
  }, {
    preDelay: 0
  });
  tsPlayer.on('START', function (_ref79) {
    var title = _ref79.title,
      extra = _ref79.extra;
    (0, _log["default"])('START SUITE');
    tsTracker.reset();
    xCmdCounter.reset();
    proxyCounter.reset();
    setState({
      tsId: extra.id,
      isPlaying: true,
      stopReason: null
    });
    store.dispatch(act.addLog('status', "Playing test suite ".concat(title)));
    store.dispatch(act.setPlayerMode(C.PLAYER_MODE.TEST_SUITE));
    store.dispatch(_simple_actions.Actions.updateTestSuite(extra.id, function (ts) {
      return _objectSpread(_objectSpread({}, ts), {}, {
        playStatus: {
          isPlaying: true,
          currentIndex: -1,
          errorIndices: [],
          doneIndices: []
        }
      });
    }));
  });
  tsPlayer.on('LOOP_START', function (_ref80) {
    var loopsCursor = _ref80.loopsCursor;
    vars.set({
      '!TESTSUITE_LOOP': loopsCursor
    }, true);
  });
  tsPlayer.on('LOOP_RESTART', function (_ref81) {
    var currentLoop = _ref81.currentLoop;
    store.dispatch(act.addLog('status', "Current test suite loop: ".concat(currentLoop)));
  });
  tsPlayer.on('PAUSED', function (_ref82) {
    var extra = _ref82.extra;
    (0, _log["default"])('PAUSED SUITE');
    store.dispatch(act.addLog('status', "Test suite paused"));
    tcPlayer.pause();
  });
  tsPlayer.on('RESUMED', function (_ref83) {
    var extra = _ref83.extra;
    (0, _log["default"])('RESUMED SUIITE');
    store.dispatch(act.addLog('status', "Test suite resumed"));
    tcPlayer.resume();
  });
  tsPlayer.on('TO_PLAY', function (_ref84) {
    var index = _ref84.index,
      extra = _ref84.extra;
    tcTracker.reset();
    setState({
      lastErrMsg: '',
      tcIndex: index
    });
    store.dispatch(_simple_actions.Actions.updateTestSuite(extra.id, function (ts) {
      return _objectSpread(_objectSpread({}, ts), {}, {
        playStatus: _objectSpread(_objectSpread({}, ts.playStatus), {}, {
          currentIndex: index
        })
      });
    }));
  });
  tsPlayer.on('PLAYED_LIST', function (_ref85) {
    var indices = _ref85.indices,
      extra = _ref85.extra;
    store.dispatch(_simple_actions.Actions.updateTestSuite(extra.id, function (ts) {
      return _objectSpread(_objectSpread({}, ts), {}, {
        playStatus: _objectSpread(_objectSpread({}, ts.playStatus), {}, {
          doneIndices: indices
        })
      });
    }));
  });
  tsPlayer.on('END', function (_ref86) {
    var reason = _ref86.reason,
      extra = _ref86.extra,
      opts = _ref86.opts;
    if (!state.isPlaying) return;
    vars.set({
      '!TESTSUITE_LOOP': 1
    }, true);
    setState({
      isPlaying: false
    });

    // Note: reset player mode to 'test case', it will only be 'test suite'
    // during replays of test suites
    store.dispatch(act.setPlayerMode(C.PLAYER_MODE.TEST_CASE));
    store.dispatch(_simple_actions.Actions.updateTestSuite(extra.id, function (ts) {
      return _objectSpread(_objectSpread({}, ts), {}, {
        playStatus: _objectSpread(_objectSpread({}, ts.playStatus), {}, {
          isPlaying: false,
          currentIndex: -1
        })
      });
    }));
    store.dispatch(act.updateUI({
      shouldEnableDesktopAutomation: undefined
    }));
    if (reason === _player.Player.C.END_REASON.MANUAL && (!opts || !opts.tcPlayerStopped)) {
      tcPlayer.stop();
    }

    // Note: give it some time, in case we're stopping tc player above
    setTimeout(function () {
      var totalCount = state.reports.length;
      var failureCount = state.reports.filter(function (r) {
        return r.stopReason === _player.Player.C.END_REASON.ERROR;
      }).length;
      var successCount = totalCount - failureCount;
      var statusMap = _defineProperty(_defineProperty(_defineProperty({}, _player.Player.C.END_REASON.MANUAL, 'Manually stopped'), _player.Player.C.END_REASON.COMPLETE, 'OK'), _player.Player.C.END_REASON.ERROR, 'Error');
      var tsStatus = statusMap[state.stopReason || reason];
      var lines = ["Test Suite name: ".concat(extra.name), "Start Time: ".concat(tsTracker.startTime.toString()), "Overall status: ".concat(tsStatus, ", Runtime: ").concat(tsTracker.elapsedInSeconds()), "Macro run: ".concat(totalCount), "Success: ".concat(successCount), "Failure: ".concat(failureCount), "Macro executed:"];
      var render = function render(_ref87) {
        var renderText = _ref87.renderText;
        return [/*#__PURE__*/_react["default"].createElement("span", null, lines.join('\n'))].concat(_toConsumableArray(state.reports.map(function (r, i) {
          return /*#__PURE__*/_react["default"].createElement("div", null, r.name, "\xA0 (", statusMap[r.stopReason], r.stopReason === _player.Player.C.END_REASON.ERROR ? ': ' : '', r.stopReason === _player.Player.C.END_REASON.ERROR ? renderText({
            type: 'error',
            text: r.errMsg,
            stack: r.stack
          }) : null, ", Runtime: ", r.usedTime, ")");
        })));
      };
      store.dispatch(act.addLog('report', render));
    }, 200);
  });

  // Test Case Player: we should handle cases when test case player stops automatically
  tcPlayer.on('END', function (_ref88) {
    var reason = _ref88.reason,
      extra = _ref88.extra;
    if (store.getState().player.mode !== C.PLAYER_MODE.TEST_SUITE) return;
    var btm = (0, _call_stack.getMacroCallStack)().bottom();
    var callStack = (0, _call_stack.getMacroCallStack)().toArray();
    var storeState = store.getState();
    var nextCommandIndex = storeState.player.lastNextCommandIndex;
    addReport({
      id: btm.resource.id,
      name: btm.resource.name,
      errMsg: state.lastErrMsg,
      stopReason: reason,
      usedTime: tcTracker.elapsedInSeconds(),
      stack: callStack.map(function (item, i) {
        return {
          macroId: item.resource.id,
          macroName: item.resource.name,
          commandIndex: i === callStack.length - 1 ? nextCommandIndex : item.runningStatus.nextIndex,
          isSubroutine: i !== 0
        };
      })
    });

    // Avoid a 'stop' loop between tsPlayer and tcPlayer
    switch (reason) {
      case _player.Player.C.END_REASON.MANUAL:
        break;
      case _player.Player.C.END_REASON.COMPLETE:
        // Note: delay the next macro run of test suite for a little bit,
        // so call stack has time to take care of itself first (like pop current frame)
        setTimeout(function () {
          state.testCasePromiseHandlers.resolve(true);
        }, 10);
        break;
      case _player.Player.C.END_REASON.ERROR:
        store.dispatch(_simple_actions.Actions.updateTestSuite(state.tsId, function (ts) {
          return _objectSpread(_objectSpread({}, ts), {}, {
            playStatus: _objectSpread(_objectSpread({}, ts.playStatus), {}, {
              errorIndices: ts.playStatus.errorIndices.concat([tsPlayer.state.nextIndex])
            })
          });
        }));
        setState({
          stopReason: _player.Player.C.END_REASON.ERROR
        });
        if (vars.get('!GLOBAL_TESTSUITE_STOP_ON_ERROR')) {
          state.testCasePromiseHandlers.reject(new Error());
          tsPlayer.stop({
            tcPlayerStopped: true
          });
          break;
        }

        // Updated on 2017-12-15, Even if there is error, test suite should move on to next macro
        // Note: tell tsPlayer not to trigger tcPlayer stop again
        // tsPlayer.stop({ tcPlayerStopped: true })
        state.testCasePromiseHandlers.resolve(true);
        break;
    }
  });
  tcPlayer.on('ERROR', function (_ref89) {
    var msg = _ref89.msg,
      restart = _ref89.restart;
    setState({
      lastErrMsg: msg
    });

    // Note: restart this player if restart is set to true in error, and it's not in test suite mode
    // Delay the execution so that 'END' event is emitted, and player is in stopped state
    //
    // Note that a couple moments after tcPlayer encounters an error and enter stopped state, it tries to set player mode
    // back to test case mode  (in tsPlayer 'END' event)
    if (restart && store.getState().player.mode === C.PLAYER_MODE.TEST_SUITE) {
      setTimeout(function () {
        return tsPlayer.replayLastConfig();
      }, 50);
    }
  });
  return tsPlayer;
};

/***/ }),

/***/ 61746:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _dexie = _interopRequireDefault(__webpack_require__(65830));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var db = new _dexie["default"]('selenium-ide');
db.version(1).stores({
  testCases: 'id,name,updateTime'
});
db.version(2).stores({
  testCases: 'id,name,updateTime',
  testSuites: 'id,name,updateTime'
});
db.open();
var _default = exports["default"] = db;

/***/ }),

/***/ 56109:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.normalizeTestCase = exports.normalizeCommand = exports.eliminateBaseUrl = exports["default"] = exports.commandWithoutBaseUrl = void 0;
var _utils = __webpack_require__(46580);
var _ts_utils = __webpack_require__(1601);
var _db = _interopRequireDefault(__webpack_require__(61746));
var _command = __webpack_require__(85393);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var model = {
  table: _db["default"].testCases,
  list: function list() {
    return _db["default"].testCases.toArray();
  },
  insert: function insert(data) {
    if (!data.name) {
      throw new Error('Model TestCase - insert: missing name');
    }
    if (!data.data) {
      throw new Error('Model TestCase - insert: missing data');
    }
    data.updateTime = new Date() * 1;
    data.id = (0, _utils.uid)();
    return _db["default"].testCases.add(normalizeTestCase(data));
  },
  bulkInsert: function bulkInsert(tcs) {
    var list = tcs.map(function (data) {
      if (!data.name) {
        throw new Error('Model TestCase - insert: missing name');
      }
      if (!data.data) {
        throw new Error('Model TestCase - insert: missing data');
      }
      data.updateTime = new Date() * 1;
      data.id = (0, _utils.uid)();
      return normalizeTestCase(data);
    });
    return _db["default"].testCases.bulkAdd(list);
  },
  update: function update(id, data) {
    return _db["default"].testCases.update(id, normalizeTestCase(data));
  },
  remove: function remove(id) {
    return _db["default"].testCases["delete"](id);
  }
};
var _default = exports["default"] = model;
var normalizeCommand = exports.normalizeCommand = function normalizeCommand(command) {
  var result = (0, _ts_utils.pickIfExist)(['cmd', 'target', 'value', 'targetOptions', 'description'], command);
  if (!(0, _command.doesCommandSupportTargetOptions)(result.cmd)) {
    delete result.targetOptions;
  }
  return result;
};
var normalizeTestCase = exports.normalizeTestCase = function normalizeTestCase(testCase) {
  var intermediate = (0, _utils.compose)((0, _utils.on)('data'), (0, _utils.on)('commands'), _utils.map)(normalizeCommand)(testCase);
  return (0, _ts_utils.pickIfExist)(['id', 'data', 'name', 'path'], intermediate);
};
var commandWithoutBaseUrl = exports.commandWithoutBaseUrl = function commandWithoutBaseUrl(baseUrl) {
  return function (command) {
    if (command.cmd !== 'open') return command;
    return _objectSpread(_objectSpread({}, command), {}, {
      target: (baseUrl + '/' + command.target).replace(/\/+/g, '/')
    });
  };
};
var eliminateBaseUrl = exports.eliminateBaseUrl = function eliminateBaseUrl(testCase) {
  if (!testCase.baseUrl) return testCase;
  return (0, _utils.compose)((0, _utils.on)('data'), (0, _utils.on)('commands'), _utils.map)(commandWithoutBaseUrl(testCase.baseUrl))(testCase);
};

/***/ }),

/***/ 38117:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
exports.normalizeTestSuite = normalizeTestSuite;
var _utils = __webpack_require__(46580);
var _ts_utils = __webpack_require__(1601);
var _db = _interopRequireDefault(__webpack_require__(61746));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var model = {
  table: _db["default"].testSuites,
  list: function list() {
    return _db["default"].testSuites.toArray();
  },
  insert: function insert(data) {
    if (!data.name) {
      throw new Error('Model TestSuite - insert: missing name');
    }
    if (!Array.isArray(data.cases)) {
      throw new Error('Model TestSuite - insert: cases should an array');
    }
    data.updateTime = new Date() * 1;
    data.id = (0, _utils.uid)();
    return _db["default"].testSuites.add(data);
  },
  bulkInsert: function bulkInsert(tcs) {
    var list = tcs.map(function (data) {
      if (!data.name) {
        throw new Error('Model TestSuite - insert: missing name');
      }
      if (!Array.isArray(data.cases)) {
        throw new Error('Model TestSuite - insert: cases should an array');
      }
      data.updateTime = new Date() * 1;
      data.id = (0, _utils.uid)();
      return data;
    });
    return _db["default"].testSuites.bulkAdd(list);
  },
  update: function update(id, data) {
    return _db["default"].testSuites.update(id, data);
  },
  remove: function remove(id) {
    return _db["default"].testSuites["delete"](id);
  }
};
var _default = exports["default"] = model;
function normalizeTestSuite(ts) {
  return (0, _ts_utils.pickIfExist)(['id', 'name', 'cases'], ts);
}

/***/ }),

/***/ 50341:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.INCREMENT = void 0;
exports["default"] = reducer;
var _urlParse = _interopRequireDefault(__webpack_require__(61160));
var _lodash = _interopRequireDefault(__webpack_require__(8142));
var _action_types = __webpack_require__(22023);
var _simple_actions = __webpack_require__(8588);
var _utils = __webpack_require__(46580);
var _test_case_model = __webpack_require__(56109);
var _convert_utils = __webpack_require__(75852);
var C = _interopRequireWildcard(__webpack_require__(95902));
var _log = _interopRequireDefault(__webpack_require__(89130));
var _ts_utils = __webpack_require__(1601);
var _recomputed = __webpack_require__(87307);
var _state = __webpack_require__(78493);
var _excluded = ["meta"];
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// Note: for update the `hasUnsaved` status in editing.meta
var updateHasUnSaved = function updateHasUnSaved(state) {
  var _state$editor$editing = state.editor.editing,
    meta = _state$editor$editing.meta,
    data = _objectWithoutProperties(_state$editor$editing, _excluded);
  var id = meta.src && meta.src.id;
  if (!id) return state;
  var currentMacro = state.editor.currentMacro;
  var normalizedEditing = (0, _test_case_model.normalizeTestCase)({
    data: data
  });
  var hasUnsaved = !(0, _lodash["default"])(currentMacro && currentMacro.data, normalizedEditing.data);
  return (0, _utils.setIn)(['editor', 'editing', 'meta', 'hasUnsaved'], hasUnsaved, state);
};
var updateBreakpointIndices = function updateBreakpointIndices(indices, action, actionIndex) {
  var handleSingleAction = function handleSingleAction(indices, action, actionIndex) {
    switch (action) {
      case 'add':
        {
          var result = indices.slice();
          for (var i = 0, len = indices.length; i < len; i++) {
            if (result[i] >= actionIndex) {
              result[i] += 1;
            }
          }
          return result;
        }
      case 'delete':
        {
          var _result = indices.slice();
          for (var _i = indices.length - 1; _i >= 0; _i--) {
            if (_result[_i] > actionIndex) {
              _result[_i] -= 1;
            } else if (_result[_i] === actionIndex) {
              _result.splice(_i, 1);
            }
          }
          return _result;
        }
      default:
        throw new Error("updateBreakpointIndices: unknown action, '".concat(action, "'"));
    }
  };
  if (typeof actionIndex === 'number') {
    return handleSingleAction(indices, action, actionIndex);
  }
  if (Array.isArray(actionIndex)) {
    // Note: sort action indices as desc.  Bigger indice will be handled earlier, so that it won't affect others
    var actionIndices = actionIndex.slice();
    actionIndices.sort(function (a, b) {
      return b - a;
    });
    return actionIndices.reduce(function (indices, actionIndex) {
      return handleSingleAction(indices, action, actionIndex);
    }, indices);
  }
  throw new Error('updateBreakpointIndices: actionIndex should be either number or an array of number');
};
var resetEditingSource = (0, _utils.partial)(function (macro, state) {
  (0, _log["default"])('resetEditingSource', macro);
  var str = (0, _convert_utils.toJSONString)(macro, {
    ignoreTargetOptions: (0, _recomputed.getShouldIgnoreTargetOptions)(state)
  });
  return (0, _utils.setIn)(['editor', 'editingSource'], {
    original: str,
    pure: str,
    current: str,
    error: null
  }, state);
});
var setEditingSourceCurrent = function setEditingSourceCurrent(state) {
  var macro = {
    name: state.editor.editing.meta.src ? state.editor.editing.meta.src.name : 'Untitled',
    commands: state.editor.editing.commands
  };
  // log('setEditingSourceCurrent', macro)

  var str = (0, _convert_utils.toJSONString)(macro, {
    ignoreTargetOptions: (0, _recomputed.getShouldIgnoreTargetOptions)(state)
  });
  return (0, _utils.updateIn)(['editor', 'editingSource'], function (editingSource) {
    return _objectSpread(_objectSpread({}, editingSource), {}, {
      pure: str,
      current: str
    });
  }, state);
};
var saveEditingSourceCurrent = function saveEditingSourceCurrent(state) {
  var current = state.editor.editingSource.current;
  return (0, _utils.updateIn)(['editor', 'editingSource'], function (editingSource) {
    return _objectSpread(_objectSpread({}, editingSource), {}, {
      pure: current,
      original: current
    });
  }, state);
};
var setEditingSourceOriginalAndPure = function setEditingSourceOriginalAndPure(macro, state) {
  var str = (0, _convert_utils.toJSONString)(macro, {
    ignoreTargetOptions: (0, _recomputed.getShouldIgnoreTargetOptions)(state)
  });
  return (0, _utils.updateIn)(['editor', 'editingSource'], function (editingSource) {
    return _objectSpread(_objectSpread({}, editingSource), {}, {
      pure: str,
      original: str
    });
  }, state);
};

// for test purpose
var INCREMENT = exports.INCREMENT = 'INCREMENT';
function reducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _state.initialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  switch (action.type) {
    // for test purpose
    case INCREMENT:
      return _objectSpread(_objectSpread({}, state), {}, {
        count: state.count + 1
      });
    case _action_types.types.START_RECORDING_SUCCESS:
      return _objectSpread(_objectSpread({}, state), {}, {
        status: C.APP_STATUS.RECORDER,
        recorderStatus: C.APP_STATUS.PENDING,
        player: _objectSpread(_objectSpread({}, state.player), {}, {
          nextCommandIndex: null
        })
      });
    case _action_types.types.STOP_RECORDING_SUCCESS:
      return _objectSpread(_objectSpread({}, state), {}, {
        status: C.APP_STATUS.NORMAL,
        recorderStatus: C.RECORDER_STATUS.STOPPED
      });
    case _action_types.types.START_INSPECTING_SUCCESS:
      return _objectSpread(_objectSpread({}, state), {}, {
        status: C.APP_STATUS.INSPECTOR,
        inspectorStatus: C.INSPECTOR_STATUS.PENDING
      });
    case _action_types.types.STOP_INSPECTING_SUCCESS:
    case _action_types.types.DONE_INSPECTING:
      return _objectSpread(_objectSpread({}, state), {}, {
        status: C.APP_STATUS.NORMAL,
        recorderStatus: C.INSPECTOR_STATUS.STOPPED
      });
    case _action_types.types.START_PLAYING:
      return _objectSpread(_objectSpread({}, state), {}, {
        status: C.APP_STATUS.PLAYER
      });
    case _action_types.types.STOP_PLAYING:
      return _objectSpread(_objectSpread({}, state), {}, {
        status: C.APP_STATUS.NORMAL
      });
    case _action_types.types.APPEND_COMMAND:
      return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (commands) {
        return [].concat(_toConsumableArray(commands), [action.data.command]);
      }))(state);
    case _action_types.types.DUPLICATE_COMMAND:
      return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.setIn)(['editor', 'editing', 'meta', 'selectedIndex'], action.data.index + 1), (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (commands) {
        var index = action.data.index;
        var newCommands = commands.slice();
        newCommands.splice(index + 1, 0, commands[index]);
        return newCommands;
      }), (0, _ts_utils.safeUpdateIn)(['editor', 'macrosExtra', (0, _recomputed.getCurrentMacroId)(state), 'breakpointIndices'], function (indices) {
        return updateBreakpointIndices(indices || [], 'add', action.data.index + 1);
      }))(state);
    case _action_types.types.INSERT_COMMAND:
      return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.setIn)(['editor', 'editing', 'meta', 'selectedIndex'], action.data.index), (0, _utils.updateIn)(['editor', 'editing', 'meta', 'indexToInsertRecorded'], function (recordIndex) {
        if (recordIndex === undefined || recordIndex === null || recordIndex < 0) {
          return recordIndex;
        }
        return recordIndex + (action.data.index <= recordIndex ? 1 : 0);
      }), (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (commands) {
        var _action$data = action.data,
          index = _action$data.index,
          command = _action$data.command;
        var newCommands = commands.slice();
        newCommands.splice(index, 0, command);
        return newCommands;
      }), (0, _ts_utils.safeUpdateIn)(['editor', 'macrosExtra', (0, _recomputed.getCurrentMacroId)(state), 'breakpointIndices'], function (indices) {
        return updateBreakpointIndices(indices || [], 'add', action.data.index);
      }))(state);
    case _action_types.types.UPDATE_COMMAND:
      return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.updateIn)(['editor', 'editing', 'commands', action.data.index], function (cmdObj) {
        return _objectSpread(_objectSpread({}, cmdObj), action.data.command);
      }))(state);
    case _action_types.types.REMOVE_COMMAND:
      return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, function (state) {
        var _state$editor$editing2 = state.editor.editing,
          commands = _state$editor$editing2.commands,
          meta = _state$editor$editing2.meta;
        var isSelectedIndexStillValid = meta.selectedIndex >= 0 && meta.selectedIndex < commands.length;
        if (isSelectedIndexStillValid) {
          return state;
        }
        var startDistance = action.data.index;
        var endDistance = commands.length - action.data.index - 1;
        var nextSelectedIndex = startDistance < endDistance ? 0 : commands.length - 1;
        return (0, _utils.setIn)(['editor', 'editing', 'meta', 'selectedIndex'], nextSelectedIndex, state);
      }, (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (commands) {
        var index = action.data.index;
        var newCommands = commands.slice();
        newCommands.splice(index, 1);
        return newCommands;
      }), (0, _ts_utils.safeUpdateIn)(['editor', 'macrosExtra', (0, _recomputed.getCurrentMacroId)(state), 'breakpointIndices'], function (indices) {
        return updateBreakpointIndices(indices || [], 'delete', action.data.index);
      }))(state);
    case _action_types.types.SELECT_COMMAND:
      return (0, _utils.compose)((0, _utils.setIn)(['editor', 'editing', 'meta', 'selectedIndex'], action.data.forceClick || state.editor.editing.meta.selectedIndex !== action.data.index ? action.data.index : -1),
      // Note: normalize commands whenever switching between commands in normal mode
      state.status === C.APP_STATUS.NORMAL ? (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (cmds) {
        return cmds.map(_test_case_model.normalizeCommand);
      }) : function (x) {
        return x;
      })(state);
    case _action_types.types.UPDATE_EDITING:
      return (0, _utils.compose)((0, _utils.setIn)(['editor', 'editing'], action.data.editing),
      // Note: normalize commands whenever switching between commands in normal mode
      state.status === C.APP_STATUS.NORMAL ? (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (cmds) {
        return cmds.map(_test_case_model.normalizeCommand);
      }) : function (x) {
        return x;
      })(state);
    case _action_types.types.CUT_COMMAND:
      {
        var commands = action.data.indices.map(function (i) {
          return state.editor.editing.commands[i];
        });
        return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.setIn)(['editor', 'clipboard', 'commands'], commands), (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (commands) {
          var newCommands = commands.slice();
          return newCommands.filter(function (c, i) {
            return action.data.indices.indexOf(i) === -1;
          });
        }), (0, _ts_utils.safeUpdateIn)(['editor', 'macrosExtra', (0, _recomputed.getCurrentMacroId)(state), 'breakpointIndices'], function (indices) {
          return updateBreakpointIndices(indices || [], 'delete', action.data.indices);
        }))(state);
      }
    case _action_types.types.COPY_COMMAND:
      {
        var _commands = action.data.indices.map(function (i) {
          return state.editor.editing.commands[i];
        });
        return (0, _utils.setIn)(['editor', 'clipboard', 'commands'], _commands, state);
      }
    case _action_types.types.PASTE_COMMAND:
      {
        var _commands2 = state.editor.clipboard.commands;
        return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (cmds) {
          var newCmds = cmds.slice();
          newCmds.splice.apply(newCmds, [action.data.index + 1, 0].concat(_toConsumableArray(_commands2)));
          return newCmds;
        }), (0, _ts_utils.safeUpdateIn)(['editor', 'macrosExtra', (0, _recomputed.getCurrentMacroId)(state), 'breakpointIndices'], function (indices) {
          return updateBreakpointIndices(indices || [], 'add', _commands2.map(function (_) {
            return action.data.index + 1;
          }));
        }))(state);
      }
    case _simple_actions.ActionTypes.moveCommands:
      {
        var _state$editor$editing3 = state.editor.editing.commands,
          _commands3 = _state$editor$editing3 === void 0 ? [] : _state$editor$editing3;
        var _action$data2 = action.data,
          startIndex = _action$data2.startIndex,
          endIndex = _action$data2.endIndex;
        if (startIndex < 0 || startIndex >= _commands3.length) {
          throw new Error('startIndex is out of range');
        }
        if (endIndex < 0 || endIndex >= _commands3.length) {
          throw new Error('endIndex is out of range');
        }
        if (endIndex === startIndex) {
          throw new Error('startIndex and endIndex must be different');
        }
        var newCommands = _toConsumableArray(_commands3);
        newCommands.splice(startIndex, 1);
        newCommands.splice(endIndex, 0, _commands3[startIndex]);
        return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.setIn)(['editor', 'editing', 'commands'], newCommands), (0, _utils.updateIn)(['editor', 'editing', 'meta', 'selectedIndex'], function (selectedIndex) {
          switch (selectedIndex) {
            case startIndex:
              return endIndex;
            case endIndex:
              return startIndex;
            default:
              return selectedIndex;
          }
        }))(state);
      }
    case _action_types.types.NORMALIZE_COMMANDS:
      return (0, _utils.updateIn)(['editor', 'editing', 'commands'], function (cmds) {
        return cmds.map(_test_case_model.normalizeCommand);
      }, state);
    case _action_types.types.UPDATE_SELECTED_COMMAND:
      if (state.editor.editing.meta.selectedIndex === -1) {
        return state;
      }
      return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.updateIn)(['editor', 'editing', 'commands', state.editor.editing.meta.selectedIndex], function (cmdObj) {
        return (0, _test_case_model.normalizeCommand)(_objectSpread(_objectSpread({}, cmdObj), action.data));
      }))(state);
    case _action_types.types.SAVE_EDITING_AS_EXISTED:
      return (0, _utils.compose)((0, _utils.setIn)(['editor', 'editing', 'meta', 'hasUnsaved'], false), saveEditingSourceCurrent)(state);
    case _action_types.types.SAVE_EDITING_AS_NEW:
      return (0, _utils.compose)((0, _utils.updateIn)(['editor', 'editing', 'meta'], function (meta) {
        return _objectSpread(_objectSpread({}, meta), {}, {
          hasUnsaved: false,
          src: (0, _utils.pick)(['id', 'name'], action.data)
        });
      }), saveEditingSourceCurrent)(state);
    case _action_types.types.SET_TEST_CASES:
      {
        return (0, _utils.compose)(function (state) {
          var src = state.editor.editing.meta.src;
          if (!src) return state;
          var tc = state.editor.testCases.find(function (tc) {
            return tc.id === src.id;
          });
          if (!tc) return state;
          return setEditingSourceOriginalAndPure({
            name: tc.name,
            commands: tc.data.commands
          }, state);
        }, (0, _utils.setIn)(['editor', 'testCases'], action.data))(state);
      }
    case _action_types.types.SET_TEST_SUITES:
      return (0, _utils.setIn)(['editor', 'testSuites'], action.data, state);
    case _simple_actions.ActionTypes.updateTestSuite:
      {
        var _action$data3 = action.data,
          id = _action$data3.id,
          updated = _action$data3.updated;
        var index = state.editor.testSuites.findIndex(function (ts) {
          return ts.id === id;
        });
        if (index === -1) return state;
        return (0, _utils.setIn)(['editor', 'testSuites', index], updated, state);
      }
    case _action_types.types.UPDATE_TEST_SUITE_STATUS:
      {
        var _action$data4 = action.data,
          _id = _action$data4.id,
          extra = _action$data4.extra;
        if (!_id) return state;
        return (0, _utils.updateIn)(['editor', 'testSuitesExtra'], function (data) {
          return _objectSpread(_objectSpread({}, data), {}, _defineProperty({}, _id, extra));
        }, state);
      }
    case _action_types.types.SET_EDITING:
      // log('REDUCER SET_EDITING', action.data)

      if (!action.data) return state;
      return (0, _utils.compose)(setEditingSourceCurrent, updateHasUnSaved, (0, _utils.setIn)(['editor', 'editing'], action.data))(state);
    case _action_types.types.EDIT_TEST_CASE:
      {
        var _ref = state.editor.editing.meta.src || {},
          _id2 = _ref.id;
        if (!action.data.macro) return state;
        var macro = action.data.macro;
        return (0, _utils.compose)((0, _utils.setIn)(['editor', 'editing'], _objectSpread(_objectSpread({}, macro.data), {}, {
          meta: {
            selectedIndex: -1,
            hasUnsaved: false,
            src: (0, _utils.pick)(['id', 'name'], macro)
          }
        })), (0, _utils.updateIn)(['player'], function (player) {
          return _objectSpread(_objectSpread({}, player), {}, {
            status: C.PLAYER_STATUS.STOPPED,
            stopReason: null,
            nextCommandIndex: null
          });
        }), resetEditingSource({
          name: macro.name,
          commands: macro.data.commands
        }), updateHasUnSaved)(state);
      }
    case _action_types.types.SET_ONE_MACRO_EXTRA:
      {
        var _action$data5 = action.data,
          _id3 = _action$data5.id,
          _extra = _action$data5.extra;
        if (!_id3) return state;
        return (0, _ts_utils.safeSetIn)(['editor', 'macrosExtra', _id3], _extra, state);
      }
    case _action_types.types.UPDATE_ONE_MACRO_EXTRA:
      {
        var _action$data6 = action.data,
          _id4 = _action$data6.id,
          _extra2 = _action$data6.extra;
        if (!_id4) return state;
        return (0, _ts_utils.safeUpdateIn)(['editor', 'macrosExtra', _id4], function (data) {
          return _objectSpread(_objectSpread({}, data), _extra2);
        }, state);
      }
    case _simple_actions.ActionTypes.renameTestCase:
      return (0, _utils.setIn)(['editor', 'editing', 'meta', 'src', 'name'], action.data, state);
    case _action_types.types.REMOVE_TEST_CASE:
      {
        if (!action.data.isCurrent) return state;
        var _id5 = state.editor.editing.meta.src.id;
        var selectedIndex = state.editor.editing.meta.selectedIndex;
        var candidates = state.editor.testCases.filter(function (tc) {
          return tc.id !== _id5;
        });
        var lastIndex = state.editor.testCases.findIndex(function (tc) {
          return tc.id === _id5;
        });
        var editing;
        if (candidates.length === 0) {
          editing = _objectSpread({}, _state.newTestCaseEditing);
        } else {
          var _index = lastIndex === -1 ? 0 : lastIndex < candidates.length ? lastIndex : lastIndex - 1;
          var tc = candidates[_index];
          editing = _objectSpread(_objectSpread({}, tc.data), {}, {
            meta: {
              src: (0, _utils.pick)(['id', 'name'], tc),
              hasUnsaved: false,
              selectedIndex: _index
            }
          });
        }
        return (0, _utils.setIn)(['editor', 'editing'], editing, state);
      }
    case _action_types.types.EDIT_NEW_TEST_CASE:
      {
        return (0, _utils.compose)((0, _utils.setIn)(['editor', 'editing'], _objectSpread({}, _state.newTestCaseEditing)), (0, _utils.updateIn)(['player'], function (player) {
          return _objectSpread(_objectSpread({}, player), {}, {
            nextCommandIndex: null
          });
        }), resetEditingSource({
          name: 'Untitled',
          commands: []
        }))(state);
      }
    case _action_types.types.SET_MACROS_EXTRA:
      {
        return (0, _utils.setIn)(['editor', 'macrosExtra'], action.data, state);
      }
    case _action_types.types.SET_TEST_SUITES_EXTRA:
      {
        return (0, _utils.setIn)(['editor', 'testSuitesExtra'], action.data, state);
      }
    case _simple_actions.ActionTypes.setMacroFolderStructure:
      {
        return (0, _utils.setIn)(['editor', 'macroFolderStructure'], action.data, state);
      }
    case _simple_actions.ActionTypes.setTestSuiteFolderStructure:
      {
        return (0, _utils.setIn)(['editor', 'testSuiteFolderStructure'], action.data, state);
      }
    case _action_types.types.SET_PLAYER_STATE:
      return (0, _utils.compose)((0, _utils.updateIn)(['player'], function (playerState) {
        return _objectSpread(_objectSpread({}, playerState), action.data);
      }), (0, _utils.updateIn)(['noDisplayInPlay'], function (noDisplayInPlay) {
        // Reset noDisplay to false when macro stops playing
        return action.data.status === C.PLAYER_STATUS.STOPPED ? false : noDisplayInPlay;
      }), (0, _utils.updateIn)(['ocrInDesktopMode'], function (ocrInDesktopMode) {
        // Reset ocrInDesktopMode to false when macro stops playing
        return action.data.status === C.PLAYER_STATUS.STOPPED ? false : ocrInDesktopMode;
      }), (0, _utils.updateIn)(['replaySpeedOverrideToFastMode'], function (replaySpeedOverrideToFastMode) {
        // Reset replaySpeedOverrideToFastMode to false when macro stops playing
        return action.data.status === C.PLAYER_STATUS.STOPPED ? false : replaySpeedOverrideToFastMode;
      }))(state);
    case _action_types.types.ADD_LOGS:
      return _objectSpread(_objectSpread({}, state), {}, {
        logs: [].concat(_toConsumableArray(state.logs), _toConsumableArray(action.data)).slice(-500)
      });
    case _action_types.types.CLEAR_LOGS:
      return _objectSpread(_objectSpread({}, state), {}, {
        logs: []
      });
    case _action_types.types.ADD_SCREENSHOT:
      return _objectSpread(_objectSpread({}, state), {}, {
        screenshots: [].concat(_toConsumableArray(state.screenshots), [action.data])
      });
    case _action_types.types.CLEAR_SCREENSHOTS:
      return _objectSpread(_objectSpread({}, state), {}, {
        screenshots: []
      });
    case _action_types.types.UPDATE_CONFIG:
      return (0, _utils.updateIn)(['config'], function (cfg) {
        return _objectSpread(_objectSpread({}, cfg), action.data);
      }, state);
    case _action_types.types.SET_CSV_LIST:
      return _objectSpread(_objectSpread({}, state), {}, {
        csvs: action.data
      });
    case _action_types.types.SET_SCREENSHOT_LIST:
      return _objectSpread(_objectSpread({}, state), {}, {
        screenshots: action.data
      });
    case _action_types.types.SET_VISION_LIST:
      return _objectSpread(_objectSpread({}, state), {}, {
        visions: action.data
      });
    case _action_types.types.SET_VARIABLE_LIST:
      return _objectSpread(_objectSpread({}, state), {}, {
        variables: action.data
      });
    case _action_types.types.UPDATE_UI:
      {
        return (0, _utils.updateIn)(['ui'], function (ui) {
          return _objectSpread(_objectSpread({}, ui), action.data);
        }, state);
      }
    case _action_types.types.SET_EDITOR_ACTIVE_TAB:
      {
        return (0, _utils.setIn)(['editor', 'activeTab'], action.data, state);
      }
    case _action_types.types.SET_SOURCE_ERROR:
      {
        return (0, _utils.setIn)(['editor', 'editingSource', 'error'], action.data, state);
      }
    case _action_types.types.SET_SOURCE_CURRENT:
      {
        return (0, _utils.setIn)(['editor', 'editingSource', 'current'], action.data, state);
      }
    case _action_types.types.UPDATE_PROXY:
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          proxy: action.data
        });
      }
    case _simple_actions.ActionTypes.setIsDraggingCommand:
      {
        return (0, _utils.setIn)(['editor', 'isDraggingCommand'], action.data, state);
      }
    case _simple_actions.ActionTypes.setCurrentMacro:
      {
        return (0, _utils.setIn)(['editor', 'currentMacro'], action.data, state);
      }
    case _simple_actions.ActionTypes.setIsLoadingMacros:
      {
        return (0, _utils.setIn)(['isLoadingMacros'], action.data, state);
      }
    case _simple_actions.ActionTypes.setFrom:
      {
        return (0, _utils.setIn)(['from'], action.data, state);
      }
    case _simple_actions.ActionTypes.setNoDisplayInPlay:
      {
        return (0, _utils.setIn)(['noDisplayInPlay'], action.data, state);
      }
    case _simple_actions.ActionTypes.setOcrInDesktopMode:
      {
        return (0, _utils.setIn)(['ocrInDesktopMode'], action.data, state);
      }
    case _simple_actions.ActionTypes.setReplaySpeedOverrideToFastMode:
      {
        return (0, _utils.setIn)(['replaySpeedOverrideToFastMode'], action.data, state);
      }
    case _simple_actions.ActionTypes.setMacroQuery:
      {
        return (0, _utils.setIn)(['macroQuery'], action.data, state);
      }
    case _simple_actions.ActionTypes.setIndexToInsertRecorded:
      {
        return (0, _utils.setIn)(['editor', 'editing', 'meta', 'indexToInsertRecorded'], action.data, state);
      }
    case _simple_actions.ActionTypes.toggleRecorderSkipOpen:
      {
        return (0, _utils.updateIn)(['recorder', 'skipOpen'], function (skipOpen) {
          return action.data !== undefined ? action.data : !skipOpen;
        }, state);
      }
    default:
      return state;
  }
}

/***/ }),

/***/ 68806:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Provider", ({
  enumerable: true,
  get: function get() {
    return _reactRedux.Provider;
  }
}));
Object.defineProperty(exports, "reducer", ({
  enumerable: true,
  get: function get() {
    return _reducers["default"];
  }
}));
exports.store = void 0;
var _reactRedux = __webpack_require__(73729);
var _redux = __webpack_require__(28895);
var _reduxThunk = __webpack_require__(29069);
var _promise_middleware = _interopRequireDefault(__webpack_require__(61346));
var _post_logic_middleware = _interopRequireDefault(__webpack_require__(81086));
var _reducers = _interopRequireWildcard(__webpack_require__(50341));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var adaptOldMethodMiddleware = function adaptOldMethodMiddleware(storeAPI) {
  return function (next) {
    return function (action) {
      var adaptedAction;
      if (!action.type) {
        var dispatch = storeAPI.dispatch,
          getState = storeAPI.getState;
        adaptedAction = action(dispatch, getState);
      } else {
        adaptedAction = action;
      }
      var result = next(adaptedAction);
      return result;
    };
  };
};
var middlewareEnhancer = (0, _redux.applyMiddleware)(_reduxThunk.thunk, (0, _promise_middleware["default"])(), (0, _post_logic_middleware["default"])(), adaptOldMethodMiddleware);
var store = exports.store = (0, _redux.createStore)(_reducers["default"], middlewareEnhancer);

// original:
// const createStore = applyMiddleware(
//   thunk,
//   createPromiseMiddleware(),
//   createPostLogicMiddleware()
// )(oldCreateStore)

/***/ }),

/***/ 81086:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = postLogicMiddleWare;
var _excluded = ["post"];
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// Note: if `post` field provided, it will call `post`
// after the action dispatched and state updated
function postLogicMiddleWare(extra) {
  return function (_ref) {
    var dispatch = _ref.dispatch,
      getState = _ref.getState;
    return function (next) {
      return function (action) {
        var post = action.post,
          rest = _objectWithoutProperties(action, _excluded);
        if (post && typeof post === 'function') {
          setTimeout(function () {
            post({
              dispatch: dispatch,
              getState: getState
            }, action, extra);
          }, 0);
        } else if (Array.isArray(post)) {
          post.forEach(function (fn) {
            setTimeout(function () {
              fn({
                dispatch: dispatch,
                getState: getState
              }, action, extra);
            }, 0);
          });
        }
        return next(action);
      };
    };
  };
}

/***/ }),

/***/ 61346:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = promiseMiddleWare;
var _excluded = ["promise", "types"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
// Note: if a `promise` field and a `types` provied, this middleware will dispatch
// 3 actions REQUEST, SUCCESS, FAILURE based on the status of the promise it returns
function promiseMiddleWare() {
  return function (_ref) {
    var dispatch = _ref.dispatch,
      getState = _ref.getState;
    return function (next) {
      return function (action) {
        var promise = action.promise,
          types = action.types,
          rest = _objectWithoutProperties(action, _excluded);
        if (!promise) {
          return next(action);
        }
        var _types = _slicedToArray(types, 3),
          REQUEST = _types[0],
          SUCCESS = _types[1],
          FAILURE = _types[2];
        next(_objectSpread(_objectSpread({}, rest), {}, {
          type: REQUEST
        }));
        return promise().then(function (data) {
          return next(_objectSpread(_objectSpread({}, rest), {}, {
            data: data,
            type: SUCCESS
          }));
        }, function (error) {
          return next(_objectSpread(_objectSpread({}, rest), {}, {
            err: error,
            type: FAILURE
          }));
        });
      };
    };
  };
}
;

/***/ }),

/***/ 54767:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31601);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76314);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.file-root{padding-top:10px;font-size:14px;line-height:18px}.file-root.drag-over{background:#d5d6f9}.file-root .tree-node-content{position:relative;display:flex;flex-direction:row;align-items:center;padding:5px 10px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;user-select:none}.file-root .tree-node-content .tree-node-icon-wrapper{display:flex;flex-direction:row;justify-content:center;margin-right:5px;width:20px}.file-root .tree-node-content .more-button{display:none;position:absolute;top:50%;right:10px;transform:translateY(-50%)}.file-root .tree-node-content:hover .more-button{display:block}.file-root .file-node.drag-over{background:#d5d6f9}.file-root .file-node.success>.tree-node-content{background:#d1ffd8}.file-root .file-node.success.blur>.tree-node-content{background:rgba(209,255,216,.6)}.file-root .file-node.error>.tree-node-content{background:#f7c1c1}.file-root .file-node.error.blur>.tree-node-content{background:rgba(247,193,193,.6)}.file-root .file-node.error-in-sub>.tree-node-content{background:#f8cf9d}.file-root .file-node.error-in-sub.blur>.tree-node-content{background:rgba(248,207,157,.6)}.file-root .file-node.selected>.tree-node-content{background:#fdffd1}.file-root .file-node.selected.blur>.tree-node-content{background:rgba(253,255,209,.6)}.file-root .file-node.selected.error>.tree-node-content,.file-root .file-node.selected.error-in-sub>.tree-node-content,.file-root .file-node.selected.success>.tree-node-content{position:relative}.file-root .file-node.selected.error>.tree-node-content::after,.file-root .file-node.selected.error-in-sub>.tree-node-content::after,.file-root .file-node.selected.success>.tree-node-content::after{content:"";position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:none}.file-root .file-node.selected.error>.tree-node-content::after{border:4px solid #f7c1c1}.file-root .file-node.selected.error.blur>.tree-node-content::after{border-color:rgba(247,193,193,.6)}.file-root .file-node.selected.error-in-sub>.tree-node-content::after{border:4px solid #f8cf9d}.file-root .file-node.selected.error-in-sub.blur>.tree-node-content::after{border-color:rgba(248,207,157,.6)}.file-root .file-node.selected.success>.tree-node-content::after{border:4px solid #d1ffd8}.file-root .file-node.selected.success.blur>.tree-node-content::after{border-color:rgba(209,255,216,.6)}.file-root .file-node .file-icon,.file-root .file-node .folder-icon{height:16px}.file-root .tree-node .tree-node .tree-node-content{padding-left:25px}.file-root .tree-node .tree-node .tree-node .tree-node-content{padding-left:40px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:55px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:70px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:85px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:100px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:115px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:130px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:145px}.file-root .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node .tree-node-content{padding-left:160px}`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 15822:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85072);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97825);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77659);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55056);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10540);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(41113);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_2_use_3_tree_file_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(54767);

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_2_use_3_tree_file_scss__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_2_use_3_tree_file_scss__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_2_use_3_tree_file_scss__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_2_use_3_tree_file_scss__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 91021:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var React = __webpack_require__(96540);

function Code (props) {
    return React.createElement("svg",props,[React.createElement("g",{"key":0},React.createElement("g",null,[React.createElement("path",{"d":"M325.762,70.513l-17.706-4.854c-2.279-0.76-4.524-0.521-6.707,0.715c-2.19,1.237-3.669,3.094-4.429,5.568L190.426,440.53\r\n\t\t\tc-0.76,2.475-0.522,4.809,0.715,6.995c1.237,2.19,3.09,3.665,5.568,4.425l17.701,4.856c2.284,0.766,4.521,0.526,6.71-0.712\r\n\t\t\tc2.19-1.243,3.666-3.094,4.425-5.564L332.042,81.936c0.759-2.474,0.523-4.808-0.716-6.999\r\n\t\t\tC330.088,72.747,328.237,71.272,325.762,70.513z","key":0}),React.createElement("path",{"d":"M166.167,142.465c0-2.474-0.953-4.665-2.856-6.567l-14.277-14.276c-1.903-1.903-4.093-2.857-6.567-2.857\r\n\t\t\ts-4.665,0.955-6.567,2.857L2.856,254.666C0.95,256.569,0,258.759,0,261.233c0,2.474,0.953,4.664,2.856,6.566l133.043,133.044\r\n\t\t\tc1.902,1.906,4.089,2.854,6.567,2.854s4.665-0.951,6.567-2.854l14.277-14.268c1.903-1.902,2.856-4.093,2.856-6.57\r\n\t\t\tc0-2.471-0.953-4.661-2.856-6.563L51.107,261.233l112.204-112.201C165.217,147.13,166.167,144.939,166.167,142.465z","key":1}),React.createElement("path",{"d":"M519.614,254.663L386.567,121.619c-1.902-1.902-4.093-2.857-6.563-2.857c-2.478,0-4.661,0.955-6.57,2.857l-14.271,14.275\r\n\t\t\tc-1.902,1.903-2.851,4.09-2.851,6.567s0.948,4.665,2.851,6.567l112.206,112.204L359.163,373.442\r\n\t\t\tc-1.902,1.902-2.851,4.093-2.851,6.563c0,2.478,0.948,4.668,2.851,6.57l14.271,14.268c1.909,1.906,4.093,2.854,6.57,2.854\r\n\t\t\tc2.471,0,4.661-0.951,6.563-2.854L519.614,267.8c1.903-1.902,2.854-4.096,2.854-6.57\r\n\t\t\tC522.468,258.755,521.517,256.565,519.614,254.663z","key":2})])),React.createElement("g",{"key":1}),React.createElement("g",{"key":2}),React.createElement("g",{"key":3}),React.createElement("g",{"key":4}),React.createElement("g",{"key":5}),React.createElement("g",{"key":6}),React.createElement("g",{"key":7}),React.createElement("g",{"key":8}),React.createElement("g",{"key":9}),React.createElement("g",{"key":10}),React.createElement("g",{"key":11}),React.createElement("g",{"key":12}),React.createElement("g",{"key":13}),React.createElement("g",{"key":14}),React.createElement("g",{"key":15})]);
}

Code.defaultProps = {"version":"1.1","id":"Capa_1","x":"0px","y":"0px","width":"522.468px","height":"522.469px","viewBox":"0 0 522.468 522.469","style":{"enableBackground":"new 0 0 522.468 522.469"},"xmlSpace":"preserve"};

module.exports = Code;

Code.default = Code;


/***/ }),

/***/ 51158:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var React = __webpack_require__(96540);

function Folder (props) {
    return React.createElement("svg",props,[React.createElement("g",{"key":0},React.createElement("path",{"d":"M456.239,128.475c-12.56-12.562-27.597-18.842-45.11-18.842h-191.86v-9.136c0-17.511-6.283-32.548-18.843-45.107\r\n\t\tc-12.562-12.562-27.6-18.846-45.111-18.846H63.953c-17.515,0-32.551,6.283-45.111,18.846C6.28,67.949,0,82.986,0,100.497v274.088\r\n\t\tc0,17.508,6.28,32.545,18.842,45.104c12.562,12.565,27.6,18.849,45.111,18.849h347.175c17.514,0,32.551-6.283,45.11-18.849\r\n\t\tc12.566-12.56,18.843-27.597,18.843-45.104V173.59C475.082,156.078,468.805,141.042,456.239,128.475z M438.536,374.585\r\n\t\tc0,7.611-2.662,14.093-7.99,19.417c-5.328,5.325-11.8,7.987-19.417,7.987H63.953c-7.614,0-14.084-2.662-19.414-7.987\r\n\t\tc-5.33-5.324-7.993-11.806-7.993-19.417V100.501c0-7.611,2.663-14.084,7.993-19.414c5.326-5.327,11.799-7.993,19.414-7.993h91.365\r\n\t\tc7.614,0,14.087,2.663,19.417,7.993c5.327,5.33,7.993,11.803,7.993,19.414v18.274c0,7.616,2.664,14.083,7.994,19.414\r\n\t\tc5.327,5.327,11.798,7.994,19.414,7.994h200.993c7.617,0,14.089,2.666,19.417,7.993c5.328,5.326,7.99,11.799,7.99,19.414V374.585\r\n\t\tL438.536,374.585z"})),React.createElement("g",{"key":1}),React.createElement("g",{"key":2}),React.createElement("g",{"key":3}),React.createElement("g",{"key":4}),React.createElement("g",{"key":5}),React.createElement("g",{"key":6}),React.createElement("g",{"key":7}),React.createElement("g",{"key":8}),React.createElement("g",{"key":9}),React.createElement("g",{"key":10}),React.createElement("g",{"key":11}),React.createElement("g",{"key":12}),React.createElement("g",{"key":13}),React.createElement("g",{"key":14}),React.createElement("g",{"key":15})]);
}

Folder.defaultProps = {"version":"1.1","id":"Capa_1","x":"0px","y":"0px","width":"475.082px","height":"475.082px","viewBox":"0 0 475.082 475.082","style":{"enableBackground":"new 0 0 475.082 475.082"},"xmlSpace":"preserve"};

module.exports = Folder;

Folder.default = Folder;


/***/ }),

/***/ 51802:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var React = __webpack_require__(96540);

function FolderExpanded (props) {
    return React.createElement("svg",props,[React.createElement("g",{"key":0},React.createElement("path",{"d":"M540.743,281.356c-4.179-8.754-10.568-15.464-19.123-20.12c-8.566-4.665-17.987-6.995-28.264-6.995h-54.819v-45.683\r\n\t\tc0-17.511-6.283-32.548-18.843-45.111c-12.566-12.562-27.604-18.842-45.111-18.842H219.268v-9.136\r\n\t\tc0-17.511-6.283-32.548-18.842-45.107c-12.564-12.562-27.6-18.846-45.111-18.846H63.953c-17.511,0-32.548,6.283-45.111,18.846\r\n\t\tC6.28,102.922,0,117.959,0,135.47v274.088c0,17.508,6.28,32.545,18.842,45.104c12.563,12.565,27.6,18.849,45.111,18.849h310.636\r\n\t\tc12.748,0,26.07-3.285,39.971-9.855c13.895-6.563,24.928-14.894,33.113-24.981L531.9,335.037\r\n\t\tc8.754-11.037,13.127-22.453,13.127-34.26C545.031,293.923,543.603,287.458,540.743,281.356z M36.547,135.474\r\n\t\tc0-7.611,2.663-14.084,7.993-19.414c5.326-5.327,11.799-7.993,19.414-7.993h91.365c7.615,0,14.084,2.663,19.414,7.993\r\n\t\tc5.327,5.33,7.993,11.803,7.993,19.414v18.274c0,7.616,2.667,14.087,7.994,19.414s11.798,7.994,19.412,7.994h164.452\r\n\t\tc7.611,0,14.089,2.666,19.418,7.993c5.324,5.326,7.99,11.799,7.99,19.414v45.682H182.725c-12.941,0-26.269,3.284-39.973,9.851\r\n\t\tc-13.706,6.567-24.744,14.893-33.12,24.986l-73.085,89.931V135.474z M503.345,311.917l-83.939,103.637\r\n\t\tc-4.753,5.899-11.512,10.943-20.272,15.125c-8.754,4.189-16.939,6.283-24.551,6.283H63.953c-10.088,0-15.131-3.333-15.131-9.992\r\n\t\tc0-3.046,1.713-6.852,5.14-11.427l83.938-103.633c4.949-5.903,11.75-10.896,20.413-14.989c8.658-4.093,16.796-6.14,24.411-6.14\r\n\t\th310.631c10.088,0,15.129,3.333,15.129,9.993C508.485,304.019,506.778,307.728,503.345,311.917z"})),React.createElement("g",{"key":1}),React.createElement("g",{"key":2}),React.createElement("g",{"key":3}),React.createElement("g",{"key":4}),React.createElement("g",{"key":5}),React.createElement("g",{"key":6}),React.createElement("g",{"key":7}),React.createElement("g",{"key":8}),React.createElement("g",{"key":9}),React.createElement("g",{"key":10}),React.createElement("g",{"key":11}),React.createElement("g",{"key":12}),React.createElement("g",{"key":13}),React.createElement("g",{"key":14}),React.createElement("g",{"key":15})]);
}

FolderExpanded.defaultProps = {"version":"1.1","id":"Capa_1","x":"0px","y":"0px","width":"545.027px","height":"545.027px","viewBox":"0 0 545.027 545.027","style":{"enableBackground":"new 0 0 545.027 545.027"},"xmlSpace":"preserve"};

module.exports = FolderExpanded;

FolderExpanded.default = FolderExpanded;


/***/ }),

/***/ 8460:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 92382:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 63779:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 77199:
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	(() => {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "ui-vision-web-extension:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			887: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkui_vision_web_extension"] = self["webpackChunkui_vision_web_extension"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, [787,626,652,624,397,188], () => (__webpack_require__(49571)))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;